// Generated by jextract

package com.nz.media.gst.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class gst_min_h_9 extends gst_min_h$shared {

    gst_min_h_9() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    private static final int G_ANALYZER_ANALYZING = (int)0L;
    /**
     * {@snippet lang=c :
     * #define G_ANALYZER_ANALYZING 0
     * }
     */
    public static int G_ANALYZER_ANALYZING() {
        return G_ANALYZER_ANALYZING;
    }
    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_CXX23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX23 0
     * }
     */
    public static int _HAS_CXX23() {
        return _HAS_CXX23;
    }
    private static final int _HAS_CXX26 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX26 0
     * }
     */
    public static int _HAS_CXX26() {
        return _HAS_CXX26;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int MB_LEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 5
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
     * }
     */
    public static int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE() {
        return _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE;
    }
    private static final int _CRT_BUILD_DESKTOP_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_BUILD_DESKTOP_APP 1
     * }
     */
    public static int _CRT_BUILD_DESKTOP_APP() {
        return _CRT_BUILD_DESKTOP_APP;
    }
    private static final int _ARGMAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _ARGMAX 100
     * }
     */
    public static int _ARGMAX() {
        return _ARGMAX;
    }
    private static final int _CRT_INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INT_MAX 2147483647
     * }
     */
    public static int _CRT_INT_MAX() {
        return _CRT_INT_MAX;
    }
    private static final int _CRT_FUNCTIONS_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_FUNCTIONS_REQUIRED 1
     * }
     */
    public static int _CRT_FUNCTIONS_REQUIRED() {
        return _CRT_FUNCTIONS_REQUIRED;
    }
    private static final int _CRT_HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_CXX17 0
     * }
     */
    public static int _CRT_HAS_CXX17() {
        return _CRT_HAS_CXX17;
    }
    private static final int _CRT_HAS_C11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_C11 1
     * }
     */
    public static int _CRT_HAS_C11() {
        return _CRT_HAS_C11;
    }
    private static final int _CRT_INTERNAL_NONSTDC_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_NONSTDC_NAMES 1
     * }
     */
    public static int _CRT_INTERNAL_NONSTDC_NAMES() {
        return _CRT_INTERNAL_NONSTDC_NAMES;
    }
    private static final int __STDC_WANT_SECURE_LIB__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_SECURE_LIB__ 1
     * }
     */
    public static int __STDC_WANT_SECURE_LIB__() {
        return __STDC_WANT_SECURE_LIB__;
    }
    private static final int _SECURECRT_FILL_BUFFER_PATTERN = (int)254L;
    /**
     * {@snippet lang=c :
     * #define _SECURECRT_FILL_BUFFER_PATTERN 254
     * }
     */
    public static int _SECURECRT_FILL_BUFFER_PATTERN() {
        return _SECURECRT_FILL_BUFFER_PATTERN;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY;
    }
    private static final int _STATIC_INLINE_UCRT_FUNCTIONS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _STATIC_INLINE_UCRT_FUNCTIONS 0
     * }
     */
    public static int _STATIC_INLINE_UCRT_FUNCTIONS() {
        return _STATIC_INLINE_UCRT_FUNCTIONS;
    }
    private static final int FLT_EVAL_METHOD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FLT_EVAL_METHOD 0
     * }
     */
    public static int FLT_EVAL_METHOD() {
        return FLT_EVAL_METHOD;
    }
    private static final int DBL_DECIMAL_DIG = (int)17L;
    /**
     * {@snippet lang=c :
     * #define DBL_DECIMAL_DIG 17
     * }
     */
    public static int DBL_DECIMAL_DIG() {
        return DBL_DECIMAL_DIG;
    }
    private static final int DBL_DIG = (int)15L;
    /**
     * {@snippet lang=c :
     * #define DBL_DIG 15
     * }
     */
    public static int DBL_DIG() {
        return DBL_DIG;
    }
    private static final int DBL_HAS_SUBNORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DBL_HAS_SUBNORM 1
     * }
     */
    public static int DBL_HAS_SUBNORM() {
        return DBL_HAS_SUBNORM;
    }
    private static final int DBL_MANT_DIG = (int)53L;
    /**
     * {@snippet lang=c :
     * #define DBL_MANT_DIG 53
     * }
     */
    public static int DBL_MANT_DIG() {
        return DBL_MANT_DIG;
    }
    private static final int DBL_MAX_10_EXP = (int)308L;
    /**
     * {@snippet lang=c :
     * #define DBL_MAX_10_EXP 308
     * }
     */
    public static int DBL_MAX_10_EXP() {
        return DBL_MAX_10_EXP;
    }
    private static final int DBL_MAX_EXP = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define DBL_MAX_EXP 1024
     * }
     */
    public static int DBL_MAX_EXP() {
        return DBL_MAX_EXP;
    }
    private static final int _DBL_RADIX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _DBL_RADIX 2
     * }
     */
    public static int _DBL_RADIX() {
        return _DBL_RADIX;
    }
    private static final int FLT_DECIMAL_DIG = (int)9L;
    /**
     * {@snippet lang=c :
     * #define FLT_DECIMAL_DIG 9
     * }
     */
    public static int FLT_DECIMAL_DIG() {
        return FLT_DECIMAL_DIG;
    }
    private static final int FLT_DIG = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FLT_DIG 6
     * }
     */
    public static int FLT_DIG() {
        return FLT_DIG;
    }
    private static final int FLT_HAS_SUBNORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FLT_HAS_SUBNORM 1
     * }
     */
    public static int FLT_HAS_SUBNORM() {
        return FLT_HAS_SUBNORM;
    }
    private static final int FLT_GUARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FLT_GUARD 0
     * }
     */
    public static int FLT_GUARD() {
        return FLT_GUARD;
    }
    private static final int FLT_MANT_DIG = (int)24L;
    /**
     * {@snippet lang=c :
     * #define FLT_MANT_DIG 24
     * }
     */
    public static int FLT_MANT_DIG() {
        return FLT_MANT_DIG;
    }
    private static final int FLT_MAX_10_EXP = (int)38L;
    /**
     * {@snippet lang=c :
     * #define FLT_MAX_10_EXP 38
     * }
     */
    public static int FLT_MAX_10_EXP() {
        return FLT_MAX_10_EXP;
    }
    private static final int FLT_MAX_EXP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FLT_MAX_EXP 128
     * }
     */
    public static int FLT_MAX_EXP() {
        return FLT_MAX_EXP;
    }
    private static final int FLT_NORMALIZE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FLT_NORMALIZE 0
     * }
     */
    public static int FLT_NORMALIZE() {
        return FLT_NORMALIZE;
    }
    private static final int FLT_RADIX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FLT_RADIX 2
     * }
     */
    public static int FLT_RADIX() {
        return FLT_RADIX;
    }
    private static final int _SW_INEXACT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SW_INEXACT 1
     * }
     */
    public static int _SW_INEXACT() {
        return _SW_INEXACT;
    }
    private static final int _SW_UNDERFLOW = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _SW_UNDERFLOW 2
     * }
     */
    public static int _SW_UNDERFLOW() {
        return _SW_UNDERFLOW;
    }
    private static final int _SW_OVERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _SW_OVERFLOW 4
     * }
     */
    public static int _SW_OVERFLOW() {
        return _SW_OVERFLOW;
    }
    private static final int _SW_ZERODIVIDE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _SW_ZERODIVIDE 8
     * }
     */
    public static int _SW_ZERODIVIDE() {
        return _SW_ZERODIVIDE;
    }
    private static final int _SW_INVALID = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _SW_INVALID 16
     * }
     */
    public static int _SW_INVALID() {
        return _SW_INVALID;
    }
    private static final int _SW_DENORMAL = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define _SW_DENORMAL 524288
     * }
     */
    public static int _SW_DENORMAL() {
        return _SW_DENORMAL;
    }
    private static final int _MCW_EM = (int)524319L;
    /**
     * {@snippet lang=c :
     * #define _MCW_EM 524319
     * }
     */
    public static int _MCW_EM() {
        return _MCW_EM;
    }
    private static final int _EM_INEXACT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _EM_INEXACT 1
     * }
     */
    public static int _EM_INEXACT() {
        return _EM_INEXACT;
    }
    private static final int _EM_UNDERFLOW = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _EM_UNDERFLOW 2
     * }
     */
    public static int _EM_UNDERFLOW() {
        return _EM_UNDERFLOW;
    }
    private static final int _EM_OVERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _EM_OVERFLOW 4
     * }
     */
    public static int _EM_OVERFLOW() {
        return _EM_OVERFLOW;
    }
    private static final int _EM_ZERODIVIDE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _EM_ZERODIVIDE 8
     * }
     */
    public static int _EM_ZERODIVIDE() {
        return _EM_ZERODIVIDE;
    }
    private static final int _EM_INVALID = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _EM_INVALID 16
     * }
     */
    public static int _EM_INVALID() {
        return _EM_INVALID;
    }
    private static final int _EM_DENORMAL = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define _EM_DENORMAL 524288
     * }
     */
    public static int _EM_DENORMAL() {
        return _EM_DENORMAL;
    }
    private static final int _MCW_RC = (int)768L;
    /**
     * {@snippet lang=c :
     * #define _MCW_RC 768
     * }
     */
    public static int _MCW_RC() {
        return _MCW_RC;
    }
    private static final int _RC_NEAR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _RC_NEAR 0
     * }
     */
    public static int _RC_NEAR() {
        return _RC_NEAR;
    }
    private static final int _RC_DOWN = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _RC_DOWN 256
     * }
     */
    public static int _RC_DOWN() {
        return _RC_DOWN;
    }
    private static final int _RC_UP = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _RC_UP 512
     * }
     */
    public static int _RC_UP() {
        return _RC_UP;
    }
    private static final int _RC_CHOP = (int)768L;
    /**
     * {@snippet lang=c :
     * #define _RC_CHOP 768
     * }
     */
    public static int _RC_CHOP() {
        return _RC_CHOP;
    }
    private static final int _MCW_PC = (int)196608L;
    /**
     * {@snippet lang=c :
     * #define _MCW_PC 196608
     * }
     */
    public static int _MCW_PC() {
        return _MCW_PC;
    }
    private static final int _PC_64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _PC_64 0
     * }
     */
    public static int _PC_64() {
        return _PC_64;
    }
    private static final int _PC_53 = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define _PC_53 65536
     * }
     */
    public static int _PC_53() {
        return _PC_53;
    }
    private static final int _PC_24 = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define _PC_24 131072
     * }
     */
    public static int _PC_24() {
        return _PC_24;
    }
    private static final int _MCW_IC = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define _MCW_IC 262144
     * }
     */
    public static int _MCW_IC() {
        return _MCW_IC;
    }
    private static final int _IC_AFFINE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define _IC_AFFINE 262144
     * }
     */
    public static int _IC_AFFINE() {
        return _IC_AFFINE;
    }
    private static final int _IC_PROJECTIVE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IC_PROJECTIVE 0
     * }
     */
    public static int _IC_PROJECTIVE() {
        return _IC_PROJECTIVE;
    }
    private static final int _MCW_DN = (int)50331648L;
    /**
     * {@snippet lang=c :
     * #define _MCW_DN 50331648
     * }
     */
    public static int _MCW_DN() {
        return _MCW_DN;
    }
    private static final int _DN_SAVE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _DN_SAVE 0
     * }
     */
    public static int _DN_SAVE() {
        return _DN_SAVE;
    }
    private static final int _DN_FLUSH = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define _DN_FLUSH 16777216
     * }
     */
    public static int _DN_FLUSH() {
        return _DN_FLUSH;
    }
    private static final int _DN_FLUSH_OPERANDS_SAVE_RESULTS = (int)33554432L;
    /**
     * {@snippet lang=c :
     * #define _DN_FLUSH_OPERANDS_SAVE_RESULTS 33554432
     * }
     */
    public static int _DN_FLUSH_OPERANDS_SAVE_RESULTS() {
        return _DN_FLUSH_OPERANDS_SAVE_RESULTS;
    }
    private static final int _DN_SAVE_OPERANDS_FLUSH_RESULTS = (int)50331648L;
    /**
     * {@snippet lang=c :
     * #define _DN_SAVE_OPERANDS_FLUSH_RESULTS 50331648
     * }
     */
    public static int _DN_SAVE_OPERANDS_FLUSH_RESULTS() {
        return _DN_SAVE_OPERANDS_FLUSH_RESULTS;
    }
    private static final int _SW_UNEMULATED = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _SW_UNEMULATED 64
     * }
     */
    public static int _SW_UNEMULATED() {
        return _SW_UNEMULATED;
    }
    private static final int _SW_SQRTNEG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SW_SQRTNEG 128
     * }
     */
    public static int _SW_SQRTNEG() {
        return _SW_SQRTNEG;
    }
    private static final int _SW_STACKOVERFLOW = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _SW_STACKOVERFLOW 512
     * }
     */
    public static int _SW_STACKOVERFLOW() {
        return _SW_STACKOVERFLOW;
    }
    private static final int _SW_STACKUNDERFLOW = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define _SW_STACKUNDERFLOW 1024
     * }
     */
    public static int _SW_STACKUNDERFLOW() {
        return _SW_STACKUNDERFLOW;
    }
    private static final int _FPE_INVALID = (int)129L;
    /**
     * {@snippet lang=c :
     * #define _FPE_INVALID 129
     * }
     */
    public static int _FPE_INVALID() {
        return _FPE_INVALID;
    }
    private static final int _FPE_DENORMAL = (int)130L;
    /**
     * {@snippet lang=c :
     * #define _FPE_DENORMAL 130
     * }
     */
    public static int _FPE_DENORMAL() {
        return _FPE_DENORMAL;
    }
    private static final int _FPE_ZERODIVIDE = (int)131L;
    /**
     * {@snippet lang=c :
     * #define _FPE_ZERODIVIDE 131
     * }
     */
    public static int _FPE_ZERODIVIDE() {
        return _FPE_ZERODIVIDE;
    }
    private static final int _FPE_OVERFLOW = (int)132L;
    /**
     * {@snippet lang=c :
     * #define _FPE_OVERFLOW 132
     * }
     */
    public static int _FPE_OVERFLOW() {
        return _FPE_OVERFLOW;
    }
    private static final int _FPE_UNDERFLOW = (int)133L;
    /**
     * {@snippet lang=c :
     * #define _FPE_UNDERFLOW 133
     * }
     */
    public static int _FPE_UNDERFLOW() {
        return _FPE_UNDERFLOW;
    }
    private static final int _FPE_INEXACT = (int)134L;
    /**
     * {@snippet lang=c :
     * #define _FPE_INEXACT 134
     * }
     */
    public static int _FPE_INEXACT() {
        return _FPE_INEXACT;
    }
    private static final int _FPE_UNEMULATED = (int)135L;
    /**
     * {@snippet lang=c :
     * #define _FPE_UNEMULATED 135
     * }
     */
    public static int _FPE_UNEMULATED() {
        return _FPE_UNEMULATED;
    }
    private static final int _FPE_SQRTNEG = (int)136L;
    /**
     * {@snippet lang=c :
     * #define _FPE_SQRTNEG 136
     * }
     */
    public static int _FPE_SQRTNEG() {
        return _FPE_SQRTNEG;
    }
    private static final int _FPE_STACKOVERFLOW = (int)138L;
    /**
     * {@snippet lang=c :
     * #define _FPE_STACKOVERFLOW 138
     * }
     */
    public static int _FPE_STACKOVERFLOW() {
        return _FPE_STACKOVERFLOW;
    }
    private static final int _FPE_STACKUNDERFLOW = (int)139L;
    /**
     * {@snippet lang=c :
     * #define _FPE_STACKUNDERFLOW 139
     * }
     */
    public static int _FPE_STACKUNDERFLOW() {
        return _FPE_STACKUNDERFLOW;
    }
    private static final int _FPE_EXPLICITGEN = (int)140L;
    /**
     * {@snippet lang=c :
     * #define _FPE_EXPLICITGEN 140
     * }
     */
    public static int _FPE_EXPLICITGEN() {
        return _FPE_EXPLICITGEN;
    }
    private static final int _FPE_MULTIPLE_TRAPS = (int)141L;
    /**
     * {@snippet lang=c :
     * #define _FPE_MULTIPLE_TRAPS 141
     * }
     */
    public static int _FPE_MULTIPLE_TRAPS() {
        return _FPE_MULTIPLE_TRAPS;
    }
    private static final int _FPE_MULTIPLE_FAULTS = (int)142L;
    /**
     * {@snippet lang=c :
     * #define _FPE_MULTIPLE_FAULTS 142
     * }
     */
    public static int _FPE_MULTIPLE_FAULTS() {
        return _FPE_MULTIPLE_FAULTS;
    }
    private static final int _FPCLASS_SNAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_SNAN 1
     * }
     */
    public static int _FPCLASS_SNAN() {
        return _FPCLASS_SNAN;
    }
    private static final int _FPCLASS_QNAN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_QNAN 2
     * }
     */
    public static int _FPCLASS_QNAN() {
        return _FPCLASS_QNAN;
    }
    private static final int _FPCLASS_NINF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_NINF 4
     * }
     */
    public static int _FPCLASS_NINF() {
        return _FPCLASS_NINF;
    }
    private static final int _FPCLASS_NN = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_NN 8
     * }
     */
    public static int _FPCLASS_NN() {
        return _FPCLASS_NN;
    }
    private static final int _FPCLASS_ND = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_ND 16
     * }
     */
    public static int _FPCLASS_ND() {
        return _FPCLASS_ND;
    }
    private static final int _FPCLASS_NZ = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_NZ 32
     * }
     */
    public static int _FPCLASS_NZ() {
        return _FPCLASS_NZ;
    }
    private static final int _FPCLASS_PZ = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_PZ 64
     * }
     */
    public static int _FPCLASS_PZ() {
        return _FPCLASS_PZ;
    }
    private static final int _FPCLASS_PD = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_PD 128
     * }
     */
    public static int _FPCLASS_PD() {
        return _FPCLASS_PD;
    }
    private static final int _FPCLASS_PN = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_PN 256
     * }
     */
    public static int _FPCLASS_PN() {
        return _FPCLASS_PN;
    }
    private static final int _FPCLASS_PINF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _FPCLASS_PINF 512
     * }
     */
    public static int _FPCLASS_PINF() {
        return _FPCLASS_PINF;
    }
    private static final int G_HAVE_GINT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define G_HAVE_GINT64 1
     * }
     */
    public static int G_HAVE_GINT64() {
        return G_HAVE_GINT64;
    }
    private static final int GLIB_SIZEOF_VOID_P = (int)8L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SIZEOF_VOID_P 8
     * }
     */
    public static int GLIB_SIZEOF_VOID_P() {
        return GLIB_SIZEOF_VOID_P;
    }
    private static final int GLIB_SIZEOF_LONG = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SIZEOF_LONG 4
     * }
     */
    public static int GLIB_SIZEOF_LONG() {
        return GLIB_SIZEOF_LONG;
    }
    private static final int GLIB_SIZEOF_SIZE_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SIZEOF_SIZE_T 8
     * }
     */
    public static int GLIB_SIZEOF_SIZE_T() {
        return GLIB_SIZEOF_SIZE_T;
    }
    private static final int GLIB_SIZEOF_SSIZE_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SIZEOF_SSIZE_T 8
     * }
     */
    public static int GLIB_SIZEOF_SSIZE_T() {
        return GLIB_SIZEOF_SSIZE_T;
    }
    private static final int GLIB_MAJOR_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GLIB_MAJOR_VERSION 2
     * }
     */
    public static int GLIB_MAJOR_VERSION() {
        return GLIB_MAJOR_VERSION;
    }
    private static final int GLIB_MINOR_VERSION = (int)80L;
    /**
     * {@snippet lang=c :
     * #define GLIB_MINOR_VERSION 80
     * }
     */
    public static int GLIB_MINOR_VERSION() {
        return GLIB_MINOR_VERSION;
    }
    private static final int GLIB_MICRO_VERSION = (int)5L;
    /**
     * {@snippet lang=c :
     * #define GLIB_MICRO_VERSION 5
     * }
     */
    public static int GLIB_MICRO_VERSION() {
        return GLIB_MICRO_VERSION;
    }
    private static final int G_HAVE_ISO_VARARGS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define G_HAVE_ISO_VARARGS 1
     * }
     */
    public static int G_HAVE_ISO_VARARGS() {
        return G_HAVE_ISO_VARARGS;
    }
    private static final int G_HAVE_GROWING_STACK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define G_HAVE_GROWING_STACK 0
     * }
     */
    public static int G_HAVE_GROWING_STACK() {
        return G_HAVE_GROWING_STACK;
    }
    private static final int GLIB_SYSDEF_AF_UNIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SYSDEF_AF_UNIX 1
     * }
     */
    public static int GLIB_SYSDEF_AF_UNIX() {
        return GLIB_SYSDEF_AF_UNIX;
    }
    private static final int GLIB_SYSDEF_AF_INET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SYSDEF_AF_INET 2
     * }
     */
    public static int GLIB_SYSDEF_AF_INET() {
        return GLIB_SYSDEF_AF_INET;
    }
    private static final int GLIB_SYSDEF_AF_INET6 = (int)23L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SYSDEF_AF_INET6 23
     * }
     */
    public static int GLIB_SYSDEF_AF_INET6() {
        return GLIB_SYSDEF_AF_INET6;
    }
    private static final int GLIB_SYSDEF_MSG_OOB = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SYSDEF_MSG_OOB 1
     * }
     */
    public static int GLIB_SYSDEF_MSG_OOB() {
        return GLIB_SYSDEF_MSG_OOB;
    }
    private static final int GLIB_SYSDEF_MSG_PEEK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SYSDEF_MSG_PEEK 2
     * }
     */
    public static int GLIB_SYSDEF_MSG_PEEK() {
        return GLIB_SYSDEF_MSG_PEEK;
    }
    private static final int GLIB_SYSDEF_MSG_DONTROUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GLIB_SYSDEF_MSG_DONTROUTE 4
     * }
     */
    public static int GLIB_SYSDEF_MSG_DONTROUTE() {
        return GLIB_SYSDEF_MSG_DONTROUTE;
    }
    private static final int _CRT_USE_CONFORMING_ANNEX_K_TIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_USE_CONFORMING_ANNEX_K_TIME 0
     * }
     */
    public static int _CRT_USE_CONFORMING_ANNEX_K_TIME() {
        return _CRT_USE_CONFORMING_ANNEX_K_TIME;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    private static final int G_LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define G_LITTLE_ENDIAN 1234
     * }
     */
    public static int G_LITTLE_ENDIAN() {
        return G_LITTLE_ENDIAN;
    }
    private static final int G_BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define G_BIG_ENDIAN 4321
     * }
     */
    public static int G_BIG_ENDIAN() {
        return G_BIG_ENDIAN;
    }
    private static final int G_PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define G_PDP_ENDIAN 3412
     * }
     */
    public static int G_PDP_ENDIAN() {
        return G_PDP_ENDIAN;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int EDEADLK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 36
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 38
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 39
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 40
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)41L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 41
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EILSEQ = (int)42L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 42
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int STRUNCATE = (int)80L;
    /**
     * {@snippet lang=c :
     * #define STRUNCATE 80
     * }
     */
    public static int STRUNCATE() {
        return STRUNCATE;
    }
    private static final int EADDRINUSE = (int)100L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 100
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)101L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 101
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int EAFNOSUPPORT = (int)102L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 102
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EALREADY = (int)103L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 103
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EBADMSG = (int)104L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 104
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int ECANCELED = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 105
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ECONNABORTED = (int)106L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 106
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNREFUSED = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 107
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int ECONNRESET = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 108
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int EDESTADDRREQ = (int)109L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 109
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EHOSTUNREACH = (int)110L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 110
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EIDRM = (int)111L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 111
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int EINPROGRESS = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 112
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int EISCONN = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 113
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ELOOP = (int)114L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 114
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int EMSGSIZE = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 115
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int ENETDOWN = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 116
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETRESET = (int)117L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 117
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ENETUNREACH = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 118
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENOBUFS = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 119
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int ENODATA = (int)120L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 120
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ENOLINK = (int)121L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 121
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int ENOMSG = (int)122L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 122
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int ENOPROTOOPT = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 123
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int ENOSR = (int)124L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 124
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENOSTR = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 125
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENOTCONN = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 126
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ENOTRECOVERABLE = (int)127L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 127
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ENOTSOCK = (int)128L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 128
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int ENOTSUP = (int)129L;
    /**
     * {@snippet lang=c :
     * #define ENOTSUP 129
     * }
     */
    public static int ENOTSUP() {
        return ENOTSUP;
    }
    private static final int EOPNOTSUPP = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 130
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EOTHER = (int)131L;
    /**
     * {@snippet lang=c :
     * #define EOTHER 131
     * }
     */
    public static int EOTHER() {
        return EOTHER;
    }
    private static final int EOVERFLOW = (int)132L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 132
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int EOWNERDEAD = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 133
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int EPROTO = (int)134L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 134
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EPROTONOSUPPORT = (int)135L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 135
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int EPROTOTYPE = (int)136L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 136
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ETIME = (int)137L;
    /**
     * {@snippet lang=c :
     * #define ETIME 137
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ETIMEDOUT = (int)138L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 138
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ETXTBSY = (int)139L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 139
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EWOULDBLOCK = (int)140L;
    /**
     * {@snippet lang=c :
     * #define EWOULDBLOCK 140
     * }
     */
    public static int EWOULDBLOCK() {
        return EWOULDBLOCK;
    }
    private static final int _FREEENTRY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _FREEENTRY 0
     * }
     */
    public static int _FREEENTRY() {
        return _FREEENTRY;
    }
    private static final int _USEDENTRY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _USEDENTRY 1
     * }
     */
    public static int _USEDENTRY() {
        return _USEDENTRY;
    }
    private static final int _ALLOCA_S_THRESHOLD = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_S_THRESHOLD 1024
     * }
     */
    public static int _ALLOCA_S_THRESHOLD() {
        return _ALLOCA_S_THRESHOLD;
    }
    private static final int _ALLOCA_S_STACK_MARKER = (int)52428L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_S_STACK_MARKER 52428
     * }
     */
    public static int _ALLOCA_S_STACK_MARKER() {
        return _ALLOCA_S_STACK_MARKER;
    }
    private static final int _ALLOCA_S_HEAP_MARKER = (int)56797L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_S_HEAP_MARKER 56797
     * }
     */
    public static int _ALLOCA_S_HEAP_MARKER() {
        return _ALLOCA_S_HEAP_MARKER;
    }
    private static final int _ALLOCA_S_MARKER_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_S_MARKER_SIZE 16
     * }
     */
    public static int _ALLOCA_S_MARKER_SIZE() {
        return _ALLOCA_S_MARKER_SIZE;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int NSIG = (int)23L;
    /**
     * {@snippet lang=c :
     * #define NSIG 23
     * }
     */
    public static int NSIG() {
        return NSIG;
    }
    private static final int SIGINT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIGINT 2
     * }
     */
    public static int SIGINT() {
        return SIGINT;
    }
    private static final int SIGILL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIGILL 4
     * }
     */
    public static int SIGILL() {
        return SIGILL;
    }
    private static final int SIGFPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIGFPE 8
     * }
     */
    public static int SIGFPE() {
        return SIGFPE;
    }
    private static final int SIGSEGV = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SIGSEGV 11
     * }
     */
    public static int SIGSEGV() {
        return SIGSEGV;
    }
    private static final int SIGTERM = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SIGTERM 15
     * }
     */
    public static int SIGTERM() {
        return SIGTERM;
    }
    private static final int SIGBREAK = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SIGBREAK 21
     * }
     */
    public static int SIGBREAK() {
        return SIGBREAK;
    }
    private static final int SIGABRT = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SIGABRT 22
     * }
     */
    public static int SIGABRT() {
        return SIGABRT;
    }
    private static final int SIGABRT_COMPAT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGABRT_COMPAT 6
     * }
     */
    public static int SIGABRT_COMPAT() {
        return SIGABRT_COMPAT;
    }
    private static final int G_DATALIST_FLAGS_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define G_DATALIST_FLAGS_MASK 3
     * }
     */
    public static int G_DATALIST_FLAGS_MASK() {
        return G_DATALIST_FLAGS_MASK;
    }
    private static final int G_PRIORITY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define G_PRIORITY_DEFAULT 0
     * }
     */
    public static int G_PRIORITY_DEFAULT() {
        return G_PRIORITY_DEFAULT;
    }
    private static final int G_PRIORITY_HIGH_IDLE = (int)100L;
    /**
     * {@snippet lang=c :
     * #define G_PRIORITY_HIGH_IDLE 100
     * }
     */
    public static int G_PRIORITY_HIGH_IDLE() {
        return G_PRIORITY_HIGH_IDLE;
    }
    private static final int G_PRIORITY_DEFAULT_IDLE = (int)200L;
    /**
     * {@snippet lang=c :
     * #define G_PRIORITY_DEFAULT_IDLE 200
     * }
     */
    public static int G_PRIORITY_DEFAULT_IDLE() {
        return G_PRIORITY_DEFAULT_IDLE;
    }
    private static final int G_PRIORITY_LOW = (int)300L;
    /**
     * {@snippet lang=c :
     * #define G_PRIORITY_LOW 300
     * }
     */
    public static int G_PRIORITY_LOW() {
        return G_PRIORITY_LOW;
    }
    private static final int G_UNICHAR_MAX_DECOMPOSITION_LENGTH = (int)18L;
    /**
     * {@snippet lang=c :
     * #define G_UNICHAR_MAX_DECOMPOSITION_LENGTH 18
     * }
     */
    public static int G_UNICHAR_MAX_DECOMPOSITION_LENGTH() {
        return G_UNICHAR_MAX_DECOMPOSITION_LENGTH;
    }
    private static final int G_WIN32_MSG_HANDLE = (int)19981206L;
    /**
     * {@snippet lang=c :
     * #define G_WIN32_MSG_HANDLE 19981206
     * }
     */
    public static int G_WIN32_MSG_HANDLE() {
        return G_WIN32_MSG_HANDLE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int _WRITE_ABORT_MSG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _WRITE_ABORT_MSG 1
     * }
     */
    public static int _WRITE_ABORT_MSG() {
        return _WRITE_ABORT_MSG;
    }
    private static final int _CALL_REPORTFAULT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _CALL_REPORTFAULT 2
     * }
     */
    public static int _CALL_REPORTFAULT() {
        return _CALL_REPORTFAULT;
    }
    private static final int _OUT_TO_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_DEFAULT 0
     * }
     */
    public static int _OUT_TO_DEFAULT() {
        return _OUT_TO_DEFAULT;
    }
    private static final int _OUT_TO_STDERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_STDERR 1
     * }
     */
    public static int _OUT_TO_STDERR() {
        return _OUT_TO_STDERR;
    }
    private static final int _OUT_TO_MSGBOX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_MSGBOX 2
     * }
     */
    public static int _OUT_TO_MSGBOX() {
        return _OUT_TO_MSGBOX;
    }
    private static final int _REPORT_ERRMODE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _REPORT_ERRMODE 3
     * }
     */
    public static int _REPORT_ERRMODE() {
        return _REPORT_ERRMODE;
    }
    private static final int RAND_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 32767
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int _MAX_PATH = (int)260L;
    /**
     * {@snippet lang=c :
     * #define _MAX_PATH 260
     * }
     */
    public static int _MAX_PATH() {
        return _MAX_PATH;
    }
    private static final int _MAX_DRIVE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _MAX_DRIVE 3
     * }
     */
    public static int _MAX_DRIVE() {
        return _MAX_DRIVE;
    }
    private static final int _MAX_DIR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_DIR 256
     * }
     */
    public static int _MAX_DIR() {
        return _MAX_DIR;
    }
    private static final int _MAX_FNAME = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_FNAME 256
     * }
     */
    public static int _MAX_FNAME() {
        return _MAX_FNAME;
    }
    private static final int _MAX_EXT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_EXT 256
     * }
     */
    public static int _MAX_EXT() {
        return _MAX_EXT;
    }
    private static final int _MAX_ENV = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ENV 32767
     * }
     */
    public static int _MAX_ENV() {
        return _MAX_ENV;
    }
    private static final int G_USEC_PER_SEC = (int)1000000L;
    /**
     * {@snippet lang=c :
     * #define G_USEC_PER_SEC 1000000
     * }
     */
    public static int G_USEC_PER_SEC() {
        return G_USEC_PER_SEC;
    }
    private static final int MAXPATHLEN = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MAXPATHLEN 1024
     * }
     */
    public static int MAXPATHLEN() {
        return MAXPATHLEN;
    }
    private static final int G_ALLOC_ONLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define G_ALLOC_ONLY 1
     * }
     */
    public static int G_ALLOC_ONLY() {
        return G_ALLOC_ONLY;
    }
    private static final int G_ALLOC_AND_FREE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define G_ALLOC_AND_FREE 2
     * }
     */
    public static int G_ALLOC_AND_FREE() {
        return G_ALLOC_AND_FREE;
    }
    private static final int G_ALLOCATOR_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define G_ALLOCATOR_LIST 1
     * }
     */
    public static int G_ALLOCATOR_LIST() {
        return G_ALLOCATOR_LIST;
    }
    private static final int G_ALLOCATOR_SLIST = (int)2L;
    /**
     * {@snippet lang=c :
     * #define G_ALLOCATOR_SLIST 2
     * }
     */
    public static int G_ALLOCATOR_SLIST() {
        return G_ALLOCATOR_SLIST;
    }
    private static final int G_ALLOCATOR_NODE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define G_ALLOCATOR_NODE 3
     * }
     */
    public static int G_ALLOCATOR_NODE() {
        return G_ALLOCATOR_NODE;
    }
    private static final int G_SIGNAL_FLAGS_MASK = (int)511L;
    /**
     * {@snippet lang=c :
     * #define G_SIGNAL_FLAGS_MASK 511
     * }
     */
    public static int G_SIGNAL_FLAGS_MASK() {
        return G_SIGNAL_FLAGS_MASK;
    }
    private static final int G_SIGNAL_MATCH_MASK = (int)63L;
    /**
     * {@snippet lang=c :
     * #define G_SIGNAL_MATCH_MASK 63
     * }
     */
    public static int G_SIGNAL_MATCH_MASK() {
        return G_SIGNAL_MATCH_MASK;
    }
    private static final int GST_PADDING = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GST_PADDING 4
     * }
     */
    public static int GST_PADDING() {
        return GST_PADDING;
    }
    private static final int GST_PADDING_LARGE = (int)20L;
    /**
     * {@snippet lang=c :
     * #define GST_PADDING_LARGE 20
     * }
     */
    public static int GST_PADDING_LARGE() {
        return GST_PADDING_LARGE;
    }
    private static final int GST_DISABLE_CAST_CHECKS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_DISABLE_CAST_CHECKS 1
     * }
     */
    public static int GST_DISABLE_CAST_CHECKS() {
        return GST_DISABLE_CAST_CHECKS;
    }
    private static final int GST_DISABLE_GLIB_ASSERTS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_DISABLE_GLIB_ASSERTS 0
     * }
     */
    public static int GST_DISABLE_GLIB_ASSERTS() {
        return GST_DISABLE_GLIB_ASSERTS;
    }
    private static final int GST_DISABLE_GLIB_CHECKS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_DISABLE_GLIB_CHECKS 0
     * }
     */
    public static int GST_DISABLE_GLIB_CHECKS() {
        return GST_DISABLE_GLIB_CHECKS;
    }
    private static final int GST_HAVE_UNALIGNED_ACCESS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_HAVE_UNALIGNED_ACCESS 1
     * }
     */
    public static int GST_HAVE_UNALIGNED_ACCESS() {
        return GST_HAVE_UNALIGNED_ACCESS;
    }
    private static final int GST_CAN_INLINE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_CAN_INLINE 1
     * }
     */
    public static int GST_CAN_INLINE() {
        return GST_CAN_INLINE;
    }
    private static final int GST_URI_NO_PORT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_URI_NO_PORT 0
     * }
     */
    public static int GST_URI_NO_PORT() {
        return GST_URI_NO_PORT;
    }
    private static final int GST_VALUE_EQUAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_VALUE_EQUAL 0
     * }
     */
    public static int GST_VALUE_EQUAL() {
        return GST_VALUE_EQUAL;
    }
    private static final int GST_VALUE_GREATER_THAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_VALUE_GREATER_THAN 1
     * }
     */
    public static int GST_VALUE_GREATER_THAN() {
        return GST_VALUE_GREATER_THAN;
    }
    private static final int GST_VALUE_UNORDERED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GST_VALUE_UNORDERED 2
     * }
     */
    public static int GST_VALUE_UNORDERED() {
        return GST_VALUE_UNORDERED;
    }
    private static final int GST_GL_HAVE_OPENGL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_OPENGL 1
     * }
     */
    public static int GST_GL_HAVE_OPENGL() {
        return GST_GL_HAVE_OPENGL;
    }
    private static final int GST_GL_HAVE_GLES2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLES2 0
     * }
     */
    public static int GST_GL_HAVE_GLES2() {
        return GST_GL_HAVE_GLES2;
    }
    private static final int GST_GL_HAVE_GLES3 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLES3 0
     * }
     */
    public static int GST_GL_HAVE_GLES3() {
        return GST_GL_HAVE_GLES3;
    }
    private static final int GST_GL_HAVE_GLES3EXT3_H = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLES3EXT3_H 0
     * }
     */
    public static int GST_GL_HAVE_GLES3EXT3_H() {
        return GST_GL_HAVE_GLES3EXT3_H;
    }
    private static final int GST_GL_HAVE_WINDOW_X11 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_X11 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_X11() {
        return GST_GL_HAVE_WINDOW_X11;
    }
    private static final int GST_GL_HAVE_WINDOW_COCOA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_COCOA 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_COCOA() {
        return GST_GL_HAVE_WINDOW_COCOA;
    }
    private static final int GST_GL_HAVE_WINDOW_WIN32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_WIN32 1
     * }
     */
    public static int GST_GL_HAVE_WINDOW_WIN32() {
        return GST_GL_HAVE_WINDOW_WIN32;
    }
    private static final int GST_GL_HAVE_WINDOW_WINRT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_WINRT 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_WINRT() {
        return GST_GL_HAVE_WINDOW_WINRT;
    }
    private static final int GST_GL_HAVE_WINDOW_WAYLAND = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_WAYLAND 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_WAYLAND() {
        return GST_GL_HAVE_WINDOW_WAYLAND;
    }
    private static final int GST_GL_HAVE_WINDOW_ANDROID = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_ANDROID 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_ANDROID() {
        return GST_GL_HAVE_WINDOW_ANDROID;
    }
    private static final int GST_GL_HAVE_WINDOW_DISPMANX = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_DISPMANX 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_DISPMANX() {
        return GST_GL_HAVE_WINDOW_DISPMANX;
    }
    private static final int GST_GL_HAVE_WINDOW_EAGL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_EAGL 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_EAGL() {
        return GST_GL_HAVE_WINDOW_EAGL;
    }
    private static final int GST_GL_HAVE_WINDOW_VIV_FB = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_VIV_FB 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_VIV_FB() {
        return GST_GL_HAVE_WINDOW_VIV_FB;
    }
    private static final int GST_GL_HAVE_WINDOW_GBM = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_WINDOW_GBM 0
     * }
     */
    public static int GST_GL_HAVE_WINDOW_GBM() {
        return GST_GL_HAVE_WINDOW_GBM;
    }
    private static final int GST_GL_HAVE_PLATFORM_EGL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_PLATFORM_EGL 0
     * }
     */
    public static int GST_GL_HAVE_PLATFORM_EGL() {
        return GST_GL_HAVE_PLATFORM_EGL;
    }
    private static final int GST_GL_HAVE_PLATFORM_GLX = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_PLATFORM_GLX 0
     * }
     */
    public static int GST_GL_HAVE_PLATFORM_GLX() {
        return GST_GL_HAVE_PLATFORM_GLX;
    }
    private static final int GST_GL_HAVE_PLATFORM_WGL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_PLATFORM_WGL 1
     * }
     */
    public static int GST_GL_HAVE_PLATFORM_WGL() {
        return GST_GL_HAVE_PLATFORM_WGL;
    }
    private static final int GST_GL_HAVE_PLATFORM_CGL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_PLATFORM_CGL 0
     * }
     */
    public static int GST_GL_HAVE_PLATFORM_CGL() {
        return GST_GL_HAVE_PLATFORM_CGL;
    }
    private static final int GST_GL_HAVE_PLATFORM_EAGL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_PLATFORM_EAGL 0
     * }
     */
    public static int GST_GL_HAVE_PLATFORM_EAGL() {
        return GST_GL_HAVE_PLATFORM_EAGL;
    }
    private static final int GST_GL_HAVE_DMABUF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_DMABUF 0
     * }
     */
    public static int GST_GL_HAVE_DMABUF() {
        return GST_GL_HAVE_DMABUF;
    }
    private static final int GST_GL_HAVE_VIV_DIRECTVIV = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_VIV_DIRECTVIV 0
     * }
     */
    public static int GST_GL_HAVE_VIV_DIRECTVIV() {
        return GST_GL_HAVE_VIV_DIRECTVIV;
    }
    private static final int GST_GL_HAVE_GLEGLIMAGEOES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLEGLIMAGEOES 1
     * }
     */
    public static int GST_GL_HAVE_GLEGLIMAGEOES() {
        return GST_GL_HAVE_GLEGLIMAGEOES;
    }
    private static final int GST_GL_HAVE_GLCHAR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLCHAR 1
     * }
     */
    public static int GST_GL_HAVE_GLCHAR() {
        return GST_GL_HAVE_GLCHAR;
    }
    private static final int GST_GL_HAVE_GLSIZEIPTR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLSIZEIPTR 1
     * }
     */
    public static int GST_GL_HAVE_GLSIZEIPTR() {
        return GST_GL_HAVE_GLSIZEIPTR;
    }
    private static final int GST_GL_HAVE_GLINTPTR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLINTPTR 1
     * }
     */
    public static int GST_GL_HAVE_GLINTPTR() {
        return GST_GL_HAVE_GLINTPTR;
    }
    private static final int GST_GL_HAVE_GLSYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLSYNC 1
     * }
     */
    public static int GST_GL_HAVE_GLSYNC() {
        return GST_GL_HAVE_GLSYNC;
    }
    private static final int GST_GL_HAVE_GLUINT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLUINT64 1
     * }
     */
    public static int GST_GL_HAVE_GLUINT64() {
        return GST_GL_HAVE_GLUINT64;
    }
    private static final int GST_GL_HAVE_GLINT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_GLINT64 1
     * }
     */
    public static int GST_GL_HAVE_GLINT64() {
        return GST_GL_HAVE_GLINT64;
    }
    private static final int GST_GL_HAVE_EGLATTRIB = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_EGLATTRIB 0
     * }
     */
    public static int GST_GL_HAVE_EGLATTRIB() {
        return GST_GL_HAVE_EGLATTRIB;
    }
    private static final int GST_GL_HAVE_EGLUINT64KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_GL_HAVE_EGLUINT64KHR 0
     * }
     */
    public static int GST_GL_HAVE_EGLUINT64KHR() {
        return GST_GL_HAVE_EGLUINT64KHR;
    }
    private static final int GST_VIDEO_MAX_PLANES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_MAX_PLANES 4
     * }
     */
    public static int GST_VIDEO_MAX_PLANES() {
        return GST_VIDEO_MAX_PLANES;
    }
    private static final int GST_VIDEO_MAX_COMPONENTS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_MAX_COMPONENTS 4
     * }
     */
    public static int GST_VIDEO_MAX_COMPONENTS() {
        return GST_VIDEO_MAX_COMPONENTS;
    }
    private static final int GST_VIDEO_COMP_Y = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_Y 0
     * }
     */
    public static int GST_VIDEO_COMP_Y() {
        return GST_VIDEO_COMP_Y;
    }
    private static final int GST_VIDEO_COMP_U = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_U 1
     * }
     */
    public static int GST_VIDEO_COMP_U() {
        return GST_VIDEO_COMP_U;
    }
    private static final int GST_VIDEO_COMP_V = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_V 2
     * }
     */
    public static int GST_VIDEO_COMP_V() {
        return GST_VIDEO_COMP_V;
    }
    private static final int GST_VIDEO_COMP_R = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_R 0
     * }
     */
    public static int GST_VIDEO_COMP_R() {
        return GST_VIDEO_COMP_R;
    }
    private static final int GST_VIDEO_COMP_G = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_G 1
     * }
     */
    public static int GST_VIDEO_COMP_G() {
        return GST_VIDEO_COMP_G;
    }
    private static final int GST_VIDEO_COMP_B = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_B 2
     * }
     */
    public static int GST_VIDEO_COMP_B() {
        return GST_VIDEO_COMP_B;
    }
    private static final int GST_VIDEO_COMP_A = (int)3L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_A 3
     * }
     */
    public static int GST_VIDEO_COMP_A() {
        return GST_VIDEO_COMP_A;
    }
    private static final int GST_VIDEO_COMP_INDEX = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_INDEX 0
     * }
     */
    public static int GST_VIDEO_COMP_INDEX() {
        return GST_VIDEO_COMP_INDEX;
    }
    private static final int GST_VIDEO_COMP_PALETTE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GST_VIDEO_COMP_PALETTE 1
     * }
     */
    public static int GST_VIDEO_COMP_PALETTE() {
        return GST_VIDEO_COMP_PALETTE;
    }
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = gst_min_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = gst_min_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *va_list
     * }
     */
    public static final AddressLayout va_list = gst_min_h.C_POINTER;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = gst_min_h.C_BOOL;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__security_init_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MemorySegment __security_init_cookie$address() {
        return __security_init_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__security_check_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __security_check_cookie$address() {
        return __security_check_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__report_gsfailure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __report_gsfailure$address() {
        return __report_gsfailure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = gst_min_h.C_LONG_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef _Bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = gst_min_h.C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invalid_parameter_noinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo$address() {
        return _invalid_parameter_noinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invalid_parameter_noinfo_noreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo_noreturn$address() {
        return _invalid_parameter_noinfo_noreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invoke_watson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MemorySegment _invoke_watson$address() {
        return _invoke_watson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName, int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = gst_min_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = gst_min_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = gst_min_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = gst_min_h.C_LONG_LONG;

    private static class _clearfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_clearfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _clearfp()
     * }
     */
    public static FunctionDescriptor _clearfp$descriptor() {
        return _clearfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _clearfp()
     * }
     */
    public static MethodHandle _clearfp$handle() {
        return _clearfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _clearfp()
     * }
     */
    public static MemorySegment _clearfp$address() {
        return _clearfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _clearfp()
     * }
     */
    public static int _clearfp() {
        var mh$ = _clearfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_clearfp");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _controlfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_controlfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _controlfp(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _controlfp$descriptor() {
        return _controlfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _controlfp(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static MethodHandle _controlfp$handle() {
        return _controlfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _controlfp(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static MemorySegment _controlfp$address() {
        return _controlfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _controlfp(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static int _controlfp(int _NewValue, int _Mask) {
        var mh$ = _controlfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_controlfp", _NewValue, _Mask);
            }
            return (int)mh$.invokeExact(_NewValue, _Mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_controlfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_controlfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _set_controlfp(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _set_controlfp$descriptor() {
        return _set_controlfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _set_controlfp(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static MethodHandle _set_controlfp$handle() {
        return _set_controlfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _set_controlfp(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static MemorySegment _set_controlfp$address() {
        return _set_controlfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _set_controlfp(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static void _set_controlfp(int _NewValue, int _Mask) {
        var mh$ = _set_controlfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_controlfp", _NewValue, _Mask);
            }
            mh$.invokeExact(_NewValue, _Mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _controlfp_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_controlfp_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _controlfp_s(unsigned int *_CurrentState, unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _controlfp_s$descriptor() {
        return _controlfp_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _controlfp_s(unsigned int *_CurrentState, unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static MethodHandle _controlfp_s$handle() {
        return _controlfp_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _controlfp_s(unsigned int *_CurrentState, unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static MemorySegment _controlfp_s$address() {
        return _controlfp_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _controlfp_s(unsigned int *_CurrentState, unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static int _controlfp_s(MemorySegment _CurrentState, int _NewValue, int _Mask) {
        var mh$ = _controlfp_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_controlfp_s", _CurrentState, _NewValue, _Mask);
            }
            return (int)mh$.invokeExact(_CurrentState, _NewValue, _Mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _statusfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_statusfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _statusfp()
     * }
     */
    public static FunctionDescriptor _statusfp$descriptor() {
        return _statusfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _statusfp()
     * }
     */
    public static MethodHandle _statusfp$handle() {
        return _statusfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _statusfp()
     * }
     */
    public static MemorySegment _statusfp$address() {
        return _statusfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _statusfp()
     * }
     */
    public static int _statusfp() {
        var mh$ = _statusfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_statusfp");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fpreset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fpreset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _fpreset()
     * }
     */
    public static FunctionDescriptor _fpreset$descriptor() {
        return _fpreset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _fpreset()
     * }
     */
    public static MethodHandle _fpreset$handle() {
        return _fpreset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _fpreset()
     * }
     */
    public static MemorySegment _fpreset$address() {
        return _fpreset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _fpreset()
     * }
     */
    public static void _fpreset() {
        var mh$ = _fpreset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fpreset");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _control87 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_control87");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _control87(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _control87$descriptor() {
        return _control87.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _control87(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static MethodHandle _control87$handle() {
        return _control87.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _control87(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static MemorySegment _control87$address() {
        return _control87.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _control87(unsigned int _NewValue, unsigned int _Mask)
     * }
     */
    public static int _control87(int _NewValue, int _Mask) {
        var mh$ = _control87.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_control87", _NewValue, _Mask);
            }
            return (int)mh$.invokeExact(_NewValue, _Mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpecode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__fpecode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__fpecode()
     * }
     */
    public static FunctionDescriptor __fpecode$descriptor() {
        return __fpecode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__fpecode()
     * }
     */
    public static MethodHandle __fpecode$handle() {
        return __fpecode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__fpecode()
     * }
     */
    public static MemorySegment __fpecode$address() {
        return __fpecode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__fpecode()
     * }
     */
    public static MemorySegment __fpecode() {
        var mh$ = __fpecode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpecode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpe_flt_rounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__fpe_flt_rounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __fpe_flt_rounds()
     * }
     */
    public static FunctionDescriptor __fpe_flt_rounds$descriptor() {
        return __fpe_flt_rounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __fpe_flt_rounds()
     * }
     */
    public static MethodHandle __fpe_flt_rounds$handle() {
        return __fpe_flt_rounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __fpe_flt_rounds()
     * }
     */
    public static MemorySegment __fpe_flt_rounds$address() {
        return __fpe_flt_rounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __fpe_flt_rounds()
     * }
     */
    public static int __fpe_flt_rounds() {
        var mh$ = __fpe_flt_rounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpe_flt_rounds");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor _copysign$descriptor() {
        return _copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle _copysign$handle() {
        return _copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment _copysign$address() {
        return _copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static double _copysign(double _Number, double _Sign) {
        var mh$ = _copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_chgsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static FunctionDescriptor _chgsign$descriptor() {
        return _chgsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MethodHandle _chgsign$handle() {
        return _chgsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MemorySegment _chgsign$address() {
        return _chgsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static double _chgsign(double _X) {
        var mh$ = _chgsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsign", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _scalb(double _X, long _Y)
     * }
     */
    public static FunctionDescriptor _scalb$descriptor() {
        return _scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _scalb(double _X, long _Y)
     * }
     */
    public static MethodHandle _scalb$handle() {
        return _scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _scalb(double _X, long _Y)
     * }
     */
    public static MemorySegment _scalb$address() {
        return _scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _scalb(double _X, long _Y)
     * }
     */
    public static double _scalb(double _X, int _Y) {
        var mh$ = _scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_scalb", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _logb(double _X)
     * }
     */
    public static FunctionDescriptor _logb$descriptor() {
        return _logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _logb(double _X)
     * }
     */
    public static MethodHandle _logb$handle() {
        return _logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _logb(double _X)
     * }
     */
    public static MemorySegment _logb$address() {
        return _logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _logb(double _X)
     * }
     */
    public static double _logb(double _X) {
        var mh$ = _logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_logb", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _nextafter(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _nextafter$descriptor() {
        return _nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _nextafter(double _X, double _Y)
     * }
     */
    public static MethodHandle _nextafter$handle() {
        return _nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _nextafter(double _X, double _Y)
     * }
     */
    public static MemorySegment _nextafter$address() {
        return _nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _nextafter(double _X, double _Y)
     * }
     */
    public static double _nextafter(double _X, double _Y) {
        var mh$ = _nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_nextafter", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _finite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_finite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _finite(double _X)
     * }
     */
    public static FunctionDescriptor _finite$descriptor() {
        return _finite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _finite(double _X)
     * }
     */
    public static MethodHandle _finite$handle() {
        return _finite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _finite(double _X)
     * }
     */
    public static MemorySegment _finite$address() {
        return _finite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _finite(double _X)
     * }
     */
    public static int _finite(double _X) {
        var mh$ = _finite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_finite", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isnan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_isnan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isnan(double _X)
     * }
     */
    public static FunctionDescriptor _isnan$descriptor() {
        return _isnan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isnan(double _X)
     * }
     */
    public static MethodHandle _isnan$handle() {
        return _isnan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isnan(double _X)
     * }
     */
    public static MemorySegment _isnan$address() {
        return _isnan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isnan(double _X)
     * }
     */
    public static int _isnan(double _X) {
        var mh$ = _isnan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isnan", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fpclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fpclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fpclass(double _X)
     * }
     */
    public static FunctionDescriptor _fpclass$descriptor() {
        return _fpclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fpclass(double _X)
     * }
     */
    public static MethodHandle _fpclass$handle() {
        return _fpclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fpclass(double _X)
     * }
     */
    public static MemorySegment _fpclass$address() {
        return _fpclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fpclass(double _X)
     * }
     */
    public static int _fpclass(double _X) {
        var mh$ = _fpclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fpclass", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _scalbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_FLOAT,
            gst_min_h.C_FLOAT,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_scalbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _scalbf(float _X, long _Y)
     * }
     */
    public static FunctionDescriptor _scalbf$descriptor() {
        return _scalbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _scalbf(float _X, long _Y)
     * }
     */
    public static MethodHandle _scalbf$handle() {
        return _scalbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _scalbf(float _X, long _Y)
     * }
     */
    public static MemorySegment _scalbf$address() {
        return _scalbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _scalbf(float _X, long _Y)
     * }
     */
    public static float _scalbf(float _X, int _Y) {
        var mh$ = _scalbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_scalbf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpreset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fpreset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fpreset()
     * }
     */
    public static FunctionDescriptor fpreset$descriptor() {
        return fpreset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fpreset()
     * }
     */
    public static MethodHandle fpreset$handle() {
        return fpreset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fpreset()
     * }
     */
    public static MemorySegment fpreset$address() {
        return fpreset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fpreset()
     * }
     */
    public static void fpreset() {
        var mh$ = fpreset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpreset");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char gint8
     * }
     */
    public static final OfByte gint8 = gst_min_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char guint8
     * }
     */
    public static final OfByte guint8 = gst_min_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short gint16
     * }
     */
    public static final OfShort gint16 = gst_min_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short guint16
     * }
     */
    public static final OfShort guint16 = gst_min_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int gint32
     * }
     */
    public static final OfInt gint32 = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int guint32
     * }
     */
    public static final OfInt guint32 = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long gint64
     * }
     */
    public static final OfLong gint64 = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long guint64
     * }
     */
    public static final OfLong guint64 = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long gssize
     * }
     */
    public static final OfLong gssize = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long gsize
     * }
     */
    public static final OfLong gsize = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef gint64 goffset
     * }
     */
    public static final OfLong goffset = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long gintptr
     * }
     */
    public static final OfLong gintptr = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long guintptr
     * }
     */
    public static final OfLong guintptr = gst_min_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *GPid
     * }
     */
    public static final AddressLayout GPid = gst_min_h.C_POINTER;

    private static class _wasctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wasctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _wasctime$descriptor() {
        return _wasctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MethodHandle _wasctime$handle() {
        return _wasctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime$address() {
        return _wasctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime(MemorySegment _Tm) {
        var mh$ = _wasctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wasctime", _Tm);
            }
            return (MemorySegment)mh$.invokeExact(_Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wasctime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wasctime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _wasctime_s$descriptor() {
        return _wasctime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static MethodHandle _wasctime_s$handle() {
        return _wasctime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime_s$address() {
        return _wasctime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static int _wasctime_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Tm) {
        var mh$ = _wasctime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wasctime_s", _Buffer, _SizeInWords, _Tm);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor wcsftime$descriptor() {
        return wcsftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static MethodHandle wcsftime$handle() {
        return wcsftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static MemorySegment wcsftime$address() {
        return wcsftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static long wcsftime(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Format, MemorySegment _Tm) {
        var mh$ = wcsftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsftime", _Buffer, _SizeInWords, _Format, _Tm);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInWords, _Format, _Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsftime_l$descriptor() {
        return _wcsftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsftime_l$handle() {
        return _wcsftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsftime_l$address() {
        return _wcsftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static long _wcsftime_l(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Format, MemorySegment _Tm, MemorySegment _Locale) {
        var mh$ = _wcsftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsftime_l", _Buffer, _SizeInWords, _Format, _Tm, _Locale);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInWords, _Format, _Tm, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wctime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime32$descriptor() {
        return _wctime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _wctime32$handle() {
        return _wctime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32$address() {
        return _wctime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32(MemorySegment _Time) {
        var mh$ = _wctime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wctime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime32_s$descriptor() {
        return _wctime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _wctime32_s$handle() {
        return _wctime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32_s$address() {
        return _wctime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static int _wctime32_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Time) {
        var mh$ = _wctime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime32_s", _Buffer, _SizeInWords, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wctime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime64$descriptor() {
        return _wctime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _wctime64$handle() {
        return _wctime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64$address() {
        return _wctime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64(MemorySegment _Time) {
        var mh$ = _wctime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wctime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime64_s$descriptor() {
        return _wctime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _wctime64_s$handle() {
        return _wctime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64_s$address() {
        return _wctime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static int _wctime64_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Time) {
        var mh$ = _wctime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime64_s", _Buffer, _SizeInWords, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrdate_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wstrdate_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wstrdate_s$descriptor() {
        return _wstrdate_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wstrdate_s$handle() {
        return _wstrdate_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wstrdate_s$address() {
        return _wstrdate_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static int _wstrdate_s(MemorySegment _Buffer, long _SizeInWords) {
        var mh$ = _wstrdate_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrdate_s", _Buffer, _SizeInWords);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wstrdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wstrdate$descriptor() {
        return _wstrdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wstrdate$handle() {
        return _wstrdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrdate$address() {
        return _wstrdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrdate(MemorySegment _Buffer) {
        var mh$ = _wstrdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrdate", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrtime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wstrtime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wstrtime_s$descriptor() {
        return _wstrtime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wstrtime_s$handle() {
        return _wstrtime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wstrtime_s$address() {
        return _wstrtime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static int _wstrtime_s(MemorySegment _Buffer, long _SizeInWords) {
        var mh$ = _wstrtime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrtime_s", _Buffer, _SizeInWords);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wstrtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wstrtime$descriptor() {
        return _wstrtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wstrtime$handle() {
        return _wstrtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrtime$address() {
        return _wstrtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrtime(MemorySegment _Buffer) {
        var mh$ = _wstrtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrtime", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long clock_t
     * }
     */
    public static final OfInt clock_t = gst_min_h.C_LONG;

    private static class __daylight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__daylight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static FunctionDescriptor __daylight$descriptor() {
        return __daylight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MethodHandle __daylight$handle() {
        return __daylight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MemorySegment __daylight$address() {
        return __daylight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MemorySegment __daylight() {
        var mh$ = __daylight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__daylight");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __dstbias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__dstbias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static FunctionDescriptor __dstbias$descriptor() {
        return __dstbias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MethodHandle __dstbias$handle() {
        return __dstbias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MemorySegment __dstbias$address() {
        return __dstbias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MemorySegment __dstbias() {
        var mh$ = __dstbias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__dstbias");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __timezone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__timezone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static FunctionDescriptor __timezone$descriptor() {
        return __timezone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MethodHandle __timezone$handle() {
        return __timezone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MemorySegment __timezone$address() {
        return __timezone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MemorySegment __timezone() {
        var mh$ = __timezone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__timezone");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__tzname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static FunctionDescriptor __tzname$descriptor() {
        return __tzname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MethodHandle __tzname$handle() {
        return __tzname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MemorySegment __tzname$address() {
        return __tzname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MemorySegment __tzname() {
        var mh$ = __tzname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tzname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_daylight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_daylight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static FunctionDescriptor _get_daylight$descriptor() {
        return _get_daylight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static MethodHandle _get_daylight$handle() {
        return _get_daylight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static MemorySegment _get_daylight$address() {
        return _get_daylight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static int _get_daylight(MemorySegment _Daylight) {
        var mh$ = _get_daylight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_daylight", _Daylight);
            }
            return (int)mh$.invokeExact(_Daylight);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_dstbias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_dstbias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static FunctionDescriptor _get_dstbias$descriptor() {
        return _get_dstbias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static MethodHandle _get_dstbias$handle() {
        return _get_dstbias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static MemorySegment _get_dstbias$address() {
        return _get_dstbias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static int _get_dstbias(MemorySegment _DaylightSavingsBias) {
        var mh$ = _get_dstbias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_dstbias", _DaylightSavingsBias);
            }
            return (int)mh$.invokeExact(_DaylightSavingsBias);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_timezone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_timezone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static FunctionDescriptor _get_timezone$descriptor() {
        return _get_timezone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static MethodHandle _get_timezone$handle() {
        return _get_timezone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static MemorySegment _get_timezone$address() {
        return _get_timezone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static int _get_timezone(MemorySegment _TimeZone) {
        var mh$ = _get_timezone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_timezone", _TimeZone);
            }
            return (int)mh$.invokeExact(_TimeZone);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_tzname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_tzname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static FunctionDescriptor _get_tzname$descriptor() {
        return _get_tzname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static MethodHandle _get_tzname$handle() {
        return _get_tzname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static MemorySegment _get_tzname$address() {
        return _get_tzname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static int _get_tzname(MemorySegment _ReturnValue, MemorySegment _Buffer, long _SizeInBytes, int _Index) {
        var mh$ = _get_tzname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_tzname", _ReturnValue, _Buffer, _SizeInBytes, _Index);
            }
            return (int)mh$.invokeExact(_ReturnValue, _Buffer, _SizeInBytes, _Index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime(MemorySegment _Tm) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", _Tm);
            }
            return (MemorySegment)mh$.invokeExact(_Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asctime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor asctime_s$descriptor() {
        return asctime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static MethodHandle asctime_s$handle() {
        return asctime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime_s$address() {
        return asctime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static int asctime_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Tm) {
        var mh$ = asctime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_s", _Buffer, _SizeInBytes, _Tm);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static int clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ctime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime32$descriptor() {
        return _ctime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _ctime32$handle() {
        return _ctime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32$address() {
        return _ctime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32(MemorySegment _Time) {
        var mh$ = _ctime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ctime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime32_s$descriptor() {
        return _ctime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _ctime32_s$handle() {
        return _ctime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32_s$address() {
        return _ctime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static int _ctime32_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Time) {
        var mh$ = _ctime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime32_s", _Buffer, _SizeInBytes, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ctime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime64$descriptor() {
        return _ctime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _ctime64$handle() {
        return _ctime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64$address() {
        return _ctime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64(MemorySegment _Time) {
        var mh$ = _ctime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ctime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime64_s$descriptor() {
        return _ctime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _ctime64_s$handle() {
        return _ctime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64_s$address() {
        return _ctime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static int _ctime64_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Time) {
        var mh$ = _ctime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime64_s", _Buffer, _SizeInBytes, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _difftime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_LONG,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_difftime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static FunctionDescriptor _difftime32$descriptor() {
        return _difftime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static MethodHandle _difftime32$handle() {
        return _difftime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static MemorySegment _difftime32$address() {
        return _difftime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static double _difftime32(int _Time1, int _Time2) {
        var mh$ = _difftime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_difftime32", _Time1, _Time2);
            }
            return (double)mh$.invokeExact(_Time1, _Time2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _difftime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_difftime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static FunctionDescriptor _difftime64$descriptor() {
        return _difftime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static MethodHandle _difftime64$handle() {
        return _difftime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static MemorySegment _difftime64$address() {
        return _difftime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static double _difftime64(long _Time1, long _Time2) {
        var mh$ = _difftime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_difftime64", _Time1, _Time2);
            }
            return (double)mh$.invokeExact(_Time1, _Time2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_gmtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime32$descriptor() {
        return _gmtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _gmtime32$handle() {
        return _gmtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32$address() {
        return _gmtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32(MemorySegment _Time) {
        var mh$ = _gmtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_gmtime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime32_s$descriptor() {
        return _gmtime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _gmtime32_s$handle() {
        return _gmtime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32_s$address() {
        return _gmtime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static int _gmtime32_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _gmtime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime32_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_gmtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime64$descriptor() {
        return _gmtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _gmtime64$handle() {
        return _gmtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64$address() {
        return _gmtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64(MemorySegment _Time) {
        var mh$ = _gmtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_gmtime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime64_s$descriptor() {
        return _gmtime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _gmtime64_s$handle() {
        return _gmtime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64_s$address() {
        return _gmtime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static int _gmtime64_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _gmtime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime64_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_localtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime32$descriptor() {
        return _localtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _localtime32$handle() {
        return _localtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32$address() {
        return _localtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32(MemorySegment _Time) {
        var mh$ = _localtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_localtime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime32_s$descriptor() {
        return _localtime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _localtime32_s$handle() {
        return _localtime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32_s$address() {
        return _localtime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static int _localtime32_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _localtime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime32_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_localtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime64$descriptor() {
        return _localtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _localtime64$handle() {
        return _localtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64$address() {
        return _localtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64(MemorySegment _Time) {
        var mh$ = _localtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_localtime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime64_s$descriptor() {
        return _localtime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _localtime64_s$handle() {
        return _localtime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64_s$address() {
        return _localtime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static int _localtime64_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _localtime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime64_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mkgmtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mkgmtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mkgmtime32$descriptor() {
        return _mkgmtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mkgmtime32$handle() {
        return _mkgmtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mkgmtime32$address() {
        return _mkgmtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static int _mkgmtime32(MemorySegment _Tm) {
        var mh$ = _mkgmtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mkgmtime32", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mkgmtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mkgmtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mkgmtime64$descriptor() {
        return _mkgmtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mkgmtime64$handle() {
        return _mkgmtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mkgmtime64$address() {
        return _mkgmtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static long _mkgmtime64(MemorySegment _Tm) {
        var mh$ = _mkgmtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mkgmtime64", _Tm);
            }
            return (long)mh$.invokeExact(_Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mktime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mktime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mktime32$descriptor() {
        return _mktime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mktime32$handle() {
        return _mktime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mktime32$address() {
        return _mktime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static int _mktime32(MemorySegment _Tm) {
        var mh$ = _mktime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mktime32", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mktime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mktime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mktime64$descriptor() {
        return _mktime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mktime64$handle() {
        return _mktime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mktime64$address() {
        return _mktime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static long _mktime64(MemorySegment _Tm) {
        var mh$ = _mktime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mktime64", _Tm);
            }
            return (long)mh$.invokeExact(_Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static long strftime(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Format, MemorySegment _Tm) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", _Buffer, _SizeInBytes, _Format, _Tm);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInBytes, _Format, _Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strftime_l$descriptor() {
        return _strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strftime_l$handle() {
        return _strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strftime_l$address() {
        return _strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static long _strftime_l(MemorySegment _Buffer, long _MaxSize, MemorySegment _Format, MemorySegment _Tm, MemorySegment _Locale) {
        var mh$ = _strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strftime_l", _Buffer, _MaxSize, _Format, _Tm, _Locale);
            }
            return (long)mh$.invokeExact(_Buffer, _MaxSize, _Format, _Tm, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdate_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strdate_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _strdate_s$descriptor() {
        return _strdate_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MethodHandle _strdate_s$handle() {
        return _strdate_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MemorySegment _strdate_s$address() {
        return _strdate_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static int _strdate_s(MemorySegment _Buffer, long _SizeInBytes) {
        var mh$ = _strdate_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdate_s", _Buffer, _SizeInBytes);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static FunctionDescriptor _strdate$descriptor() {
        return _strdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MethodHandle _strdate$handle() {
        return _strdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MemorySegment _strdate$address() {
        return _strdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MemorySegment _strdate(MemorySegment _Buffer) {
        var mh$ = _strdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdate", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _strtime_s$descriptor() {
        return _strtime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MethodHandle _strtime_s$handle() {
        return _strtime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MemorySegment _strtime_s$address() {
        return _strtime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static int _strtime_s(MemorySegment _Buffer, long _SizeInBytes) {
        var mh$ = _strtime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtime_s", _Buffer, _SizeInBytes);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static FunctionDescriptor _strtime$descriptor() {
        return _strtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MethodHandle _strtime$handle() {
        return _strtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MemorySegment _strtime$address() {
        return _strtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MemorySegment _strtime(MemorySegment _Buffer) {
        var mh$ = _strtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtime", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _time32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_time32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _time32$descriptor() {
        return _time32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static MethodHandle _time32$handle() {
        return _time32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static MemorySegment _time32$address() {
        return _time32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static int _time32(MemorySegment _Time) {
        var mh$ = _time32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_time32", _Time);
            }
            return (int)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _time64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_time64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _time64$descriptor() {
        return _time64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static MethodHandle _time64$handle() {
        return _time64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static MemorySegment _time64$address() {
        return _time64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static long _time64(MemorySegment _Time) {
        var mh$ = _time64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_time64", _Time);
            }
            return (long)mh$.invokeExact(_Time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _timespec32_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_timespec32_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static FunctionDescriptor _timespec32_get$descriptor() {
        return _timespec32_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static MethodHandle _timespec32_get$handle() {
        return _timespec32_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static MemorySegment _timespec32_get$address() {
        return _timespec32_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static int _timespec32_get(MemorySegment _Ts, int _Base) {
        var mh$ = _timespec32_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_timespec32_get", _Ts, _Base);
            }
            return (int)mh$.invokeExact(_Ts, _Base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _timespec64_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_timespec64_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static FunctionDescriptor _timespec64_get$descriptor() {
        return _timespec64_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static MethodHandle _timespec64_get$handle() {
        return _timespec64_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static MemorySegment _timespec64_get$address() {
        return _timespec64_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static int _timespec64_get(MemorySegment _Ts, int _Base) {
        var mh$ = _timespec64_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_timespec64_get", _Ts, _Base);
            }
            return (int)mh$.invokeExact(_Ts, _Base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static FunctionDescriptor _tzset$descriptor() {
        return _tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static MethodHandle _tzset$handle() {
        return _tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static MemorySegment _tzset$address() {
        return _tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static void _tzset() {
        var mh$ = _tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tzset");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getsystime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getsystime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _getsystime$descriptor() {
        return _getsystime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static MethodHandle _getsystime$handle() {
        return _getsystime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static MemorySegment _getsystime$address() {
        return _getsystime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static int _getsystime(MemorySegment _Tm) {
        var mh$ = _getsystime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getsystime", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setsystime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_setsystime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static FunctionDescriptor _setsystime$descriptor() {
        return _setsystime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static MethodHandle _setsystime$handle() {
        return _setsystime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static MemorySegment _setsystime$address() {
        return _setsystime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static int _setsystime(MemorySegment _Tm, int _Milliseconds) {
        var mh$ = _setsystime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setsystime", _Tm, _Milliseconds);
            }
            return (int)mh$.invokeExact(_Tm, _Milliseconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef char gchar
     * }
     */
    public static final OfByte gchar = gst_min_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short gshort
     * }
     */
    public static final OfShort gshort = gst_min_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long glong
     * }
     */
    public static final OfInt glong = gst_min_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int gint
     * }
     */
    public static final OfInt gint = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef gint gboolean
     * }
     */
    public static final OfInt gboolean = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char guchar
     * }
     */
    public static final OfByte guchar = gst_min_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short gushort
     * }
     */
    public static final OfShort gushort = gst_min_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long gulong
     * }
     */
    public static final OfInt gulong = gst_min_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int guint
     * }
     */
    public static final OfInt guint = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float gfloat
     * }
     */
    public static final OfFloat gfloat = gst_min_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double gdouble
     * }
     */
    public static final OfDouble gdouble = gst_min_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef void *gpointer
     * }
     */
    public static final AddressLayout gpointer = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const void *gconstpointer
     * }
     */
    public static final AddressLayout gconstpointer = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef gint grefcount
     * }
     */
    public static final OfInt grefcount = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef gint gatomicrefcount
     * }
     */
    public static final OfInt gatomicrefcount = gst_min_h.C_INT;

    private static class _errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static FunctionDescriptor _errno$descriptor() {
        return _errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MethodHandle _errno$handle() {
        return _errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno$address() {
        return _errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno() {
        var mh$ = _errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_errno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static FunctionDescriptor _set_errno$descriptor() {
        return _set_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MethodHandle _set_errno$handle() {
        return _set_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MemorySegment _set_errno$address() {
        return _set_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static int _set_errno(int _Value) {
        var mh$ = _set_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static FunctionDescriptor _get_errno$descriptor() {
        return _get_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MethodHandle _get_errno$handle() {
        return _get_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MemorySegment _get_errno$address() {
        return _get_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static int _get_errno(MemorySegment _Value) {
        var mh$ = _get_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static FunctionDescriptor __doserrno$descriptor() {
        return __doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MethodHandle __doserrno$handle() {
        return __doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno$address() {
        return __doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno() {
        var mh$ = __doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__doserrno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static FunctionDescriptor _set_doserrno$descriptor() {
        return _set_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MethodHandle _set_doserrno$handle() {
        return _set_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MemorySegment _set_doserrno$address() {
        return _set_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static int _set_doserrno(int _Value) {
        var mh$ = _set_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static FunctionDescriptor _get_doserrno$descriptor() {
        return _get_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MethodHandle _get_doserrno$handle() {
        return _get_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MemorySegment _get_doserrno$address() {
        return _get_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static int _get_doserrno(MemorySegment _Value) {
        var mh$ = _get_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr(MemorySegment _Buf, int _Val, long _MaxCount) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", _Buf, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buf, _Val, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memcmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset(MemorySegment _Dst, int _Val, long _Size) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", _Dst, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Val, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr(MemorySegment _Str, int _Val) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", _Str, _Val);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr(MemorySegment _Str, int _Ch) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcschr$descriptor() {
        return wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcschr$handle() {
        return wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr$address() {
        return wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr(MemorySegment _Str, short _Ch) {
        var mh$ = wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcschr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcsrchr$descriptor() {
        return wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcsrchr$handle() {
        return wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr$address() {
        return wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr(MemorySegment _Str, short _Ch) {
        var mh$ = wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static FunctionDescriptor wcsstr$descriptor() {
        return wcsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MethodHandle wcsstr$handle() {
        return wcsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr$address() {
        return wcsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = wcsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor _memicmp$descriptor() {
        return _memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle _memicmp$handle() {
        return _memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment _memicmp$address() {
        return _memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int _memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = _memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_memicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _memicmp_l$descriptor() {
        return _memicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _memicmp_l$handle() {
        return _memicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _memicmp_l$address() {
        return _memicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _memicmp_l(MemorySegment _Buf1, MemorySegment _Buf2, long _Size, MemorySegment _Locale) {
        var mh$ = _memicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp_l", _Buf1, _Buf2, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _Size) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", _Dst, _Src, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memicmp$descriptor() {
        return memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memicmp$handle() {
        return memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memicmp$address() {
        return memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat_s$descriptor() {
        return wcscat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat_s$handle() {
        return wcscat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat_s$address() {
        return wcscat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy_s$descriptor() {
        return wcscpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy_s$handle() {
        return wcscpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy_s$address() {
        return wcscpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncat_s$descriptor() {
        return wcsncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncat_s$handle() {
        return wcsncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncat_s$address() {
        return wcsncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncpy_s$descriptor() {
        return wcsncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncpy_s$handle() {
        return wcsncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncpy_s$address() {
        return wcsncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok_s$descriptor() {
        return wcstok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok_s$handle() {
        return wcstok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s$address() {
        return wcstok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsdup$descriptor() {
        return _wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsdup$handle() {
        return _wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup$address() {
        return _wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup(MemorySegment _String) {
        var mh$ = _wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat$descriptor() {
        return wcscat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat$handle() {
        return wcscat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat$address() {
        return wcscat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscmp$descriptor() {
        return wcscmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscmp$handle() {
        return wcscmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscmp$address() {
        return wcscmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy$descriptor() {
        return wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy$handle() {
        return wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy$address() {
        return wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcscspn$descriptor() {
        return wcscspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcscspn$handle() {
        return wcscspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcscspn$address() {
        return wcscspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcscspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcscspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslen$descriptor() {
        return wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcslen$handle() {
        return wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcslen$address() {
        return wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static long wcslen(MemorySegment _String) {
        var mh$ = wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnlen$descriptor() {
        return wcsnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnlen$handle() {
        return wcsnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnlen$address() {
        return wcsnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsnlen(MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnlen", _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncat$descriptor() {
        return wcsncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncat$handle() {
        return wcsncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat$address() {
        return wcsncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncmp$descriptor() {
        return wcsncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncmp$handle() {
        return wcsncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncmp$address() {
        return wcsncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsncmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncpy$descriptor() {
        return wcsncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncpy$handle() {
        return wcsncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy$address() {
        return wcsncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcspbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcspbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcspbrk$descriptor() {
        return wcspbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcspbrk$handle() {
        return wcspbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk$address() {
        return wcspbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcspbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcspbrk", _String, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcsspn$descriptor() {
        return wcsspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcsspn$handle() {
        return wcsspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcsspn$address() {
        return wcsspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcsspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcsspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok$descriptor() {
        return wcstok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok$handle() {
        return wcstok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok$address() {
        return wcstok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror$descriptor() {
        return _wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror$handle() {
        return _wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror$address() {
        return _wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror(int _ErrorNumber) {
        var mh$ = _wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror", _ErrorNumber);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorNumber);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror_s$descriptor() {
        return _wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror_s$handle() {
        return _wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror_s$address() {
        return _wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static int _wcserror_s(MemorySegment _Buffer, long _SizeInWords, int _ErrorNumber) {
        var mh$ = _wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror_s", _Buffer, _SizeInWords, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorNumber);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor __wcserror$descriptor() {
        return __wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MethodHandle __wcserror$handle() {
        return __wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror$address() {
        return __wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror(MemorySegment _String) {
        var mh$ = __wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor __wcserror_s$descriptor() {
        return __wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle __wcserror_s$handle() {
        return __wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment __wcserror_s$address() {
        return __wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static int __wcserror_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _ErrorMessage) {
        var mh$ = __wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror_s", _Buffer, _SizeInWords, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicmp$descriptor() {
        return _wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicmp$handle() {
        return _wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicmp$address() {
        return _wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicmp_l$descriptor() {
        return _wcsicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicmp_l$handle() {
        return _wcsicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicmp_l$address() {
        return _wcsicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicmp$descriptor() {
        return _wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicmp$handle() {
        return _wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicmp$address() {
        return _wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicmp_l$descriptor() {
        return _wcsnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicmp_l$handle() {
        return _wcsnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicmp_l$address() {
        return _wcsnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_SHORT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset_s$descriptor() {
        return _wcsnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset_s$handle() {
        return _wcsnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset_s$address() {
        return _wcsnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static int _wcsnset_s(MemorySegment _Destination, long _SizeInWords, short _Value, long _MaxCount) {
        var mh$ = _wcsnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset_s", _Destination, _SizeInWords, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset$descriptor() {
        return _wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset$handle() {
        return _wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset$address() {
        return _wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = _wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsrev$descriptor() {
        return _wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsrev$handle() {
        return _wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev$address() {
        return _wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev(MemorySegment _String) {
        var mh$ = _wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset_s$descriptor() {
        return _wcsset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset_s$handle() {
        return _wcsset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset_s$address() {
        return _wcsset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static int _wcsset_s(MemorySegment _Destination, long _SizeInWords, short _Value) {
        var mh$ = _wcsset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset_s", _Destination, _SizeInWords, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset$descriptor() {
        return _wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset$handle() {
        return _wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset$address() {
        return _wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset(MemorySegment _String, short _Value) {
        var mh$ = _wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcslwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wcslwr_s$descriptor() {
        return _wcslwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wcslwr_s$handle() {
        return _wcslwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wcslwr_s$address() {
        return _wcslwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static int _wcslwr_s(MemorySegment _String, long _SizeInWords) {
        var mh$ = _wcslwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s", _String, _SizeInWords);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcslwr$descriptor() {
        return _wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcslwr$handle() {
        return _wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr$address() {
        return _wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr(MemorySegment _String) {
        var mh$ = _wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcslwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_s_l$descriptor() {
        return _wcslwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_s_l$handle() {
        return _wcslwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_s_l$address() {
        return _wcslwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static int _wcslwr_s_l(MemorySegment _String, long _SizeInWords, MemorySegment _Locale) {
        var mh$ = _wcslwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s_l", _String, _SizeInWords, _Locale);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcslwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_l$descriptor() {
        return _wcslwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_l$handle() {
        return _wcslwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l$address() {
        return _wcslwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcslwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _wcsupr_s$descriptor() {
        return _wcsupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MethodHandle _wcsupr_s$handle() {
        return _wcsupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MemorySegment _wcsupr_s$address() {
        return _wcsupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static int _wcsupr_s(MemorySegment _String, long _Size) {
        var mh$ = _wcsupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsupr$descriptor() {
        return _wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsupr$handle() {
        return _wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr$address() {
        return _wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr(MemorySegment _String) {
        var mh$ = _wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_s_l$descriptor() {
        return _wcsupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_s_l$handle() {
        return _wcsupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_s_l$address() {
        return _wcsupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _wcsupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _wcsupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_l$descriptor() {
        return _wcsupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_l$handle() {
        return _wcsupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l$address() {
        return _wcsupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcsupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsxfrm$descriptor() {
        return wcsxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsxfrm$handle() {
        return wcsxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsxfrm$address() {
        return wcsxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsxfrm_l$descriptor() {
        return _wcsxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsxfrm_l$handle() {
        return _wcsxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsxfrm_l$address() {
        return _wcsxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcsxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscoll$descriptor() {
        return wcscoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscoll$handle() {
        return wcscoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscoll$address() {
        return wcscoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcscoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcscoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcscoll_l$descriptor() {
        return _wcscoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcscoll_l$handle() {
        return _wcscoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcscoll_l$address() {
        return _wcscoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcscoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcscoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcscoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicoll$descriptor() {
        return _wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicoll$handle() {
        return _wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicoll$address() {
        return _wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicoll_l$descriptor() {
        return _wcsicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicoll_l$handle() {
        return _wcsicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicoll_l$address() {
        return _wcsicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsncoll$descriptor() {
        return _wcsncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsncoll$handle() {
        return _wcsncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsncoll$address() {
        return _wcsncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsncoll_l$descriptor() {
        return _wcsncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsncoll_l$handle() {
        return _wcsncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsncoll_l$address() {
        return _wcsncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicoll$descriptor() {
        return _wcsnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicoll$handle() {
        return _wcsnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicoll$address() {
        return _wcsnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicoll_l$descriptor() {
        return _wcsnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicoll_l$handle() {
        return _wcsnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicoll_l$address() {
        return _wcsnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsdup$descriptor() {
        return wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcsdup$handle() {
        return wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup$address() {
        return wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup(MemorySegment _String) {
        var mh$ = wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicmp$descriptor() {
        return wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicmp$handle() {
        return wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicmp$address() {
        return wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnicmp$descriptor() {
        return wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnicmp$handle() {
        return wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnicmp$address() {
        return wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnset$descriptor() {
        return wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnset$handle() {
        return wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset$address() {
        return wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsrev$descriptor() {
        return wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsrev$handle() {
        return wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev$address() {
        return wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev(MemorySegment _String) {
        var mh$ = wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor wcsset$descriptor() {
        return wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle wcsset$handle() {
        return wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset$address() {
        return wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset(MemorySegment _String, short _Value) {
        var mh$ = wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslwr$descriptor() {
        return wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcslwr$handle() {
        return wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr$address() {
        return wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr(MemorySegment _String) {
        var mh$ = wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsupr$descriptor() {
        return wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsupr$handle() {
        return wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr$address() {
        return wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr(MemorySegment _String) {
        var mh$ = wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicoll$descriptor() {
        return wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicoll$handle() {
        return wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicoll$address() {
        return wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy_s$descriptor() {
        return strcpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcpy_s$handle() {
        return strcpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcpy_s$address() {
        return strcpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat_s$descriptor() {
        return strcat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcat_s$handle() {
        return strcat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcat_s$address() {
        return strcat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor strerror_s$descriptor() {
        return strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MethodHandle strerror_s$handle() {
        return strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MemorySegment strerror_s$address() {
        return strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static int strerror_s(MemorySegment _Buffer, long _SizeInBytes, int _ErrorNumber) {
        var mh$ = strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_s", _Buffer, _SizeInBytes, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorNumber);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncat_s$descriptor() {
        return strncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncat_s$handle() {
        return strncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncat_s$address() {
        return strncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncpy_s$descriptor() {
        return strncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncpy_s$handle() {
        return strncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncpy_s$address() {
        return strncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static FunctionDescriptor strtok_s$descriptor() {
        return strtok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MethodHandle strtok_s$handle() {
        return strtok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s$address() {
        return strtok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = strtok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _memccpy$descriptor() {
        return _memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle _memccpy$handle() {
        return _memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy$address() {
        return _memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _MaxCount) {
        var mh$ = _memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memccpy", _Dst, _Src, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static int strcmp(MemorySegment _Str1, MemorySegment _Str2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", _Str1, _Str2);
            }
            return (int)mh$.invokeExact(_Str1, _Str2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _strcmpi$descriptor() {
        return _strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _strcmpi$handle() {
        return _strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _strcmpi$address() {
        return _strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int _strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static int strcoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strcoll_l$descriptor() {
        return _strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strcoll_l$handle() {
        return _strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strcoll_l$address() {
        return _strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _strcoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strcspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static FunctionDescriptor _strdup$descriptor() {
        return _strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MethodHandle _strdup$handle() {
        return _strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup$address() {
        return _strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup(MemorySegment _Source) {
        var mh$ = _strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdup", _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror$descriptor() {
        return _strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror$handle() {
        return _strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror$address() {
        return _strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror(MemorySegment _ErrorMessage) {
        var mh$ = _strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror_s$descriptor() {
        return _strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror_s$handle() {
        return _strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror_s$address() {
        return _strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static int _strerror_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _ErrorMessage) {
        var mh$ = _strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror_s", _Buffer, _SizeInBytes, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror(int _ErrorMessage) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricmp$descriptor() {
        return _stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricmp$handle() {
        return _stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricmp$address() {
        return _stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_stricoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricoll$descriptor() {
        return _stricoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricoll$handle() {
        return _stricoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricoll$address() {
        return _stricoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_stricoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricoll_l$descriptor() {
        return _stricoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricoll_l$handle() {
        return _stricoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricoll_l$address() {
        return _stricoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_stricmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricmp_l$descriptor() {
        return _stricmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricmp_l$handle() {
        return _stricmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricmp_l$address() {
        return _stricmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static long strlen(MemorySegment _Str) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", _Str);
            }
            return (long)mh$.invokeExact(_Str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strlwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strlwr_s$descriptor() {
        return _strlwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strlwr_s$handle() {
        return _strlwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strlwr_s$address() {
        return _strlwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strlwr_s(MemorySegment _String, long _Size) {
        var mh$ = _strlwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor _strlwr$descriptor() {
        return _strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MethodHandle _strlwr$handle() {
        return _strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr$address() {
        return _strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr(MemorySegment _String) {
        var mh$ = _strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strlwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_s_l$descriptor() {
        return _strlwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_s_l$handle() {
        return _strlwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_s_l$address() {
        return _strlwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strlwr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strlwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strlwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_l$descriptor() {
        return _strlwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_l$handle() {
        return _strlwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l$address() {
        return _strlwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strlwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static int strncmp(MemorySegment _Str1, MemorySegment _Str2, long _MaxCount) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", _Str1, _Str2, _MaxCount);
            }
            return (int)mh$.invokeExact(_Str1, _Str2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicmp$descriptor() {
        return _strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicmp$handle() {
        return _strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicmp$address() {
        return _strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicmp_l$descriptor() {
        return _strnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicmp_l$handle() {
        return _strnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicmp_l$address() {
        return _strnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicoll$descriptor() {
        return _strnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicoll$handle() {
        return _strnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicoll$address() {
        return _strnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicoll_l$descriptor() {
        return _strnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicoll_l$handle() {
        return _strnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicoll_l$address() {
        return _strnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strncoll$descriptor() {
        return _strncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strncoll$handle() {
        return _strncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strncoll$address() {
        return _strncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strncoll_l$descriptor() {
        return _strncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strncoll_l$handle() {
        return _strncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strncoll_l$address() {
        return _strncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strncnt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__strncnt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static FunctionDescriptor __strncnt$descriptor() {
        return __strncnt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MethodHandle __strncnt$handle() {
        return __strncnt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MemorySegment __strncnt$address() {
        return __strncnt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static long __strncnt(MemorySegment _String, long _Count) {
        var mh$ = __strncnt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strncnt", _String, _Count);
            }
            return (long)mh$.invokeExact(_String, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long strnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnset_s$descriptor() {
        return _strnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnset_s$handle() {
        return _strnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnset_s$address() {
        return _strnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static int _strnset_s(MemorySegment _String, long _SizeInBytes, int _Value, long _MaxCount) {
        var mh$ = _strnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset_s", _String, _SizeInBytes, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_String, _SizeInBytes, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static FunctionDescriptor _strnset$descriptor() {
        return _strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MethodHandle _strnset$handle() {
        return _strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset$address() {
        return _strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset(MemorySegment _Destination, int _Value, long _Count) {
        var mh$ = _strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset", _Destination, _Value, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", _Str, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static FunctionDescriptor _strrev$descriptor() {
        return _strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MethodHandle _strrev$handle() {
        return _strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev$address() {
        return _strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev(MemorySegment _Str) {
        var mh$ = _strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strrev", _Str);
            }
            return (MemorySegment)mh$.invokeExact(_Str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static FunctionDescriptor _strset_s$descriptor() {
        return _strset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MethodHandle _strset_s$handle() {
        return _strset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MemorySegment _strset_s$address() {
        return _strset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static int _strset_s(MemorySegment _Destination, long _DestinationSize, int _Value) {
        var mh$ = _strset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset_s", _Destination, _DestinationSize, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _DestinationSize, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static FunctionDescriptor _strset$descriptor() {
        return _strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MethodHandle _strset$handle() {
        return _strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset$address() {
        return _strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset(MemorySegment _Destination, int _Value) {
        var mh$ = _strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset", _Destination, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok(MemorySegment _String, MemorySegment _Delimiter) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", _String, _Delimiter);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strupr_s$descriptor() {
        return _strupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strupr_s$handle() {
        return _strupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strupr_s$address() {
        return _strupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strupr_s(MemorySegment _String, long _Size) {
        var mh$ = _strupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static FunctionDescriptor _strupr$descriptor() {
        return _strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MethodHandle _strupr$handle() {
        return _strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr$address() {
        return _strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr(MemorySegment _String) {
        var mh$ = _strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_s_l$descriptor() {
        return _strupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_s_l$handle() {
        return _strupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_s_l$address() {
        return _strupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_l$descriptor() {
        return _strupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_l$handle() {
        return _strupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l$address() {
        return _strupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long strxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strxfrm_l$descriptor() {
        return _strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strxfrm_l$handle() {
        return _strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strxfrm_l$address() {
        return _strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _strxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup(MemorySegment _String) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcmpi$descriptor() {
        return strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcmpi$handle() {
        return strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcmpi$address() {
        return strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor stricmp$descriptor() {
        return stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle stricmp$handle() {
        return stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment stricmp$address() {
        return stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor strlwr$descriptor() {
        return strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MethodHandle strlwr$handle() {
        return strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr$address() {
        return strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr(MemorySegment _String) {
        var mh$ = strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnicmp$descriptor() {
        return strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnicmp$handle() {
        return strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnicmp$address() {
        return strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnset$descriptor() {
        return strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnset$handle() {
        return strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset$address() {
        return strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset(MemorySegment _String, int _Value, long _MaxCount) {
        var mh$ = strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static FunctionDescriptor strrev$descriptor() {
        return strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MethodHandle strrev$handle() {
        return strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev$address() {
        return strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev(MemorySegment _String) {
        var mh$ = strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static FunctionDescriptor strset$descriptor() {
        return strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MethodHandle strset$handle() {
        return strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset$address() {
        return strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset(MemorySegment _String, int _Value) {
        var mh$ = strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static FunctionDescriptor strupr$descriptor() {
        return strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MethodHandle strupr$handle() {
        return strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr$address() {
        return strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr(MemorySegment _String) {
        var mh$ = strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _calloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_calloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _calloc_base$descriptor() {
        return _calloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _calloc_base$handle() {
        return _calloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base$address() {
        return _calloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base(long _Count, long _Size) {
        var mh$ = _calloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_calloc_base", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc(long _Count, long _Size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _callnewh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_callnewh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static FunctionDescriptor _callnewh$descriptor() {
        return _callnewh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MethodHandle _callnewh$handle() {
        return _callnewh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MemorySegment _callnewh$address() {
        return _callnewh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static int _callnewh(long _Size) {
        var mh$ = _callnewh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_callnewh", _Size);
            }
            return (int)mh$.invokeExact(_Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _expand$descriptor() {
        return _expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _expand$handle() {
        return _expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand$address() {
        return _expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand(MemorySegment _Block, long _Size) {
        var mh$ = _expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_expand", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _free_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_free_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _free_base$descriptor() {
        return _free_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MethodHandle _free_base$handle() {
        return _free_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MemorySegment _free_base$address() {
        return _free_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static void _free_base(MemorySegment _Block) {
        var mh$ = _free_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_free_base", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static void free(MemorySegment _Block) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _malloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_malloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static FunctionDescriptor _malloc_base$descriptor() {
        return _malloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MethodHandle _malloc_base$handle() {
        return _malloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base$address() {
        return _malloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base(long _Size) {
        var mh$ = _malloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_malloc_base", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc(long _Size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_msize_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize_base$descriptor() {
        return _msize_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MethodHandle _msize_base$handle() {
        return _msize_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MemorySegment _msize_base$address() {
        return _msize_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static long _msize_base(MemorySegment _Block) {
        var mh$ = _msize_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize_base", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_msize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize$descriptor() {
        return _msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MethodHandle _msize$handle() {
        return _msize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MemorySegment _msize$address() {
        return _msize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static long _msize(MemorySegment _Block) {
        var mh$ = _msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _realloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_realloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _realloc_base$descriptor() {
        return _realloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _realloc_base$handle() {
        return _realloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base$address() {
        return _realloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base(MemorySegment _Block, long _Size) {
        var mh$ = _realloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_realloc_base", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc(MemorySegment _Block, long _Size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_recalloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc_base$descriptor() {
        return _recalloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc_base$handle() {
        return _recalloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base$address() {
        return _recalloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc_base", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc$descriptor() {
        return _recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc$handle() {
        return _recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc$address() {
        return _recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static FunctionDescriptor _aligned_free$descriptor() {
        return _aligned_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MethodHandle _aligned_free$handle() {
        return _aligned_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MemorySegment _aligned_free$address() {
        return _aligned_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static void _aligned_free(MemorySegment _Block) {
        var mh$ = _aligned_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_malloc$descriptor() {
        return _aligned_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_malloc$handle() {
        return _aligned_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc$address() {
        return _aligned_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc(long _Size, long _Alignment) {
        var mh$ = _aligned_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_malloc", _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_offset_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_malloc$descriptor() {
        return _aligned_offset_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_malloc$handle() {
        return _aligned_offset_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc$address() {
        return _aligned_offset_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc(long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_malloc", _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment, _Offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_msize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_msize$descriptor() {
        return _aligned_msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_msize$handle() {
        return _aligned_msize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_msize$address() {
        return _aligned_msize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static long _aligned_msize(MemorySegment _Block, long _Alignment, long _Offset) {
        var mh$ = _aligned_msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_msize", _Block, _Alignment, _Offset);
            }
            return (long)mh$.invokeExact(_Block, _Alignment, _Offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_offset_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_realloc$descriptor() {
        return _aligned_offset_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_realloc$handle() {
        return _aligned_offset_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc$address() {
        return _aligned_offset_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc(MemorySegment _Block, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_realloc", _Block, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment, _Offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_offset_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_recalloc$descriptor() {
        return _aligned_offset_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_recalloc$handle() {
        return _aligned_offset_recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc$address() {
        return _aligned_offset_recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_recalloc", _Block, _Count, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment, _Offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_realloc$descriptor() {
        return _aligned_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_realloc$handle() {
        return _aligned_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc$address() {
        return _aligned_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc(MemorySegment _Block, long _Size, long _Alignment) {
        var mh$ = _aligned_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_realloc", _Block, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_recalloc$descriptor() {
        return _aligned_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_recalloc$handle() {
        return _aligned_recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc$address() {
        return _aligned_recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment) {
        var mh$ = _aligned_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_recalloc", _Block, _Count, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_alloca(size_t _Size)
     * }
     */
    public static FunctionDescriptor _alloca$descriptor() {
        return _alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_alloca(size_t _Size)
     * }
     */
    public static MethodHandle _alloca$handle() {
        return _alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_alloca(size_t _Size)
     * }
     */
    public static MemorySegment _alloca$address() {
        return _alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_alloca(size_t _Size)
     * }
     */
    public static MemorySegment _alloca(long _Size) {
        var mh$ = _alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_alloca", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_heap_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_heap_handle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _get_heap_handle()
     * }
     */
    public static FunctionDescriptor _get_heap_handle$descriptor() {
        return _get_heap_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _get_heap_handle()
     * }
     */
    public static MethodHandle _get_heap_handle$handle() {
        return _get_heap_handle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _get_heap_handle()
     * }
     */
    public static MemorySegment _get_heap_handle$address() {
        return _get_heap_handle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _get_heap_handle()
     * }
     */
    public static long _get_heap_handle() {
        var mh$ = _get_heap_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_heap_handle");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _heapmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_heapmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _heapmin()
     * }
     */
    public static FunctionDescriptor _heapmin$descriptor() {
        return _heapmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _heapmin()
     * }
     */
    public static MethodHandle _heapmin$handle() {
        return _heapmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _heapmin()
     * }
     */
    public static MemorySegment _heapmin$address() {
        return _heapmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _heapmin()
     * }
     */
    public static int _heapmin() {
        var mh$ = _heapmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_heapmin");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _heapwalk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_heapwalk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _heapwalk(_HEAPINFO *_EntryInfo)
     * }
     */
    public static FunctionDescriptor _heapwalk$descriptor() {
        return _heapwalk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _heapwalk(_HEAPINFO *_EntryInfo)
     * }
     */
    public static MethodHandle _heapwalk$handle() {
        return _heapwalk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _heapwalk(_HEAPINFO *_EntryInfo)
     * }
     */
    public static MemorySegment _heapwalk$address() {
        return _heapwalk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _heapwalk(_HEAPINFO *_EntryInfo)
     * }
     */
    public static int _heapwalk(MemorySegment _EntryInfo) {
        var mh$ = _heapwalk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_heapwalk", _EntryInfo);
            }
            return (int)mh$.invokeExact(_EntryInfo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _heapchk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_heapchk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _heapchk()
     * }
     */
    public static FunctionDescriptor _heapchk$descriptor() {
        return _heapchk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _heapchk()
     * }
     */
    public static MethodHandle _heapchk$handle() {
        return _heapchk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _heapchk()
     * }
     */
    public static MemorySegment _heapchk$address() {
        return _heapchk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _heapchk()
     * }
     */
    public static int _heapchk() {
        var mh$ = _heapchk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_heapchk");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _resetstkoflw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_resetstkoflw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _resetstkoflw()
     * }
     */
    public static FunctionDescriptor _resetstkoflw$descriptor() {
        return _resetstkoflw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _resetstkoflw()
     * }
     */
    public static MethodHandle _resetstkoflw$handle() {
        return _resetstkoflw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _resetstkoflw()
     * }
     */
    public static MemorySegment _resetstkoflw$address() {
        return _resetstkoflw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _resetstkoflw()
     * }
     */
    public static int _resetstkoflw() {
        var mh$ = _resetstkoflw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_resetstkoflw");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_new(gboolean zero_terminated, gboolean clear_, guint element_size)
     * }
     */
    public static FunctionDescriptor g_array_new$descriptor() {
        return g_array_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_new(gboolean zero_terminated, gboolean clear_, guint element_size)
     * }
     */
    public static MethodHandle g_array_new$handle() {
        return g_array_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_new(gboolean zero_terminated, gboolean clear_, guint element_size)
     * }
     */
    public static MemorySegment g_array_new$address() {
        return g_array_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_new(gboolean zero_terminated, gboolean clear_, guint element_size)
     * }
     */
    public static MemorySegment g_array_new(int zero_terminated, int clear_, int element_size) {
        var mh$ = g_array_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_new", zero_terminated, clear_, element_size);
            }
            return (MemorySegment)mh$.invokeExact(zero_terminated, clear_, element_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_new_take {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_new_take");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_new_take(gpointer data, gsize len, gboolean clear, gsize element_size)
     * }
     */
    public static FunctionDescriptor g_array_new_take$descriptor() {
        return g_array_new_take.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_new_take(gpointer data, gsize len, gboolean clear, gsize element_size)
     * }
     */
    public static MethodHandle g_array_new_take$handle() {
        return g_array_new_take.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_new_take(gpointer data, gsize len, gboolean clear, gsize element_size)
     * }
     */
    public static MemorySegment g_array_new_take$address() {
        return g_array_new_take.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_new_take(gpointer data, gsize len, gboolean clear, gsize element_size)
     * }
     */
    public static MemorySegment g_array_new_take(MemorySegment data, long len, int clear, long element_size) {
        var mh$ = g_array_new_take.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_new_take", data, len, clear, element_size);
            }
            return (MemorySegment)mh$.invokeExact(data, len, clear, element_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_new_take_zero_terminated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_new_take_zero_terminated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_new_take_zero_terminated(gpointer data, gboolean clear, gsize element_size)
     * }
     */
    public static FunctionDescriptor g_array_new_take_zero_terminated$descriptor() {
        return g_array_new_take_zero_terminated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_new_take_zero_terminated(gpointer data, gboolean clear, gsize element_size)
     * }
     */
    public static MethodHandle g_array_new_take_zero_terminated$handle() {
        return g_array_new_take_zero_terminated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_new_take_zero_terminated(gpointer data, gboolean clear, gsize element_size)
     * }
     */
    public static MemorySegment g_array_new_take_zero_terminated$address() {
        return g_array_new_take_zero_terminated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_new_take_zero_terminated(gpointer data, gboolean clear, gsize element_size)
     * }
     */
    public static MemorySegment g_array_new_take_zero_terminated(MemorySegment data, int clear, long element_size) {
        var mh$ = g_array_new_take_zero_terminated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_new_take_zero_terminated", data, clear, element_size);
            }
            return (MemorySegment)mh$.invokeExact(data, clear, element_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_array_steal(GArray *array, gsize *len)
     * }
     */
    public static FunctionDescriptor g_array_steal$descriptor() {
        return g_array_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_array_steal(GArray *array, gsize *len)
     * }
     */
    public static MethodHandle g_array_steal$handle() {
        return g_array_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_array_steal(GArray *array, gsize *len)
     * }
     */
    public static MemorySegment g_array_steal$address() {
        return g_array_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_array_steal(GArray *array, gsize *len)
     * }
     */
    public static MemorySegment g_array_steal(MemorySegment array, MemorySegment len) {
        var mh$ = g_array_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_steal", array, len);
            }
            return (MemorySegment)mh$.invokeExact(array, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_sized_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_sized_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_sized_new(gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size)
     * }
     */
    public static FunctionDescriptor g_array_sized_new$descriptor() {
        return g_array_sized_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_sized_new(gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size)
     * }
     */
    public static MethodHandle g_array_sized_new$handle() {
        return g_array_sized_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_sized_new(gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size)
     * }
     */
    public static MemorySegment g_array_sized_new$address() {
        return g_array_sized_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_sized_new(gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size)
     * }
     */
    public static MemorySegment g_array_sized_new(int zero_terminated, int clear_, int element_size, int reserved_size) {
        var mh$ = g_array_sized_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_sized_new", zero_terminated, clear_, element_size, reserved_size);
            }
            return (MemorySegment)mh$.invokeExact(zero_terminated, clear_, element_size, reserved_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_copy(GArray *array)
     * }
     */
    public static FunctionDescriptor g_array_copy$descriptor() {
        return g_array_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_copy(GArray *array)
     * }
     */
    public static MethodHandle g_array_copy$handle() {
        return g_array_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_copy(GArray *array)
     * }
     */
    public static MemorySegment g_array_copy$address() {
        return g_array_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_copy(GArray *array)
     * }
     */
    public static MemorySegment g_array_copy(MemorySegment array) {
        var mh$ = g_array_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_copy", array);
            }
            return (MemorySegment)mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_array_free(GArray *array, gboolean free_segment)
     * }
     */
    public static FunctionDescriptor g_array_free$descriptor() {
        return g_array_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_array_free(GArray *array, gboolean free_segment)
     * }
     */
    public static MethodHandle g_array_free$handle() {
        return g_array_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_array_free(GArray *array, gboolean free_segment)
     * }
     */
    public static MemorySegment g_array_free$address() {
        return g_array_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_array_free(GArray *array, gboolean free_segment)
     * }
     */
    public static MemorySegment g_array_free(MemorySegment array, int free_segment) {
        var mh$ = g_array_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_free", array, free_segment);
            }
            return (MemorySegment)mh$.invokeExact(array, free_segment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_ref(GArray *array)
     * }
     */
    public static FunctionDescriptor g_array_ref$descriptor() {
        return g_array_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_ref(GArray *array)
     * }
     */
    public static MethodHandle g_array_ref$handle() {
        return g_array_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_ref(GArray *array)
     * }
     */
    public static MemorySegment g_array_ref$address() {
        return g_array_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_ref(GArray *array)
     * }
     */
    public static MemorySegment g_array_ref(MemorySegment array) {
        var mh$ = g_array_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_ref", array);
            }
            return (MemorySegment)mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_array_unref(GArray *array)
     * }
     */
    public static FunctionDescriptor g_array_unref$descriptor() {
        return g_array_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_array_unref(GArray *array)
     * }
     */
    public static MethodHandle g_array_unref$handle() {
        return g_array_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_array_unref(GArray *array)
     * }
     */
    public static MemorySegment g_array_unref$address() {
        return g_array_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_array_unref(GArray *array)
     * }
     */
    public static void g_array_unref(MemorySegment array) {
        var mh$ = g_array_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_unref", array);
            }
            mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_get_element_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_get_element_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_array_get_element_size(GArray *array)
     * }
     */
    public static FunctionDescriptor g_array_get_element_size$descriptor() {
        return g_array_get_element_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_array_get_element_size(GArray *array)
     * }
     */
    public static MethodHandle g_array_get_element_size$handle() {
        return g_array_get_element_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_array_get_element_size(GArray *array)
     * }
     */
    public static MemorySegment g_array_get_element_size$address() {
        return g_array_get_element_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_array_get_element_size(GArray *array)
     * }
     */
    public static int g_array_get_element_size(MemorySegment array) {
        var mh$ = g_array_get_element_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_get_element_size", array);
            }
            return (int)mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_append_vals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_append_vals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_append_vals(GArray *array, gconstpointer data, guint len)
     * }
     */
    public static FunctionDescriptor g_array_append_vals$descriptor() {
        return g_array_append_vals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_append_vals(GArray *array, gconstpointer data, guint len)
     * }
     */
    public static MethodHandle g_array_append_vals$handle() {
        return g_array_append_vals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_append_vals(GArray *array, gconstpointer data, guint len)
     * }
     */
    public static MemorySegment g_array_append_vals$address() {
        return g_array_append_vals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_append_vals(GArray *array, gconstpointer data, guint len)
     * }
     */
    public static MemorySegment g_array_append_vals(MemorySegment array, MemorySegment data, int len) {
        var mh$ = g_array_append_vals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_append_vals", array, data, len);
            }
            return (MemorySegment)mh$.invokeExact(array, data, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_prepend_vals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_prepend_vals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_prepend_vals(GArray *array, gconstpointer data, guint len)
     * }
     */
    public static FunctionDescriptor g_array_prepend_vals$descriptor() {
        return g_array_prepend_vals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_prepend_vals(GArray *array, gconstpointer data, guint len)
     * }
     */
    public static MethodHandle g_array_prepend_vals$handle() {
        return g_array_prepend_vals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_prepend_vals(GArray *array, gconstpointer data, guint len)
     * }
     */
    public static MemorySegment g_array_prepend_vals$address() {
        return g_array_prepend_vals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_prepend_vals(GArray *array, gconstpointer data, guint len)
     * }
     */
    public static MemorySegment g_array_prepend_vals(MemorySegment array, MemorySegment data, int len) {
        var mh$ = g_array_prepend_vals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_prepend_vals", array, data, len);
            }
            return (MemorySegment)mh$.invokeExact(array, data, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_insert_vals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_insert_vals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_insert_vals(GArray *array, guint index_, gconstpointer data, guint len)
     * }
     */
    public static FunctionDescriptor g_array_insert_vals$descriptor() {
        return g_array_insert_vals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_insert_vals(GArray *array, guint index_, gconstpointer data, guint len)
     * }
     */
    public static MethodHandle g_array_insert_vals$handle() {
        return g_array_insert_vals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_insert_vals(GArray *array, guint index_, gconstpointer data, guint len)
     * }
     */
    public static MemorySegment g_array_insert_vals$address() {
        return g_array_insert_vals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_insert_vals(GArray *array, guint index_, gconstpointer data, guint len)
     * }
     */
    public static MemorySegment g_array_insert_vals(MemorySegment array, int index_, MemorySegment data, int len) {
        var mh$ = g_array_insert_vals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_insert_vals", array, index_, data, len);
            }
            return (MemorySegment)mh$.invokeExact(array, index_, data, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_set_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_set_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_set_size(GArray *array, guint length)
     * }
     */
    public static FunctionDescriptor g_array_set_size$descriptor() {
        return g_array_set_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_set_size(GArray *array, guint length)
     * }
     */
    public static MethodHandle g_array_set_size$handle() {
        return g_array_set_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_set_size(GArray *array, guint length)
     * }
     */
    public static MemorySegment g_array_set_size$address() {
        return g_array_set_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_set_size(GArray *array, guint length)
     * }
     */
    public static MemorySegment g_array_set_size(MemorySegment array, int length) {
        var mh$ = g_array_set_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_set_size", array, length);
            }
            return (MemorySegment)mh$.invokeExact(array, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_remove_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_remove_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_index(GArray *array, guint index_)
     * }
     */
    public static FunctionDescriptor g_array_remove_index$descriptor() {
        return g_array_remove_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_index(GArray *array, guint index_)
     * }
     */
    public static MethodHandle g_array_remove_index$handle() {
        return g_array_remove_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_index(GArray *array, guint index_)
     * }
     */
    public static MemorySegment g_array_remove_index$address() {
        return g_array_remove_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_remove_index(GArray *array, guint index_)
     * }
     */
    public static MemorySegment g_array_remove_index(MemorySegment array, int index_) {
        var mh$ = g_array_remove_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_remove_index", array, index_);
            }
            return (MemorySegment)mh$.invokeExact(array, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_remove_index_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_remove_index_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_index_fast(GArray *array, guint index_)
     * }
     */
    public static FunctionDescriptor g_array_remove_index_fast$descriptor() {
        return g_array_remove_index_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_index_fast(GArray *array, guint index_)
     * }
     */
    public static MethodHandle g_array_remove_index_fast$handle() {
        return g_array_remove_index_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_index_fast(GArray *array, guint index_)
     * }
     */
    public static MemorySegment g_array_remove_index_fast$address() {
        return g_array_remove_index_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_remove_index_fast(GArray *array, guint index_)
     * }
     */
    public static MemorySegment g_array_remove_index_fast(MemorySegment array, int index_) {
        var mh$ = g_array_remove_index_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_remove_index_fast", array, index_);
            }
            return (MemorySegment)mh$.invokeExact(array, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_remove_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_remove_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_range(GArray *array, guint index_, guint length)
     * }
     */
    public static FunctionDescriptor g_array_remove_range$descriptor() {
        return g_array_remove_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_range(GArray *array, guint index_, guint length)
     * }
     */
    public static MethodHandle g_array_remove_range$handle() {
        return g_array_remove_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GArray *g_array_remove_range(GArray *array, guint index_, guint length)
     * }
     */
    public static MemorySegment g_array_remove_range$address() {
        return g_array_remove_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GArray *g_array_remove_range(GArray *array, guint index_, guint length)
     * }
     */
    public static MemorySegment g_array_remove_range(MemorySegment array, int index_, int length) {
        var mh$ = g_array_remove_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_remove_range", array, index_, length);
            }
            return (MemorySegment)mh$.invokeExact(array, index_, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_array_sort(GArray *array, GCompareFunc compare_func)
     * }
     */
    public static FunctionDescriptor g_array_sort$descriptor() {
        return g_array_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_array_sort(GArray *array, GCompareFunc compare_func)
     * }
     */
    public static MethodHandle g_array_sort$handle() {
        return g_array_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_array_sort(GArray *array, GCompareFunc compare_func)
     * }
     */
    public static MemorySegment g_array_sort$address() {
        return g_array_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_array_sort(GArray *array, GCompareFunc compare_func)
     * }
     */
    public static void g_array_sort(MemorySegment array, MemorySegment compare_func) {
        var mh$ = g_array_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_sort", array, compare_func);
            }
            mh$.invokeExact(array, compare_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_sort_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_sort_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_array_sort_with_data(GArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_array_sort_with_data$descriptor() {
        return g_array_sort_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_array_sort_with_data(GArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_array_sort_with_data$handle() {
        return g_array_sort_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_array_sort_with_data(GArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_array_sort_with_data$address() {
        return g_array_sort_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_array_sort_with_data(GArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static void g_array_sort_with_data(MemorySegment array, MemorySegment compare_func, MemorySegment user_data) {
        var mh$ = g_array_sort_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_sort_with_data", array, compare_func, user_data);
            }
            mh$.invokeExact(array, compare_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_binary_search {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_binary_search");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_array_binary_search(GArray *array, gconstpointer target, GCompareFunc compare_func, guint *out_match_index)
     * }
     */
    public static FunctionDescriptor g_array_binary_search$descriptor() {
        return g_array_binary_search.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_array_binary_search(GArray *array, gconstpointer target, GCompareFunc compare_func, guint *out_match_index)
     * }
     */
    public static MethodHandle g_array_binary_search$handle() {
        return g_array_binary_search.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_array_binary_search(GArray *array, gconstpointer target, GCompareFunc compare_func, guint *out_match_index)
     * }
     */
    public static MemorySegment g_array_binary_search$address() {
        return g_array_binary_search.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_array_binary_search(GArray *array, gconstpointer target, GCompareFunc compare_func, guint *out_match_index)
     * }
     */
    public static int g_array_binary_search(MemorySegment array, MemorySegment target, MemorySegment compare_func, MemorySegment out_match_index) {
        var mh$ = g_array_binary_search.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_binary_search", array, target, compare_func, out_match_index);
            }
            return (int)mh$.invokeExact(array, target, compare_func, out_match_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_set_clear_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_set_clear_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_array_set_clear_func(GArray *array, GDestroyNotify clear_func)
     * }
     */
    public static FunctionDescriptor g_array_set_clear_func$descriptor() {
        return g_array_set_clear_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_array_set_clear_func(GArray *array, GDestroyNotify clear_func)
     * }
     */
    public static MethodHandle g_array_set_clear_func$handle() {
        return g_array_set_clear_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_array_set_clear_func(GArray *array, GDestroyNotify clear_func)
     * }
     */
    public static MemorySegment g_array_set_clear_func$address() {
        return g_array_set_clear_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_array_set_clear_func(GArray *array, GDestroyNotify clear_func)
     * }
     */
    public static void g_array_set_clear_func(MemorySegment array, MemorySegment clear_func) {
        var mh$ = g_array_set_clear_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_set_clear_func", array, clear_func);
            }
            mh$.invokeExact(array, clear_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new()
     * }
     */
    public static FunctionDescriptor g_ptr_array_new$descriptor() {
        return g_ptr_array_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new()
     * }
     */
    public static MethodHandle g_ptr_array_new$handle() {
        return g_ptr_array_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new()
     * }
     */
    public static MemorySegment g_ptr_array_new$address() {
        return g_ptr_array_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new()
     * }
     */
    public static MemorySegment g_ptr_array_new() {
        var mh$ = g_ptr_array_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_new_with_free_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_new_with_free_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify element_free_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_new_with_free_func$descriptor() {
        return g_ptr_array_new_with_free_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify element_free_func)
     * }
     */
    public static MethodHandle g_ptr_array_new_with_free_func$handle() {
        return g_ptr_array_new_with_free_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_with_free_func$address() {
        return g_ptr_array_new_with_free_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_with_free_func(MemorySegment element_free_func) {
        var mh$ = g_ptr_array_new_with_free_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_new_with_free_func", element_free_func);
            }
            return (MemorySegment)mh$.invokeExact(element_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_new_take {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_new_take");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_take(gpointer *data, gsize len, GDestroyNotify element_free_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_new_take$descriptor() {
        return g_ptr_array_new_take.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_take(gpointer *data, gsize len, GDestroyNotify element_free_func)
     * }
     */
    public static MethodHandle g_ptr_array_new_take$handle() {
        return g_ptr_array_new_take.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_take(gpointer *data, gsize len, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_take$address() {
        return g_ptr_array_new_take.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_take(gpointer *data, gsize len, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_take(MemorySegment data, long len, MemorySegment element_free_func) {
        var mh$ = g_ptr_array_new_take.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_new_take", data, len, element_free_func);
            }
            return (MemorySegment)mh$.invokeExact(data, len, element_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_new_from_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_new_from_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_from_array(gpointer *data, gsize len, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_new_from_array$descriptor() {
        return g_ptr_array_new_from_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_from_array(gpointer *data, gsize len, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func)
     * }
     */
    public static MethodHandle g_ptr_array_new_from_array$handle() {
        return g_ptr_array_new_from_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_from_array(gpointer *data, gsize len, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_from_array$address() {
        return g_ptr_array_new_from_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_from_array(gpointer *data, gsize len, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_from_array(MemorySegment data, long len, MemorySegment copy_func, MemorySegment copy_func_user_data, MemorySegment element_free_func) {
        var mh$ = g_ptr_array_new_from_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_new_from_array", data, len, copy_func, copy_func_user_data, element_free_func);
            }
            return (MemorySegment)mh$.invokeExact(data, len, copy_func, copy_func_user_data, element_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer *g_ptr_array_steal(GPtrArray *array, gsize *len)
     * }
     */
    public static FunctionDescriptor g_ptr_array_steal$descriptor() {
        return g_ptr_array_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer *g_ptr_array_steal(GPtrArray *array, gsize *len)
     * }
     */
    public static MethodHandle g_ptr_array_steal$handle() {
        return g_ptr_array_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer *g_ptr_array_steal(GPtrArray *array, gsize *len)
     * }
     */
    public static MemorySegment g_ptr_array_steal$address() {
        return g_ptr_array_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer *g_ptr_array_steal(GPtrArray *array, gsize *len)
     * }
     */
    public static MemorySegment g_ptr_array_steal(MemorySegment array, MemorySegment len) {
        var mh$ = g_ptr_array_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_steal", array, len);
            }
            return (MemorySegment)mh$.invokeExact(array, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_copy(GPtrArray *array, GCopyFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_copy$descriptor() {
        return g_ptr_array_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_copy(GPtrArray *array, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_ptr_array_copy$handle() {
        return g_ptr_array_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_copy(GPtrArray *array, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_ptr_array_copy$address() {
        return g_ptr_array_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_copy(GPtrArray *array, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_ptr_array_copy(MemorySegment array, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_ptr_array_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_copy", array, func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(array, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_sized_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_sized_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_sized_new(guint reserved_size)
     * }
     */
    public static FunctionDescriptor g_ptr_array_sized_new$descriptor() {
        return g_ptr_array_sized_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_sized_new(guint reserved_size)
     * }
     */
    public static MethodHandle g_ptr_array_sized_new$handle() {
        return g_ptr_array_sized_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_sized_new(guint reserved_size)
     * }
     */
    public static MemorySegment g_ptr_array_sized_new$address() {
        return g_ptr_array_sized_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_sized_new(guint reserved_size)
     * }
     */
    public static MemorySegment g_ptr_array_sized_new(int reserved_size) {
        var mh$ = g_ptr_array_sized_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_sized_new", reserved_size);
            }
            return (MemorySegment)mh$.invokeExact(reserved_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_new_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_new_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_full(guint reserved_size, GDestroyNotify element_free_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_new_full$descriptor() {
        return g_ptr_array_new_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_full(guint reserved_size, GDestroyNotify element_free_func)
     * }
     */
    public static MethodHandle g_ptr_array_new_full$handle() {
        return g_ptr_array_new_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_full(guint reserved_size, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_full$address() {
        return g_ptr_array_new_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_full(guint reserved_size, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_full(int reserved_size, MemorySegment element_free_func) {
        var mh$ = g_ptr_array_new_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_new_full", reserved_size, element_free_func);
            }
            return (MemorySegment)mh$.invokeExact(reserved_size, element_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_new_null_terminated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_new_null_terminated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_null_terminated(guint reserved_size, GDestroyNotify element_free_func, gboolean null_terminated)
     * }
     */
    public static FunctionDescriptor g_ptr_array_new_null_terminated$descriptor() {
        return g_ptr_array_new_null_terminated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_null_terminated(guint reserved_size, GDestroyNotify element_free_func, gboolean null_terminated)
     * }
     */
    public static MethodHandle g_ptr_array_new_null_terminated$handle() {
        return g_ptr_array_new_null_terminated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_null_terminated(guint reserved_size, GDestroyNotify element_free_func, gboolean null_terminated)
     * }
     */
    public static MemorySegment g_ptr_array_new_null_terminated$address() {
        return g_ptr_array_new_null_terminated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_null_terminated(guint reserved_size, GDestroyNotify element_free_func, gboolean null_terminated)
     * }
     */
    public static MemorySegment g_ptr_array_new_null_terminated(int reserved_size, MemorySegment element_free_func, int null_terminated) {
        var mh$ = g_ptr_array_new_null_terminated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_new_null_terminated", reserved_size, element_free_func, null_terminated);
            }
            return (MemorySegment)mh$.invokeExact(reserved_size, element_free_func, null_terminated);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_new_take_null_terminated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_new_take_null_terminated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_take_null_terminated(gpointer *data, GDestroyNotify element_free_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_new_take_null_terminated$descriptor() {
        return g_ptr_array_new_take_null_terminated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_take_null_terminated(gpointer *data, GDestroyNotify element_free_func)
     * }
     */
    public static MethodHandle g_ptr_array_new_take_null_terminated$handle() {
        return g_ptr_array_new_take_null_terminated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_take_null_terminated(gpointer *data, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_take_null_terminated$address() {
        return g_ptr_array_new_take_null_terminated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_take_null_terminated(gpointer *data, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_take_null_terminated(MemorySegment data, MemorySegment element_free_func) {
        var mh$ = g_ptr_array_new_take_null_terminated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_new_take_null_terminated", data, element_free_func);
            }
            return (MemorySegment)mh$.invokeExact(data, element_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_new_from_null_terminated_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_new_from_null_terminated_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_from_null_terminated_array(gpointer *data, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_new_from_null_terminated_array$descriptor() {
        return g_ptr_array_new_from_null_terminated_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_from_null_terminated_array(gpointer *data, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func)
     * }
     */
    public static MethodHandle g_ptr_array_new_from_null_terminated_array$handle() {
        return g_ptr_array_new_from_null_terminated_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_from_null_terminated_array(gpointer *data, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_from_null_terminated_array$address() {
        return g_ptr_array_new_from_null_terminated_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_new_from_null_terminated_array(gpointer *data, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_new_from_null_terminated_array(MemorySegment data, MemorySegment copy_func, MemorySegment copy_func_user_data, MemorySegment element_free_func) {
        var mh$ = g_ptr_array_new_from_null_terminated_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_new_from_null_terminated_array", data, copy_func, copy_func_user_data, element_free_func);
            }
            return (MemorySegment)mh$.invokeExact(data, copy_func, copy_func_user_data, element_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer *g_ptr_array_free(GPtrArray *array, gboolean free_seg)
     * }
     */
    public static FunctionDescriptor g_ptr_array_free$descriptor() {
        return g_ptr_array_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer *g_ptr_array_free(GPtrArray *array, gboolean free_seg)
     * }
     */
    public static MethodHandle g_ptr_array_free$handle() {
        return g_ptr_array_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer *g_ptr_array_free(GPtrArray *array, gboolean free_seg)
     * }
     */
    public static MemorySegment g_ptr_array_free$address() {
        return g_ptr_array_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer *g_ptr_array_free(GPtrArray *array, gboolean free_seg)
     * }
     */
    public static MemorySegment g_ptr_array_free(MemorySegment array, int free_seg) {
        var mh$ = g_ptr_array_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_free", array, free_seg);
            }
            return (MemorySegment)mh$.invokeExact(array, free_seg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_ref(GPtrArray *array)
     * }
     */
    public static FunctionDescriptor g_ptr_array_ref$descriptor() {
        return g_ptr_array_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_ref(GPtrArray *array)
     * }
     */
    public static MethodHandle g_ptr_array_ref$handle() {
        return g_ptr_array_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_ref(GPtrArray *array)
     * }
     */
    public static MemorySegment g_ptr_array_ref$address() {
        return g_ptr_array_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_ref(GPtrArray *array)
     * }
     */
    public static MemorySegment g_ptr_array_ref(MemorySegment array) {
        var mh$ = g_ptr_array_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_ref", array);
            }
            return (MemorySegment)mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_unref(GPtrArray *array)
     * }
     */
    public static FunctionDescriptor g_ptr_array_unref$descriptor() {
        return g_ptr_array_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_unref(GPtrArray *array)
     * }
     */
    public static MethodHandle g_ptr_array_unref$handle() {
        return g_ptr_array_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_unref(GPtrArray *array)
     * }
     */
    public static MemorySegment g_ptr_array_unref$address() {
        return g_ptr_array_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_unref(GPtrArray *array)
     * }
     */
    public static void g_ptr_array_unref(MemorySegment array) {
        var mh$ = g_ptr_array_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_unref", array);
            }
            mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_set_free_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_set_free_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_set_free_func(GPtrArray *array, GDestroyNotify element_free_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_set_free_func$descriptor() {
        return g_ptr_array_set_free_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_set_free_func(GPtrArray *array, GDestroyNotify element_free_func)
     * }
     */
    public static MethodHandle g_ptr_array_set_free_func$handle() {
        return g_ptr_array_set_free_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_set_free_func(GPtrArray *array, GDestroyNotify element_free_func)
     * }
     */
    public static MemorySegment g_ptr_array_set_free_func$address() {
        return g_ptr_array_set_free_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_set_free_func(GPtrArray *array, GDestroyNotify element_free_func)
     * }
     */
    public static void g_ptr_array_set_free_func(MemorySegment array, MemorySegment element_free_func) {
        var mh$ = g_ptr_array_set_free_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_set_free_func", array, element_free_func);
            }
            mh$.invokeExact(array, element_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_set_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_set_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_set_size(GPtrArray *array, gint length)
     * }
     */
    public static FunctionDescriptor g_ptr_array_set_size$descriptor() {
        return g_ptr_array_set_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_set_size(GPtrArray *array, gint length)
     * }
     */
    public static MethodHandle g_ptr_array_set_size$handle() {
        return g_ptr_array_set_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_set_size(GPtrArray *array, gint length)
     * }
     */
    public static MemorySegment g_ptr_array_set_size$address() {
        return g_ptr_array_set_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_set_size(GPtrArray *array, gint length)
     * }
     */
    public static void g_ptr_array_set_size(MemorySegment array, int length) {
        var mh$ = g_ptr_array_set_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_set_size", array, length);
            }
            mh$.invokeExact(array, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_remove_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_remove_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_remove_index(GPtrArray *array, guint index_)
     * }
     */
    public static FunctionDescriptor g_ptr_array_remove_index$descriptor() {
        return g_ptr_array_remove_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_remove_index(GPtrArray *array, guint index_)
     * }
     */
    public static MethodHandle g_ptr_array_remove_index$handle() {
        return g_ptr_array_remove_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_remove_index(GPtrArray *array, guint index_)
     * }
     */
    public static MemorySegment g_ptr_array_remove_index$address() {
        return g_ptr_array_remove_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_remove_index(GPtrArray *array, guint index_)
     * }
     */
    public static MemorySegment g_ptr_array_remove_index(MemorySegment array, int index_) {
        var mh$ = g_ptr_array_remove_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_remove_index", array, index_);
            }
            return (MemorySegment)mh$.invokeExact(array, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_remove_index_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_remove_index_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array, guint index_)
     * }
     */
    public static FunctionDescriptor g_ptr_array_remove_index_fast$descriptor() {
        return g_ptr_array_remove_index_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array, guint index_)
     * }
     */
    public static MethodHandle g_ptr_array_remove_index_fast$handle() {
        return g_ptr_array_remove_index_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array, guint index_)
     * }
     */
    public static MemorySegment g_ptr_array_remove_index_fast$address() {
        return g_ptr_array_remove_index_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array, guint index_)
     * }
     */
    public static MemorySegment g_ptr_array_remove_index_fast(MemorySegment array, int index_) {
        var mh$ = g_ptr_array_remove_index_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_remove_index_fast", array, index_);
            }
            return (MemorySegment)mh$.invokeExact(array, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_steal_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_steal_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_steal_index(GPtrArray *array, guint index_)
     * }
     */
    public static FunctionDescriptor g_ptr_array_steal_index$descriptor() {
        return g_ptr_array_steal_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_steal_index(GPtrArray *array, guint index_)
     * }
     */
    public static MethodHandle g_ptr_array_steal_index$handle() {
        return g_ptr_array_steal_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_steal_index(GPtrArray *array, guint index_)
     * }
     */
    public static MemorySegment g_ptr_array_steal_index$address() {
        return g_ptr_array_steal_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_steal_index(GPtrArray *array, guint index_)
     * }
     */
    public static MemorySegment g_ptr_array_steal_index(MemorySegment array, int index_) {
        var mh$ = g_ptr_array_steal_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_steal_index", array, index_);
            }
            return (MemorySegment)mh$.invokeExact(array, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_steal_index_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_steal_index_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_steal_index_fast(GPtrArray *array, guint index_)
     * }
     */
    public static FunctionDescriptor g_ptr_array_steal_index_fast$descriptor() {
        return g_ptr_array_steal_index_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_steal_index_fast(GPtrArray *array, guint index_)
     * }
     */
    public static MethodHandle g_ptr_array_steal_index_fast$handle() {
        return g_ptr_array_steal_index_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_steal_index_fast(GPtrArray *array, guint index_)
     * }
     */
    public static MemorySegment g_ptr_array_steal_index_fast$address() {
        return g_ptr_array_steal_index_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_ptr_array_steal_index_fast(GPtrArray *array, guint index_)
     * }
     */
    public static MemorySegment g_ptr_array_steal_index_fast(MemorySegment array, int index_) {
        var mh$ = g_ptr_array_steal_index_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_steal_index_fast", array, index_);
            }
            return (MemorySegment)mh$.invokeExact(array, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_remove(GPtrArray *array, gpointer data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_remove$descriptor() {
        return g_ptr_array_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_remove(GPtrArray *array, gpointer data)
     * }
     */
    public static MethodHandle g_ptr_array_remove$handle() {
        return g_ptr_array_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_remove(GPtrArray *array, gpointer data)
     * }
     */
    public static MemorySegment g_ptr_array_remove$address() {
        return g_ptr_array_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_remove(GPtrArray *array, gpointer data)
     * }
     */
    public static int g_ptr_array_remove(MemorySegment array, MemorySegment data) {
        var mh$ = g_ptr_array_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_remove", array, data);
            }
            return (int)mh$.invokeExact(array, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_remove_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_remove_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_remove_fast(GPtrArray *array, gpointer data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_remove_fast$descriptor() {
        return g_ptr_array_remove_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_remove_fast(GPtrArray *array, gpointer data)
     * }
     */
    public static MethodHandle g_ptr_array_remove_fast$handle() {
        return g_ptr_array_remove_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_remove_fast(GPtrArray *array, gpointer data)
     * }
     */
    public static MemorySegment g_ptr_array_remove_fast$address() {
        return g_ptr_array_remove_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_remove_fast(GPtrArray *array, gpointer data)
     * }
     */
    public static int g_ptr_array_remove_fast(MemorySegment array, MemorySegment data) {
        var mh$ = g_ptr_array_remove_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_remove_fast", array, data);
            }
            return (int)mh$.invokeExact(array, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_remove_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_remove_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array, guint index_, guint length)
     * }
     */
    public static FunctionDescriptor g_ptr_array_remove_range$descriptor() {
        return g_ptr_array_remove_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array, guint index_, guint length)
     * }
     */
    public static MethodHandle g_ptr_array_remove_range$handle() {
        return g_ptr_array_remove_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array, guint index_, guint length)
     * }
     */
    public static MemorySegment g_ptr_array_remove_range$address() {
        return g_ptr_array_remove_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array, guint index_, guint length)
     * }
     */
    public static MemorySegment g_ptr_array_remove_range(MemorySegment array, int index_, int length) {
        var mh$ = g_ptr_array_remove_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_remove_range", array, index_, length);
            }
            return (MemorySegment)mh$.invokeExact(array, index_, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_add(GPtrArray *array, gpointer data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_add$descriptor() {
        return g_ptr_array_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_add(GPtrArray *array, gpointer data)
     * }
     */
    public static MethodHandle g_ptr_array_add$handle() {
        return g_ptr_array_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_add(GPtrArray *array, gpointer data)
     * }
     */
    public static MemorySegment g_ptr_array_add$address() {
        return g_ptr_array_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_add(GPtrArray *array, gpointer data)
     * }
     */
    public static void g_ptr_array_add(MemorySegment array, MemorySegment data) {
        var mh$ = g_ptr_array_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_add", array, data);
            }
            mh$.invokeExact(array, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_extend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_extend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_extend(GPtrArray *array_to_extend, GPtrArray *array, GCopyFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_extend$descriptor() {
        return g_ptr_array_extend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_extend(GPtrArray *array_to_extend, GPtrArray *array, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_ptr_array_extend$handle() {
        return g_ptr_array_extend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_extend(GPtrArray *array_to_extend, GPtrArray *array, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_ptr_array_extend$address() {
        return g_ptr_array_extend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_extend(GPtrArray *array_to_extend, GPtrArray *array, GCopyFunc func, gpointer user_data)
     * }
     */
    public static void g_ptr_array_extend(MemorySegment array_to_extend, MemorySegment array, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_ptr_array_extend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_extend", array_to_extend, array, func, user_data);
            }
            mh$.invokeExact(array_to_extend, array, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_extend_and_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_extend_and_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_extend_and_steal(GPtrArray *array_to_extend, GPtrArray *array)
     * }
     */
    public static FunctionDescriptor g_ptr_array_extend_and_steal$descriptor() {
        return g_ptr_array_extend_and_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_extend_and_steal(GPtrArray *array_to_extend, GPtrArray *array)
     * }
     */
    public static MethodHandle g_ptr_array_extend_and_steal$handle() {
        return g_ptr_array_extend_and_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_extend_and_steal(GPtrArray *array_to_extend, GPtrArray *array)
     * }
     */
    public static MemorySegment g_ptr_array_extend_and_steal$address() {
        return g_ptr_array_extend_and_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_extend_and_steal(GPtrArray *array_to_extend, GPtrArray *array)
     * }
     */
    public static void g_ptr_array_extend_and_steal(MemorySegment array_to_extend, MemorySegment array) {
        var mh$ = g_ptr_array_extend_and_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_extend_and_steal", array_to_extend, array);
            }
            mh$.invokeExact(array_to_extend, array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_insert(GPtrArray *array, gint index_, gpointer data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_insert$descriptor() {
        return g_ptr_array_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_insert(GPtrArray *array, gint index_, gpointer data)
     * }
     */
    public static MethodHandle g_ptr_array_insert$handle() {
        return g_ptr_array_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_insert(GPtrArray *array, gint index_, gpointer data)
     * }
     */
    public static MemorySegment g_ptr_array_insert$address() {
        return g_ptr_array_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_insert(GPtrArray *array, gint index_, gpointer data)
     * }
     */
    public static void g_ptr_array_insert(MemorySegment array, int index_, MemorySegment data) {
        var mh$ = g_ptr_array_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_insert", array, index_, data);
            }
            mh$.invokeExact(array, index_, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort(GPtrArray *array, GCompareFunc compare_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_sort$descriptor() {
        return g_ptr_array_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort(GPtrArray *array, GCompareFunc compare_func)
     * }
     */
    public static MethodHandle g_ptr_array_sort$handle() {
        return g_ptr_array_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort(GPtrArray *array, GCompareFunc compare_func)
     * }
     */
    public static MemorySegment g_ptr_array_sort$address() {
        return g_ptr_array_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_sort(GPtrArray *array, GCompareFunc compare_func)
     * }
     */
    public static void g_ptr_array_sort(MemorySegment array, MemorySegment compare_func) {
        var mh$ = g_ptr_array_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_sort", array, compare_func);
            }
            mh$.invokeExact(array, compare_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_sort_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_sort_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_with_data(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_sort_with_data$descriptor() {
        return g_ptr_array_sort_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_with_data(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_ptr_array_sort_with_data$handle() {
        return g_ptr_array_sort_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_with_data(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_ptr_array_sort_with_data$address() {
        return g_ptr_array_sort_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_with_data(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static void g_ptr_array_sort_with_data(MemorySegment array, MemorySegment compare_func, MemorySegment user_data) {
        var mh$ = g_ptr_array_sort_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_sort_with_data", array, compare_func, user_data);
            }
            mh$.invokeExact(array, compare_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_sort_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_sort_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_values(GPtrArray *array, GCompareFunc compare_func)
     * }
     */
    public static FunctionDescriptor g_ptr_array_sort_values$descriptor() {
        return g_ptr_array_sort_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_values(GPtrArray *array, GCompareFunc compare_func)
     * }
     */
    public static MethodHandle g_ptr_array_sort_values$handle() {
        return g_ptr_array_sort_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_values(GPtrArray *array, GCompareFunc compare_func)
     * }
     */
    public static MemorySegment g_ptr_array_sort_values$address() {
        return g_ptr_array_sort_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_values(GPtrArray *array, GCompareFunc compare_func)
     * }
     */
    public static void g_ptr_array_sort_values(MemorySegment array, MemorySegment compare_func) {
        var mh$ = g_ptr_array_sort_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_sort_values", array, compare_func);
            }
            mh$.invokeExact(array, compare_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_sort_values_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_sort_values_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_values_with_data(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_sort_values_with_data$descriptor() {
        return g_ptr_array_sort_values_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_values_with_data(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_ptr_array_sort_values_with_data$handle() {
        return g_ptr_array_sort_values_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_values_with_data(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_ptr_array_sort_values_with_data$address() {
        return g_ptr_array_sort_values_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_sort_values_with_data(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static void g_ptr_array_sort_values_with_data(MemorySegment array, MemorySegment compare_func, MemorySegment user_data) {
        var mh$ = g_ptr_array_sort_values_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_sort_values_with_data", array, compare_func, user_data);
            }
            mh$.invokeExact(array, compare_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ptr_array_foreach(GPtrArray *array, GFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_ptr_array_foreach$descriptor() {
        return g_ptr_array_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ptr_array_foreach(GPtrArray *array, GFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_ptr_array_foreach$handle() {
        return g_ptr_array_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ptr_array_foreach(GPtrArray *array, GFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_ptr_array_foreach$address() {
        return g_ptr_array_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ptr_array_foreach(GPtrArray *array, GFunc func, gpointer user_data)
     * }
     */
    public static void g_ptr_array_foreach(MemorySegment array, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_ptr_array_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_foreach", array, func, user_data);
            }
            mh$.invokeExact(array, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_find(GPtrArray *haystack, gconstpointer needle, guint *index_)
     * }
     */
    public static FunctionDescriptor g_ptr_array_find$descriptor() {
        return g_ptr_array_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_find(GPtrArray *haystack, gconstpointer needle, guint *index_)
     * }
     */
    public static MethodHandle g_ptr_array_find$handle() {
        return g_ptr_array_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_find(GPtrArray *haystack, gconstpointer needle, guint *index_)
     * }
     */
    public static MemorySegment g_ptr_array_find$address() {
        return g_ptr_array_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_find(GPtrArray *haystack, gconstpointer needle, guint *index_)
     * }
     */
    public static int g_ptr_array_find(MemorySegment haystack, MemorySegment needle, MemorySegment index_) {
        var mh$ = g_ptr_array_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_find", haystack, needle, index_);
            }
            return (int)mh$.invokeExact(haystack, needle, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_find_with_equal_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_find_with_equal_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_find_with_equal_func(GPtrArray *haystack, gconstpointer needle, GEqualFunc equal_func, guint *index_)
     * }
     */
    public static FunctionDescriptor g_ptr_array_find_with_equal_func$descriptor() {
        return g_ptr_array_find_with_equal_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_find_with_equal_func(GPtrArray *haystack, gconstpointer needle, GEqualFunc equal_func, guint *index_)
     * }
     */
    public static MethodHandle g_ptr_array_find_with_equal_func$handle() {
        return g_ptr_array_find_with_equal_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_find_with_equal_func(GPtrArray *haystack, gconstpointer needle, GEqualFunc equal_func, guint *index_)
     * }
     */
    public static MemorySegment g_ptr_array_find_with_equal_func$address() {
        return g_ptr_array_find_with_equal_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_find_with_equal_func(GPtrArray *haystack, gconstpointer needle, GEqualFunc equal_func, guint *index_)
     * }
     */
    public static int g_ptr_array_find_with_equal_func(MemorySegment haystack, MemorySegment needle, MemorySegment equal_func, MemorySegment index_) {
        var mh$ = g_ptr_array_find_with_equal_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_find_with_equal_func", haystack, needle, equal_func, index_);
            }
            return (int)mh$.invokeExact(haystack, needle, equal_func, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_is_null_terminated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_is_null_terminated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_is_null_terminated(GPtrArray *array)
     * }
     */
    public static FunctionDescriptor g_ptr_array_is_null_terminated$descriptor() {
        return g_ptr_array_is_null_terminated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_is_null_terminated(GPtrArray *array)
     * }
     */
    public static MethodHandle g_ptr_array_is_null_terminated$handle() {
        return g_ptr_array_is_null_terminated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_is_null_terminated(GPtrArray *array)
     * }
     */
    public static MemorySegment g_ptr_array_is_null_terminated$address() {
        return g_ptr_array_is_null_terminated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ptr_array_is_null_terminated(GPtrArray *array)
     * }
     */
    public static int g_ptr_array_is_null_terminated(MemorySegment array) {
        var mh$ = g_ptr_array_is_null_terminated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_is_null_terminated", array);
            }
            return (int)mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_new()
     * }
     */
    public static FunctionDescriptor g_byte_array_new$descriptor() {
        return g_byte_array_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_new()
     * }
     */
    public static MethodHandle g_byte_array_new$handle() {
        return g_byte_array_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_new()
     * }
     */
    public static MemorySegment g_byte_array_new$address() {
        return g_byte_array_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_new()
     * }
     */
    public static MemorySegment g_byte_array_new() {
        var mh$ = g_byte_array_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_new_take {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_new_take");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_new_take(guint8 *data, gsize len)
     * }
     */
    public static FunctionDescriptor g_byte_array_new_take$descriptor() {
        return g_byte_array_new_take.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_new_take(guint8 *data, gsize len)
     * }
     */
    public static MethodHandle g_byte_array_new_take$handle() {
        return g_byte_array_new_take.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_new_take(guint8 *data, gsize len)
     * }
     */
    public static MemorySegment g_byte_array_new_take$address() {
        return g_byte_array_new_take.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_new_take(guint8 *data, gsize len)
     * }
     */
    public static MemorySegment g_byte_array_new_take(MemorySegment data, long len) {
        var mh$ = g_byte_array_new_take.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_new_take", data, len);
            }
            return (MemorySegment)mh$.invokeExact(data, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint8 *g_byte_array_steal(GByteArray *array, gsize *len)
     * }
     */
    public static FunctionDescriptor g_byte_array_steal$descriptor() {
        return g_byte_array_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint8 *g_byte_array_steal(GByteArray *array, gsize *len)
     * }
     */
    public static MethodHandle g_byte_array_steal$handle() {
        return g_byte_array_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint8 *g_byte_array_steal(GByteArray *array, gsize *len)
     * }
     */
    public static MemorySegment g_byte_array_steal$address() {
        return g_byte_array_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint8 *g_byte_array_steal(GByteArray *array, gsize *len)
     * }
     */
    public static MemorySegment g_byte_array_steal(MemorySegment array, MemorySegment len) {
        var mh$ = g_byte_array_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_steal", array, len);
            }
            return (MemorySegment)mh$.invokeExact(array, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_sized_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_sized_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_sized_new(guint reserved_size)
     * }
     */
    public static FunctionDescriptor g_byte_array_sized_new$descriptor() {
        return g_byte_array_sized_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_sized_new(guint reserved_size)
     * }
     */
    public static MethodHandle g_byte_array_sized_new$handle() {
        return g_byte_array_sized_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_sized_new(guint reserved_size)
     * }
     */
    public static MemorySegment g_byte_array_sized_new$address() {
        return g_byte_array_sized_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_sized_new(guint reserved_size)
     * }
     */
    public static MemorySegment g_byte_array_sized_new(int reserved_size) {
        var mh$ = g_byte_array_sized_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_sized_new", reserved_size);
            }
            return (MemorySegment)mh$.invokeExact(reserved_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint8 *g_byte_array_free(GByteArray *array, gboolean free_segment)
     * }
     */
    public static FunctionDescriptor g_byte_array_free$descriptor() {
        return g_byte_array_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint8 *g_byte_array_free(GByteArray *array, gboolean free_segment)
     * }
     */
    public static MethodHandle g_byte_array_free$handle() {
        return g_byte_array_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint8 *g_byte_array_free(GByteArray *array, gboolean free_segment)
     * }
     */
    public static MemorySegment g_byte_array_free$address() {
        return g_byte_array_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint8 *g_byte_array_free(GByteArray *array, gboolean free_segment)
     * }
     */
    public static MemorySegment g_byte_array_free(MemorySegment array, int free_segment) {
        var mh$ = g_byte_array_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_free", array, free_segment);
            }
            return (MemorySegment)mh$.invokeExact(array, free_segment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_free_to_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_free_to_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_byte_array_free_to_bytes(GByteArray *array)
     * }
     */
    public static FunctionDescriptor g_byte_array_free_to_bytes$descriptor() {
        return g_byte_array_free_to_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_byte_array_free_to_bytes(GByteArray *array)
     * }
     */
    public static MethodHandle g_byte_array_free_to_bytes$handle() {
        return g_byte_array_free_to_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_byte_array_free_to_bytes(GByteArray *array)
     * }
     */
    public static MemorySegment g_byte_array_free_to_bytes$address() {
        return g_byte_array_free_to_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_byte_array_free_to_bytes(GByteArray *array)
     * }
     */
    public static MemorySegment g_byte_array_free_to_bytes(MemorySegment array) {
        var mh$ = g_byte_array_free_to_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_free_to_bytes", array);
            }
            return (MemorySegment)mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_ref(GByteArray *array)
     * }
     */
    public static FunctionDescriptor g_byte_array_ref$descriptor() {
        return g_byte_array_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_ref(GByteArray *array)
     * }
     */
    public static MethodHandle g_byte_array_ref$handle() {
        return g_byte_array_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_ref(GByteArray *array)
     * }
     */
    public static MemorySegment g_byte_array_ref$address() {
        return g_byte_array_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_ref(GByteArray *array)
     * }
     */
    public static MemorySegment g_byte_array_ref(MemorySegment array) {
        var mh$ = g_byte_array_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_ref", array);
            }
            return (MemorySegment)mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_byte_array_unref(GByteArray *array)
     * }
     */
    public static FunctionDescriptor g_byte_array_unref$descriptor() {
        return g_byte_array_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_byte_array_unref(GByteArray *array)
     * }
     */
    public static MethodHandle g_byte_array_unref$handle() {
        return g_byte_array_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_byte_array_unref(GByteArray *array)
     * }
     */
    public static MemorySegment g_byte_array_unref$address() {
        return g_byte_array_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_byte_array_unref(GByteArray *array)
     * }
     */
    public static void g_byte_array_unref(MemorySegment array) {
        var mh$ = g_byte_array_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_unref", array);
            }
            mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_append(GByteArray *array, const guint8 *data, guint len)
     * }
     */
    public static FunctionDescriptor g_byte_array_append$descriptor() {
        return g_byte_array_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_append(GByteArray *array, const guint8 *data, guint len)
     * }
     */
    public static MethodHandle g_byte_array_append$handle() {
        return g_byte_array_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_append(GByteArray *array, const guint8 *data, guint len)
     * }
     */
    public static MemorySegment g_byte_array_append$address() {
        return g_byte_array_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_append(GByteArray *array, const guint8 *data, guint len)
     * }
     */
    public static MemorySegment g_byte_array_append(MemorySegment array, MemorySegment data, int len) {
        var mh$ = g_byte_array_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_append", array, data, len);
            }
            return (MemorySegment)mh$.invokeExact(array, data, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_prepend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_prepend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_prepend(GByteArray *array, const guint8 *data, guint len)
     * }
     */
    public static FunctionDescriptor g_byte_array_prepend$descriptor() {
        return g_byte_array_prepend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_prepend(GByteArray *array, const guint8 *data, guint len)
     * }
     */
    public static MethodHandle g_byte_array_prepend$handle() {
        return g_byte_array_prepend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_prepend(GByteArray *array, const guint8 *data, guint len)
     * }
     */
    public static MemorySegment g_byte_array_prepend$address() {
        return g_byte_array_prepend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_prepend(GByteArray *array, const guint8 *data, guint len)
     * }
     */
    public static MemorySegment g_byte_array_prepend(MemorySegment array, MemorySegment data, int len) {
        var mh$ = g_byte_array_prepend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_prepend", array, data, len);
            }
            return (MemorySegment)mh$.invokeExact(array, data, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_set_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_set_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_set_size(GByteArray *array, guint length)
     * }
     */
    public static FunctionDescriptor g_byte_array_set_size$descriptor() {
        return g_byte_array_set_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_set_size(GByteArray *array, guint length)
     * }
     */
    public static MethodHandle g_byte_array_set_size$handle() {
        return g_byte_array_set_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_set_size(GByteArray *array, guint length)
     * }
     */
    public static MemorySegment g_byte_array_set_size$address() {
        return g_byte_array_set_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_set_size(GByteArray *array, guint length)
     * }
     */
    public static MemorySegment g_byte_array_set_size(MemorySegment array, int length) {
        var mh$ = g_byte_array_set_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_set_size", array, length);
            }
            return (MemorySegment)mh$.invokeExact(array, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_remove_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_remove_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_index(GByteArray *array, guint index_)
     * }
     */
    public static FunctionDescriptor g_byte_array_remove_index$descriptor() {
        return g_byte_array_remove_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_index(GByteArray *array, guint index_)
     * }
     */
    public static MethodHandle g_byte_array_remove_index$handle() {
        return g_byte_array_remove_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_index(GByteArray *array, guint index_)
     * }
     */
    public static MemorySegment g_byte_array_remove_index$address() {
        return g_byte_array_remove_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_index(GByteArray *array, guint index_)
     * }
     */
    public static MemorySegment g_byte_array_remove_index(MemorySegment array, int index_) {
        var mh$ = g_byte_array_remove_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_remove_index", array, index_);
            }
            return (MemorySegment)mh$.invokeExact(array, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_remove_index_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_remove_index_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array, guint index_)
     * }
     */
    public static FunctionDescriptor g_byte_array_remove_index_fast$descriptor() {
        return g_byte_array_remove_index_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array, guint index_)
     * }
     */
    public static MethodHandle g_byte_array_remove_index_fast$handle() {
        return g_byte_array_remove_index_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array, guint index_)
     * }
     */
    public static MemorySegment g_byte_array_remove_index_fast$address() {
        return g_byte_array_remove_index_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array, guint index_)
     * }
     */
    public static MemorySegment g_byte_array_remove_index_fast(MemorySegment array, int index_) {
        var mh$ = g_byte_array_remove_index_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_remove_index_fast", array, index_);
            }
            return (MemorySegment)mh$.invokeExact(array, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_remove_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_remove_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_range(GByteArray *array, guint index_, guint length)
     * }
     */
    public static FunctionDescriptor g_byte_array_remove_range$descriptor() {
        return g_byte_array_remove_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_range(GByteArray *array, guint index_, guint length)
     * }
     */
    public static MethodHandle g_byte_array_remove_range$handle() {
        return g_byte_array_remove_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_range(GByteArray *array, guint index_, guint length)
     * }
     */
    public static MemorySegment g_byte_array_remove_range$address() {
        return g_byte_array_remove_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_byte_array_remove_range(GByteArray *array, guint index_, guint length)
     * }
     */
    public static MemorySegment g_byte_array_remove_range(MemorySegment array, int index_, int length) {
        var mh$ = g_byte_array_remove_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_remove_range", array, index_, length);
            }
            return (MemorySegment)mh$.invokeExact(array, index_, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_byte_array_sort(GByteArray *array, GCompareFunc compare_func)
     * }
     */
    public static FunctionDescriptor g_byte_array_sort$descriptor() {
        return g_byte_array_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_byte_array_sort(GByteArray *array, GCompareFunc compare_func)
     * }
     */
    public static MethodHandle g_byte_array_sort$handle() {
        return g_byte_array_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_byte_array_sort(GByteArray *array, GCompareFunc compare_func)
     * }
     */
    public static MemorySegment g_byte_array_sort$address() {
        return g_byte_array_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_byte_array_sort(GByteArray *array, GCompareFunc compare_func)
     * }
     */
    public static void g_byte_array_sort(MemorySegment array, MemorySegment compare_func) {
        var mh$ = g_byte_array_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_sort", array, compare_func);
            }
            mh$.invokeExact(array, compare_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_sort_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_sort_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_byte_array_sort_with_data(GByteArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_byte_array_sort_with_data$descriptor() {
        return g_byte_array_sort_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_byte_array_sort_with_data(GByteArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_byte_array_sort_with_data$handle() {
        return g_byte_array_sort_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_byte_array_sort_with_data(GByteArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_byte_array_sort_with_data$address() {
        return g_byte_array_sort_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_byte_array_sort_with_data(GByteArray *array, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static void g_byte_array_sort_with_data(MemorySegment array, MemorySegment compare_func, MemorySegment user_data) {
        var mh$ = g_byte_array_sort_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_sort_with_data", array, compare_func, user_data);
            }
            mh$.invokeExact(array, compare_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_get(const volatile gint *atomic)
     * }
     */
    public static FunctionDescriptor g_atomic_int_get$descriptor() {
        return g_atomic_int_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_get(const volatile gint *atomic)
     * }
     */
    public static MethodHandle g_atomic_int_get$handle() {
        return g_atomic_int_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_get(const volatile gint *atomic)
     * }
     */
    public static MemorySegment g_atomic_int_get$address() {
        return g_atomic_int_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_atomic_int_get(const volatile gint *atomic)
     * }
     */
    public static int g_atomic_int_get(MemorySegment atomic) {
        var mh$ = g_atomic_int_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_get", atomic);
            }
            return (int)mh$.invokeExact(atomic);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_atomic_int_set(volatile gint *atomic, gint newval)
     * }
     */
    public static FunctionDescriptor g_atomic_int_set$descriptor() {
        return g_atomic_int_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_atomic_int_set(volatile gint *atomic, gint newval)
     * }
     */
    public static MethodHandle g_atomic_int_set$handle() {
        return g_atomic_int_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_atomic_int_set(volatile gint *atomic, gint newval)
     * }
     */
    public static MemorySegment g_atomic_int_set$address() {
        return g_atomic_int_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_atomic_int_set(volatile gint *atomic, gint newval)
     * }
     */
    public static void g_atomic_int_set(MemorySegment atomic, int newval) {
        var mh$ = g_atomic_int_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_set", atomic, newval);
            }
            mh$.invokeExact(atomic, newval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_inc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_inc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_atomic_int_inc(volatile gint *atomic)
     * }
     */
    public static FunctionDescriptor g_atomic_int_inc$descriptor() {
        return g_atomic_int_inc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_atomic_int_inc(volatile gint *atomic)
     * }
     */
    public static MethodHandle g_atomic_int_inc$handle() {
        return g_atomic_int_inc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_atomic_int_inc(volatile gint *atomic)
     * }
     */
    public static MemorySegment g_atomic_int_inc$address() {
        return g_atomic_int_inc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_atomic_int_inc(volatile gint *atomic)
     * }
     */
    public static void g_atomic_int_inc(MemorySegment atomic) {
        var mh$ = g_atomic_int_inc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_inc", atomic);
            }
            mh$.invokeExact(atomic);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_dec_and_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_dec_and_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_dec_and_test(volatile gint *atomic)
     * }
     */
    public static FunctionDescriptor g_atomic_int_dec_and_test$descriptor() {
        return g_atomic_int_dec_and_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_dec_and_test(volatile gint *atomic)
     * }
     */
    public static MethodHandle g_atomic_int_dec_and_test$handle() {
        return g_atomic_int_dec_and_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_dec_and_test(volatile gint *atomic)
     * }
     */
    public static MemorySegment g_atomic_int_dec_and_test$address() {
        return g_atomic_int_dec_and_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_dec_and_test(volatile gint *atomic)
     * }
     */
    public static int g_atomic_int_dec_and_test(MemorySegment atomic) {
        var mh$ = g_atomic_int_dec_and_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_dec_and_test", atomic);
            }
            return (int)mh$.invokeExact(atomic);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_compare_and_exchange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_compare_and_exchange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_compare_and_exchange(volatile gint *atomic, gint oldval, gint newval)
     * }
     */
    public static FunctionDescriptor g_atomic_int_compare_and_exchange$descriptor() {
        return g_atomic_int_compare_and_exchange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_compare_and_exchange(volatile gint *atomic, gint oldval, gint newval)
     * }
     */
    public static MethodHandle g_atomic_int_compare_and_exchange$handle() {
        return g_atomic_int_compare_and_exchange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_compare_and_exchange(volatile gint *atomic, gint oldval, gint newval)
     * }
     */
    public static MemorySegment g_atomic_int_compare_and_exchange$address() {
        return g_atomic_int_compare_and_exchange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_compare_and_exchange(volatile gint *atomic, gint oldval, gint newval)
     * }
     */
    public static int g_atomic_int_compare_and_exchange(MemorySegment atomic, int oldval, int newval) {
        var mh$ = g_atomic_int_compare_and_exchange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_compare_and_exchange", atomic, oldval, newval);
            }
            return (int)mh$.invokeExact(atomic, oldval, newval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_compare_and_exchange_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_compare_and_exchange_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_compare_and_exchange_full(gint *atomic, gint oldval, gint newval, gint *preval)
     * }
     */
    public static FunctionDescriptor g_atomic_int_compare_and_exchange_full$descriptor() {
        return g_atomic_int_compare_and_exchange_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_compare_and_exchange_full(gint *atomic, gint oldval, gint newval, gint *preval)
     * }
     */
    public static MethodHandle g_atomic_int_compare_and_exchange_full$handle() {
        return g_atomic_int_compare_and_exchange_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_compare_and_exchange_full(gint *atomic, gint oldval, gint newval, gint *preval)
     * }
     */
    public static MemorySegment g_atomic_int_compare_and_exchange_full$address() {
        return g_atomic_int_compare_and_exchange_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_atomic_int_compare_and_exchange_full(gint *atomic, gint oldval, gint newval, gint *preval)
     * }
     */
    public static int g_atomic_int_compare_and_exchange_full(MemorySegment atomic, int oldval, int newval, MemorySegment preval) {
        var mh$ = g_atomic_int_compare_and_exchange_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_compare_and_exchange_full", atomic, oldval, newval, preval);
            }
            return (int)mh$.invokeExact(atomic, oldval, newval, preval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_exchange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_exchange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_exchange(gint *atomic, gint newval)
     * }
     */
    public static FunctionDescriptor g_atomic_int_exchange$descriptor() {
        return g_atomic_int_exchange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_exchange(gint *atomic, gint newval)
     * }
     */
    public static MethodHandle g_atomic_int_exchange$handle() {
        return g_atomic_int_exchange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_exchange(gint *atomic, gint newval)
     * }
     */
    public static MemorySegment g_atomic_int_exchange$address() {
        return g_atomic_int_exchange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_atomic_int_exchange(gint *atomic, gint newval)
     * }
     */
    public static int g_atomic_int_exchange(MemorySegment atomic, int newval) {
        var mh$ = g_atomic_int_exchange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_exchange", atomic, newval);
            }
            return (int)mh$.invokeExact(atomic, newval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_add(volatile gint *atomic, gint val)
     * }
     */
    public static FunctionDescriptor g_atomic_int_add$descriptor() {
        return g_atomic_int_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_add(volatile gint *atomic, gint val)
     * }
     */
    public static MethodHandle g_atomic_int_add$handle() {
        return g_atomic_int_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_add(volatile gint *atomic, gint val)
     * }
     */
    public static MemorySegment g_atomic_int_add$address() {
        return g_atomic_int_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_atomic_int_add(volatile gint *atomic, gint val)
     * }
     */
    public static int g_atomic_int_add(MemorySegment atomic, int val) {
        var mh$ = g_atomic_int_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_add", atomic, val);
            }
            return (int)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_and {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_and");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_and(volatile guint *atomic, guint val)
     * }
     */
    public static FunctionDescriptor g_atomic_int_and$descriptor() {
        return g_atomic_int_and.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_and(volatile guint *atomic, guint val)
     * }
     */
    public static MethodHandle g_atomic_int_and$handle() {
        return g_atomic_int_and.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_and(volatile guint *atomic, guint val)
     * }
     */
    public static MemorySegment g_atomic_int_and$address() {
        return g_atomic_int_and.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_atomic_int_and(volatile guint *atomic, guint val)
     * }
     */
    public static int g_atomic_int_and(MemorySegment atomic, int val) {
        var mh$ = g_atomic_int_and.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_and", atomic, val);
            }
            return (int)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_or {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_or");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_or(volatile guint *atomic, guint val)
     * }
     */
    public static FunctionDescriptor g_atomic_int_or$descriptor() {
        return g_atomic_int_or.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_or(volatile guint *atomic, guint val)
     * }
     */
    public static MethodHandle g_atomic_int_or$handle() {
        return g_atomic_int_or.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_or(volatile guint *atomic, guint val)
     * }
     */
    public static MemorySegment g_atomic_int_or$address() {
        return g_atomic_int_or.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_atomic_int_or(volatile guint *atomic, guint val)
     * }
     */
    public static int g_atomic_int_or(MemorySegment atomic, int val) {
        var mh$ = g_atomic_int_or.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_or", atomic, val);
            }
            return (int)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_xor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_xor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_xor(volatile guint *atomic, guint val)
     * }
     */
    public static FunctionDescriptor g_atomic_int_xor$descriptor() {
        return g_atomic_int_xor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_xor(volatile guint *atomic, guint val)
     * }
     */
    public static MethodHandle g_atomic_int_xor$handle() {
        return g_atomic_int_xor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_atomic_int_xor(volatile guint *atomic, guint val)
     * }
     */
    public static MemorySegment g_atomic_int_xor$address() {
        return g_atomic_int_xor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_atomic_int_xor(volatile guint *atomic, guint val)
     * }
     */
    public static int g_atomic_int_xor(MemorySegment atomic, int val) {
        var mh$ = g_atomic_int_xor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_xor", atomic, val);
            }
            return (int)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_pointer_get(const volatile void *atomic)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_get$descriptor() {
        return g_atomic_pointer_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_pointer_get(const volatile void *atomic)
     * }
     */
    public static MethodHandle g_atomic_pointer_get$handle() {
        return g_atomic_pointer_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_pointer_get(const volatile void *atomic)
     * }
     */
    public static MemorySegment g_atomic_pointer_get$address() {
        return g_atomic_pointer_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_atomic_pointer_get(const volatile void *atomic)
     * }
     */
    public static MemorySegment g_atomic_pointer_get(MemorySegment atomic) {
        var mh$ = g_atomic_pointer_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_get", atomic);
            }
            return (MemorySegment)mh$.invokeExact(atomic);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_atomic_pointer_set(volatile void *atomic, gpointer newval)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_set$descriptor() {
        return g_atomic_pointer_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_atomic_pointer_set(volatile void *atomic, gpointer newval)
     * }
     */
    public static MethodHandle g_atomic_pointer_set$handle() {
        return g_atomic_pointer_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_atomic_pointer_set(volatile void *atomic, gpointer newval)
     * }
     */
    public static MemorySegment g_atomic_pointer_set$address() {
        return g_atomic_pointer_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_atomic_pointer_set(volatile void *atomic, gpointer newval)
     * }
     */
    public static void g_atomic_pointer_set(MemorySegment atomic, MemorySegment newval) {
        var mh$ = g_atomic_pointer_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_set", atomic, newval);
            }
            mh$.invokeExact(atomic, newval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_compare_and_exchange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_compare_and_exchange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_pointer_compare_and_exchange(volatile void *atomic, gpointer oldval, gpointer newval)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_compare_and_exchange$descriptor() {
        return g_atomic_pointer_compare_and_exchange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_pointer_compare_and_exchange(volatile void *atomic, gpointer oldval, gpointer newval)
     * }
     */
    public static MethodHandle g_atomic_pointer_compare_and_exchange$handle() {
        return g_atomic_pointer_compare_and_exchange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_pointer_compare_and_exchange(volatile void *atomic, gpointer oldval, gpointer newval)
     * }
     */
    public static MemorySegment g_atomic_pointer_compare_and_exchange$address() {
        return g_atomic_pointer_compare_and_exchange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_atomic_pointer_compare_and_exchange(volatile void *atomic, gpointer oldval, gpointer newval)
     * }
     */
    public static int g_atomic_pointer_compare_and_exchange(MemorySegment atomic, MemorySegment oldval, MemorySegment newval) {
        var mh$ = g_atomic_pointer_compare_and_exchange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_compare_and_exchange", atomic, oldval, newval);
            }
            return (int)mh$.invokeExact(atomic, oldval, newval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_compare_and_exchange_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_compare_and_exchange_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_pointer_compare_and_exchange_full(void *atomic, gpointer oldval, gpointer newval, void *preval)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_compare_and_exchange_full$descriptor() {
        return g_atomic_pointer_compare_and_exchange_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_pointer_compare_and_exchange_full(void *atomic, gpointer oldval, gpointer newval, void *preval)
     * }
     */
    public static MethodHandle g_atomic_pointer_compare_and_exchange_full$handle() {
        return g_atomic_pointer_compare_and_exchange_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_pointer_compare_and_exchange_full(void *atomic, gpointer oldval, gpointer newval, void *preval)
     * }
     */
    public static MemorySegment g_atomic_pointer_compare_and_exchange_full$address() {
        return g_atomic_pointer_compare_and_exchange_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_atomic_pointer_compare_and_exchange_full(void *atomic, gpointer oldval, gpointer newval, void *preval)
     * }
     */
    public static int g_atomic_pointer_compare_and_exchange_full(MemorySegment atomic, MemorySegment oldval, MemorySegment newval, MemorySegment preval) {
        var mh$ = g_atomic_pointer_compare_and_exchange_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_compare_and_exchange_full", atomic, oldval, newval, preval);
            }
            return (int)mh$.invokeExact(atomic, oldval, newval, preval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_exchange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_exchange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_pointer_exchange(void *atomic, gpointer newval)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_exchange$descriptor() {
        return g_atomic_pointer_exchange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_pointer_exchange(void *atomic, gpointer newval)
     * }
     */
    public static MethodHandle g_atomic_pointer_exchange$handle() {
        return g_atomic_pointer_exchange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_pointer_exchange(void *atomic, gpointer newval)
     * }
     */
    public static MemorySegment g_atomic_pointer_exchange$address() {
        return g_atomic_pointer_exchange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_atomic_pointer_exchange(void *atomic, gpointer newval)
     * }
     */
    public static MemorySegment g_atomic_pointer_exchange(MemorySegment atomic, MemorySegment newval) {
        var mh$ = g_atomic_pointer_exchange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_exchange", atomic, newval);
            }
            return (MemorySegment)mh$.invokeExact(atomic, newval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gintptr g_atomic_pointer_add(volatile void *atomic, gssize val)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_add$descriptor() {
        return g_atomic_pointer_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gintptr g_atomic_pointer_add(volatile void *atomic, gssize val)
     * }
     */
    public static MethodHandle g_atomic_pointer_add$handle() {
        return g_atomic_pointer_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gintptr g_atomic_pointer_add(volatile void *atomic, gssize val)
     * }
     */
    public static MemorySegment g_atomic_pointer_add$address() {
        return g_atomic_pointer_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gintptr g_atomic_pointer_add(volatile void *atomic, gssize val)
     * }
     */
    public static long g_atomic_pointer_add(MemorySegment atomic, long val) {
        var mh$ = g_atomic_pointer_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_add", atomic, val);
            }
            return (long)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_and {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_and");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_and(volatile void *atomic, gsize val)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_and$descriptor() {
        return g_atomic_pointer_and.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_and(volatile void *atomic, gsize val)
     * }
     */
    public static MethodHandle g_atomic_pointer_and$handle() {
        return g_atomic_pointer_and.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_and(volatile void *atomic, gsize val)
     * }
     */
    public static MemorySegment g_atomic_pointer_and$address() {
        return g_atomic_pointer_and.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_and(volatile void *atomic, gsize val)
     * }
     */
    public static long g_atomic_pointer_and(MemorySegment atomic, long val) {
        var mh$ = g_atomic_pointer_and.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_and", atomic, val);
            }
            return (long)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_or {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_or");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_or(volatile void *atomic, gsize val)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_or$descriptor() {
        return g_atomic_pointer_or.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_or(volatile void *atomic, gsize val)
     * }
     */
    public static MethodHandle g_atomic_pointer_or$handle() {
        return g_atomic_pointer_or.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_or(volatile void *atomic, gsize val)
     * }
     */
    public static MemorySegment g_atomic_pointer_or$address() {
        return g_atomic_pointer_or.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_or(volatile void *atomic, gsize val)
     * }
     */
    public static long g_atomic_pointer_or(MemorySegment atomic, long val) {
        var mh$ = g_atomic_pointer_or.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_or", atomic, val);
            }
            return (long)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_pointer_xor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_pointer_xor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_xor(volatile void *atomic, gsize val)
     * }
     */
    public static FunctionDescriptor g_atomic_pointer_xor$descriptor() {
        return g_atomic_pointer_xor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_xor(volatile void *atomic, gsize val)
     * }
     */
    public static MethodHandle g_atomic_pointer_xor$handle() {
        return g_atomic_pointer_xor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_xor(volatile void *atomic, gsize val)
     * }
     */
    public static MemorySegment g_atomic_pointer_xor$address() {
        return g_atomic_pointer_xor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guintptr g_atomic_pointer_xor(volatile void *atomic, gsize val)
     * }
     */
    public static long g_atomic_pointer_xor(MemorySegment atomic, long val) {
        var mh$ = g_atomic_pointer_xor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_pointer_xor", atomic, val);
            }
            return (long)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_int_exchange_and_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_int_exchange_and_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_exchange_and_add(volatile gint *atomic, gint val)
     * }
     */
    public static FunctionDescriptor g_atomic_int_exchange_and_add$descriptor() {
        return g_atomic_int_exchange_and_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_exchange_and_add(volatile gint *atomic, gint val)
     * }
     */
    public static MethodHandle g_atomic_int_exchange_and_add$handle() {
        return g_atomic_int_exchange_and_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_atomic_int_exchange_and_add(volatile gint *atomic, gint val)
     * }
     */
    public static MemorySegment g_atomic_int_exchange_and_add$address() {
        return g_atomic_int_exchange_and_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_atomic_int_exchange_and_add(volatile gint *atomic, gint val)
     * }
     */
    public static int g_atomic_int_exchange_and_add(MemorySegment atomic, int val) {
        var mh$ = g_atomic_int_exchange_and_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_int_exchange_and_add", atomic, val);
            }
            return (int)mh$.invokeExact(atomic, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef guint32 GQuark
     * }
     */
    public static final OfInt GQuark = gst_min_h.C_INT;

    private static class g_quark_try_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_quark_try_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_quark_try_string(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_quark_try_string$descriptor() {
        return g_quark_try_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_quark_try_string(const gchar *string)
     * }
     */
    public static MethodHandle g_quark_try_string$handle() {
        return g_quark_try_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_quark_try_string(const gchar *string)
     * }
     */
    public static MemorySegment g_quark_try_string$address() {
        return g_quark_try_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_quark_try_string(const gchar *string)
     * }
     */
    public static int g_quark_try_string(MemorySegment string) {
        var mh$ = g_quark_try_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_quark_try_string", string);
            }
            return (int)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_quark_from_static_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_quark_from_static_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_quark_from_static_string(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_quark_from_static_string$descriptor() {
        return g_quark_from_static_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_quark_from_static_string(const gchar *string)
     * }
     */
    public static MethodHandle g_quark_from_static_string$handle() {
        return g_quark_from_static_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_quark_from_static_string(const gchar *string)
     * }
     */
    public static MemorySegment g_quark_from_static_string$address() {
        return g_quark_from_static_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_quark_from_static_string(const gchar *string)
     * }
     */
    public static int g_quark_from_static_string(MemorySegment string) {
        var mh$ = g_quark_from_static_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_quark_from_static_string", string);
            }
            return (int)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_quark_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_quark_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_quark_from_string(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_quark_from_string$descriptor() {
        return g_quark_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_quark_from_string(const gchar *string)
     * }
     */
    public static MethodHandle g_quark_from_string$handle() {
        return g_quark_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_quark_from_string(const gchar *string)
     * }
     */
    public static MemorySegment g_quark_from_string$address() {
        return g_quark_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_quark_from_string(const gchar *string)
     * }
     */
    public static int g_quark_from_string(MemorySegment string) {
        var mh$ = g_quark_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_quark_from_string", string);
            }
            return (int)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_quark_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_quark_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_quark_to_string(GQuark quark)
     * }
     */
    public static FunctionDescriptor g_quark_to_string$descriptor() {
        return g_quark_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_quark_to_string(GQuark quark)
     * }
     */
    public static MethodHandle g_quark_to_string$handle() {
        return g_quark_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_quark_to_string(GQuark quark)
     * }
     */
    public static MemorySegment g_quark_to_string$address() {
        return g_quark_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_quark_to_string(GQuark quark)
     * }
     */
    public static MemorySegment g_quark_to_string(int quark) {
        var mh$ = g_quark_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_quark_to_string", quark);
            }
            return (MemorySegment)mh$.invokeExact(quark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_intern_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_intern_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_intern_string(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_intern_string$descriptor() {
        return g_intern_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_intern_string(const gchar *string)
     * }
     */
    public static MethodHandle g_intern_string$handle() {
        return g_intern_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_intern_string(const gchar *string)
     * }
     */
    public static MemorySegment g_intern_string$address() {
        return g_intern_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_intern_string(const gchar *string)
     * }
     */
    public static MemorySegment g_intern_string(MemorySegment string) {
        var mh$ = g_intern_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_intern_string", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_intern_static_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_intern_static_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_intern_static_string(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_intern_static_string$descriptor() {
        return g_intern_static_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_intern_static_string(const gchar *string)
     * }
     */
    public static MethodHandle g_intern_static_string$handle() {
        return g_intern_static_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_intern_static_string(const gchar *string)
     * }
     */
    public static MemorySegment g_intern_static_string$address() {
        return g_intern_static_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_intern_static_string(const gchar *string)
     * }
     */
    public static MemorySegment g_intern_static_string(MemorySegment string) {
        var mh$ = g_intern_static_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_intern_static_string", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_error_domain_register_static {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_domain_register_static");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_error_domain_register_static(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear)
     * }
     */
    public static FunctionDescriptor g_error_domain_register_static$descriptor() {
        return g_error_domain_register_static.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_error_domain_register_static(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear)
     * }
     */
    public static MethodHandle g_error_domain_register_static$handle() {
        return g_error_domain_register_static.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_error_domain_register_static(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear)
     * }
     */
    public static MemorySegment g_error_domain_register_static$address() {
        return g_error_domain_register_static.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_error_domain_register_static(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear)
     * }
     */
    public static int g_error_domain_register_static(MemorySegment error_type_name, long error_type_private_size, MemorySegment error_type_init, MemorySegment error_type_copy, MemorySegment error_type_clear) {
        var mh$ = g_error_domain_register_static.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_error_domain_register_static", error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear);
            }
            return (int)mh$.invokeExact(error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_error_domain_register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_domain_register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_error_domain_register(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear)
     * }
     */
    public static FunctionDescriptor g_error_domain_register$descriptor() {
        return g_error_domain_register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_error_domain_register(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear)
     * }
     */
    public static MethodHandle g_error_domain_register$handle() {
        return g_error_domain_register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_error_domain_register(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear)
     * }
     */
    public static MemorySegment g_error_domain_register$address() {
        return g_error_domain_register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_error_domain_register(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear)
     * }
     */
    public static int g_error_domain_register(MemorySegment error_type_name, long error_type_private_size, MemorySegment error_type_init, MemorySegment error_type_copy, MemorySegment error_type_clear) {
        var mh$ = g_error_domain_register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_error_domain_register", error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear);
            }
            return (int)mh$.invokeExact(error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern GError *g_error_new(GQuark domain, gint code, const gchar *format, ...)
     * }
     */
    public static class g_error_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_INT,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_error_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern GError *g_error_new(GQuark domain, gint code, const gchar *format, ...)
         * }
         */
        public static g_error_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_error_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(int domain, int code, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_error_new", domain, code, format, x3);
                }
                return (MemorySegment) spreader.invokeExact(domain, code, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_error_new_literal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_new_literal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GError *g_error_new_literal(GQuark domain, gint code, const gchar *message)
     * }
     */
    public static FunctionDescriptor g_error_new_literal$descriptor() {
        return g_error_new_literal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GError *g_error_new_literal(GQuark domain, gint code, const gchar *message)
     * }
     */
    public static MethodHandle g_error_new_literal$handle() {
        return g_error_new_literal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GError *g_error_new_literal(GQuark domain, gint code, const gchar *message)
     * }
     */
    public static MemorySegment g_error_new_literal$address() {
        return g_error_new_literal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GError *g_error_new_literal(GQuark domain, gint code, const gchar *message)
     * }
     */
    public static MemorySegment g_error_new_literal(int domain, int code, MemorySegment message) {
        var mh$ = g_error_new_literal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_error_new_literal", domain, code, message);
            }
            return (MemorySegment)mh$.invokeExact(domain, code, message);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_error_new_valist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_new_valist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GError *g_error_new_valist(GQuark domain, gint code, const gchar *format, va_list args)
     * }
     */
    public static FunctionDescriptor g_error_new_valist$descriptor() {
        return g_error_new_valist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GError *g_error_new_valist(GQuark domain, gint code, const gchar *format, va_list args)
     * }
     */
    public static MethodHandle g_error_new_valist$handle() {
        return g_error_new_valist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GError *g_error_new_valist(GQuark domain, gint code, const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_error_new_valist$address() {
        return g_error_new_valist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GError *g_error_new_valist(GQuark domain, gint code, const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_error_new_valist(int domain, int code, MemorySegment format, MemorySegment args) {
        var mh$ = g_error_new_valist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_error_new_valist", domain, code, format, args);
            }
            return (MemorySegment)mh$.invokeExact(domain, code, format, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_error_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_error_free(GError *error)
     * }
     */
    public static FunctionDescriptor g_error_free$descriptor() {
        return g_error_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_error_free(GError *error)
     * }
     */
    public static MethodHandle g_error_free$handle() {
        return g_error_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_error_free(GError *error)
     * }
     */
    public static MemorySegment g_error_free$address() {
        return g_error_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_error_free(GError *error)
     * }
     */
    public static void g_error_free(MemorySegment error) {
        var mh$ = g_error_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_error_free", error);
            }
            mh$.invokeExact(error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_error_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GError *g_error_copy(const GError *error)
     * }
     */
    public static FunctionDescriptor g_error_copy$descriptor() {
        return g_error_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GError *g_error_copy(const GError *error)
     * }
     */
    public static MethodHandle g_error_copy$handle() {
        return g_error_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GError *g_error_copy(const GError *error)
     * }
     */
    public static MemorySegment g_error_copy$address() {
        return g_error_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GError *g_error_copy(const GError *error)
     * }
     */
    public static MemorySegment g_error_copy(MemorySegment error) {
        var mh$ = g_error_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_error_copy", error);
            }
            return (MemorySegment)mh$.invokeExact(error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_error_matches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_matches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_error_matches(const GError *error, GQuark domain, gint code)
     * }
     */
    public static FunctionDescriptor g_error_matches$descriptor() {
        return g_error_matches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_error_matches(const GError *error, GQuark domain, gint code)
     * }
     */
    public static MethodHandle g_error_matches$handle() {
        return g_error_matches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_error_matches(const GError *error, GQuark domain, gint code)
     * }
     */
    public static MemorySegment g_error_matches$address() {
        return g_error_matches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_error_matches(const GError *error, GQuark domain, gint code)
     * }
     */
    public static int g_error_matches(MemorySegment error, int domain, int code) {
        var mh$ = g_error_matches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_error_matches", error, domain, code);
            }
            return (int)mh$.invokeExact(error, domain, code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_set_error(GError **err, GQuark domain, gint code, const gchar *format, ...)
     * }
     */
    public static class g_set_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_INT,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_set_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_set_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_set_error(GError **err, GQuark domain, gint code, const gchar *format, ...)
         * }
         */
        public static g_set_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_set_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment err, int domain, int code, MemorySegment format, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_set_error", err, domain, code, format, x4);
                }
                 spreader.invokeExact(err, domain, code, format, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_set_error_literal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_set_error_literal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_set_error_literal(GError **err, GQuark domain, gint code, const gchar *message)
     * }
     */
    public static FunctionDescriptor g_set_error_literal$descriptor() {
        return g_set_error_literal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_set_error_literal(GError **err, GQuark domain, gint code, const gchar *message)
     * }
     */
    public static MethodHandle g_set_error_literal$handle() {
        return g_set_error_literal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_set_error_literal(GError **err, GQuark domain, gint code, const gchar *message)
     * }
     */
    public static MemorySegment g_set_error_literal$address() {
        return g_set_error_literal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_set_error_literal(GError **err, GQuark domain, gint code, const gchar *message)
     * }
     */
    public static void g_set_error_literal(MemorySegment err, int domain, int code, MemorySegment message) {
        var mh$ = g_set_error_literal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_set_error_literal", err, domain, code, message);
            }
            mh$.invokeExact(err, domain, code, message);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_propagate_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_propagate_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_propagate_error(GError **dest, GError *src)
     * }
     */
    public static FunctionDescriptor g_propagate_error$descriptor() {
        return g_propagate_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_propagate_error(GError **dest, GError *src)
     * }
     */
    public static MethodHandle g_propagate_error$handle() {
        return g_propagate_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_propagate_error(GError **dest, GError *src)
     * }
     */
    public static MemorySegment g_propagate_error$address() {
        return g_propagate_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_propagate_error(GError **dest, GError *src)
     * }
     */
    public static void g_propagate_error(MemorySegment dest, MemorySegment src) {
        var mh$ = g_propagate_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_propagate_error", dest, src);
            }
            mh$.invokeExact(dest, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_clear_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_clear_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_clear_error(GError **err)
     * }
     */
    public static FunctionDescriptor g_clear_error$descriptor() {
        return g_clear_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_clear_error(GError **err)
     * }
     */
    public static MethodHandle g_clear_error$handle() {
        return g_clear_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_clear_error(GError **err)
     * }
     */
    public static MemorySegment g_clear_error$address() {
        return g_clear_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_clear_error(GError **err)
     * }
     */
    public static void g_clear_error(MemorySegment err) {
        var mh$ = g_clear_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_clear_error", err);
            }
            mh$.invokeExact(err);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_prefix_error(GError **err, const gchar *format, ...)
     * }
     */
    public static class g_prefix_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_prefix_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_prefix_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_prefix_error(GError **err, const gchar *format, ...)
         * }
         */
        public static g_prefix_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_prefix_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment err, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_prefix_error", err, format, x2);
                }
                 spreader.invokeExact(err, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_prefix_error_literal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_prefix_error_literal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_prefix_error_literal(GError **err, const gchar *prefix)
     * }
     */
    public static FunctionDescriptor g_prefix_error_literal$descriptor() {
        return g_prefix_error_literal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_prefix_error_literal(GError **err, const gchar *prefix)
     * }
     */
    public static MethodHandle g_prefix_error_literal$handle() {
        return g_prefix_error_literal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_prefix_error_literal(GError **err, const gchar *prefix)
     * }
     */
    public static MemorySegment g_prefix_error_literal$address() {
        return g_prefix_error_literal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_prefix_error_literal(GError **err, const gchar *prefix)
     * }
     */
    public static void g_prefix_error_literal(MemorySegment err, MemorySegment prefix) {
        var mh$ = g_prefix_error_literal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_prefix_error_literal", err, prefix);
            }
            mh$.invokeExact(err, prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_propagate_prefixed_error(GError **dest, GError *src, const gchar *format, ...)
     * }
     */
    public static class g_propagate_prefixed_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_propagate_prefixed_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_propagate_prefixed_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_propagate_prefixed_error(GError **dest, GError *src, const gchar *format, ...)
         * }
         */
        public static g_propagate_prefixed_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_propagate_prefixed_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment dest, MemorySegment src, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_propagate_prefixed_error", dest, src, format, x3);
                }
                 spreader.invokeExact(dest, src, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_get_user_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_user_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_name()
     * }
     */
    public static FunctionDescriptor g_get_user_name$descriptor() {
        return g_get_user_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_name()
     * }
     */
    public static MethodHandle g_get_user_name$handle() {
        return g_get_user_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_name()
     * }
     */
    public static MemorySegment g_get_user_name$address() {
        return g_get_user_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_user_name()
     * }
     */
    public static MemorySegment g_get_user_name() {
        var mh$ = g_get_user_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_user_name");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_real_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_real_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_real_name()
     * }
     */
    public static FunctionDescriptor g_get_real_name$descriptor() {
        return g_get_real_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_real_name()
     * }
     */
    public static MethodHandle g_get_real_name$handle() {
        return g_get_real_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_real_name()
     * }
     */
    public static MemorySegment g_get_real_name$address() {
        return g_get_real_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_real_name()
     * }
     */
    public static MemorySegment g_get_real_name() {
        var mh$ = g_get_real_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_real_name");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_home_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_home_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_home_dir()
     * }
     */
    public static FunctionDescriptor g_get_home_dir$descriptor() {
        return g_get_home_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_home_dir()
     * }
     */
    public static MethodHandle g_get_home_dir$handle() {
        return g_get_home_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_home_dir()
     * }
     */
    public static MemorySegment g_get_home_dir$address() {
        return g_get_home_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_home_dir()
     * }
     */
    public static MemorySegment g_get_home_dir() {
        var mh$ = g_get_home_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_home_dir");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_tmp_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_tmp_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_tmp_dir()
     * }
     */
    public static FunctionDescriptor g_get_tmp_dir$descriptor() {
        return g_get_tmp_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_tmp_dir()
     * }
     */
    public static MethodHandle g_get_tmp_dir$handle() {
        return g_get_tmp_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_tmp_dir()
     * }
     */
    public static MemorySegment g_get_tmp_dir$address() {
        return g_get_tmp_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_tmp_dir()
     * }
     */
    public static MemorySegment g_get_tmp_dir() {
        var mh$ = g_get_tmp_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_tmp_dir");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_host_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_host_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_host_name()
     * }
     */
    public static FunctionDescriptor g_get_host_name$descriptor() {
        return g_get_host_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_host_name()
     * }
     */
    public static MethodHandle g_get_host_name$handle() {
        return g_get_host_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_host_name()
     * }
     */
    public static MemorySegment g_get_host_name$address() {
        return g_get_host_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_host_name()
     * }
     */
    public static MemorySegment g_get_host_name() {
        var mh$ = g_get_host_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_host_name");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_prgname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_prgname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_prgname()
     * }
     */
    public static FunctionDescriptor g_get_prgname$descriptor() {
        return g_get_prgname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_prgname()
     * }
     */
    public static MethodHandle g_get_prgname$handle() {
        return g_get_prgname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_prgname()
     * }
     */
    public static MemorySegment g_get_prgname$address() {
        return g_get_prgname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_prgname()
     * }
     */
    public static MemorySegment g_get_prgname() {
        var mh$ = g_get_prgname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_prgname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_set_prgname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_set_prgname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_set_prgname(const gchar *prgname)
     * }
     */
    public static FunctionDescriptor g_set_prgname$descriptor() {
        return g_set_prgname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_set_prgname(const gchar *prgname)
     * }
     */
    public static MethodHandle g_set_prgname$handle() {
        return g_set_prgname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_set_prgname(const gchar *prgname)
     * }
     */
    public static MemorySegment g_set_prgname$address() {
        return g_set_prgname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_set_prgname(const gchar *prgname)
     * }
     */
    public static void g_set_prgname(MemorySegment prgname) {
        var mh$ = g_set_prgname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_set_prgname", prgname);
            }
            mh$.invokeExact(prgname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_application_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_application_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_application_name()
     * }
     */
    public static FunctionDescriptor g_get_application_name$descriptor() {
        return g_get_application_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_application_name()
     * }
     */
    public static MethodHandle g_get_application_name$handle() {
        return g_get_application_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_application_name()
     * }
     */
    public static MemorySegment g_get_application_name$address() {
        return g_get_application_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_application_name()
     * }
     */
    public static MemorySegment g_get_application_name() {
        var mh$ = g_get_application_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_application_name");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_set_application_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_set_application_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_set_application_name(const gchar *application_name)
     * }
     */
    public static FunctionDescriptor g_set_application_name$descriptor() {
        return g_set_application_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_set_application_name(const gchar *application_name)
     * }
     */
    public static MethodHandle g_set_application_name$handle() {
        return g_set_application_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_set_application_name(const gchar *application_name)
     * }
     */
    public static MemorySegment g_set_application_name$address() {
        return g_set_application_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_set_application_name(const gchar *application_name)
     * }
     */
    public static void g_set_application_name(MemorySegment application_name) {
        var mh$ = g_set_application_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_set_application_name", application_name);
            }
            mh$.invokeExact(application_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_os_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_os_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_get_os_info(const gchar *key_name)
     * }
     */
    public static FunctionDescriptor g_get_os_info$descriptor() {
        return g_get_os_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_get_os_info(const gchar *key_name)
     * }
     */
    public static MethodHandle g_get_os_info$handle() {
        return g_get_os_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_get_os_info(const gchar *key_name)
     * }
     */
    public static MemorySegment g_get_os_info$address() {
        return g_get_os_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_get_os_info(const gchar *key_name)
     * }
     */
    public static MemorySegment g_get_os_info(MemorySegment key_name) {
        var mh$ = g_get_os_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_os_info", key_name);
            }
            return (MemorySegment)mh$.invokeExact(key_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_reload_user_special_dirs_cache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_reload_user_special_dirs_cache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_reload_user_special_dirs_cache()
     * }
     */
    public static FunctionDescriptor g_reload_user_special_dirs_cache$descriptor() {
        return g_reload_user_special_dirs_cache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_reload_user_special_dirs_cache()
     * }
     */
    public static MethodHandle g_reload_user_special_dirs_cache$handle() {
        return g_reload_user_special_dirs_cache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_reload_user_special_dirs_cache()
     * }
     */
    public static MemorySegment g_reload_user_special_dirs_cache$address() {
        return g_reload_user_special_dirs_cache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_reload_user_special_dirs_cache()
     * }
     */
    public static void g_reload_user_special_dirs_cache() {
        var mh$ = g_reload_user_special_dirs_cache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_reload_user_special_dirs_cache");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_user_data_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_user_data_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_data_dir()
     * }
     */
    public static FunctionDescriptor g_get_user_data_dir$descriptor() {
        return g_get_user_data_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_data_dir()
     * }
     */
    public static MethodHandle g_get_user_data_dir$handle() {
        return g_get_user_data_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_data_dir()
     * }
     */
    public static MemorySegment g_get_user_data_dir$address() {
        return g_get_user_data_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_user_data_dir()
     * }
     */
    public static MemorySegment g_get_user_data_dir() {
        var mh$ = g_get_user_data_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_user_data_dir");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_user_config_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_user_config_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_config_dir()
     * }
     */
    public static FunctionDescriptor g_get_user_config_dir$descriptor() {
        return g_get_user_config_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_config_dir()
     * }
     */
    public static MethodHandle g_get_user_config_dir$handle() {
        return g_get_user_config_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_config_dir()
     * }
     */
    public static MemorySegment g_get_user_config_dir$address() {
        return g_get_user_config_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_user_config_dir()
     * }
     */
    public static MemorySegment g_get_user_config_dir() {
        var mh$ = g_get_user_config_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_user_config_dir");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_user_cache_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_user_cache_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_cache_dir()
     * }
     */
    public static FunctionDescriptor g_get_user_cache_dir$descriptor() {
        return g_get_user_cache_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_cache_dir()
     * }
     */
    public static MethodHandle g_get_user_cache_dir$handle() {
        return g_get_user_cache_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_cache_dir()
     * }
     */
    public static MemorySegment g_get_user_cache_dir$address() {
        return g_get_user_cache_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_user_cache_dir()
     * }
     */
    public static MemorySegment g_get_user_cache_dir() {
        var mh$ = g_get_user_cache_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_user_cache_dir");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_user_state_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_user_state_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_state_dir()
     * }
     */
    public static FunctionDescriptor g_get_user_state_dir$descriptor() {
        return g_get_user_state_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_state_dir()
     * }
     */
    public static MethodHandle g_get_user_state_dir$handle() {
        return g_get_user_state_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_state_dir()
     * }
     */
    public static MemorySegment g_get_user_state_dir$address() {
        return g_get_user_state_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_user_state_dir()
     * }
     */
    public static MemorySegment g_get_user_state_dir() {
        var mh$ = g_get_user_state_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_user_state_dir");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_system_data_dirs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_system_data_dirs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_system_data_dirs()
     * }
     */
    public static FunctionDescriptor g_get_system_data_dirs$descriptor() {
        return g_get_system_data_dirs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_system_data_dirs()
     * }
     */
    public static MethodHandle g_get_system_data_dirs$handle() {
        return g_get_system_data_dirs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_system_data_dirs()
     * }
     */
    public static MemorySegment g_get_system_data_dirs$address() {
        return g_get_system_data_dirs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *const *g_get_system_data_dirs()
     * }
     */
    public static MemorySegment g_get_system_data_dirs() {
        var mh$ = g_get_system_data_dirs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_system_data_dirs");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_get_system_data_dirs_for_module {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_get_system_data_dirs_for_module");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *const *g_win32_get_system_data_dirs_for_module(void (*address_of_function)(void))
     * }
     */
    public static FunctionDescriptor g_win32_get_system_data_dirs_for_module$descriptor() {
        return g_win32_get_system_data_dirs_for_module.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *const *g_win32_get_system_data_dirs_for_module(void (*address_of_function)(void))
     * }
     */
    public static MethodHandle g_win32_get_system_data_dirs_for_module$handle() {
        return g_win32_get_system_data_dirs_for_module.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *const *g_win32_get_system_data_dirs_for_module(void (*address_of_function)(void))
     * }
     */
    public static MemorySegment g_win32_get_system_data_dirs_for_module$address() {
        return g_win32_get_system_data_dirs_for_module.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *const *g_win32_get_system_data_dirs_for_module(void (*address_of_function)(void))
     * }
     */
    public static MemorySegment g_win32_get_system_data_dirs_for_module(MemorySegment address_of_function) {
        var mh$ = g_win32_get_system_data_dirs_for_module.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_get_system_data_dirs_for_module", address_of_function);
            }
            return (MemorySegment)mh$.invokeExact(address_of_function);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_system_config_dirs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_system_config_dirs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_system_config_dirs()
     * }
     */
    public static FunctionDescriptor g_get_system_config_dirs$descriptor() {
        return g_get_system_config_dirs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_system_config_dirs()
     * }
     */
    public static MethodHandle g_get_system_config_dirs$handle() {
        return g_get_system_config_dirs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_system_config_dirs()
     * }
     */
    public static MemorySegment g_get_system_config_dirs$address() {
        return g_get_system_config_dirs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *const *g_get_system_config_dirs()
     * }
     */
    public static MemorySegment g_get_system_config_dirs() {
        var mh$ = g_get_system_config_dirs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_system_config_dirs");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_user_runtime_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_user_runtime_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_runtime_dir()
     * }
     */
    public static FunctionDescriptor g_get_user_runtime_dir$descriptor() {
        return g_get_user_runtime_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_runtime_dir()
     * }
     */
    public static MethodHandle g_get_user_runtime_dir$handle() {
        return g_get_user_runtime_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_runtime_dir()
     * }
     */
    public static MemorySegment g_get_user_runtime_dir$address() {
        return g_get_user_runtime_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_user_runtime_dir()
     * }
     */
    public static MemorySegment g_get_user_runtime_dir() {
        var mh$ = g_get_user_runtime_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_user_runtime_dir");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_USER_DIRECTORY_DESKTOP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_DIRECTORY_DESKTOP = 0
     * }
     */
    public static int G_USER_DIRECTORY_DESKTOP() {
        return G_USER_DIRECTORY_DESKTOP;
    }
    private static final int G_USER_DIRECTORY_DOCUMENTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_DIRECTORY_DOCUMENTS = 1
     * }
     */
    public static int G_USER_DIRECTORY_DOCUMENTS() {
        return G_USER_DIRECTORY_DOCUMENTS;
    }
    private static final int G_USER_DIRECTORY_DOWNLOAD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_DIRECTORY_DOWNLOAD = 2
     * }
     */
    public static int G_USER_DIRECTORY_DOWNLOAD() {
        return G_USER_DIRECTORY_DOWNLOAD;
    }
    private static final int G_USER_DIRECTORY_MUSIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_DIRECTORY_MUSIC = 3
     * }
     */
    public static int G_USER_DIRECTORY_MUSIC() {
        return G_USER_DIRECTORY_MUSIC;
    }
    private static final int G_USER_DIRECTORY_PICTURES = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_DIRECTORY_PICTURES = 4
     * }
     */
    public static int G_USER_DIRECTORY_PICTURES() {
        return G_USER_DIRECTORY_PICTURES;
    }
    private static final int G_USER_DIRECTORY_PUBLIC_SHARE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_DIRECTORY_PUBLIC_SHARE = 5
     * }
     */
    public static int G_USER_DIRECTORY_PUBLIC_SHARE() {
        return G_USER_DIRECTORY_PUBLIC_SHARE;
    }
    private static final int G_USER_DIRECTORY_TEMPLATES = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_DIRECTORY_TEMPLATES = 6
     * }
     */
    public static int G_USER_DIRECTORY_TEMPLATES() {
        return G_USER_DIRECTORY_TEMPLATES;
    }
    private static final int G_USER_DIRECTORY_VIDEOS = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_DIRECTORY_VIDEOS = 7
     * }
     */
    public static int G_USER_DIRECTORY_VIDEOS() {
        return G_USER_DIRECTORY_VIDEOS;
    }
    private static final int G_USER_N_DIRECTORIES = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_USER_N_DIRECTORIES = 8
     * }
     */
    public static int G_USER_N_DIRECTORIES() {
        return G_USER_N_DIRECTORIES;
    }

    private static class g_get_user_special_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_user_special_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_special_dir(GUserDirectory directory)
     * }
     */
    public static FunctionDescriptor g_get_user_special_dir$descriptor() {
        return g_get_user_special_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_special_dir(GUserDirectory directory)
     * }
     */
    public static MethodHandle g_get_user_special_dir$handle() {
        return g_get_user_special_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_get_user_special_dir(GUserDirectory directory)
     * }
     */
    public static MemorySegment g_get_user_special_dir$address() {
        return g_get_user_special_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_get_user_special_dir(GUserDirectory directory)
     * }
     */
    public static MemorySegment g_get_user_special_dir(int directory) {
        var mh$ = g_get_user_special_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_user_special_dir", directory);
            }
            return (MemorySegment)mh$.invokeExact(directory);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_parse_debug_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_parse_debug_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_parse_debug_string(const gchar *string, const GDebugKey *keys, guint nkeys)
     * }
     */
    public static FunctionDescriptor g_parse_debug_string$descriptor() {
        return g_parse_debug_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_parse_debug_string(const gchar *string, const GDebugKey *keys, guint nkeys)
     * }
     */
    public static MethodHandle g_parse_debug_string$handle() {
        return g_parse_debug_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_parse_debug_string(const gchar *string, const GDebugKey *keys, guint nkeys)
     * }
     */
    public static MemorySegment g_parse_debug_string$address() {
        return g_parse_debug_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_parse_debug_string(const gchar *string, const GDebugKey *keys, guint nkeys)
     * }
     */
    public static int g_parse_debug_string(MemorySegment string, MemorySegment keys, int nkeys) {
        var mh$ = g_parse_debug_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_parse_debug_string", string, keys, nkeys);
            }
            return (int)mh$.invokeExact(string, keys, nkeys);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gint g_snprintf(gchar *string, gulong n, const gchar *format, ...)
     * }
     */
    public static class g_snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_LONG,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gint g_snprintf(gchar *string, gulong n, const gchar *format, ...)
         * }
         */
        public static g_snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment string, int n, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_snprintf", string, n, format, x3);
                }
                return (int) spreader.invokeExact(string, n, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_vsnprintf(gchar *string, gulong n, const gchar *format, va_list args)
     * }
     */
    public static FunctionDescriptor g_vsnprintf$descriptor() {
        return g_vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_vsnprintf(gchar *string, gulong n, const gchar *format, va_list args)
     * }
     */
    public static MethodHandle g_vsnprintf$handle() {
        return g_vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_vsnprintf(gchar *string, gulong n, const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_vsnprintf$address() {
        return g_vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_vsnprintf(gchar *string, gulong n, const gchar *format, va_list args)
     * }
     */
    public static int g_vsnprintf(MemorySegment string, int n, MemorySegment format, MemorySegment args) {
        var mh$ = g_vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_vsnprintf", string, n, format, args);
            }
            return (int)mh$.invokeExact(string, n, format, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_nullify_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_nullify_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_nullify_pointer(gpointer *nullify_location)
     * }
     */
    public static FunctionDescriptor g_nullify_pointer$descriptor() {
        return g_nullify_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_nullify_pointer(gpointer *nullify_location)
     * }
     */
    public static MethodHandle g_nullify_pointer$handle() {
        return g_nullify_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_nullify_pointer(gpointer *nullify_location)
     * }
     */
    public static MemorySegment g_nullify_pointer$address() {
        return g_nullify_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_nullify_pointer(gpointer *nullify_location)
     * }
     */
    public static void g_nullify_pointer(MemorySegment nullify_location) {
        var mh$ = g_nullify_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_nullify_pointer", nullify_location);
            }
            mh$.invokeExact(nullify_location);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_FORMAT_SIZE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FORMAT_SIZE_DEFAULT = 0
     * }
     */
    public static int G_FORMAT_SIZE_DEFAULT() {
        return G_FORMAT_SIZE_DEFAULT;
    }
    private static final int G_FORMAT_SIZE_LONG_FORMAT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FORMAT_SIZE_LONG_FORMAT = 1
     * }
     */
    public static int G_FORMAT_SIZE_LONG_FORMAT() {
        return G_FORMAT_SIZE_LONG_FORMAT;
    }
    private static final int G_FORMAT_SIZE_IEC_UNITS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FORMAT_SIZE_IEC_UNITS = 2
     * }
     */
    public static int G_FORMAT_SIZE_IEC_UNITS() {
        return G_FORMAT_SIZE_IEC_UNITS;
    }
    private static final int G_FORMAT_SIZE_BITS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FORMAT_SIZE_BITS = 4
     * }
     */
    public static int G_FORMAT_SIZE_BITS() {
        return G_FORMAT_SIZE_BITS;
    }
    private static final int G_FORMAT_SIZE_ONLY_VALUE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FORMAT_SIZE_ONLY_VALUE = 8
     * }
     */
    public static int G_FORMAT_SIZE_ONLY_VALUE() {
        return G_FORMAT_SIZE_ONLY_VALUE;
    }
    private static final int G_FORMAT_SIZE_ONLY_UNIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FORMAT_SIZE_ONLY_UNIT = 16
     * }
     */
    public static int G_FORMAT_SIZE_ONLY_UNIT() {
        return G_FORMAT_SIZE_ONLY_UNIT;
    }

    private static class g_format_size_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_format_size_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_format_size_full(guint64 size, GFormatSizeFlags flags)
     * }
     */
    public static FunctionDescriptor g_format_size_full$descriptor() {
        return g_format_size_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_format_size_full(guint64 size, GFormatSizeFlags flags)
     * }
     */
    public static MethodHandle g_format_size_full$handle() {
        return g_format_size_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_format_size_full(guint64 size, GFormatSizeFlags flags)
     * }
     */
    public static MemorySegment g_format_size_full$address() {
        return g_format_size_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_format_size_full(guint64 size, GFormatSizeFlags flags)
     * }
     */
    public static MemorySegment g_format_size_full(long size, int flags) {
        var mh$ = g_format_size_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_format_size_full", size, flags);
            }
            return (MemorySegment)mh$.invokeExact(size, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_format_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_format_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_format_size(guint64 size)
     * }
     */
    public static FunctionDescriptor g_format_size$descriptor() {
        return g_format_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_format_size(guint64 size)
     * }
     */
    public static MethodHandle g_format_size$handle() {
        return g_format_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_format_size(guint64 size)
     * }
     */
    public static MemorySegment g_format_size$address() {
        return g_format_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_format_size(guint64 size)
     * }
     */
    public static MemorySegment g_format_size(long size) {
        var mh$ = g_format_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_format_size", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_format_size_for_display {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_format_size_for_display");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_format_size_for_display(goffset size)
     * }
     */
    public static FunctionDescriptor g_format_size_for_display$descriptor() {
        return g_format_size_for_display.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_format_size_for_display(goffset size)
     * }
     */
    public static MethodHandle g_format_size_for_display$handle() {
        return g_format_size_for_display.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_format_size_for_display(goffset size)
     * }
     */
    public static MemorySegment g_format_size_for_display$address() {
        return g_format_size_for_display.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_format_size_for_display(goffset size)
     * }
     */
    public static MemorySegment g_format_size_for_display(long size) {
        var mh$ = g_format_size_for_display.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_format_size_for_display", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_atexit(GVoidFunc func)
     * }
     */
    public static FunctionDescriptor g_atexit$descriptor() {
        return g_atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_atexit(GVoidFunc func)
     * }
     */
    public static MethodHandle g_atexit$handle() {
        return g_atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_atexit(GVoidFunc func)
     * }
     */
    public static MemorySegment g_atexit$address() {
        return g_atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_atexit(GVoidFunc func)
     * }
     */
    public static void g_atexit(MemorySegment func) {
        var mh$ = g_atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atexit", func);
            }
            mh$.invokeExact(func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (*)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (*)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (*)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (*)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_find_program_in_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_find_program_in_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_find_program_in_path(const gchar *program)
     * }
     */
    public static FunctionDescriptor g_find_program_in_path$descriptor() {
        return g_find_program_in_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_find_program_in_path(const gchar *program)
     * }
     */
    public static MethodHandle g_find_program_in_path$handle() {
        return g_find_program_in_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_find_program_in_path(const gchar *program)
     * }
     */
    public static MemorySegment g_find_program_in_path$address() {
        return g_find_program_in_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_find_program_in_path(const gchar *program)
     * }
     */
    public static MemorySegment g_find_program_in_path(MemorySegment program) {
        var mh$ = g_find_program_in_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_find_program_in_path", program);
            }
            return (MemorySegment)mh$.invokeExact(program);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bit_nth_lsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bit_nth_lsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint (g_bit_nth_lsf)(gulong mask, gint nth_bit)
     * }
     */
    public static FunctionDescriptor g_bit_nth_lsf$descriptor() {
        return g_bit_nth_lsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint (g_bit_nth_lsf)(gulong mask, gint nth_bit)
     * }
     */
    public static MethodHandle g_bit_nth_lsf$handle() {
        return g_bit_nth_lsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint (g_bit_nth_lsf)(gulong mask, gint nth_bit)
     * }
     */
    public static MemorySegment g_bit_nth_lsf$address() {
        return g_bit_nth_lsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint (g_bit_nth_lsf)(gulong mask, gint nth_bit)
     * }
     */
    public static int g_bit_nth_lsf(int mask, int nth_bit) {
        var mh$ = g_bit_nth_lsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bit_nth_lsf", mask, nth_bit);
            }
            return (int)mh$.invokeExact(mask, nth_bit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bit_nth_msf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bit_nth_msf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint (g_bit_nth_msf)(gulong mask, gint nth_bit)
     * }
     */
    public static FunctionDescriptor g_bit_nth_msf$descriptor() {
        return g_bit_nth_msf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint (g_bit_nth_msf)(gulong mask, gint nth_bit)
     * }
     */
    public static MethodHandle g_bit_nth_msf$handle() {
        return g_bit_nth_msf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint (g_bit_nth_msf)(gulong mask, gint nth_bit)
     * }
     */
    public static MemorySegment g_bit_nth_msf$address() {
        return g_bit_nth_msf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint (g_bit_nth_msf)(gulong mask, gint nth_bit)
     * }
     */
    public static int g_bit_nth_msf(int mask, int nth_bit) {
        var mh$ = g_bit_nth_msf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bit_nth_msf", mask, nth_bit);
            }
            return (int)mh$.invokeExact(mask, nth_bit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bit_storage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bit_storage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint (g_bit_storage)(gulong number)
     * }
     */
    public static FunctionDescriptor g_bit_storage$descriptor() {
        return g_bit_storage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint (g_bit_storage)(gulong number)
     * }
     */
    public static MethodHandle g_bit_storage$handle() {
        return g_bit_storage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint (g_bit_storage)(gulong number)
     * }
     */
    public static MemorySegment g_bit_storage$address() {
        return g_bit_storage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint (g_bit_storage)(gulong number)
     * }
     */
    public static int g_bit_storage(int number) {
        var mh$ = g_bit_storage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bit_storage", number);
            }
            return (int)mh$.invokeExact(number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_abort()
     * }
     */
    public static FunctionDescriptor g_abort$descriptor() {
        return g_abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_abort()
     * }
     */
    public static MethodHandle g_abort$handle() {
        return g_abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_abort()
     * }
     */
    public static MemorySegment g_abort$address() {
        return g_abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_abort()
     * }
     */
    public static void g_abort() {
        var mh$ = g_abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_abort");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_thread_error_quark()
     * }
     */
    public static FunctionDescriptor g_thread_error_quark$descriptor() {
        return g_thread_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_thread_error_quark()
     * }
     */
    public static MethodHandle g_thread_error_quark$handle() {
        return g_thread_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_thread_error_quark()
     * }
     */
    public static MemorySegment g_thread_error_quark$address() {
        return g_thread_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_thread_error_quark()
     * }
     */
    public static int g_thread_error_quark() {
        var mh$ = g_thread_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_THREAD_ERROR_AGAIN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_THREAD_ERROR_AGAIN = 0
     * }
     */
    public static int G_THREAD_ERROR_AGAIN() {
        return G_THREAD_ERROR_AGAIN;
    }
    private static final int G_ONCE_STATUS_NOTCALLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ONCE_STATUS_NOTCALLED = 0
     * }
     */
    public static int G_ONCE_STATUS_NOTCALLED() {
        return G_ONCE_STATUS_NOTCALLED;
    }
    private static final int G_ONCE_STATUS_PROGRESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ONCE_STATUS_PROGRESS = 1
     * }
     */
    public static int G_ONCE_STATUS_PROGRESS() {
        return G_ONCE_STATUS_PROGRESS;
    }
    private static final int G_ONCE_STATUS_READY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ONCE_STATUS_READY = 2
     * }
     */
    public static int G_ONCE_STATUS_READY() {
        return G_ONCE_STATUS_READY;
    }

    private static class g_thread_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GThread *g_thread_ref(GThread *thread)
     * }
     */
    public static FunctionDescriptor g_thread_ref$descriptor() {
        return g_thread_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GThread *g_thread_ref(GThread *thread)
     * }
     */
    public static MethodHandle g_thread_ref$handle() {
        return g_thread_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GThread *g_thread_ref(GThread *thread)
     * }
     */
    public static MemorySegment g_thread_ref$address() {
        return g_thread_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GThread *g_thread_ref(GThread *thread)
     * }
     */
    public static MemorySegment g_thread_ref(MemorySegment thread) {
        var mh$ = g_thread_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_ref", thread);
            }
            return (MemorySegment)mh$.invokeExact(thread);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_unref(GThread *thread)
     * }
     */
    public static FunctionDescriptor g_thread_unref$descriptor() {
        return g_thread_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_unref(GThread *thread)
     * }
     */
    public static MethodHandle g_thread_unref$handle() {
        return g_thread_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_unref(GThread *thread)
     * }
     */
    public static MemorySegment g_thread_unref$address() {
        return g_thread_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_unref(GThread *thread)
     * }
     */
    public static void g_thread_unref(MemorySegment thread) {
        var mh$ = g_thread_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_unref", thread);
            }
            mh$.invokeExact(thread);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GThread *g_thread_new(const gchar *name, GThreadFunc func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_thread_new$descriptor() {
        return g_thread_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GThread *g_thread_new(const gchar *name, GThreadFunc func, gpointer data)
     * }
     */
    public static MethodHandle g_thread_new$handle() {
        return g_thread_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GThread *g_thread_new(const gchar *name, GThreadFunc func, gpointer data)
     * }
     */
    public static MemorySegment g_thread_new$address() {
        return g_thread_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GThread *g_thread_new(const gchar *name, GThreadFunc func, gpointer data)
     * }
     */
    public static MemorySegment g_thread_new(MemorySegment name, MemorySegment func, MemorySegment data) {
        var mh$ = g_thread_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_new", name, func, data);
            }
            return (MemorySegment)mh$.invokeExact(name, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_try_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_try_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GThread *g_thread_try_new(const gchar *name, GThreadFunc func, gpointer data, GError **error)
     * }
     */
    public static FunctionDescriptor g_thread_try_new$descriptor() {
        return g_thread_try_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GThread *g_thread_try_new(const gchar *name, GThreadFunc func, gpointer data, GError **error)
     * }
     */
    public static MethodHandle g_thread_try_new$handle() {
        return g_thread_try_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GThread *g_thread_try_new(const gchar *name, GThreadFunc func, gpointer data, GError **error)
     * }
     */
    public static MemorySegment g_thread_try_new$address() {
        return g_thread_try_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GThread *g_thread_try_new(const gchar *name, GThreadFunc func, gpointer data, GError **error)
     * }
     */
    public static MemorySegment g_thread_try_new(MemorySegment name, MemorySegment func, MemorySegment data, MemorySegment error) {
        var mh$ = g_thread_try_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_try_new", name, func, data, error);
            }
            return (MemorySegment)mh$.invokeExact(name, func, data, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GThread *g_thread_self()
     * }
     */
    public static FunctionDescriptor g_thread_self$descriptor() {
        return g_thread_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GThread *g_thread_self()
     * }
     */
    public static MethodHandle g_thread_self$handle() {
        return g_thread_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GThread *g_thread_self()
     * }
     */
    public static MemorySegment g_thread_self$address() {
        return g_thread_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GThread *g_thread_self()
     * }
     */
    public static MemorySegment g_thread_self() {
        var mh$ = g_thread_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_self");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_exit(gpointer retval)
     * }
     */
    public static FunctionDescriptor g_thread_exit$descriptor() {
        return g_thread_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_exit(gpointer retval)
     * }
     */
    public static MethodHandle g_thread_exit$handle() {
        return g_thread_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_exit(gpointer retval)
     * }
     */
    public static MemorySegment g_thread_exit$address() {
        return g_thread_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_exit(gpointer retval)
     * }
     */
    public static void g_thread_exit(MemorySegment retval) {
        var mh$ = g_thread_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_exit", retval);
            }
            mh$.invokeExact(retval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_thread_join(GThread *thread)
     * }
     */
    public static FunctionDescriptor g_thread_join$descriptor() {
        return g_thread_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_thread_join(GThread *thread)
     * }
     */
    public static MethodHandle g_thread_join$handle() {
        return g_thread_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_thread_join(GThread *thread)
     * }
     */
    public static MemorySegment g_thread_join$address() {
        return g_thread_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_thread_join(GThread *thread)
     * }
     */
    public static MemorySegment g_thread_join(MemorySegment thread) {
        var mh$ = g_thread_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_join", thread);
            }
            return (MemorySegment)mh$.invokeExact(thread);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_yield()
     * }
     */
    public static FunctionDescriptor g_thread_yield$descriptor() {
        return g_thread_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_yield()
     * }
     */
    public static MethodHandle g_thread_yield$handle() {
        return g_thread_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_yield()
     * }
     */
    public static MemorySegment g_thread_yield$address() {
        return g_thread_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_yield()
     * }
     */
    public static void g_thread_yield() {
        var mh$ = g_thread_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_yield");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mutex_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mutex_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mutex_init(GMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_mutex_init$descriptor() {
        return g_mutex_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mutex_init(GMutex *mutex)
     * }
     */
    public static MethodHandle g_mutex_init$handle() {
        return g_mutex_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mutex_init(GMutex *mutex)
     * }
     */
    public static MemorySegment g_mutex_init$address() {
        return g_mutex_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mutex_init(GMutex *mutex)
     * }
     */
    public static void g_mutex_init(MemorySegment mutex) {
        var mh$ = g_mutex_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mutex_init", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mutex_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mutex_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mutex_clear(GMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_mutex_clear$descriptor() {
        return g_mutex_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mutex_clear(GMutex *mutex)
     * }
     */
    public static MethodHandle g_mutex_clear$handle() {
        return g_mutex_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mutex_clear(GMutex *mutex)
     * }
     */
    public static MemorySegment g_mutex_clear$address() {
        return g_mutex_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mutex_clear(GMutex *mutex)
     * }
     */
    public static void g_mutex_clear(MemorySegment mutex) {
        var mh$ = g_mutex_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mutex_clear", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mutex_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mutex_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mutex_lock(GMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_mutex_lock$descriptor() {
        return g_mutex_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mutex_lock(GMutex *mutex)
     * }
     */
    public static MethodHandle g_mutex_lock$handle() {
        return g_mutex_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mutex_lock(GMutex *mutex)
     * }
     */
    public static MemorySegment g_mutex_lock$address() {
        return g_mutex_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mutex_lock(GMutex *mutex)
     * }
     */
    public static void g_mutex_lock(MemorySegment mutex) {
        var mh$ = g_mutex_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mutex_lock", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mutex_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mutex_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_mutex_trylock(GMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_mutex_trylock$descriptor() {
        return g_mutex_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_mutex_trylock(GMutex *mutex)
     * }
     */
    public static MethodHandle g_mutex_trylock$handle() {
        return g_mutex_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_mutex_trylock(GMutex *mutex)
     * }
     */
    public static MemorySegment g_mutex_trylock$address() {
        return g_mutex_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_mutex_trylock(GMutex *mutex)
     * }
     */
    public static int g_mutex_trylock(MemorySegment mutex) {
        var mh$ = g_mutex_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mutex_trylock", mutex);
            }
            return (int)mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mutex_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mutex_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mutex_unlock(GMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_mutex_unlock$descriptor() {
        return g_mutex_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mutex_unlock(GMutex *mutex)
     * }
     */
    public static MethodHandle g_mutex_unlock$handle() {
        return g_mutex_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mutex_unlock(GMutex *mutex)
     * }
     */
    public static MemorySegment g_mutex_unlock$address() {
        return g_mutex_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mutex_unlock(GMutex *mutex)
     * }
     */
    public static void g_mutex_unlock(MemorySegment mutex) {
        var mh$ = g_mutex_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mutex_unlock", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rw_lock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rw_lock_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rw_lock_init(GRWLock *rw_lock)
     * }
     */
    public static FunctionDescriptor g_rw_lock_init$descriptor() {
        return g_rw_lock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rw_lock_init(GRWLock *rw_lock)
     * }
     */
    public static MethodHandle g_rw_lock_init$handle() {
        return g_rw_lock_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rw_lock_init(GRWLock *rw_lock)
     * }
     */
    public static MemorySegment g_rw_lock_init$address() {
        return g_rw_lock_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rw_lock_init(GRWLock *rw_lock)
     * }
     */
    public static void g_rw_lock_init(MemorySegment rw_lock) {
        var mh$ = g_rw_lock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rw_lock_init", rw_lock);
            }
            mh$.invokeExact(rw_lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rw_lock_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rw_lock_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rw_lock_clear(GRWLock *rw_lock)
     * }
     */
    public static FunctionDescriptor g_rw_lock_clear$descriptor() {
        return g_rw_lock_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rw_lock_clear(GRWLock *rw_lock)
     * }
     */
    public static MethodHandle g_rw_lock_clear$handle() {
        return g_rw_lock_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rw_lock_clear(GRWLock *rw_lock)
     * }
     */
    public static MemorySegment g_rw_lock_clear$address() {
        return g_rw_lock_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rw_lock_clear(GRWLock *rw_lock)
     * }
     */
    public static void g_rw_lock_clear(MemorySegment rw_lock) {
        var mh$ = g_rw_lock_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rw_lock_clear", rw_lock);
            }
            mh$.invokeExact(rw_lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rw_lock_writer_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rw_lock_writer_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rw_lock_writer_lock(GRWLock *rw_lock)
     * }
     */
    public static FunctionDescriptor g_rw_lock_writer_lock$descriptor() {
        return g_rw_lock_writer_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rw_lock_writer_lock(GRWLock *rw_lock)
     * }
     */
    public static MethodHandle g_rw_lock_writer_lock$handle() {
        return g_rw_lock_writer_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rw_lock_writer_lock(GRWLock *rw_lock)
     * }
     */
    public static MemorySegment g_rw_lock_writer_lock$address() {
        return g_rw_lock_writer_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rw_lock_writer_lock(GRWLock *rw_lock)
     * }
     */
    public static void g_rw_lock_writer_lock(MemorySegment rw_lock) {
        var mh$ = g_rw_lock_writer_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rw_lock_writer_lock", rw_lock);
            }
            mh$.invokeExact(rw_lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rw_lock_writer_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rw_lock_writer_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock)
     * }
     */
    public static FunctionDescriptor g_rw_lock_writer_trylock$descriptor() {
        return g_rw_lock_writer_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock)
     * }
     */
    public static MethodHandle g_rw_lock_writer_trylock$handle() {
        return g_rw_lock_writer_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock)
     * }
     */
    public static MemorySegment g_rw_lock_writer_trylock$address() {
        return g_rw_lock_writer_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock)
     * }
     */
    public static int g_rw_lock_writer_trylock(MemorySegment rw_lock) {
        var mh$ = g_rw_lock_writer_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rw_lock_writer_trylock", rw_lock);
            }
            return (int)mh$.invokeExact(rw_lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rw_lock_writer_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rw_lock_writer_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rw_lock_writer_unlock(GRWLock *rw_lock)
     * }
     */
    public static FunctionDescriptor g_rw_lock_writer_unlock$descriptor() {
        return g_rw_lock_writer_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rw_lock_writer_unlock(GRWLock *rw_lock)
     * }
     */
    public static MethodHandle g_rw_lock_writer_unlock$handle() {
        return g_rw_lock_writer_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rw_lock_writer_unlock(GRWLock *rw_lock)
     * }
     */
    public static MemorySegment g_rw_lock_writer_unlock$address() {
        return g_rw_lock_writer_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rw_lock_writer_unlock(GRWLock *rw_lock)
     * }
     */
    public static void g_rw_lock_writer_unlock(MemorySegment rw_lock) {
        var mh$ = g_rw_lock_writer_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rw_lock_writer_unlock", rw_lock);
            }
            mh$.invokeExact(rw_lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rw_lock_reader_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rw_lock_reader_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rw_lock_reader_lock(GRWLock *rw_lock)
     * }
     */
    public static FunctionDescriptor g_rw_lock_reader_lock$descriptor() {
        return g_rw_lock_reader_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rw_lock_reader_lock(GRWLock *rw_lock)
     * }
     */
    public static MethodHandle g_rw_lock_reader_lock$handle() {
        return g_rw_lock_reader_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rw_lock_reader_lock(GRWLock *rw_lock)
     * }
     */
    public static MemorySegment g_rw_lock_reader_lock$address() {
        return g_rw_lock_reader_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rw_lock_reader_lock(GRWLock *rw_lock)
     * }
     */
    public static void g_rw_lock_reader_lock(MemorySegment rw_lock) {
        var mh$ = g_rw_lock_reader_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rw_lock_reader_lock", rw_lock);
            }
            mh$.invokeExact(rw_lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rw_lock_reader_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rw_lock_reader_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock)
     * }
     */
    public static FunctionDescriptor g_rw_lock_reader_trylock$descriptor() {
        return g_rw_lock_reader_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock)
     * }
     */
    public static MethodHandle g_rw_lock_reader_trylock$handle() {
        return g_rw_lock_reader_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock)
     * }
     */
    public static MemorySegment g_rw_lock_reader_trylock$address() {
        return g_rw_lock_reader_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock)
     * }
     */
    public static int g_rw_lock_reader_trylock(MemorySegment rw_lock) {
        var mh$ = g_rw_lock_reader_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rw_lock_reader_trylock", rw_lock);
            }
            return (int)mh$.invokeExact(rw_lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rw_lock_reader_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rw_lock_reader_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rw_lock_reader_unlock(GRWLock *rw_lock)
     * }
     */
    public static FunctionDescriptor g_rw_lock_reader_unlock$descriptor() {
        return g_rw_lock_reader_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rw_lock_reader_unlock(GRWLock *rw_lock)
     * }
     */
    public static MethodHandle g_rw_lock_reader_unlock$handle() {
        return g_rw_lock_reader_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rw_lock_reader_unlock(GRWLock *rw_lock)
     * }
     */
    public static MemorySegment g_rw_lock_reader_unlock$address() {
        return g_rw_lock_reader_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rw_lock_reader_unlock(GRWLock *rw_lock)
     * }
     */
    public static void g_rw_lock_reader_unlock(MemorySegment rw_lock) {
        var mh$ = g_rw_lock_reader_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rw_lock_reader_unlock", rw_lock);
            }
            mh$.invokeExact(rw_lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rec_mutex_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rec_mutex_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_init(GRecMutex *rec_mutex)
     * }
     */
    public static FunctionDescriptor g_rec_mutex_init$descriptor() {
        return g_rec_mutex_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_init(GRecMutex *rec_mutex)
     * }
     */
    public static MethodHandle g_rec_mutex_init$handle() {
        return g_rec_mutex_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_init(GRecMutex *rec_mutex)
     * }
     */
    public static MemorySegment g_rec_mutex_init$address() {
        return g_rec_mutex_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rec_mutex_init(GRecMutex *rec_mutex)
     * }
     */
    public static void g_rec_mutex_init(MemorySegment rec_mutex) {
        var mh$ = g_rec_mutex_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rec_mutex_init", rec_mutex);
            }
            mh$.invokeExact(rec_mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rec_mutex_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rec_mutex_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_clear(GRecMutex *rec_mutex)
     * }
     */
    public static FunctionDescriptor g_rec_mutex_clear$descriptor() {
        return g_rec_mutex_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_clear(GRecMutex *rec_mutex)
     * }
     */
    public static MethodHandle g_rec_mutex_clear$handle() {
        return g_rec_mutex_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_clear(GRecMutex *rec_mutex)
     * }
     */
    public static MemorySegment g_rec_mutex_clear$address() {
        return g_rec_mutex_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rec_mutex_clear(GRecMutex *rec_mutex)
     * }
     */
    public static void g_rec_mutex_clear(MemorySegment rec_mutex) {
        var mh$ = g_rec_mutex_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rec_mutex_clear", rec_mutex);
            }
            mh$.invokeExact(rec_mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rec_mutex_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rec_mutex_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_lock(GRecMutex *rec_mutex)
     * }
     */
    public static FunctionDescriptor g_rec_mutex_lock$descriptor() {
        return g_rec_mutex_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_lock(GRecMutex *rec_mutex)
     * }
     */
    public static MethodHandle g_rec_mutex_lock$handle() {
        return g_rec_mutex_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_lock(GRecMutex *rec_mutex)
     * }
     */
    public static MemorySegment g_rec_mutex_lock$address() {
        return g_rec_mutex_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rec_mutex_lock(GRecMutex *rec_mutex)
     * }
     */
    public static void g_rec_mutex_lock(MemorySegment rec_mutex) {
        var mh$ = g_rec_mutex_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rec_mutex_lock", rec_mutex);
            }
            mh$.invokeExact(rec_mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rec_mutex_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rec_mutex_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex)
     * }
     */
    public static FunctionDescriptor g_rec_mutex_trylock$descriptor() {
        return g_rec_mutex_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex)
     * }
     */
    public static MethodHandle g_rec_mutex_trylock$handle() {
        return g_rec_mutex_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex)
     * }
     */
    public static MemorySegment g_rec_mutex_trylock$address() {
        return g_rec_mutex_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex)
     * }
     */
    public static int g_rec_mutex_trylock(MemorySegment rec_mutex) {
        var mh$ = g_rec_mutex_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rec_mutex_trylock", rec_mutex);
            }
            return (int)mh$.invokeExact(rec_mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rec_mutex_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rec_mutex_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_unlock(GRecMutex *rec_mutex)
     * }
     */
    public static FunctionDescriptor g_rec_mutex_unlock$descriptor() {
        return g_rec_mutex_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_unlock(GRecMutex *rec_mutex)
     * }
     */
    public static MethodHandle g_rec_mutex_unlock$handle() {
        return g_rec_mutex_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rec_mutex_unlock(GRecMutex *rec_mutex)
     * }
     */
    public static MemorySegment g_rec_mutex_unlock$address() {
        return g_rec_mutex_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rec_mutex_unlock(GRecMutex *rec_mutex)
     * }
     */
    public static void g_rec_mutex_unlock(MemorySegment rec_mutex) {
        var mh$ = g_rec_mutex_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rec_mutex_unlock", rec_mutex);
            }
            mh$.invokeExact(rec_mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cond_init(GCond *cond)
     * }
     */
    public static FunctionDescriptor g_cond_init$descriptor() {
        return g_cond_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cond_init(GCond *cond)
     * }
     */
    public static MethodHandle g_cond_init$handle() {
        return g_cond_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cond_init(GCond *cond)
     * }
     */
    public static MemorySegment g_cond_init$address() {
        return g_cond_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cond_init(GCond *cond)
     * }
     */
    public static void g_cond_init(MemorySegment cond) {
        var mh$ = g_cond_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_init", cond);
            }
            mh$.invokeExact(cond);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cond_clear(GCond *cond)
     * }
     */
    public static FunctionDescriptor g_cond_clear$descriptor() {
        return g_cond_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cond_clear(GCond *cond)
     * }
     */
    public static MethodHandle g_cond_clear$handle() {
        return g_cond_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cond_clear(GCond *cond)
     * }
     */
    public static MemorySegment g_cond_clear$address() {
        return g_cond_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cond_clear(GCond *cond)
     * }
     */
    public static void g_cond_clear(MemorySegment cond) {
        var mh$ = g_cond_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_clear", cond);
            }
            mh$.invokeExact(cond);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cond_wait(GCond *cond, GMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_cond_wait$descriptor() {
        return g_cond_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cond_wait(GCond *cond, GMutex *mutex)
     * }
     */
    public static MethodHandle g_cond_wait$handle() {
        return g_cond_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cond_wait(GCond *cond, GMutex *mutex)
     * }
     */
    public static MemorySegment g_cond_wait$address() {
        return g_cond_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cond_wait(GCond *cond, GMutex *mutex)
     * }
     */
    public static void g_cond_wait(MemorySegment cond, MemorySegment mutex) {
        var mh$ = g_cond_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_wait", cond, mutex);
            }
            mh$.invokeExact(cond, mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cond_signal(GCond *cond)
     * }
     */
    public static FunctionDescriptor g_cond_signal$descriptor() {
        return g_cond_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cond_signal(GCond *cond)
     * }
     */
    public static MethodHandle g_cond_signal$handle() {
        return g_cond_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cond_signal(GCond *cond)
     * }
     */
    public static MemorySegment g_cond_signal$address() {
        return g_cond_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cond_signal(GCond *cond)
     * }
     */
    public static void g_cond_signal(MemorySegment cond) {
        var mh$ = g_cond_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_signal", cond);
            }
            mh$.invokeExact(cond);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_broadcast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_broadcast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cond_broadcast(GCond *cond)
     * }
     */
    public static FunctionDescriptor g_cond_broadcast$descriptor() {
        return g_cond_broadcast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cond_broadcast(GCond *cond)
     * }
     */
    public static MethodHandle g_cond_broadcast$handle() {
        return g_cond_broadcast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cond_broadcast(GCond *cond)
     * }
     */
    public static MemorySegment g_cond_broadcast$address() {
        return g_cond_broadcast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cond_broadcast(GCond *cond)
     * }
     */
    public static void g_cond_broadcast(MemorySegment cond) {
        var mh$ = g_cond_broadcast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_broadcast", cond);
            }
            mh$.invokeExact(cond);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_wait_until {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_wait_until");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_cond_wait_until(GCond *cond, GMutex *mutex, gint64 end_time)
     * }
     */
    public static FunctionDescriptor g_cond_wait_until$descriptor() {
        return g_cond_wait_until.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_cond_wait_until(GCond *cond, GMutex *mutex, gint64 end_time)
     * }
     */
    public static MethodHandle g_cond_wait_until$handle() {
        return g_cond_wait_until.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_cond_wait_until(GCond *cond, GMutex *mutex, gint64 end_time)
     * }
     */
    public static MemorySegment g_cond_wait_until$address() {
        return g_cond_wait_until.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_cond_wait_until(GCond *cond, GMutex *mutex, gint64 end_time)
     * }
     */
    public static int g_cond_wait_until(MemorySegment cond, MemorySegment mutex, long end_time) {
        var mh$ = g_cond_wait_until.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_wait_until", cond, mutex, end_time);
            }
            return (int)mh$.invokeExact(cond, mutex, end_time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_private_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_private_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_private_get(GPrivate *key)
     * }
     */
    public static FunctionDescriptor g_private_get$descriptor() {
        return g_private_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_private_get(GPrivate *key)
     * }
     */
    public static MethodHandle g_private_get$handle() {
        return g_private_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_private_get(GPrivate *key)
     * }
     */
    public static MemorySegment g_private_get$address() {
        return g_private_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_private_get(GPrivate *key)
     * }
     */
    public static MemorySegment g_private_get(MemorySegment key) {
        var mh$ = g_private_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_private_get", key);
            }
            return (MemorySegment)mh$.invokeExact(key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_private_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_private_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_private_set(GPrivate *key, gpointer value)
     * }
     */
    public static FunctionDescriptor g_private_set$descriptor() {
        return g_private_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_private_set(GPrivate *key, gpointer value)
     * }
     */
    public static MethodHandle g_private_set$handle() {
        return g_private_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_private_set(GPrivate *key, gpointer value)
     * }
     */
    public static MemorySegment g_private_set$address() {
        return g_private_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_private_set(GPrivate *key, gpointer value)
     * }
     */
    public static void g_private_set(MemorySegment key, MemorySegment value) {
        var mh$ = g_private_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_private_set", key, value);
            }
            mh$.invokeExact(key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_private_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_private_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_private_replace(GPrivate *key, gpointer value)
     * }
     */
    public static FunctionDescriptor g_private_replace$descriptor() {
        return g_private_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_private_replace(GPrivate *key, gpointer value)
     * }
     */
    public static MethodHandle g_private_replace$handle() {
        return g_private_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_private_replace(GPrivate *key, gpointer value)
     * }
     */
    public static MemorySegment g_private_replace$address() {
        return g_private_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_private_replace(GPrivate *key, gpointer value)
     * }
     */
    public static void g_private_replace(MemorySegment key, MemorySegment value) {
        var mh$ = g_private_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_private_replace", key, value);
            }
            mh$.invokeExact(key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_once_impl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_once_impl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_once_impl(GOnce *once, GThreadFunc func, gpointer arg)
     * }
     */
    public static FunctionDescriptor g_once_impl$descriptor() {
        return g_once_impl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_once_impl(GOnce *once, GThreadFunc func, gpointer arg)
     * }
     */
    public static MethodHandle g_once_impl$handle() {
        return g_once_impl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_once_impl(GOnce *once, GThreadFunc func, gpointer arg)
     * }
     */
    public static MemorySegment g_once_impl$address() {
        return g_once_impl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_once_impl(GOnce *once, GThreadFunc func, gpointer arg)
     * }
     */
    public static MemorySegment g_once_impl(MemorySegment once, MemorySegment func, MemorySegment arg) {
        var mh$ = g_once_impl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_once_impl", once, func, arg);
            }
            return (MemorySegment)mh$.invokeExact(once, func, arg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_once_init_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_once_init_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter(volatile void *location)
     * }
     */
    public static FunctionDescriptor g_once_init_enter$descriptor() {
        return g_once_init_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter(volatile void *location)
     * }
     */
    public static MethodHandle g_once_init_enter$handle() {
        return g_once_init_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter(volatile void *location)
     * }
     */
    public static MemorySegment g_once_init_enter$address() {
        return g_once_init_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter(volatile void *location)
     * }
     */
    public static int g_once_init_enter(MemorySegment location) {
        var mh$ = g_once_init_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_once_init_enter", location);
            }
            return (int)mh$.invokeExact(location);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_once_init_leave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_once_init_leave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_once_init_leave(volatile void *location, gsize result)
     * }
     */
    public static FunctionDescriptor g_once_init_leave$descriptor() {
        return g_once_init_leave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_once_init_leave(volatile void *location, gsize result)
     * }
     */
    public static MethodHandle g_once_init_leave$handle() {
        return g_once_init_leave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_once_init_leave(volatile void *location, gsize result)
     * }
     */
    public static MemorySegment g_once_init_leave$address() {
        return g_once_init_leave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_once_init_leave(volatile void *location, gsize result)
     * }
     */
    public static void g_once_init_leave(MemorySegment location, long result) {
        var mh$ = g_once_init_leave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_once_init_leave", location, result);
            }
            mh$.invokeExact(location, result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_once_init_enter_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_once_init_enter_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter_pointer(void *location)
     * }
     */
    public static FunctionDescriptor g_once_init_enter_pointer$descriptor() {
        return g_once_init_enter_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter_pointer(void *location)
     * }
     */
    public static MethodHandle g_once_init_enter_pointer$handle() {
        return g_once_init_enter_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter_pointer(void *location)
     * }
     */
    public static MemorySegment g_once_init_enter_pointer$address() {
        return g_once_init_enter_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter_pointer(void *location)
     * }
     */
    public static int g_once_init_enter_pointer(MemorySegment location) {
        var mh$ = g_once_init_enter_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_once_init_enter_pointer", location);
            }
            return (int)mh$.invokeExact(location);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_once_init_leave_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_once_init_leave_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_once_init_leave_pointer(void *location, gpointer result)
     * }
     */
    public static FunctionDescriptor g_once_init_leave_pointer$descriptor() {
        return g_once_init_leave_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_once_init_leave_pointer(void *location, gpointer result)
     * }
     */
    public static MethodHandle g_once_init_leave_pointer$handle() {
        return g_once_init_leave_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_once_init_leave_pointer(void *location, gpointer result)
     * }
     */
    public static MemorySegment g_once_init_leave_pointer$address() {
        return g_once_init_leave_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_once_init_leave_pointer(void *location, gpointer result)
     * }
     */
    public static void g_once_init_leave_pointer(MemorySegment location, MemorySegment result) {
        var mh$ = g_once_init_leave_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_once_init_leave_pointer", location, result);
            }
            mh$.invokeExact(location, result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_num_processors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_num_processors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_get_num_processors()
     * }
     */
    public static FunctionDescriptor g_get_num_processors$descriptor() {
        return g_get_num_processors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_get_num_processors()
     * }
     */
    public static MethodHandle g_get_num_processors$handle() {
        return g_get_num_processors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_get_num_processors()
     * }
     */
    public static MemorySegment g_get_num_processors$address() {
        return g_get_num_processors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_get_num_processors()
     * }
     */
    public static int g_get_num_processors() {
        var mh$ = g_get_num_processors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_num_processors");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_new()
     * }
     */
    public static FunctionDescriptor g_async_queue_new$descriptor() {
        return g_async_queue_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_new()
     * }
     */
    public static MethodHandle g_async_queue_new$handle() {
        return g_async_queue_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_new()
     * }
     */
    public static MemorySegment g_async_queue_new$address() {
        return g_async_queue_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_new()
     * }
     */
    public static MemorySegment g_async_queue_new() {
        var mh$ = g_async_queue_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_new_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_new_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func)
     * }
     */
    public static FunctionDescriptor g_async_queue_new_full$descriptor() {
        return g_async_queue_new_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func)
     * }
     */
    public static MethodHandle g_async_queue_new_full$handle() {
        return g_async_queue_new_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func)
     * }
     */
    public static MemorySegment g_async_queue_new_full$address() {
        return g_async_queue_new_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func)
     * }
     */
    public static MemorySegment g_async_queue_new_full(MemorySegment item_free_func) {
        var mh$ = g_async_queue_new_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_new_full", item_free_func);
            }
            return (MemorySegment)mh$.invokeExact(item_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_lock(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_lock$descriptor() {
        return g_async_queue_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_lock(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_lock$handle() {
        return g_async_queue_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_lock(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_lock$address() {
        return g_async_queue_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_lock(GAsyncQueue *queue)
     * }
     */
    public static void g_async_queue_lock(MemorySegment queue) {
        var mh$ = g_async_queue_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_lock", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_unlock(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_unlock$descriptor() {
        return g_async_queue_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_unlock(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_unlock$handle() {
        return g_async_queue_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_unlock(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_unlock$address() {
        return g_async_queue_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_unlock(GAsyncQueue *queue)
     * }
     */
    public static void g_async_queue_unlock(MemorySegment queue) {
        var mh$ = g_async_queue_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_unlock", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_ref$descriptor() {
        return g_async_queue_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_ref$handle() {
        return g_async_queue_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_ref$address() {
        return g_async_queue_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_ref(MemorySegment queue) {
        var mh$ = g_async_queue_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_ref", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_unref(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_unref$descriptor() {
        return g_async_queue_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_unref(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_unref$handle() {
        return g_async_queue_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_unref(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_unref$address() {
        return g_async_queue_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_unref(GAsyncQueue *queue)
     * }
     */
    public static void g_async_queue_unref(MemorySegment queue) {
        var mh$ = g_async_queue_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_unref", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_ref_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_ref_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_ref_unlocked(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_ref_unlocked$descriptor() {
        return g_async_queue_ref_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_ref_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_ref_unlocked$handle() {
        return g_async_queue_ref_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_ref_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_ref_unlocked$address() {
        return g_async_queue_ref_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_ref_unlocked(GAsyncQueue *queue)
     * }
     */
    public static void g_async_queue_ref_unlocked(MemorySegment queue) {
        var mh$ = g_async_queue_ref_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_ref_unlocked", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_unref_and_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_unref_and_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_unref_and_unlock$descriptor() {
        return g_async_queue_unref_and_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_unref_and_unlock$handle() {
        return g_async_queue_unref_and_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_unref_and_unlock$address() {
        return g_async_queue_unref_and_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue)
     * }
     */
    public static void g_async_queue_unref_and_unlock(MemorySegment queue) {
        var mh$ = g_async_queue_unref_and_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_unref_and_unlock", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_push(GAsyncQueue *queue, gpointer data)
     * }
     */
    public static FunctionDescriptor g_async_queue_push$descriptor() {
        return g_async_queue_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_push(GAsyncQueue *queue, gpointer data)
     * }
     */
    public static MethodHandle g_async_queue_push$handle() {
        return g_async_queue_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_push(GAsyncQueue *queue, gpointer data)
     * }
     */
    public static MemorySegment g_async_queue_push$address() {
        return g_async_queue_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_push(GAsyncQueue *queue, gpointer data)
     * }
     */
    public static void g_async_queue_push(MemorySegment queue, MemorySegment data) {
        var mh$ = g_async_queue_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_push", queue, data);
            }
            mh$.invokeExact(queue, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_push_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_push_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_unlocked(GAsyncQueue *queue, gpointer data)
     * }
     */
    public static FunctionDescriptor g_async_queue_push_unlocked$descriptor() {
        return g_async_queue_push_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_unlocked(GAsyncQueue *queue, gpointer data)
     * }
     */
    public static MethodHandle g_async_queue_push_unlocked$handle() {
        return g_async_queue_push_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_unlocked(GAsyncQueue *queue, gpointer data)
     * }
     */
    public static MemorySegment g_async_queue_push_unlocked$address() {
        return g_async_queue_push_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_push_unlocked(GAsyncQueue *queue, gpointer data)
     * }
     */
    public static void g_async_queue_push_unlocked(MemorySegment queue, MemorySegment data) {
        var mh$ = g_async_queue_push_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_push_unlocked", queue, data);
            }
            mh$.invokeExact(queue, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_push_sorted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_push_sorted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_sorted(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_async_queue_push_sorted$descriptor() {
        return g_async_queue_push_sorted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_sorted(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_async_queue_push_sorted$handle() {
        return g_async_queue_push_sorted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_sorted(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_async_queue_push_sorted$address() {
        return g_async_queue_push_sorted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_push_sorted(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static void g_async_queue_push_sorted(MemorySegment queue, MemorySegment data, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_async_queue_push_sorted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_push_sorted", queue, data, func, user_data);
            }
            mh$.invokeExact(queue, data, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_push_sorted_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_push_sorted_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_async_queue_push_sorted_unlocked$descriptor() {
        return g_async_queue_push_sorted_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_async_queue_push_sorted_unlocked$handle() {
        return g_async_queue_push_sorted_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_async_queue_push_sorted_unlocked$address() {
        return g_async_queue_push_sorted_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static void g_async_queue_push_sorted_unlocked(MemorySegment queue, MemorySegment data, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_async_queue_push_sorted_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_push_sorted_unlocked", queue, data, func, user_data);
            }
            mh$.invokeExact(queue, data, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_pop(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_pop$descriptor() {
        return g_async_queue_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_pop(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_pop$handle() {
        return g_async_queue_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_pop(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_pop$address() {
        return g_async_queue_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_async_queue_pop(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_pop(MemorySegment queue) {
        var mh$ = g_async_queue_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_pop", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_pop_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_pop_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_pop_unlocked$descriptor() {
        return g_async_queue_pop_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_pop_unlocked$handle() {
        return g_async_queue_pop_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_pop_unlocked$address() {
        return g_async_queue_pop_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_pop_unlocked(MemorySegment queue) {
        var mh$ = g_async_queue_pop_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_pop_unlocked", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_try_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_try_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_try_pop(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_try_pop$descriptor() {
        return g_async_queue_try_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_try_pop(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_try_pop$handle() {
        return g_async_queue_try_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_try_pop(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_try_pop$address() {
        return g_async_queue_try_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_async_queue_try_pop(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_try_pop(MemorySegment queue) {
        var mh$ = g_async_queue_try_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_try_pop", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_try_pop_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_try_pop_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_try_pop_unlocked$descriptor() {
        return g_async_queue_try_pop_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_try_pop_unlocked$handle() {
        return g_async_queue_try_pop_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_try_pop_unlocked$address() {
        return g_async_queue_try_pop_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_try_pop_unlocked(MemorySegment queue) {
        var mh$ = g_async_queue_try_pop_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_try_pop_unlocked", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_timeout_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_timeout_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue, guint64 timeout)
     * }
     */
    public static FunctionDescriptor g_async_queue_timeout_pop$descriptor() {
        return g_async_queue_timeout_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue, guint64 timeout)
     * }
     */
    public static MethodHandle g_async_queue_timeout_pop$handle() {
        return g_async_queue_timeout_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue, guint64 timeout)
     * }
     */
    public static MemorySegment g_async_queue_timeout_pop$address() {
        return g_async_queue_timeout_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue, guint64 timeout)
     * }
     */
    public static MemorySegment g_async_queue_timeout_pop(MemorySegment queue, long timeout) {
        var mh$ = g_async_queue_timeout_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_timeout_pop", queue, timeout);
            }
            return (MemorySegment)mh$.invokeExact(queue, timeout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_timeout_pop_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_timeout_pop_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue, guint64 timeout)
     * }
     */
    public static FunctionDescriptor g_async_queue_timeout_pop_unlocked$descriptor() {
        return g_async_queue_timeout_pop_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue, guint64 timeout)
     * }
     */
    public static MethodHandle g_async_queue_timeout_pop_unlocked$handle() {
        return g_async_queue_timeout_pop_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue, guint64 timeout)
     * }
     */
    public static MemorySegment g_async_queue_timeout_pop_unlocked$address() {
        return g_async_queue_timeout_pop_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue, guint64 timeout)
     * }
     */
    public static MemorySegment g_async_queue_timeout_pop_unlocked(MemorySegment queue, long timeout) {
        var mh$ = g_async_queue_timeout_pop_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_timeout_pop_unlocked", queue, timeout);
            }
            return (MemorySegment)mh$.invokeExact(queue, timeout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_async_queue_length(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_length$descriptor() {
        return g_async_queue_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_async_queue_length(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_length$handle() {
        return g_async_queue_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_async_queue_length(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_length$address() {
        return g_async_queue_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_async_queue_length(GAsyncQueue *queue)
     * }
     */
    public static int g_async_queue_length(MemorySegment queue) {
        var mh$ = g_async_queue_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_length", queue);
            }
            return (int)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_length_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_length_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_async_queue_length_unlocked(GAsyncQueue *queue)
     * }
     */
    public static FunctionDescriptor g_async_queue_length_unlocked$descriptor() {
        return g_async_queue_length_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_async_queue_length_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MethodHandle g_async_queue_length_unlocked$handle() {
        return g_async_queue_length_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_async_queue_length_unlocked(GAsyncQueue *queue)
     * }
     */
    public static MemorySegment g_async_queue_length_unlocked$address() {
        return g_async_queue_length_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_async_queue_length_unlocked(GAsyncQueue *queue)
     * }
     */
    public static int g_async_queue_length_unlocked(MemorySegment queue) {
        var mh$ = g_async_queue_length_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_length_unlocked", queue);
            }
            return (int)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_sort(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_async_queue_sort$descriptor() {
        return g_async_queue_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_sort(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_async_queue_sort$handle() {
        return g_async_queue_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_sort(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_async_queue_sort$address() {
        return g_async_queue_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_sort(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static void g_async_queue_sort(MemorySegment queue, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_async_queue_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_sort", queue, func, user_data);
            }
            mh$.invokeExact(queue, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_sort_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_sort_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_sort_unlocked(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_async_queue_sort_unlocked$descriptor() {
        return g_async_queue_sort_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_sort_unlocked(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_async_queue_sort_unlocked$handle() {
        return g_async_queue_sort_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_sort_unlocked(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_async_queue_sort_unlocked$address() {
        return g_async_queue_sort_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_sort_unlocked(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static void g_async_queue_sort_unlocked(MemorySegment queue, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_async_queue_sort_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_sort_unlocked", queue, func, user_data);
            }
            mh$.invokeExact(queue, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_async_queue_remove(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static FunctionDescriptor g_async_queue_remove$descriptor() {
        return g_async_queue_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_async_queue_remove(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static MethodHandle g_async_queue_remove$handle() {
        return g_async_queue_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_async_queue_remove(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static MemorySegment g_async_queue_remove$address() {
        return g_async_queue_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_async_queue_remove(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static int g_async_queue_remove(MemorySegment queue, MemorySegment item) {
        var mh$ = g_async_queue_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_remove", queue, item);
            }
            return (int)mh$.invokeExact(queue, item);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_remove_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_remove_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static FunctionDescriptor g_async_queue_remove_unlocked$descriptor() {
        return g_async_queue_remove_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static MethodHandle g_async_queue_remove_unlocked$handle() {
        return g_async_queue_remove_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static MemorySegment g_async_queue_remove_unlocked$address() {
        return g_async_queue_remove_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static int g_async_queue_remove_unlocked(MemorySegment queue, MemorySegment item) {
        var mh$ = g_async_queue_remove_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_remove_unlocked", queue, item);
            }
            return (int)mh$.invokeExact(queue, item);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_push_front {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_push_front");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_front(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static FunctionDescriptor g_async_queue_push_front$descriptor() {
        return g_async_queue_push_front.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_front(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static MethodHandle g_async_queue_push_front$handle() {
        return g_async_queue_push_front.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_front(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static MemorySegment g_async_queue_push_front$address() {
        return g_async_queue_push_front.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_push_front(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static void g_async_queue_push_front(MemorySegment queue, MemorySegment item) {
        var mh$ = g_async_queue_push_front.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_push_front", queue, item);
            }
            mh$.invokeExact(queue, item);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_push_front_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_push_front_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static FunctionDescriptor g_async_queue_push_front_unlocked$descriptor() {
        return g_async_queue_push_front_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static MethodHandle g_async_queue_push_front_unlocked$handle() {
        return g_async_queue_push_front_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static MemorySegment g_async_queue_push_front_unlocked$address() {
        return g_async_queue_push_front_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue, gpointer item)
     * }
     */
    public static void g_async_queue_push_front_unlocked(MemorySegment queue, MemorySegment item) {
        var mh$ = g_async_queue_push_front_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_push_front_unlocked", queue, item);
            }
            mh$.invokeExact(queue, item);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_timed_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_timed_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue, GTimeVal *end_time)
     * }
     */
    public static FunctionDescriptor g_async_queue_timed_pop$descriptor() {
        return g_async_queue_timed_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue, GTimeVal *end_time)
     * }
     */
    public static MethodHandle g_async_queue_timed_pop$handle() {
        return g_async_queue_timed_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue, GTimeVal *end_time)
     * }
     */
    public static MemorySegment g_async_queue_timed_pop$address() {
        return g_async_queue_timed_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue, GTimeVal *end_time)
     * }
     */
    public static MemorySegment g_async_queue_timed_pop(MemorySegment queue, MemorySegment end_time) {
        var mh$ = g_async_queue_timed_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_timed_pop", queue, end_time);
            }
            return (MemorySegment)mh$.invokeExact(queue, end_time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_async_queue_timed_pop_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_async_queue_timed_pop_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue, GTimeVal *end_time)
     * }
     */
    public static FunctionDescriptor g_async_queue_timed_pop_unlocked$descriptor() {
        return g_async_queue_timed_pop_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue, GTimeVal *end_time)
     * }
     */
    public static MethodHandle g_async_queue_timed_pop_unlocked$handle() {
        return g_async_queue_timed_pop_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue, GTimeVal *end_time)
     * }
     */
    public static MemorySegment g_async_queue_timed_pop_unlocked$address() {
        return g_async_queue_timed_pop_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue, GTimeVal *end_time)
     * }
     */
    public static MemorySegment g_async_queue_timed_pop_unlocked(MemorySegment queue, MemorySegment end_time) {
        var mh$ = g_async_queue_timed_pop_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_async_queue_timed_pop_unlocked", queue, end_time);
            }
            return (MemorySegment)mh$.invokeExact(queue, end_time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = gst_min_h.C_INT;

    private static class __pxcptinfoptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__pxcptinfoptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void **__pxcptinfoptrs()
     * }
     */
    public static FunctionDescriptor __pxcptinfoptrs$descriptor() {
        return __pxcptinfoptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void **__pxcptinfoptrs()
     * }
     */
    public static MethodHandle __pxcptinfoptrs$handle() {
        return __pxcptinfoptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void **__pxcptinfoptrs()
     * }
     */
    public static MemorySegment __pxcptinfoptrs$address() {
        return __pxcptinfoptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void **__pxcptinfoptrs()
     * }
     */
    public static MemorySegment __pxcptinfoptrs() {
        var mh$ = __pxcptinfoptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pxcptinfoptrs");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _crt_signal_t signal(int _Signal, _crt_signal_t _Function)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _crt_signal_t signal(int _Signal, _crt_signal_t _Function)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _crt_signal_t signal(int _Signal, _crt_signal_t _Function)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _crt_signal_t signal(int _Signal, _crt_signal_t _Function)
     * }
     */
    public static MemorySegment signal(int _Signal, MemorySegment _Function) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", _Signal, _Function);
            }
            return (MemorySegment)mh$.invokeExact(_Signal, _Function);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class raise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("raise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int raise(int _Signal)
     * }
     */
    public static FunctionDescriptor raise$descriptor() {
        return raise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int raise(int _Signal)
     * }
     */
    public static MethodHandle raise$handle() {
        return raise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int raise(int _Signal)
     * }
     */
    public static MemorySegment raise$address() {
        return raise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int raise(int _Signal)
     * }
     */
    public static int raise(int _Signal) {
        var mh$ = raise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("raise", _Signal);
            }
            return (int)mh$.invokeExact(_Signal);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_on_error_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_on_error_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_on_error_query(const gchar *prg_name)
     * }
     */
    public static FunctionDescriptor g_on_error_query$descriptor() {
        return g_on_error_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_on_error_query(const gchar *prg_name)
     * }
     */
    public static MethodHandle g_on_error_query$handle() {
        return g_on_error_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_on_error_query(const gchar *prg_name)
     * }
     */
    public static MemorySegment g_on_error_query$address() {
        return g_on_error_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_on_error_query(const gchar *prg_name)
     * }
     */
    public static void g_on_error_query(MemorySegment prg_name) {
        var mh$ = g_on_error_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_on_error_query", prg_name);
            }
            mh$.invokeExact(prg_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_on_error_stack_trace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_on_error_stack_trace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_on_error_stack_trace(const gchar *prg_name)
     * }
     */
    public static FunctionDescriptor g_on_error_stack_trace$descriptor() {
        return g_on_error_stack_trace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_on_error_stack_trace(const gchar *prg_name)
     * }
     */
    public static MethodHandle g_on_error_stack_trace$handle() {
        return g_on_error_stack_trace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_on_error_stack_trace(const gchar *prg_name)
     * }
     */
    public static MemorySegment g_on_error_stack_trace$address() {
        return g_on_error_stack_trace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_on_error_stack_trace(const gchar *prg_name)
     * }
     */
    public static void g_on_error_stack_trace(MemorySegment prg_name) {
        var mh$ = g_on_error_stack_trace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_on_error_stack_trace", prg_name);
            }
            mh$.invokeExact(prg_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_base64_encode_step {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_base64_encode_step");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_base64_encode_step(const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save)
     * }
     */
    public static FunctionDescriptor g_base64_encode_step$descriptor() {
        return g_base64_encode_step.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_base64_encode_step(const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save)
     * }
     */
    public static MethodHandle g_base64_encode_step$handle() {
        return g_base64_encode_step.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_base64_encode_step(const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save)
     * }
     */
    public static MemorySegment g_base64_encode_step$address() {
        return g_base64_encode_step.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_base64_encode_step(const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save)
     * }
     */
    public static long g_base64_encode_step(MemorySegment in, long len, int break_lines, MemorySegment out, MemorySegment state, MemorySegment save) {
        var mh$ = g_base64_encode_step.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_base64_encode_step", in, len, break_lines, out, state, save);
            }
            return (long)mh$.invokeExact(in, len, break_lines, out, state, save);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_base64_encode_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_base64_encode_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_base64_encode_close(gboolean break_lines, gchar *out, gint *state, gint *save)
     * }
     */
    public static FunctionDescriptor g_base64_encode_close$descriptor() {
        return g_base64_encode_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_base64_encode_close(gboolean break_lines, gchar *out, gint *state, gint *save)
     * }
     */
    public static MethodHandle g_base64_encode_close$handle() {
        return g_base64_encode_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_base64_encode_close(gboolean break_lines, gchar *out, gint *state, gint *save)
     * }
     */
    public static MemorySegment g_base64_encode_close$address() {
        return g_base64_encode_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_base64_encode_close(gboolean break_lines, gchar *out, gint *state, gint *save)
     * }
     */
    public static long g_base64_encode_close(int break_lines, MemorySegment out, MemorySegment state, MemorySegment save) {
        var mh$ = g_base64_encode_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_base64_encode_close", break_lines, out, state, save);
            }
            return (long)mh$.invokeExact(break_lines, out, state, save);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_base64_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_base64_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_base64_encode(const guchar *data, gsize len)
     * }
     */
    public static FunctionDescriptor g_base64_encode$descriptor() {
        return g_base64_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_base64_encode(const guchar *data, gsize len)
     * }
     */
    public static MethodHandle g_base64_encode$handle() {
        return g_base64_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_base64_encode(const guchar *data, gsize len)
     * }
     */
    public static MemorySegment g_base64_encode$address() {
        return g_base64_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_base64_encode(const guchar *data, gsize len)
     * }
     */
    public static MemorySegment g_base64_encode(MemorySegment data, long len) {
        var mh$ = g_base64_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_base64_encode", data, len);
            }
            return (MemorySegment)mh$.invokeExact(data, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_base64_decode_step {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_base64_decode_step");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_base64_decode_step(const gchar *in, gsize len, guchar *out, gint *state, guint *save)
     * }
     */
    public static FunctionDescriptor g_base64_decode_step$descriptor() {
        return g_base64_decode_step.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_base64_decode_step(const gchar *in, gsize len, guchar *out, gint *state, guint *save)
     * }
     */
    public static MethodHandle g_base64_decode_step$handle() {
        return g_base64_decode_step.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_base64_decode_step(const gchar *in, gsize len, guchar *out, gint *state, guint *save)
     * }
     */
    public static MemorySegment g_base64_decode_step$address() {
        return g_base64_decode_step.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_base64_decode_step(const gchar *in, gsize len, guchar *out, gint *state, guint *save)
     * }
     */
    public static long g_base64_decode_step(MemorySegment in, long len, MemorySegment out, MemorySegment state, MemorySegment save) {
        var mh$ = g_base64_decode_step.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_base64_decode_step", in, len, out, state, save);
            }
            return (long)mh$.invokeExact(in, len, out, state, save);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_base64_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_base64_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guchar *g_base64_decode(const gchar *text, gsize *out_len)
     * }
     */
    public static FunctionDescriptor g_base64_decode$descriptor() {
        return g_base64_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guchar *g_base64_decode(const gchar *text, gsize *out_len)
     * }
     */
    public static MethodHandle g_base64_decode$handle() {
        return g_base64_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guchar *g_base64_decode(const gchar *text, gsize *out_len)
     * }
     */
    public static MemorySegment g_base64_decode$address() {
        return g_base64_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guchar *g_base64_decode(const gchar *text, gsize *out_len)
     * }
     */
    public static MemorySegment g_base64_decode(MemorySegment text, MemorySegment out_len) {
        var mh$ = g_base64_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_base64_decode", text, out_len);
            }
            return (MemorySegment)mh$.invokeExact(text, out_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_base64_decode_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_base64_decode_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guchar *g_base64_decode_inplace(gchar *text, gsize *out_len)
     * }
     */
    public static FunctionDescriptor g_base64_decode_inplace$descriptor() {
        return g_base64_decode_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guchar *g_base64_decode_inplace(gchar *text, gsize *out_len)
     * }
     */
    public static MethodHandle g_base64_decode_inplace$handle() {
        return g_base64_decode_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guchar *g_base64_decode_inplace(gchar *text, gsize *out_len)
     * }
     */
    public static MemorySegment g_base64_decode_inplace$address() {
        return g_base64_decode_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guchar *g_base64_decode_inplace(gchar *text, gsize *out_len)
     * }
     */
    public static MemorySegment g_base64_decode_inplace(MemorySegment text, MemorySegment out_len) {
        var mh$ = g_base64_decode_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_base64_decode_inplace", text, out_len);
            }
            return (MemorySegment)mh$.invokeExact(text, out_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bit_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bit_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bit_lock(volatile gint *address, gint lock_bit)
     * }
     */
    public static FunctionDescriptor g_bit_lock$descriptor() {
        return g_bit_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bit_lock(volatile gint *address, gint lock_bit)
     * }
     */
    public static MethodHandle g_bit_lock$handle() {
        return g_bit_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bit_lock(volatile gint *address, gint lock_bit)
     * }
     */
    public static MemorySegment g_bit_lock$address() {
        return g_bit_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bit_lock(volatile gint *address, gint lock_bit)
     * }
     */
    public static void g_bit_lock(MemorySegment address, int lock_bit) {
        var mh$ = g_bit_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bit_lock", address, lock_bit);
            }
            mh$.invokeExact(address, lock_bit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bit_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bit_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bit_trylock(volatile gint *address, gint lock_bit)
     * }
     */
    public static FunctionDescriptor g_bit_trylock$descriptor() {
        return g_bit_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bit_trylock(volatile gint *address, gint lock_bit)
     * }
     */
    public static MethodHandle g_bit_trylock$handle() {
        return g_bit_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bit_trylock(volatile gint *address, gint lock_bit)
     * }
     */
    public static MemorySegment g_bit_trylock$address() {
        return g_bit_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bit_trylock(volatile gint *address, gint lock_bit)
     * }
     */
    public static int g_bit_trylock(MemorySegment address, int lock_bit) {
        var mh$ = g_bit_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bit_trylock", address, lock_bit);
            }
            return (int)mh$.invokeExact(address, lock_bit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bit_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bit_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bit_unlock(volatile gint *address, gint lock_bit)
     * }
     */
    public static FunctionDescriptor g_bit_unlock$descriptor() {
        return g_bit_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bit_unlock(volatile gint *address, gint lock_bit)
     * }
     */
    public static MethodHandle g_bit_unlock$handle() {
        return g_bit_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bit_unlock(volatile gint *address, gint lock_bit)
     * }
     */
    public static MemorySegment g_bit_unlock$address() {
        return g_bit_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bit_unlock(volatile gint *address, gint lock_bit)
     * }
     */
    public static void g_bit_unlock(MemorySegment address, int lock_bit) {
        var mh$ = g_bit_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bit_unlock", address, lock_bit);
            }
            mh$.invokeExact(address, lock_bit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pointer_bit_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pointer_bit_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_lock(volatile void *address, gint lock_bit)
     * }
     */
    public static FunctionDescriptor g_pointer_bit_lock$descriptor() {
        return g_pointer_bit_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_lock(volatile void *address, gint lock_bit)
     * }
     */
    public static MethodHandle g_pointer_bit_lock$handle() {
        return g_pointer_bit_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_lock(volatile void *address, gint lock_bit)
     * }
     */
    public static MemorySegment g_pointer_bit_lock$address() {
        return g_pointer_bit_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_pointer_bit_lock(volatile void *address, gint lock_bit)
     * }
     */
    public static void g_pointer_bit_lock(MemorySegment address, int lock_bit) {
        var mh$ = g_pointer_bit_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pointer_bit_lock", address, lock_bit);
            }
            mh$.invokeExact(address, lock_bit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pointer_bit_lock_and_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pointer_bit_lock_and_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_lock_and_get(gpointer address, guint lock_bit, guintptr *out_ptr)
     * }
     */
    public static FunctionDescriptor g_pointer_bit_lock_and_get$descriptor() {
        return g_pointer_bit_lock_and_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_lock_and_get(gpointer address, guint lock_bit, guintptr *out_ptr)
     * }
     */
    public static MethodHandle g_pointer_bit_lock_and_get$handle() {
        return g_pointer_bit_lock_and_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_lock_and_get(gpointer address, guint lock_bit, guintptr *out_ptr)
     * }
     */
    public static MemorySegment g_pointer_bit_lock_and_get$address() {
        return g_pointer_bit_lock_and_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_pointer_bit_lock_and_get(gpointer address, guint lock_bit, guintptr *out_ptr)
     * }
     */
    public static void g_pointer_bit_lock_and_get(MemorySegment address, int lock_bit, MemorySegment out_ptr) {
        var mh$ = g_pointer_bit_lock_and_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pointer_bit_lock_and_get", address, lock_bit, out_ptr);
            }
            mh$.invokeExact(address, lock_bit, out_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pointer_bit_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pointer_bit_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_pointer_bit_trylock(volatile void *address, gint lock_bit)
     * }
     */
    public static FunctionDescriptor g_pointer_bit_trylock$descriptor() {
        return g_pointer_bit_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_pointer_bit_trylock(volatile void *address, gint lock_bit)
     * }
     */
    public static MethodHandle g_pointer_bit_trylock$handle() {
        return g_pointer_bit_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_pointer_bit_trylock(volatile void *address, gint lock_bit)
     * }
     */
    public static MemorySegment g_pointer_bit_trylock$address() {
        return g_pointer_bit_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_pointer_bit_trylock(volatile void *address, gint lock_bit)
     * }
     */
    public static int g_pointer_bit_trylock(MemorySegment address, int lock_bit) {
        var mh$ = g_pointer_bit_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pointer_bit_trylock", address, lock_bit);
            }
            return (int)mh$.invokeExact(address, lock_bit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pointer_bit_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pointer_bit_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_unlock(volatile void *address, gint lock_bit)
     * }
     */
    public static FunctionDescriptor g_pointer_bit_unlock$descriptor() {
        return g_pointer_bit_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_unlock(volatile void *address, gint lock_bit)
     * }
     */
    public static MethodHandle g_pointer_bit_unlock$handle() {
        return g_pointer_bit_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_unlock(volatile void *address, gint lock_bit)
     * }
     */
    public static MemorySegment g_pointer_bit_unlock$address() {
        return g_pointer_bit_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_pointer_bit_unlock(volatile void *address, gint lock_bit)
     * }
     */
    public static void g_pointer_bit_unlock(MemorySegment address, int lock_bit) {
        var mh$ = g_pointer_bit_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pointer_bit_unlock", address, lock_bit);
            }
            mh$.invokeExact(address, lock_bit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pointer_bit_lock_mask_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pointer_bit_lock_mask_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_pointer_bit_lock_mask_ptr(gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr)
     * }
     */
    public static FunctionDescriptor g_pointer_bit_lock_mask_ptr$descriptor() {
        return g_pointer_bit_lock_mask_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_pointer_bit_lock_mask_ptr(gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr)
     * }
     */
    public static MethodHandle g_pointer_bit_lock_mask_ptr$handle() {
        return g_pointer_bit_lock_mask_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_pointer_bit_lock_mask_ptr(gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr)
     * }
     */
    public static MemorySegment g_pointer_bit_lock_mask_ptr$address() {
        return g_pointer_bit_lock_mask_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_pointer_bit_lock_mask_ptr(gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr)
     * }
     */
    public static MemorySegment g_pointer_bit_lock_mask_ptr(MemorySegment ptr, int lock_bit, int set, long preserve_mask, MemorySegment preserve_ptr) {
        var mh$ = g_pointer_bit_lock_mask_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pointer_bit_lock_mask_ptr", ptr, lock_bit, set, preserve_mask, preserve_ptr);
            }
            return (MemorySegment)mh$.invokeExact(ptr, lock_bit, set, preserve_mask, preserve_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pointer_bit_unlock_and_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pointer_bit_unlock_and_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_unlock_and_set(void *address, guint lock_bit, gpointer ptr, guintptr preserve_mask)
     * }
     */
    public static FunctionDescriptor g_pointer_bit_unlock_and_set$descriptor() {
        return g_pointer_bit_unlock_and_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_unlock_and_set(void *address, guint lock_bit, gpointer ptr, guintptr preserve_mask)
     * }
     */
    public static MethodHandle g_pointer_bit_unlock_and_set$handle() {
        return g_pointer_bit_unlock_and_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_pointer_bit_unlock_and_set(void *address, guint lock_bit, gpointer ptr, guintptr preserve_mask)
     * }
     */
    public static MemorySegment g_pointer_bit_unlock_and_set$address() {
        return g_pointer_bit_unlock_and_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_pointer_bit_unlock_and_set(void *address, guint lock_bit, gpointer ptr, guintptr preserve_mask)
     * }
     */
    public static void g_pointer_bit_unlock_and_set(MemorySegment address, int lock_bit, MemorySegment ptr, long preserve_mask) {
        var mh$ = g_pointer_bit_unlock_and_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pointer_bit_unlock_and_set", address, lock_bit, ptr, preserve_mask);
            }
            mh$.invokeExact(address, lock_bit, ptr, preserve_mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_TIME_TYPE_STANDARD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TIME_TYPE_STANDARD = 0
     * }
     */
    public static int G_TIME_TYPE_STANDARD() {
        return G_TIME_TYPE_STANDARD;
    }
    private static final int G_TIME_TYPE_DAYLIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TIME_TYPE_DAYLIGHT = 1
     * }
     */
    public static int G_TIME_TYPE_DAYLIGHT() {
        return G_TIME_TYPE_DAYLIGHT;
    }
    private static final int G_TIME_TYPE_UNIVERSAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TIME_TYPE_UNIVERSAL = 2
     * }
     */
    public static int G_TIME_TYPE_UNIVERSAL() {
        return G_TIME_TYPE_UNIVERSAL;
    }

    private static class g_time_zone_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new(const gchar *identifier)
     * }
     */
    public static FunctionDescriptor g_time_zone_new$descriptor() {
        return g_time_zone_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new(const gchar *identifier)
     * }
     */
    public static MethodHandle g_time_zone_new$handle() {
        return g_time_zone_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new(const gchar *identifier)
     * }
     */
    public static MemorySegment g_time_zone_new$address() {
        return g_time_zone_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new(const gchar *identifier)
     * }
     */
    public static MemorySegment g_time_zone_new(MemorySegment identifier) {
        var mh$ = g_time_zone_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_new", identifier);
            }
            return (MemorySegment)mh$.invokeExact(identifier);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_new_identifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_new_identifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_identifier(const gchar *identifier)
     * }
     */
    public static FunctionDescriptor g_time_zone_new_identifier$descriptor() {
        return g_time_zone_new_identifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_identifier(const gchar *identifier)
     * }
     */
    public static MethodHandle g_time_zone_new_identifier$handle() {
        return g_time_zone_new_identifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_identifier(const gchar *identifier)
     * }
     */
    public static MemorySegment g_time_zone_new_identifier$address() {
        return g_time_zone_new_identifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_identifier(const gchar *identifier)
     * }
     */
    public static MemorySegment g_time_zone_new_identifier(MemorySegment identifier) {
        var mh$ = g_time_zone_new_identifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_new_identifier", identifier);
            }
            return (MemorySegment)mh$.invokeExact(identifier);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_new_utc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_new_utc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_utc()
     * }
     */
    public static FunctionDescriptor g_time_zone_new_utc$descriptor() {
        return g_time_zone_new_utc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_utc()
     * }
     */
    public static MethodHandle g_time_zone_new_utc$handle() {
        return g_time_zone_new_utc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_utc()
     * }
     */
    public static MemorySegment g_time_zone_new_utc$address() {
        return g_time_zone_new_utc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_utc()
     * }
     */
    public static MemorySegment g_time_zone_new_utc() {
        var mh$ = g_time_zone_new_utc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_new_utc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_new_local {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_new_local");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_local()
     * }
     */
    public static FunctionDescriptor g_time_zone_new_local$descriptor() {
        return g_time_zone_new_local.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_local()
     * }
     */
    public static MethodHandle g_time_zone_new_local$handle() {
        return g_time_zone_new_local.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_local()
     * }
     */
    public static MemorySegment g_time_zone_new_local$address() {
        return g_time_zone_new_local.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_local()
     * }
     */
    public static MemorySegment g_time_zone_new_local() {
        var mh$ = g_time_zone_new_local.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_new_local");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_new_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_new_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_offset(gint32 seconds)
     * }
     */
    public static FunctionDescriptor g_time_zone_new_offset$descriptor() {
        return g_time_zone_new_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_offset(gint32 seconds)
     * }
     */
    public static MethodHandle g_time_zone_new_offset$handle() {
        return g_time_zone_new_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_offset(gint32 seconds)
     * }
     */
    public static MemorySegment g_time_zone_new_offset$address() {
        return g_time_zone_new_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_new_offset(gint32 seconds)
     * }
     */
    public static MemorySegment g_time_zone_new_offset(int seconds) {
        var mh$ = g_time_zone_new_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_new_offset", seconds);
            }
            return (MemorySegment)mh$.invokeExact(seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_ref(GTimeZone *tz)
     * }
     */
    public static FunctionDescriptor g_time_zone_ref$descriptor() {
        return g_time_zone_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_ref(GTimeZone *tz)
     * }
     */
    public static MethodHandle g_time_zone_ref$handle() {
        return g_time_zone_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_ref(GTimeZone *tz)
     * }
     */
    public static MemorySegment g_time_zone_ref$address() {
        return g_time_zone_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeZone *g_time_zone_ref(GTimeZone *tz)
     * }
     */
    public static MemorySegment g_time_zone_ref(MemorySegment tz) {
        var mh$ = g_time_zone_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_ref", tz);
            }
            return (MemorySegment)mh$.invokeExact(tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_time_zone_unref(GTimeZone *tz)
     * }
     */
    public static FunctionDescriptor g_time_zone_unref$descriptor() {
        return g_time_zone_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_time_zone_unref(GTimeZone *tz)
     * }
     */
    public static MethodHandle g_time_zone_unref$handle() {
        return g_time_zone_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_time_zone_unref(GTimeZone *tz)
     * }
     */
    public static MemorySegment g_time_zone_unref$address() {
        return g_time_zone_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_time_zone_unref(GTimeZone *tz)
     * }
     */
    public static void g_time_zone_unref(MemorySegment tz) {
        var mh$ = g_time_zone_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_unref", tz);
            }
            mh$.invokeExact(tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_find_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_find_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_time_zone_find_interval(GTimeZone *tz, GTimeType type, gint64 time_)
     * }
     */
    public static FunctionDescriptor g_time_zone_find_interval$descriptor() {
        return g_time_zone_find_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_time_zone_find_interval(GTimeZone *tz, GTimeType type, gint64 time_)
     * }
     */
    public static MethodHandle g_time_zone_find_interval$handle() {
        return g_time_zone_find_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_time_zone_find_interval(GTimeZone *tz, GTimeType type, gint64 time_)
     * }
     */
    public static MemorySegment g_time_zone_find_interval$address() {
        return g_time_zone_find_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_time_zone_find_interval(GTimeZone *tz, GTimeType type, gint64 time_)
     * }
     */
    public static int g_time_zone_find_interval(MemorySegment tz, int type, long time_) {
        var mh$ = g_time_zone_find_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_find_interval", tz, type, time_);
            }
            return (int)mh$.invokeExact(tz, type, time_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_adjust_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_adjust_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_time_zone_adjust_time(GTimeZone *tz, GTimeType type, gint64 *time_)
     * }
     */
    public static FunctionDescriptor g_time_zone_adjust_time$descriptor() {
        return g_time_zone_adjust_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_time_zone_adjust_time(GTimeZone *tz, GTimeType type, gint64 *time_)
     * }
     */
    public static MethodHandle g_time_zone_adjust_time$handle() {
        return g_time_zone_adjust_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_time_zone_adjust_time(GTimeZone *tz, GTimeType type, gint64 *time_)
     * }
     */
    public static MemorySegment g_time_zone_adjust_time$address() {
        return g_time_zone_adjust_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_time_zone_adjust_time(GTimeZone *tz, GTimeType type, gint64 *time_)
     * }
     */
    public static int g_time_zone_adjust_time(MemorySegment tz, int type, MemorySegment time_) {
        var mh$ = g_time_zone_adjust_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_adjust_time", tz, type, time_);
            }
            return (int)mh$.invokeExact(tz, type, time_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_get_abbreviation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_get_abbreviation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_time_zone_get_abbreviation(GTimeZone *tz, gint interval)
     * }
     */
    public static FunctionDescriptor g_time_zone_get_abbreviation$descriptor() {
        return g_time_zone_get_abbreviation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_time_zone_get_abbreviation(GTimeZone *tz, gint interval)
     * }
     */
    public static MethodHandle g_time_zone_get_abbreviation$handle() {
        return g_time_zone_get_abbreviation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_time_zone_get_abbreviation(GTimeZone *tz, gint interval)
     * }
     */
    public static MemorySegment g_time_zone_get_abbreviation$address() {
        return g_time_zone_get_abbreviation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_time_zone_get_abbreviation(GTimeZone *tz, gint interval)
     * }
     */
    public static MemorySegment g_time_zone_get_abbreviation(MemorySegment tz, int interval) {
        var mh$ = g_time_zone_get_abbreviation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_get_abbreviation", tz, interval);
            }
            return (MemorySegment)mh$.invokeExact(tz, interval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_get_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_get_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint32 g_time_zone_get_offset(GTimeZone *tz, gint interval)
     * }
     */
    public static FunctionDescriptor g_time_zone_get_offset$descriptor() {
        return g_time_zone_get_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint32 g_time_zone_get_offset(GTimeZone *tz, gint interval)
     * }
     */
    public static MethodHandle g_time_zone_get_offset$handle() {
        return g_time_zone_get_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint32 g_time_zone_get_offset(GTimeZone *tz, gint interval)
     * }
     */
    public static MemorySegment g_time_zone_get_offset$address() {
        return g_time_zone_get_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint32 g_time_zone_get_offset(GTimeZone *tz, gint interval)
     * }
     */
    public static int g_time_zone_get_offset(MemorySegment tz, int interval) {
        var mh$ = g_time_zone_get_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_get_offset", tz, interval);
            }
            return (int)mh$.invokeExact(tz, interval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_is_dst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_is_dst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_time_zone_is_dst(GTimeZone *tz, gint interval)
     * }
     */
    public static FunctionDescriptor g_time_zone_is_dst$descriptor() {
        return g_time_zone_is_dst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_time_zone_is_dst(GTimeZone *tz, gint interval)
     * }
     */
    public static MethodHandle g_time_zone_is_dst$handle() {
        return g_time_zone_is_dst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_time_zone_is_dst(GTimeZone *tz, gint interval)
     * }
     */
    public static MemorySegment g_time_zone_is_dst$address() {
        return g_time_zone_is_dst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_time_zone_is_dst(GTimeZone *tz, gint interval)
     * }
     */
    public static int g_time_zone_is_dst(MemorySegment tz, int interval) {
        var mh$ = g_time_zone_is_dst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_is_dst", tz, interval);
            }
            return (int)mh$.invokeExact(tz, interval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_get_identifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_get_identifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_time_zone_get_identifier(GTimeZone *tz)
     * }
     */
    public static FunctionDescriptor g_time_zone_get_identifier$descriptor() {
        return g_time_zone_get_identifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_time_zone_get_identifier(GTimeZone *tz)
     * }
     */
    public static MethodHandle g_time_zone_get_identifier$handle() {
        return g_time_zone_get_identifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_time_zone_get_identifier(GTimeZone *tz)
     * }
     */
    public static MemorySegment g_time_zone_get_identifier$address() {
        return g_time_zone_get_identifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_time_zone_get_identifier(GTimeZone *tz)
     * }
     */
    public static MemorySegment g_time_zone_get_identifier(MemorySegment tz) {
        var mh$ = g_time_zone_get_identifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_get_identifier", tz);
            }
            return (MemorySegment)mh$.invokeExact(tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef gint64 GTimeSpan
     * }
     */
    public static final OfLong GTimeSpan = gst_min_h.C_LONG_LONG;

    private static class g_date_time_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_time_unref(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_unref$descriptor() {
        return g_date_time_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_time_unref(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_unref$handle() {
        return g_date_time_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_time_unref(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_unref$address() {
        return g_date_time_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_time_unref(GDateTime *datetime)
     * }
     */
    public static void g_date_time_unref(MemorySegment datetime) {
        var mh$ = g_date_time_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_unref", datetime);
            }
            mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_ref(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_ref$descriptor() {
        return g_date_time_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_ref(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_ref$handle() {
        return g_date_time_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_ref(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_ref$address() {
        return g_date_time_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_ref(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_ref(MemorySegment datetime) {
        var mh$ = g_date_time_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_ref", datetime);
            }
            return (MemorySegment)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_now {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_now");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now(GTimeZone *tz)
     * }
     */
    public static FunctionDescriptor g_date_time_new_now$descriptor() {
        return g_date_time_new_now.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now(GTimeZone *tz)
     * }
     */
    public static MethodHandle g_date_time_new_now$handle() {
        return g_date_time_new_now.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now(GTimeZone *tz)
     * }
     */
    public static MemorySegment g_date_time_new_now$address() {
        return g_date_time_new_now.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now(GTimeZone *tz)
     * }
     */
    public static MemorySegment g_date_time_new_now(MemorySegment tz) {
        var mh$ = g_date_time_new_now.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_now", tz);
            }
            return (MemorySegment)mh$.invokeExact(tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_now_local {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_now_local");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now_local()
     * }
     */
    public static FunctionDescriptor g_date_time_new_now_local$descriptor() {
        return g_date_time_new_now_local.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now_local()
     * }
     */
    public static MethodHandle g_date_time_new_now_local$handle() {
        return g_date_time_new_now_local.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now_local()
     * }
     */
    public static MemorySegment g_date_time_new_now_local$address() {
        return g_date_time_new_now_local.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now_local()
     * }
     */
    public static MemorySegment g_date_time_new_now_local() {
        var mh$ = g_date_time_new_now_local.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_now_local");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_now_utc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_now_utc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now_utc()
     * }
     */
    public static FunctionDescriptor g_date_time_new_now_utc$descriptor() {
        return g_date_time_new_now_utc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now_utc()
     * }
     */
    public static MethodHandle g_date_time_new_now_utc$handle() {
        return g_date_time_new_now_utc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now_utc()
     * }
     */
    public static MemorySegment g_date_time_new_now_utc$address() {
        return g_date_time_new_now_utc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_now_utc()
     * }
     */
    public static MemorySegment g_date_time_new_now_utc() {
        var mh$ = g_date_time_new_now_utc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_now_utc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_from_unix_local {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_from_unix_local");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_local(gint64 t)
     * }
     */
    public static FunctionDescriptor g_date_time_new_from_unix_local$descriptor() {
        return g_date_time_new_from_unix_local.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_local(gint64 t)
     * }
     */
    public static MethodHandle g_date_time_new_from_unix_local$handle() {
        return g_date_time_new_from_unix_local.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_local(gint64 t)
     * }
     */
    public static MemorySegment g_date_time_new_from_unix_local$address() {
        return g_date_time_new_from_unix_local.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_local(gint64 t)
     * }
     */
    public static MemorySegment g_date_time_new_from_unix_local(long t) {
        var mh$ = g_date_time_new_from_unix_local.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_from_unix_local", t);
            }
            return (MemorySegment)mh$.invokeExact(t);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_from_unix_utc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_from_unix_utc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_utc(gint64 t)
     * }
     */
    public static FunctionDescriptor g_date_time_new_from_unix_utc$descriptor() {
        return g_date_time_new_from_unix_utc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_utc(gint64 t)
     * }
     */
    public static MethodHandle g_date_time_new_from_unix_utc$handle() {
        return g_date_time_new_from_unix_utc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_utc(gint64 t)
     * }
     */
    public static MemorySegment g_date_time_new_from_unix_utc$address() {
        return g_date_time_new_from_unix_utc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_utc(gint64 t)
     * }
     */
    public static MemorySegment g_date_time_new_from_unix_utc(long t) {
        var mh$ = g_date_time_new_from_unix_utc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_from_unix_utc", t);
            }
            return (MemorySegment)mh$.invokeExact(t);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_from_unix_local_usec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_from_unix_local_usec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_local_usec(gint64 usecs)
     * }
     */
    public static FunctionDescriptor g_date_time_new_from_unix_local_usec$descriptor() {
        return g_date_time_new_from_unix_local_usec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_local_usec(gint64 usecs)
     * }
     */
    public static MethodHandle g_date_time_new_from_unix_local_usec$handle() {
        return g_date_time_new_from_unix_local_usec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_local_usec(gint64 usecs)
     * }
     */
    public static MemorySegment g_date_time_new_from_unix_local_usec$address() {
        return g_date_time_new_from_unix_local_usec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_local_usec(gint64 usecs)
     * }
     */
    public static MemorySegment g_date_time_new_from_unix_local_usec(long usecs) {
        var mh$ = g_date_time_new_from_unix_local_usec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_from_unix_local_usec", usecs);
            }
            return (MemorySegment)mh$.invokeExact(usecs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_from_unix_utc_usec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_from_unix_utc_usec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_utc_usec(gint64 usecs)
     * }
     */
    public static FunctionDescriptor g_date_time_new_from_unix_utc_usec$descriptor() {
        return g_date_time_new_from_unix_utc_usec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_utc_usec(gint64 usecs)
     * }
     */
    public static MethodHandle g_date_time_new_from_unix_utc_usec$handle() {
        return g_date_time_new_from_unix_utc_usec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_utc_usec(gint64 usecs)
     * }
     */
    public static MemorySegment g_date_time_new_from_unix_utc_usec$address() {
        return g_date_time_new_from_unix_utc_usec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_unix_utc_usec(gint64 usecs)
     * }
     */
    public static MemorySegment g_date_time_new_from_unix_utc_usec(long usecs) {
        var mh$ = g_date_time_new_from_unix_utc_usec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_from_unix_utc_usec", usecs);
            }
            return (MemorySegment)mh$.invokeExact(usecs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_from_timeval_local {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_from_timeval_local");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_timeval_local(const GTimeVal *tv)
     * }
     */
    public static FunctionDescriptor g_date_time_new_from_timeval_local$descriptor() {
        return g_date_time_new_from_timeval_local.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_timeval_local(const GTimeVal *tv)
     * }
     */
    public static MethodHandle g_date_time_new_from_timeval_local$handle() {
        return g_date_time_new_from_timeval_local.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_timeval_local(const GTimeVal *tv)
     * }
     */
    public static MemorySegment g_date_time_new_from_timeval_local$address() {
        return g_date_time_new_from_timeval_local.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_timeval_local(const GTimeVal *tv)
     * }
     */
    public static MemorySegment g_date_time_new_from_timeval_local(MemorySegment tv) {
        var mh$ = g_date_time_new_from_timeval_local.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_from_timeval_local", tv);
            }
            return (MemorySegment)mh$.invokeExact(tv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_from_timeval_utc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_from_timeval_utc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_timeval_utc(const GTimeVal *tv)
     * }
     */
    public static FunctionDescriptor g_date_time_new_from_timeval_utc$descriptor() {
        return g_date_time_new_from_timeval_utc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_timeval_utc(const GTimeVal *tv)
     * }
     */
    public static MethodHandle g_date_time_new_from_timeval_utc$handle() {
        return g_date_time_new_from_timeval_utc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_timeval_utc(const GTimeVal *tv)
     * }
     */
    public static MemorySegment g_date_time_new_from_timeval_utc$address() {
        return g_date_time_new_from_timeval_utc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_timeval_utc(const GTimeVal *tv)
     * }
     */
    public static MemorySegment g_date_time_new_from_timeval_utc(MemorySegment tv) {
        var mh$ = g_date_time_new_from_timeval_utc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_from_timeval_utc", tv);
            }
            return (MemorySegment)mh$.invokeExact(tv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_from_iso8601 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_from_iso8601");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_iso8601(const gchar *text, GTimeZone *default_tz)
     * }
     */
    public static FunctionDescriptor g_date_time_new_from_iso8601$descriptor() {
        return g_date_time_new_from_iso8601.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_iso8601(const gchar *text, GTimeZone *default_tz)
     * }
     */
    public static MethodHandle g_date_time_new_from_iso8601$handle() {
        return g_date_time_new_from_iso8601.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_iso8601(const gchar *text, GTimeZone *default_tz)
     * }
     */
    public static MemorySegment g_date_time_new_from_iso8601$address() {
        return g_date_time_new_from_iso8601.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_from_iso8601(const gchar *text, GTimeZone *default_tz)
     * }
     */
    public static MemorySegment g_date_time_new_from_iso8601(MemorySegment text, MemorySegment default_tz) {
        var mh$ = g_date_time_new_from_iso8601.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_from_iso8601", text, default_tz);
            }
            return (MemorySegment)mh$.invokeExact(text, default_tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new(GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static FunctionDescriptor g_date_time_new$descriptor() {
        return g_date_time_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new(GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MethodHandle g_date_time_new$handle() {
        return g_date_time_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new(GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_new$address() {
        return g_date_time_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new(GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_new(MemorySegment tz, int year, int month, int day, int hour, int minute, double seconds) {
        var mh$ = g_date_time_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new", tz, year, month, day, hour, minute, seconds);
            }
            return (MemorySegment)mh$.invokeExact(tz, year, month, day, hour, minute, seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_local {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_local");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_local(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static FunctionDescriptor g_date_time_new_local$descriptor() {
        return g_date_time_new_local.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_local(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MethodHandle g_date_time_new_local$handle() {
        return g_date_time_new_local.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_local(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_new_local$address() {
        return g_date_time_new_local.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_local(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_new_local(int year, int month, int day, int hour, int minute, double seconds) {
        var mh$ = g_date_time_new_local.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_local", year, month, day, hour, minute, seconds);
            }
            return (MemorySegment)mh$.invokeExact(year, month, day, hour, minute, seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_new_utc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_new_utc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_utc(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static FunctionDescriptor g_date_time_new_utc$descriptor() {
        return g_date_time_new_utc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_utc(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MethodHandle g_date_time_new_utc$handle() {
        return g_date_time_new_utc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_utc(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_new_utc$address() {
        return g_date_time_new_utc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_new_utc(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_new_utc(int year, int month, int day, int hour, int minute, double seconds) {
        var mh$ = g_date_time_new_utc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_new_utc", year, month, day, hour, minute, seconds);
            }
            return (MemorySegment)mh$.invokeExact(year, month, day, hour, minute, seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add(GDateTime *datetime, GTimeSpan timespan)
     * }
     */
    public static FunctionDescriptor g_date_time_add$descriptor() {
        return g_date_time_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add(GDateTime *datetime, GTimeSpan timespan)
     * }
     */
    public static MethodHandle g_date_time_add$handle() {
        return g_date_time_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add(GDateTime *datetime, GTimeSpan timespan)
     * }
     */
    public static MemorySegment g_date_time_add$address() {
        return g_date_time_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add(GDateTime *datetime, GTimeSpan timespan)
     * }
     */
    public static MemorySegment g_date_time_add(MemorySegment datetime, long timespan) {
        var mh$ = g_date_time_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add", datetime, timespan);
            }
            return (MemorySegment)mh$.invokeExact(datetime, timespan);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add_years {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add_years");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_years(GDateTime *datetime, gint years)
     * }
     */
    public static FunctionDescriptor g_date_time_add_years$descriptor() {
        return g_date_time_add_years.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_years(GDateTime *datetime, gint years)
     * }
     */
    public static MethodHandle g_date_time_add_years$handle() {
        return g_date_time_add_years.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_years(GDateTime *datetime, gint years)
     * }
     */
    public static MemorySegment g_date_time_add_years$address() {
        return g_date_time_add_years.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_years(GDateTime *datetime, gint years)
     * }
     */
    public static MemorySegment g_date_time_add_years(MemorySegment datetime, int years) {
        var mh$ = g_date_time_add_years.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add_years", datetime, years);
            }
            return (MemorySegment)mh$.invokeExact(datetime, years);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add_months {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add_months");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_months(GDateTime *datetime, gint months)
     * }
     */
    public static FunctionDescriptor g_date_time_add_months$descriptor() {
        return g_date_time_add_months.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_months(GDateTime *datetime, gint months)
     * }
     */
    public static MethodHandle g_date_time_add_months$handle() {
        return g_date_time_add_months.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_months(GDateTime *datetime, gint months)
     * }
     */
    public static MemorySegment g_date_time_add_months$address() {
        return g_date_time_add_months.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_months(GDateTime *datetime, gint months)
     * }
     */
    public static MemorySegment g_date_time_add_months(MemorySegment datetime, int months) {
        var mh$ = g_date_time_add_months.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add_months", datetime, months);
            }
            return (MemorySegment)mh$.invokeExact(datetime, months);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add_weeks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add_weeks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_weeks(GDateTime *datetime, gint weeks)
     * }
     */
    public static FunctionDescriptor g_date_time_add_weeks$descriptor() {
        return g_date_time_add_weeks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_weeks(GDateTime *datetime, gint weeks)
     * }
     */
    public static MethodHandle g_date_time_add_weeks$handle() {
        return g_date_time_add_weeks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_weeks(GDateTime *datetime, gint weeks)
     * }
     */
    public static MemorySegment g_date_time_add_weeks$address() {
        return g_date_time_add_weeks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_weeks(GDateTime *datetime, gint weeks)
     * }
     */
    public static MemorySegment g_date_time_add_weeks(MemorySegment datetime, int weeks) {
        var mh$ = g_date_time_add_weeks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add_weeks", datetime, weeks);
            }
            return (MemorySegment)mh$.invokeExact(datetime, weeks);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add_days {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add_days");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_days(GDateTime *datetime, gint days)
     * }
     */
    public static FunctionDescriptor g_date_time_add_days$descriptor() {
        return g_date_time_add_days.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_days(GDateTime *datetime, gint days)
     * }
     */
    public static MethodHandle g_date_time_add_days$handle() {
        return g_date_time_add_days.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_days(GDateTime *datetime, gint days)
     * }
     */
    public static MemorySegment g_date_time_add_days$address() {
        return g_date_time_add_days.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_days(GDateTime *datetime, gint days)
     * }
     */
    public static MemorySegment g_date_time_add_days(MemorySegment datetime, int days) {
        var mh$ = g_date_time_add_days.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add_days", datetime, days);
            }
            return (MemorySegment)mh$.invokeExact(datetime, days);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add_hours {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add_hours");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_hours(GDateTime *datetime, gint hours)
     * }
     */
    public static FunctionDescriptor g_date_time_add_hours$descriptor() {
        return g_date_time_add_hours.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_hours(GDateTime *datetime, gint hours)
     * }
     */
    public static MethodHandle g_date_time_add_hours$handle() {
        return g_date_time_add_hours.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_hours(GDateTime *datetime, gint hours)
     * }
     */
    public static MemorySegment g_date_time_add_hours$address() {
        return g_date_time_add_hours.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_hours(GDateTime *datetime, gint hours)
     * }
     */
    public static MemorySegment g_date_time_add_hours(MemorySegment datetime, int hours) {
        var mh$ = g_date_time_add_hours.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add_hours", datetime, hours);
            }
            return (MemorySegment)mh$.invokeExact(datetime, hours);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add_minutes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add_minutes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_minutes(GDateTime *datetime, gint minutes)
     * }
     */
    public static FunctionDescriptor g_date_time_add_minutes$descriptor() {
        return g_date_time_add_minutes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_minutes(GDateTime *datetime, gint minutes)
     * }
     */
    public static MethodHandle g_date_time_add_minutes$handle() {
        return g_date_time_add_minutes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_minutes(GDateTime *datetime, gint minutes)
     * }
     */
    public static MemorySegment g_date_time_add_minutes$address() {
        return g_date_time_add_minutes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_minutes(GDateTime *datetime, gint minutes)
     * }
     */
    public static MemorySegment g_date_time_add_minutes(MemorySegment datetime, int minutes) {
        var mh$ = g_date_time_add_minutes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add_minutes", datetime, minutes);
            }
            return (MemorySegment)mh$.invokeExact(datetime, minutes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add_seconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add_seconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_seconds(GDateTime *datetime, gdouble seconds)
     * }
     */
    public static FunctionDescriptor g_date_time_add_seconds$descriptor() {
        return g_date_time_add_seconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_seconds(GDateTime *datetime, gdouble seconds)
     * }
     */
    public static MethodHandle g_date_time_add_seconds$handle() {
        return g_date_time_add_seconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_seconds(GDateTime *datetime, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_add_seconds$address() {
        return g_date_time_add_seconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_seconds(GDateTime *datetime, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_add_seconds(MemorySegment datetime, double seconds) {
        var mh$ = g_date_time_add_seconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add_seconds", datetime, seconds);
            }
            return (MemorySegment)mh$.invokeExact(datetime, seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_add_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_add_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_full(GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds)
     * }
     */
    public static FunctionDescriptor g_date_time_add_full$descriptor() {
        return g_date_time_add_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_full(GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds)
     * }
     */
    public static MethodHandle g_date_time_add_full$handle() {
        return g_date_time_add_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_full(GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_add_full$address() {
        return g_date_time_add_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_add_full(GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds)
     * }
     */
    public static MemorySegment g_date_time_add_full(MemorySegment datetime, int years, int months, int days, int hours, int minutes, double seconds) {
        var mh$ = g_date_time_add_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_add_full", datetime, years, months, days, hours, minutes, seconds);
            }
            return (MemorySegment)mh$.invokeExact(datetime, years, months, days, hours, minutes, seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_compare(gconstpointer dt1, gconstpointer dt2)
     * }
     */
    public static FunctionDescriptor g_date_time_compare$descriptor() {
        return g_date_time_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_compare(gconstpointer dt1, gconstpointer dt2)
     * }
     */
    public static MethodHandle g_date_time_compare$handle() {
        return g_date_time_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_compare(gconstpointer dt1, gconstpointer dt2)
     * }
     */
    public static MemorySegment g_date_time_compare$address() {
        return g_date_time_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_compare(gconstpointer dt1, gconstpointer dt2)
     * }
     */
    public static int g_date_time_compare(MemorySegment dt1, MemorySegment dt2) {
        var mh$ = g_date_time_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_compare", dt1, dt2);
            }
            return (int)mh$.invokeExact(dt1, dt2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_difference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_difference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeSpan g_date_time_difference(GDateTime *end, GDateTime *begin)
     * }
     */
    public static FunctionDescriptor g_date_time_difference$descriptor() {
        return g_date_time_difference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeSpan g_date_time_difference(GDateTime *end, GDateTime *begin)
     * }
     */
    public static MethodHandle g_date_time_difference$handle() {
        return g_date_time_difference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeSpan g_date_time_difference(GDateTime *end, GDateTime *begin)
     * }
     */
    public static MemorySegment g_date_time_difference$address() {
        return g_date_time_difference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeSpan g_date_time_difference(GDateTime *end, GDateTime *begin)
     * }
     */
    public static long g_date_time_difference(MemorySegment end, MemorySegment begin) {
        var mh$ = g_date_time_difference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_difference", end, begin);
            }
            return (long)mh$.invokeExact(end, begin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_date_time_hash(gconstpointer datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_hash$descriptor() {
        return g_date_time_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_date_time_hash(gconstpointer datetime)
     * }
     */
    public static MethodHandle g_date_time_hash$handle() {
        return g_date_time_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_date_time_hash(gconstpointer datetime)
     * }
     */
    public static MemorySegment g_date_time_hash$address() {
        return g_date_time_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_date_time_hash(gconstpointer datetime)
     * }
     */
    public static int g_date_time_hash(MemorySegment datetime) {
        var mh$ = g_date_time_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_hash", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_equal(gconstpointer dt1, gconstpointer dt2)
     * }
     */
    public static FunctionDescriptor g_date_time_equal$descriptor() {
        return g_date_time_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_equal(gconstpointer dt1, gconstpointer dt2)
     * }
     */
    public static MethodHandle g_date_time_equal$handle() {
        return g_date_time_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_equal(gconstpointer dt1, gconstpointer dt2)
     * }
     */
    public static MemorySegment g_date_time_equal$address() {
        return g_date_time_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_time_equal(gconstpointer dt1, gconstpointer dt2)
     * }
     */
    public static int g_date_time_equal(MemorySegment dt1, MemorySegment dt2) {
        var mh$ = g_date_time_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_equal", dt1, dt2);
            }
            return (int)mh$.invokeExact(dt1, dt2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_ymd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_ymd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_time_get_ymd(GDateTime *datetime, gint *year, gint *month, gint *day)
     * }
     */
    public static FunctionDescriptor g_date_time_get_ymd$descriptor() {
        return g_date_time_get_ymd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_time_get_ymd(GDateTime *datetime, gint *year, gint *month, gint *day)
     * }
     */
    public static MethodHandle g_date_time_get_ymd$handle() {
        return g_date_time_get_ymd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_time_get_ymd(GDateTime *datetime, gint *year, gint *month, gint *day)
     * }
     */
    public static MemorySegment g_date_time_get_ymd$address() {
        return g_date_time_get_ymd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_time_get_ymd(GDateTime *datetime, gint *year, gint *month, gint *day)
     * }
     */
    public static void g_date_time_get_ymd(MemorySegment datetime, MemorySegment year, MemorySegment month, MemorySegment day) {
        var mh$ = g_date_time_get_ymd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_ymd", datetime, year, month, day);
            }
            mh$.invokeExact(datetime, year, month, day);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_year(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_year$descriptor() {
        return g_date_time_get_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_year(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_year$handle() {
        return g_date_time_get_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_year(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_year$address() {
        return g_date_time_get_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_year(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_year(MemorySegment datetime) {
        var mh$ = g_date_time_get_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_year", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_month {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_month");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_month(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_month$descriptor() {
        return g_date_time_get_month.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_month(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_month$handle() {
        return g_date_time_get_month.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_month(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_month$address() {
        return g_date_time_get_month.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_month(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_month(MemorySegment datetime) {
        var mh$ = g_date_time_get_month.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_month", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_day_of_month {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_day_of_month");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_month(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_day_of_month$descriptor() {
        return g_date_time_get_day_of_month.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_month(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_day_of_month$handle() {
        return g_date_time_get_day_of_month.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_month(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_day_of_month$address() {
        return g_date_time_get_day_of_month.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_month(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_day_of_month(MemorySegment datetime) {
        var mh$ = g_date_time_get_day_of_month.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_day_of_month", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_week_numbering_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_week_numbering_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_week_numbering_year(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_week_numbering_year$descriptor() {
        return g_date_time_get_week_numbering_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_week_numbering_year(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_week_numbering_year$handle() {
        return g_date_time_get_week_numbering_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_week_numbering_year(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_week_numbering_year$address() {
        return g_date_time_get_week_numbering_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_week_numbering_year(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_week_numbering_year(MemorySegment datetime) {
        var mh$ = g_date_time_get_week_numbering_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_week_numbering_year", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_week_of_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_week_of_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_week_of_year(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_week_of_year$descriptor() {
        return g_date_time_get_week_of_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_week_of_year(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_week_of_year$handle() {
        return g_date_time_get_week_of_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_week_of_year(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_week_of_year$address() {
        return g_date_time_get_week_of_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_week_of_year(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_week_of_year(MemorySegment datetime) {
        var mh$ = g_date_time_get_week_of_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_week_of_year", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_day_of_week {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_day_of_week");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_week(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_day_of_week$descriptor() {
        return g_date_time_get_day_of_week.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_week(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_day_of_week$handle() {
        return g_date_time_get_day_of_week.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_week(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_day_of_week$address() {
        return g_date_time_get_day_of_week.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_week(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_day_of_week(MemorySegment datetime) {
        var mh$ = g_date_time_get_day_of_week.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_day_of_week", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_day_of_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_day_of_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_year(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_day_of_year$descriptor() {
        return g_date_time_get_day_of_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_year(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_day_of_year$handle() {
        return g_date_time_get_day_of_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_year(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_day_of_year$address() {
        return g_date_time_get_day_of_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_day_of_year(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_day_of_year(MemorySegment datetime) {
        var mh$ = g_date_time_get_day_of_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_day_of_year", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_hour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_hour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_hour(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_hour$descriptor() {
        return g_date_time_get_hour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_hour(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_hour$handle() {
        return g_date_time_get_hour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_hour(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_hour$address() {
        return g_date_time_get_hour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_hour(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_hour(MemorySegment datetime) {
        var mh$ = g_date_time_get_hour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_hour", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_minute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_minute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_minute(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_minute$descriptor() {
        return g_date_time_get_minute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_minute(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_minute$handle() {
        return g_date_time_get_minute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_minute(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_minute$address() {
        return g_date_time_get_minute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_minute(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_minute(MemorySegment datetime) {
        var mh$ = g_date_time_get_minute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_minute", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_second {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_second");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_second(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_second$descriptor() {
        return g_date_time_get_second.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_second(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_second$handle() {
        return g_date_time_get_second.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_second(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_second$address() {
        return g_date_time_get_second.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_second(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_second(MemorySegment datetime) {
        var mh$ = g_date_time_get_second.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_second", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_microsecond {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_microsecond");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_microsecond(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_microsecond$descriptor() {
        return g_date_time_get_microsecond.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_microsecond(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_microsecond$handle() {
        return g_date_time_get_microsecond.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_time_get_microsecond(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_microsecond$address() {
        return g_date_time_get_microsecond.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_time_get_microsecond(GDateTime *datetime)
     * }
     */
    public static int g_date_time_get_microsecond(MemorySegment datetime) {
        var mh$ = g_date_time_get_microsecond.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_microsecond", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_seconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_seconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_date_time_get_seconds(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_seconds$descriptor() {
        return g_date_time_get_seconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_date_time_get_seconds(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_seconds$handle() {
        return g_date_time_get_seconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_date_time_get_seconds(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_seconds$address() {
        return g_date_time_get_seconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_date_time_get_seconds(GDateTime *datetime)
     * }
     */
    public static double g_date_time_get_seconds(MemorySegment datetime) {
        var mh$ = g_date_time_get_seconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_seconds", datetime);
            }
            return (double)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_to_unix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_to_unix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_date_time_to_unix(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_to_unix$descriptor() {
        return g_date_time_to_unix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_date_time_to_unix(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_to_unix$handle() {
        return g_date_time_to_unix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_date_time_to_unix(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_to_unix$address() {
        return g_date_time_to_unix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_date_time_to_unix(GDateTime *datetime)
     * }
     */
    public static long g_date_time_to_unix(MemorySegment datetime) {
        var mh$ = g_date_time_to_unix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_to_unix", datetime);
            }
            return (long)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_to_unix_usec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_to_unix_usec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_date_time_to_unix_usec(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_to_unix_usec$descriptor() {
        return g_date_time_to_unix_usec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_date_time_to_unix_usec(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_to_unix_usec$handle() {
        return g_date_time_to_unix_usec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_date_time_to_unix_usec(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_to_unix_usec$address() {
        return g_date_time_to_unix_usec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_date_time_to_unix_usec(GDateTime *datetime)
     * }
     */
    public static long g_date_time_to_unix_usec(MemorySegment datetime) {
        var mh$ = g_date_time_to_unix_usec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_to_unix_usec", datetime);
            }
            return (long)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_to_timeval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_to_timeval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_to_timeval(GDateTime *datetime, GTimeVal *tv)
     * }
     */
    public static FunctionDescriptor g_date_time_to_timeval$descriptor() {
        return g_date_time_to_timeval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_to_timeval(GDateTime *datetime, GTimeVal *tv)
     * }
     */
    public static MethodHandle g_date_time_to_timeval$handle() {
        return g_date_time_to_timeval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_to_timeval(GDateTime *datetime, GTimeVal *tv)
     * }
     */
    public static MemorySegment g_date_time_to_timeval$address() {
        return g_date_time_to_timeval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_time_to_timeval(GDateTime *datetime, GTimeVal *tv)
     * }
     */
    public static int g_date_time_to_timeval(MemorySegment datetime, MemorySegment tv) {
        var mh$ = g_date_time_to_timeval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_to_timeval", datetime, tv);
            }
            return (int)mh$.invokeExact(datetime, tv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_utc_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_utc_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_utc_offset$descriptor() {
        return g_date_time_get_utc_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_utc_offset$handle() {
        return g_date_time_get_utc_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_utc_offset$address() {
        return g_date_time_get_utc_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime)
     * }
     */
    public static long g_date_time_get_utc_offset(MemorySegment datetime) {
        var mh$ = g_date_time_get_utc_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_utc_offset", datetime);
            }
            return (long)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_timezone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_timezone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimeZone *g_date_time_get_timezone(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_timezone$descriptor() {
        return g_date_time_get_timezone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimeZone *g_date_time_get_timezone(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_timezone$handle() {
        return g_date_time_get_timezone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimeZone *g_date_time_get_timezone(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_timezone$address() {
        return g_date_time_get_timezone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimeZone *g_date_time_get_timezone(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_timezone(MemorySegment datetime) {
        var mh$ = g_date_time_get_timezone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_timezone", datetime);
            }
            return (MemorySegment)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_timezone_abbreviation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_timezone_abbreviation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_date_time_get_timezone_abbreviation(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_get_timezone_abbreviation$descriptor() {
        return g_date_time_get_timezone_abbreviation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_date_time_get_timezone_abbreviation(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_get_timezone_abbreviation$handle() {
        return g_date_time_get_timezone_abbreviation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_date_time_get_timezone_abbreviation(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_timezone_abbreviation$address() {
        return g_date_time_get_timezone_abbreviation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_date_time_get_timezone_abbreviation(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_get_timezone_abbreviation(MemorySegment datetime) {
        var mh$ = g_date_time_get_timezone_abbreviation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_timezone_abbreviation", datetime);
            }
            return (MemorySegment)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_is_daylight_savings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_is_daylight_savings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_is_daylight_savings$descriptor() {
        return g_date_time_is_daylight_savings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_is_daylight_savings$handle() {
        return g_date_time_is_daylight_savings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_is_daylight_savings$address() {
        return g_date_time_is_daylight_savings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime)
     * }
     */
    public static int g_date_time_is_daylight_savings(MemorySegment datetime) {
        var mh$ = g_date_time_is_daylight_savings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_is_daylight_savings", datetime);
            }
            return (int)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_to_timezone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_to_timezone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_timezone(GDateTime *datetime, GTimeZone *tz)
     * }
     */
    public static FunctionDescriptor g_date_time_to_timezone$descriptor() {
        return g_date_time_to_timezone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_timezone(GDateTime *datetime, GTimeZone *tz)
     * }
     */
    public static MethodHandle g_date_time_to_timezone$handle() {
        return g_date_time_to_timezone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_timezone(GDateTime *datetime, GTimeZone *tz)
     * }
     */
    public static MemorySegment g_date_time_to_timezone$address() {
        return g_date_time_to_timezone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_timezone(GDateTime *datetime, GTimeZone *tz)
     * }
     */
    public static MemorySegment g_date_time_to_timezone(MemorySegment datetime, MemorySegment tz) {
        var mh$ = g_date_time_to_timezone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_to_timezone", datetime, tz);
            }
            return (MemorySegment)mh$.invokeExact(datetime, tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_to_local {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_to_local");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_local(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_to_local$descriptor() {
        return g_date_time_to_local.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_local(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_to_local$handle() {
        return g_date_time_to_local.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_local(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_to_local$address() {
        return g_date_time_to_local.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_local(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_to_local(MemorySegment datetime) {
        var mh$ = g_date_time_to_local.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_to_local", datetime);
            }
            return (MemorySegment)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_to_utc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_to_utc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_utc(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_to_utc$descriptor() {
        return g_date_time_to_utc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_utc(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_to_utc$handle() {
        return g_date_time_to_utc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_utc(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_to_utc$address() {
        return g_date_time_to_utc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_date_time_to_utc(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_to_utc(MemorySegment datetime) {
        var mh$ = g_date_time_to_utc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_to_utc", datetime);
            }
            return (MemorySegment)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_date_time_format(GDateTime *datetime, const gchar *format)
     * }
     */
    public static FunctionDescriptor g_date_time_format$descriptor() {
        return g_date_time_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_date_time_format(GDateTime *datetime, const gchar *format)
     * }
     */
    public static MethodHandle g_date_time_format$handle() {
        return g_date_time_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_date_time_format(GDateTime *datetime, const gchar *format)
     * }
     */
    public static MemorySegment g_date_time_format$address() {
        return g_date_time_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_date_time_format(GDateTime *datetime, const gchar *format)
     * }
     */
    public static MemorySegment g_date_time_format(MemorySegment datetime, MemorySegment format) {
        var mh$ = g_date_time_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_format", datetime, format);
            }
            return (MemorySegment)mh$.invokeExact(datetime, format);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_format_iso8601 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_format_iso8601");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_date_time_format_iso8601(GDateTime *datetime)
     * }
     */
    public static FunctionDescriptor g_date_time_format_iso8601$descriptor() {
        return g_date_time_format_iso8601.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_date_time_format_iso8601(GDateTime *datetime)
     * }
     */
    public static MethodHandle g_date_time_format_iso8601$handle() {
        return g_date_time_format_iso8601.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_date_time_format_iso8601(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_format_iso8601$address() {
        return g_date_time_format_iso8601.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_date_time_format_iso8601(GDateTime *datetime)
     * }
     */
    public static MemorySegment g_date_time_format_iso8601(MemorySegment datetime) {
        var mh$ = g_date_time_format_iso8601.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_format_iso8601", datetime);
            }
            return (MemorySegment)mh$.invokeExact(datetime);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_BOOKMARK_FILE_ERROR_INVALID_URI = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BOOKMARK_FILE_ERROR_INVALID_URI = 0
     * }
     */
    public static int G_BOOKMARK_FILE_ERROR_INVALID_URI() {
        return G_BOOKMARK_FILE_ERROR_INVALID_URI;
    }
    private static final int G_BOOKMARK_FILE_ERROR_INVALID_VALUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1
     * }
     */
    public static int G_BOOKMARK_FILE_ERROR_INVALID_VALUE() {
        return G_BOOKMARK_FILE_ERROR_INVALID_VALUE;
    }
    private static final int G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2
     * }
     */
    public static int G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED() {
        return G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED;
    }
    private static final int G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3
     * }
     */
    public static int G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND() {
        return G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND;
    }
    private static final int G_BOOKMARK_FILE_ERROR_READ = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BOOKMARK_FILE_ERROR_READ = 4
     * }
     */
    public static int G_BOOKMARK_FILE_ERROR_READ() {
        return G_BOOKMARK_FILE_ERROR_READ;
    }
    private static final int G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5
     * }
     */
    public static int G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING() {
        return G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING;
    }
    private static final int G_BOOKMARK_FILE_ERROR_WRITE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BOOKMARK_FILE_ERROR_WRITE = 6
     * }
     */
    public static int G_BOOKMARK_FILE_ERROR_WRITE() {
        return G_BOOKMARK_FILE_ERROR_WRITE;
    }
    private static final int G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7
     * }
     */
    public static int G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND() {
        return G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND;
    }

    private static class g_bookmark_file_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_bookmark_file_error_quark()
     * }
     */
    public static FunctionDescriptor g_bookmark_file_error_quark$descriptor() {
        return g_bookmark_file_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_bookmark_file_error_quark()
     * }
     */
    public static MethodHandle g_bookmark_file_error_quark$handle() {
        return g_bookmark_file_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_bookmark_file_error_quark()
     * }
     */
    public static MemorySegment g_bookmark_file_error_quark$address() {
        return g_bookmark_file_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_bookmark_file_error_quark()
     * }
     */
    public static int g_bookmark_file_error_quark() {
        var mh$ = g_bookmark_file_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBookmarkFile *g_bookmark_file_new()
     * }
     */
    public static FunctionDescriptor g_bookmark_file_new$descriptor() {
        return g_bookmark_file_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBookmarkFile *g_bookmark_file_new()
     * }
     */
    public static MethodHandle g_bookmark_file_new$handle() {
        return g_bookmark_file_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBookmarkFile *g_bookmark_file_new()
     * }
     */
    public static MemorySegment g_bookmark_file_new$address() {
        return g_bookmark_file_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBookmarkFile *g_bookmark_file_new()
     * }
     */
    public static MemorySegment g_bookmark_file_new() {
        var mh$ = g_bookmark_file_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_free(GBookmarkFile *bookmark)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_free$descriptor() {
        return g_bookmark_file_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_free(GBookmarkFile *bookmark)
     * }
     */
    public static MethodHandle g_bookmark_file_free$handle() {
        return g_bookmark_file_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_free(GBookmarkFile *bookmark)
     * }
     */
    public static MemorySegment g_bookmark_file_free$address() {
        return g_bookmark_file_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_free(GBookmarkFile *bookmark)
     * }
     */
    public static void g_bookmark_file_free(MemorySegment bookmark) {
        var mh$ = g_bookmark_file_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_free", bookmark);
            }
            mh$.invokeExact(bookmark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBookmarkFile *g_bookmark_file_copy(GBookmarkFile *bookmark)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_copy$descriptor() {
        return g_bookmark_file_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBookmarkFile *g_bookmark_file_copy(GBookmarkFile *bookmark)
     * }
     */
    public static MethodHandle g_bookmark_file_copy$handle() {
        return g_bookmark_file_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBookmarkFile *g_bookmark_file_copy(GBookmarkFile *bookmark)
     * }
     */
    public static MemorySegment g_bookmark_file_copy$address() {
        return g_bookmark_file_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBookmarkFile *g_bookmark_file_copy(GBookmarkFile *bookmark)
     * }
     */
    public static MemorySegment g_bookmark_file_copy(MemorySegment bookmark) {
        var mh$ = g_bookmark_file_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_copy", bookmark);
            }
            return (MemorySegment)mh$.invokeExact(bookmark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_load_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_load_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark, const gchar *filename, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_load_from_file$descriptor() {
        return g_bookmark_file_load_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark, const gchar *filename, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_load_from_file$handle() {
        return g_bookmark_file_load_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark, const gchar *filename, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_load_from_file$address() {
        return g_bookmark_file_load_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark, const gchar *filename, GError **error)
     * }
     */
    public static int g_bookmark_file_load_from_file(MemorySegment bookmark, MemorySegment filename, MemorySegment error) {
        var mh$ = g_bookmark_file_load_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_load_from_file", bookmark, filename, error);
            }
            return (int)mh$.invokeExact(bookmark, filename, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_load_from_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_load_from_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_load_from_data$descriptor() {
        return g_bookmark_file_load_from_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_load_from_data$handle() {
        return g_bookmark_file_load_from_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_load_from_data$address() {
        return g_bookmark_file_load_from_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error)
     * }
     */
    public static int g_bookmark_file_load_from_data(MemorySegment bookmark, MemorySegment data, long length, MemorySegment error) {
        var mh$ = g_bookmark_file_load_from_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_load_from_data", bookmark, data, length, error);
            }
            return (int)mh$.invokeExact(bookmark, data, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_load_from_data_dirs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_load_from_data_dirs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_load_from_data_dirs$descriptor() {
        return g_bookmark_file_load_from_data_dirs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_load_from_data_dirs$handle() {
        return g_bookmark_file_load_from_data_dirs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_load_from_data_dirs$address() {
        return g_bookmark_file_load_from_data_dirs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error)
     * }
     */
    public static int g_bookmark_file_load_from_data_dirs(MemorySegment bookmark, MemorySegment file, MemorySegment full_path, MemorySegment error) {
        var mh$ = g_bookmark_file_load_from_data_dirs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_load_from_data_dirs", bookmark, file, full_path, error);
            }
            return (int)mh$.invokeExact(bookmark, file, full_path, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_to_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_to_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_to_data$descriptor() {
        return g_bookmark_file_to_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_to_data$handle() {
        return g_bookmark_file_to_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_to_data$address() {
        return g_bookmark_file_to_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_to_data(MemorySegment bookmark, MemorySegment length, MemorySegment error) {
        var mh$ = g_bookmark_file_to_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_to_data", bookmark, length, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_to_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_to_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark, const gchar *filename, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_to_file$descriptor() {
        return g_bookmark_file_to_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark, const gchar *filename, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_to_file$handle() {
        return g_bookmark_file_to_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark, const gchar *filename, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_to_file$address() {
        return g_bookmark_file_to_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark, const gchar *filename, GError **error)
     * }
     */
    public static int g_bookmark_file_to_file(MemorySegment bookmark, MemorySegment filename, MemorySegment error) {
        var mh$ = g_bookmark_file_to_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_to_file", bookmark, filename, error);
            }
            return (int)mh$.invokeExact(bookmark, filename, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_title {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_title");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_title(GBookmarkFile *bookmark, const gchar *uri, const gchar *title)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_title$descriptor() {
        return g_bookmark_file_set_title.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_title(GBookmarkFile *bookmark, const gchar *uri, const gchar *title)
     * }
     */
    public static MethodHandle g_bookmark_file_set_title$handle() {
        return g_bookmark_file_set_title.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_title(GBookmarkFile *bookmark, const gchar *uri, const gchar *title)
     * }
     */
    public static MemorySegment g_bookmark_file_set_title$address() {
        return g_bookmark_file_set_title.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_title(GBookmarkFile *bookmark, const gchar *uri, const gchar *title)
     * }
     */
    public static void g_bookmark_file_set_title(MemorySegment bookmark, MemorySegment uri, MemorySegment title) {
        var mh$ = g_bookmark_file_set_title.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_title", bookmark, uri, title);
            }
            mh$.invokeExact(bookmark, uri, title);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_title {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_title");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_title$descriptor() {
        return g_bookmark_file_get_title.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_title$handle() {
        return g_bookmark_file_get_title.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_title$address() {
        return g_bookmark_file_get_title.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_title(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_title.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_title", bookmark, uri, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_description(GBookmarkFile *bookmark, const gchar *uri, const gchar *description)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_description$descriptor() {
        return g_bookmark_file_set_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_description(GBookmarkFile *bookmark, const gchar *uri, const gchar *description)
     * }
     */
    public static MethodHandle g_bookmark_file_set_description$handle() {
        return g_bookmark_file_set_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_description(GBookmarkFile *bookmark, const gchar *uri, const gchar *description)
     * }
     */
    public static MemorySegment g_bookmark_file_set_description$address() {
        return g_bookmark_file_set_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_description(GBookmarkFile *bookmark, const gchar *uri, const gchar *description)
     * }
     */
    public static void g_bookmark_file_set_description(MemorySegment bookmark, MemorySegment uri, MemorySegment description) {
        var mh$ = g_bookmark_file_set_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_description", bookmark, uri, description);
            }
            mh$.invokeExact(bookmark, uri, description);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_description$descriptor() {
        return g_bookmark_file_get_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_description$handle() {
        return g_bookmark_file_get_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_description$address() {
        return g_bookmark_file_get_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_description(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_description", bookmark, uri, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_mime_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_mime_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_mime_type$descriptor() {
        return g_bookmark_file_set_mime_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type)
     * }
     */
    public static MethodHandle g_bookmark_file_set_mime_type$handle() {
        return g_bookmark_file_set_mime_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type)
     * }
     */
    public static MemorySegment g_bookmark_file_set_mime_type$address() {
        return g_bookmark_file_set_mime_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type)
     * }
     */
    public static void g_bookmark_file_set_mime_type(MemorySegment bookmark, MemorySegment uri, MemorySegment mime_type) {
        var mh$ = g_bookmark_file_set_mime_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_mime_type", bookmark, uri, mime_type);
            }
            mh$.invokeExact(bookmark, uri, mime_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_mime_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_mime_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_mime_type$descriptor() {
        return g_bookmark_file_get_mime_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_mime_type$handle() {
        return g_bookmark_file_get_mime_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_mime_type$address() {
        return g_bookmark_file_get_mime_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_mime_type(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_mime_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_mime_type", bookmark, uri, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_groups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_groups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_groups$descriptor() {
        return g_bookmark_file_set_groups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length)
     * }
     */
    public static MethodHandle g_bookmark_file_set_groups$handle() {
        return g_bookmark_file_set_groups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length)
     * }
     */
    public static MemorySegment g_bookmark_file_set_groups$address() {
        return g_bookmark_file_set_groups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length)
     * }
     */
    public static void g_bookmark_file_set_groups(MemorySegment bookmark, MemorySegment uri, MemorySegment groups, long length) {
        var mh$ = g_bookmark_file_set_groups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_groups", bookmark, uri, groups, length);
            }
            mh$.invokeExact(bookmark, uri, groups, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_add_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_add_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_add_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_add_group$descriptor() {
        return g_bookmark_file_add_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_add_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group)
     * }
     */
    public static MethodHandle g_bookmark_file_add_group$handle() {
        return g_bookmark_file_add_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_add_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group)
     * }
     */
    public static MemorySegment g_bookmark_file_add_group$address() {
        return g_bookmark_file_add_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_add_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group)
     * }
     */
    public static void g_bookmark_file_add_group(MemorySegment bookmark, MemorySegment uri, MemorySegment group) {
        var mh$ = g_bookmark_file_add_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_add_group", bookmark, uri, group);
            }
            mh$.invokeExact(bookmark, uri, group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_has_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_has_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_has_group$descriptor() {
        return g_bookmark_file_has_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_has_group$handle() {
        return g_bookmark_file_has_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_has_group$address() {
        return g_bookmark_file_has_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error)
     * }
     */
    public static int g_bookmark_file_has_group(MemorySegment bookmark, MemorySegment uri, MemorySegment group, MemorySegment error) {
        var mh$ = g_bookmark_file_has_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_has_group", bookmark, uri, group, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, group, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_groups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_groups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_groups$descriptor() {
        return g_bookmark_file_get_groups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_groups$handle() {
        return g_bookmark_file_get_groups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_groups$address() {
        return g_bookmark_file_get_groups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_groups(MemorySegment bookmark, MemorySegment uri, MemorySegment length, MemorySegment error) {
        var mh$ = g_bookmark_file_get_groups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_groups", bookmark, uri, length, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, uri, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_add_application {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_add_application");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_add_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_add_application$descriptor() {
        return g_bookmark_file_add_application.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_add_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec)
     * }
     */
    public static MethodHandle g_bookmark_file_add_application$handle() {
        return g_bookmark_file_add_application.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_add_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec)
     * }
     */
    public static MemorySegment g_bookmark_file_add_application$address() {
        return g_bookmark_file_add_application.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_add_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec)
     * }
     */
    public static void g_bookmark_file_add_application(MemorySegment bookmark, MemorySegment uri, MemorySegment name, MemorySegment exec) {
        var mh$ = g_bookmark_file_add_application.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_add_application", bookmark, uri, name, exec);
            }
            mh$.invokeExact(bookmark, uri, name, exec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_has_application {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_has_application");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_has_application$descriptor() {
        return g_bookmark_file_has_application.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_has_application$handle() {
        return g_bookmark_file_has_application.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_has_application$address() {
        return g_bookmark_file_has_application.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error)
     * }
     */
    public static int g_bookmark_file_has_application(MemorySegment bookmark, MemorySegment uri, MemorySegment name, MemorySegment error) {
        var mh$ = g_bookmark_file_has_application.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_has_application", bookmark, uri, name, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, name, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_applications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_applications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_applications$descriptor() {
        return g_bookmark_file_get_applications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_applications$handle() {
        return g_bookmark_file_get_applications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_applications$address() {
        return g_bookmark_file_get_applications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_applications(MemorySegment bookmark, MemorySegment uri, MemorySegment length, MemorySegment error) {
        var mh$ = g_bookmark_file_get_applications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_applications", bookmark, uri, length, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, uri, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_app_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_app_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_app_info$descriptor() {
        return g_bookmark_file_set_app_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_set_app_info$handle() {
        return g_bookmark_file_set_app_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_set_app_info$address() {
        return g_bookmark_file_set_app_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error)
     * }
     */
    public static int g_bookmark_file_set_app_info(MemorySegment bookmark, MemorySegment uri, MemorySegment name, MemorySegment exec, int count, long stamp, MemorySegment error) {
        var mh$ = g_bookmark_file_set_app_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_app_info", bookmark, uri, name, exec, count, stamp, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, name, exec, count, stamp, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_application_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_application_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_set_application_info(GBookmarkFile *bookmark, const char *uri, const char *name, const char *exec, int count, GDateTime *stamp, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_application_info$descriptor() {
        return g_bookmark_file_set_application_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_set_application_info(GBookmarkFile *bookmark, const char *uri, const char *name, const char *exec, int count, GDateTime *stamp, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_set_application_info$handle() {
        return g_bookmark_file_set_application_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_set_application_info(GBookmarkFile *bookmark, const char *uri, const char *name, const char *exec, int count, GDateTime *stamp, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_set_application_info$address() {
        return g_bookmark_file_set_application_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_set_application_info(GBookmarkFile *bookmark, const char *uri, const char *name, const char *exec, int count, GDateTime *stamp, GError **error)
     * }
     */
    public static int g_bookmark_file_set_application_info(MemorySegment bookmark, MemorySegment uri, MemorySegment name, MemorySegment exec, int count, MemorySegment stamp, MemorySegment error) {
        var mh$ = g_bookmark_file_set_application_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_application_info", bookmark, uri, name, exec, count, stamp, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, name, exec, count, stamp, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_app_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_app_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_app_info$descriptor() {
        return g_bookmark_file_get_app_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_app_info$handle() {
        return g_bookmark_file_get_app_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_app_info$address() {
        return g_bookmark_file_get_app_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error)
     * }
     */
    public static int g_bookmark_file_get_app_info(MemorySegment bookmark, MemorySegment uri, MemorySegment name, MemorySegment exec, MemorySegment count, MemorySegment stamp, MemorySegment error) {
        var mh$ = g_bookmark_file_get_app_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_app_info", bookmark, uri, name, exec, count, stamp, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, name, exec, count, stamp, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_application_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_application_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_application_info(GBookmarkFile *bookmark, const char *uri, const char *name, char **exec, unsigned int *count, GDateTime **stamp, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_application_info$descriptor() {
        return g_bookmark_file_get_application_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_application_info(GBookmarkFile *bookmark, const char *uri, const char *name, char **exec, unsigned int *count, GDateTime **stamp, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_application_info$handle() {
        return g_bookmark_file_get_application_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_application_info(GBookmarkFile *bookmark, const char *uri, const char *name, char **exec, unsigned int *count, GDateTime **stamp, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_application_info$address() {
        return g_bookmark_file_get_application_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_application_info(GBookmarkFile *bookmark, const char *uri, const char *name, char **exec, unsigned int *count, GDateTime **stamp, GError **error)
     * }
     */
    public static int g_bookmark_file_get_application_info(MemorySegment bookmark, MemorySegment uri, MemorySegment name, MemorySegment exec, MemorySegment count, MemorySegment stamp, MemorySegment error) {
        var mh$ = g_bookmark_file_get_application_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_application_info", bookmark, uri, name, exec, count, stamp, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, name, exec, count, stamp, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_is_private {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_is_private");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark, const gchar *uri, gboolean is_private)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_is_private$descriptor() {
        return g_bookmark_file_set_is_private.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark, const gchar *uri, gboolean is_private)
     * }
     */
    public static MethodHandle g_bookmark_file_set_is_private$handle() {
        return g_bookmark_file_set_is_private.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark, const gchar *uri, gboolean is_private)
     * }
     */
    public static MemorySegment g_bookmark_file_set_is_private$address() {
        return g_bookmark_file_set_is_private.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark, const gchar *uri, gboolean is_private)
     * }
     */
    public static void g_bookmark_file_set_is_private(MemorySegment bookmark, MemorySegment uri, int is_private) {
        var mh$ = g_bookmark_file_set_is_private.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_is_private", bookmark, uri, is_private);
            }
            mh$.invokeExact(bookmark, uri, is_private);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_is_private {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_is_private");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_is_private$descriptor() {
        return g_bookmark_file_get_is_private.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_is_private$handle() {
        return g_bookmark_file_get_is_private.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_is_private$address() {
        return g_bookmark_file_get_is_private.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static int g_bookmark_file_get_is_private(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_is_private.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_is_private", bookmark, uri, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_icon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_icon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_icon$descriptor() {
        return g_bookmark_file_set_icon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type)
     * }
     */
    public static MethodHandle g_bookmark_file_set_icon$handle() {
        return g_bookmark_file_set_icon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type)
     * }
     */
    public static MemorySegment g_bookmark_file_set_icon$address() {
        return g_bookmark_file_set_icon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type)
     * }
     */
    public static void g_bookmark_file_set_icon(MemorySegment bookmark, MemorySegment uri, MemorySegment href, MemorySegment mime_type) {
        var mh$ = g_bookmark_file_set_icon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_icon", bookmark, uri, href, mime_type);
            }
            mh$.invokeExact(bookmark, uri, href, mime_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_icon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_icon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_icon$descriptor() {
        return g_bookmark_file_get_icon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_icon$handle() {
        return g_bookmark_file_get_icon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_icon$address() {
        return g_bookmark_file_get_icon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error)
     * }
     */
    public static int g_bookmark_file_get_icon(MemorySegment bookmark, MemorySegment uri, MemorySegment href, MemorySegment mime_type, MemorySegment error) {
        var mh$ = g_bookmark_file_get_icon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_icon", bookmark, uri, href, mime_type, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, href, mime_type, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_added {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_added");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_added(GBookmarkFile *bookmark, const gchar *uri, time_t added)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_added$descriptor() {
        return g_bookmark_file_set_added.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_added(GBookmarkFile *bookmark, const gchar *uri, time_t added)
     * }
     */
    public static MethodHandle g_bookmark_file_set_added$handle() {
        return g_bookmark_file_set_added.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_added(GBookmarkFile *bookmark, const gchar *uri, time_t added)
     * }
     */
    public static MemorySegment g_bookmark_file_set_added$address() {
        return g_bookmark_file_set_added.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_added(GBookmarkFile *bookmark, const gchar *uri, time_t added)
     * }
     */
    public static void g_bookmark_file_set_added(MemorySegment bookmark, MemorySegment uri, long added) {
        var mh$ = g_bookmark_file_set_added.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_added", bookmark, uri, added);
            }
            mh$.invokeExact(bookmark, uri, added);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_added_date_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_added_date_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_added_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *added)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_added_date_time$descriptor() {
        return g_bookmark_file_set_added_date_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_added_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *added)
     * }
     */
    public static MethodHandle g_bookmark_file_set_added_date_time$handle() {
        return g_bookmark_file_set_added_date_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_added_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *added)
     * }
     */
    public static MemorySegment g_bookmark_file_set_added_date_time$address() {
        return g_bookmark_file_set_added_date_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_added_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *added)
     * }
     */
    public static void g_bookmark_file_set_added_date_time(MemorySegment bookmark, MemorySegment uri, MemorySegment added) {
        var mh$ = g_bookmark_file_set_added_date_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_added_date_time", bookmark, uri, added);
            }
            mh$.invokeExact(bookmark, uri, added);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_added {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_added");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_added$descriptor() {
        return g_bookmark_file_get_added.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_added$handle() {
        return g_bookmark_file_get_added.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_added$address() {
        return g_bookmark_file_get_added.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static long g_bookmark_file_get_added(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_added.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_added", bookmark, uri, error);
            }
            return (long)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_added_date_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_added_date_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_added_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_added_date_time$descriptor() {
        return g_bookmark_file_get_added_date_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_added_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_added_date_time$handle() {
        return g_bookmark_file_get_added_date_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_added_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_added_date_time$address() {
        return g_bookmark_file_get_added_date_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_added_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_added_date_time(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_added_date_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_added_date_time", bookmark, uri, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_modified {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_modified");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark, const gchar *uri, time_t modified)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_modified$descriptor() {
        return g_bookmark_file_set_modified.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark, const gchar *uri, time_t modified)
     * }
     */
    public static MethodHandle g_bookmark_file_set_modified$handle() {
        return g_bookmark_file_set_modified.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark, const gchar *uri, time_t modified)
     * }
     */
    public static MemorySegment g_bookmark_file_set_modified$address() {
        return g_bookmark_file_set_modified.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark, const gchar *uri, time_t modified)
     * }
     */
    public static void g_bookmark_file_set_modified(MemorySegment bookmark, MemorySegment uri, long modified) {
        var mh$ = g_bookmark_file_set_modified.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_modified", bookmark, uri, modified);
            }
            mh$.invokeExact(bookmark, uri, modified);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_modified_date_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_modified_date_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_modified_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *modified)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_modified_date_time$descriptor() {
        return g_bookmark_file_set_modified_date_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_modified_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *modified)
     * }
     */
    public static MethodHandle g_bookmark_file_set_modified_date_time$handle() {
        return g_bookmark_file_set_modified_date_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_modified_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *modified)
     * }
     */
    public static MemorySegment g_bookmark_file_set_modified_date_time$address() {
        return g_bookmark_file_set_modified_date_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_modified_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *modified)
     * }
     */
    public static void g_bookmark_file_set_modified_date_time(MemorySegment bookmark, MemorySegment uri, MemorySegment modified) {
        var mh$ = g_bookmark_file_set_modified_date_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_modified_date_time", bookmark, uri, modified);
            }
            mh$.invokeExact(bookmark, uri, modified);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_modified {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_modified");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_modified$descriptor() {
        return g_bookmark_file_get_modified.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_modified$handle() {
        return g_bookmark_file_get_modified.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_modified$address() {
        return g_bookmark_file_get_modified.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static long g_bookmark_file_get_modified(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_modified.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_modified", bookmark, uri, error);
            }
            return (long)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_modified_date_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_modified_date_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_modified_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_modified_date_time$descriptor() {
        return g_bookmark_file_get_modified_date_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_modified_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_modified_date_time$handle() {
        return g_bookmark_file_get_modified_date_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_modified_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_modified_date_time$address() {
        return g_bookmark_file_get_modified_date_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_modified_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_modified_date_time(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_modified_date_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_modified_date_time", bookmark, uri, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_visited {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_visited");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark, const gchar *uri, time_t visited)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_visited$descriptor() {
        return g_bookmark_file_set_visited.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark, const gchar *uri, time_t visited)
     * }
     */
    public static MethodHandle g_bookmark_file_set_visited$handle() {
        return g_bookmark_file_set_visited.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark, const gchar *uri, time_t visited)
     * }
     */
    public static MemorySegment g_bookmark_file_set_visited$address() {
        return g_bookmark_file_set_visited.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark, const gchar *uri, time_t visited)
     * }
     */
    public static void g_bookmark_file_set_visited(MemorySegment bookmark, MemorySegment uri, long visited) {
        var mh$ = g_bookmark_file_set_visited.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_visited", bookmark, uri, visited);
            }
            mh$.invokeExact(bookmark, uri, visited);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_set_visited_date_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_set_visited_date_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_visited_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *visited)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_set_visited_date_time$descriptor() {
        return g_bookmark_file_set_visited_date_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_visited_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *visited)
     * }
     */
    public static MethodHandle g_bookmark_file_set_visited_date_time$handle() {
        return g_bookmark_file_set_visited_date_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_visited_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *visited)
     * }
     */
    public static MemorySegment g_bookmark_file_set_visited_date_time$address() {
        return g_bookmark_file_set_visited_date_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bookmark_file_set_visited_date_time(GBookmarkFile *bookmark, const char *uri, GDateTime *visited)
     * }
     */
    public static void g_bookmark_file_set_visited_date_time(MemorySegment bookmark, MemorySegment uri, MemorySegment visited) {
        var mh$ = g_bookmark_file_set_visited_date_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_set_visited_date_time", bookmark, uri, visited);
            }
            mh$.invokeExact(bookmark, uri, visited);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_visited {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_visited");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_visited$descriptor() {
        return g_bookmark_file_get_visited.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_visited$handle() {
        return g_bookmark_file_get_visited.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_visited$address() {
        return g_bookmark_file_get_visited.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static long g_bookmark_file_get_visited(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_visited.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_visited", bookmark, uri, error);
            }
            return (long)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_visited_date_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_visited_date_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_visited_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_visited_date_time$descriptor() {
        return g_bookmark_file_get_visited_date_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_visited_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_get_visited_date_time$handle() {
        return g_bookmark_file_get_visited_date_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_visited_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_visited_date_time$address() {
        return g_bookmark_file_get_visited_date_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateTime *g_bookmark_file_get_visited_date_time(GBookmarkFile *bookmark, const char *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_get_visited_date_time(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_get_visited_date_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_visited_date_time", bookmark, uri, error);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_has_item {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_has_item");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark, const gchar *uri)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_has_item$descriptor() {
        return g_bookmark_file_has_item.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark, const gchar *uri)
     * }
     */
    public static MethodHandle g_bookmark_file_has_item$handle() {
        return g_bookmark_file_has_item.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark, const gchar *uri)
     * }
     */
    public static MemorySegment g_bookmark_file_has_item$address() {
        return g_bookmark_file_has_item.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark, const gchar *uri)
     * }
     */
    public static int g_bookmark_file_has_item(MemorySegment bookmark, MemorySegment uri) {
        var mh$ = g_bookmark_file_has_item.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_has_item", bookmark, uri);
            }
            return (int)mh$.invokeExact(bookmark, uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_size$descriptor() {
        return g_bookmark_file_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark)
     * }
     */
    public static MethodHandle g_bookmark_file_get_size$handle() {
        return g_bookmark_file_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark)
     * }
     */
    public static MemorySegment g_bookmark_file_get_size$address() {
        return g_bookmark_file_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark)
     * }
     */
    public static int g_bookmark_file_get_size(MemorySegment bookmark) {
        var mh$ = g_bookmark_file_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_size", bookmark);
            }
            return (int)mh$.invokeExact(bookmark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_uris {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_uris");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark, gsize *length)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_uris$descriptor() {
        return g_bookmark_file_get_uris.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark, gsize *length)
     * }
     */
    public static MethodHandle g_bookmark_file_get_uris$handle() {
        return g_bookmark_file_get_uris.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark, gsize *length)
     * }
     */
    public static MemorySegment g_bookmark_file_get_uris$address() {
        return g_bookmark_file_get_uris.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark, gsize *length)
     * }
     */
    public static MemorySegment g_bookmark_file_get_uris(MemorySegment bookmark, MemorySegment length) {
        var mh$ = g_bookmark_file_get_uris.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_uris", bookmark, length);
            }
            return (MemorySegment)mh$.invokeExact(bookmark, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_remove_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_remove_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_remove_group$descriptor() {
        return g_bookmark_file_remove_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_remove_group$handle() {
        return g_bookmark_file_remove_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_remove_group$address() {
        return g_bookmark_file_remove_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error)
     * }
     */
    public static int g_bookmark_file_remove_group(MemorySegment bookmark, MemorySegment uri, MemorySegment group, MemorySegment error) {
        var mh$ = g_bookmark_file_remove_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_remove_group", bookmark, uri, group, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, group, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_remove_application {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_remove_application");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_remove_application$descriptor() {
        return g_bookmark_file_remove_application.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_remove_application$handle() {
        return g_bookmark_file_remove_application.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_remove_application$address() {
        return g_bookmark_file_remove_application.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error)
     * }
     */
    public static int g_bookmark_file_remove_application(MemorySegment bookmark, MemorySegment uri, MemorySegment name, MemorySegment error) {
        var mh$ = g_bookmark_file_remove_application.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_remove_application", bookmark, uri, name, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, name, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_remove_item {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_remove_item");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_remove_item$descriptor() {
        return g_bookmark_file_remove_item.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_remove_item$handle() {
        return g_bookmark_file_remove_item.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_remove_item$address() {
        return g_bookmark_file_remove_item.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark, const gchar *uri, GError **error)
     * }
     */
    public static int g_bookmark_file_remove_item(MemorySegment bookmark, MemorySegment uri, MemorySegment error) {
        var mh$ = g_bookmark_file_remove_item.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_remove_item", bookmark, uri, error);
            }
            return (int)mh$.invokeExact(bookmark, uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_move_item {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_move_item");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error)
     * }
     */
    public static FunctionDescriptor g_bookmark_file_move_item$descriptor() {
        return g_bookmark_file_move_item.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error)
     * }
     */
    public static MethodHandle g_bookmark_file_move_item$handle() {
        return g_bookmark_file_move_item.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error)
     * }
     */
    public static MemorySegment g_bookmark_file_move_item$address() {
        return g_bookmark_file_move_item.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error)
     * }
     */
    public static int g_bookmark_file_move_item(MemorySegment bookmark, MemorySegment old_uri, MemorySegment new_uri, MemorySegment error) {
        var mh$ = g_bookmark_file_move_item.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_move_item", bookmark, old_uri, new_uri, error);
            }
            return (int)mh$.invokeExact(bookmark, old_uri, new_uri, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new(gconstpointer data, gsize size)
     * }
     */
    public static FunctionDescriptor g_bytes_new$descriptor() {
        return g_bytes_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new(gconstpointer data, gsize size)
     * }
     */
    public static MethodHandle g_bytes_new$handle() {
        return g_bytes_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new(gconstpointer data, gsize size)
     * }
     */
    public static MemorySegment g_bytes_new$address() {
        return g_bytes_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new(gconstpointer data, gsize size)
     * }
     */
    public static MemorySegment g_bytes_new(MemorySegment data, long size) {
        var mh$ = g_bytes_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_new", data, size);
            }
            return (MemorySegment)mh$.invokeExact(data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_new_take {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_new_take");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_take(gpointer data, gsize size)
     * }
     */
    public static FunctionDescriptor g_bytes_new_take$descriptor() {
        return g_bytes_new_take.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_take(gpointer data, gsize size)
     * }
     */
    public static MethodHandle g_bytes_new_take$handle() {
        return g_bytes_new_take.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_take(gpointer data, gsize size)
     * }
     */
    public static MemorySegment g_bytes_new_take$address() {
        return g_bytes_new_take.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_take(gpointer data, gsize size)
     * }
     */
    public static MemorySegment g_bytes_new_take(MemorySegment data, long size) {
        var mh$ = g_bytes_new_take.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_new_take", data, size);
            }
            return (MemorySegment)mh$.invokeExact(data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_new_static {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_new_static");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_static(gconstpointer data, gsize size)
     * }
     */
    public static FunctionDescriptor g_bytes_new_static$descriptor() {
        return g_bytes_new_static.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_static(gconstpointer data, gsize size)
     * }
     */
    public static MethodHandle g_bytes_new_static$handle() {
        return g_bytes_new_static.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_static(gconstpointer data, gsize size)
     * }
     */
    public static MemorySegment g_bytes_new_static$address() {
        return g_bytes_new_static.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_static(gconstpointer data, gsize size)
     * }
     */
    public static MemorySegment g_bytes_new_static(MemorySegment data, long size) {
        var mh$ = g_bytes_new_static.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_new_static", data, size);
            }
            return (MemorySegment)mh$.invokeExact(data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_new_with_free_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_new_with_free_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_with_free_func(gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_bytes_new_with_free_func$descriptor() {
        return g_bytes_new_with_free_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_with_free_func(gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_bytes_new_with_free_func$handle() {
        return g_bytes_new_with_free_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_with_free_func(gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_bytes_new_with_free_func$address() {
        return g_bytes_new_with_free_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_with_free_func(gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_bytes_new_with_free_func(MemorySegment data, long size, MemorySegment free_func, MemorySegment user_data) {
        var mh$ = g_bytes_new_with_free_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_new_with_free_func", data, size, free_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(data, size, free_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_new_from_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_new_from_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_from_bytes(GBytes *bytes, gsize offset, gsize length)
     * }
     */
    public static FunctionDescriptor g_bytes_new_from_bytes$descriptor() {
        return g_bytes_new_from_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_from_bytes(GBytes *bytes, gsize offset, gsize length)
     * }
     */
    public static MethodHandle g_bytes_new_from_bytes$handle() {
        return g_bytes_new_from_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_from_bytes(GBytes *bytes, gsize offset, gsize length)
     * }
     */
    public static MemorySegment g_bytes_new_from_bytes$address() {
        return g_bytes_new_from_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_bytes_new_from_bytes(GBytes *bytes, gsize offset, gsize length)
     * }
     */
    public static MemorySegment g_bytes_new_from_bytes(MemorySegment bytes, long offset, long length) {
        var mh$ = g_bytes_new_from_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_new_from_bytes", bytes, offset, length);
            }
            return (MemorySegment)mh$.invokeExact(bytes, offset, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gconstpointer g_bytes_get_data(GBytes *bytes, gsize *size)
     * }
     */
    public static FunctionDescriptor g_bytes_get_data$descriptor() {
        return g_bytes_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gconstpointer g_bytes_get_data(GBytes *bytes, gsize *size)
     * }
     */
    public static MethodHandle g_bytes_get_data$handle() {
        return g_bytes_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gconstpointer g_bytes_get_data(GBytes *bytes, gsize *size)
     * }
     */
    public static MemorySegment g_bytes_get_data$address() {
        return g_bytes_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gconstpointer g_bytes_get_data(GBytes *bytes, gsize *size)
     * }
     */
    public static MemorySegment g_bytes_get_data(MemorySegment bytes, MemorySegment size) {
        var mh$ = g_bytes_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_get_data", bytes, size);
            }
            return (MemorySegment)mh$.invokeExact(bytes, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

