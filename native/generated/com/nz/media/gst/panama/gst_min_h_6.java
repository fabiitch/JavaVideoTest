// Generated by jextract

package com.nz.media.gst.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class gst_min_h_6 extends gst_min_h_7 {

    gst_min_h_6() {
        // Should not be called directly
    }

    private static class _itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa$descriptor() {
        return _itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itoa$handle() {
        return _itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa$address() {
        return _itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ltoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa_s$descriptor() {
        return _ltoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltoa_s$handle() {
        return _ltoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltoa_s$address() {
        return _ltoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa$descriptor() {
        return _ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltoa$handle() {
        return _ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa$address() {
        return _ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ultoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa_s$descriptor() {
        return _ultoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultoa_s$handle() {
        return _ultoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultoa_s$address() {
        return _ultoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa$descriptor() {
        return _ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultoa$handle() {
        return _ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa$address() {
        return _ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_i64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa_s$descriptor() {
        return _i64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64toa_s$handle() {
        return _i64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64toa_s$address() {
        return _i64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_i64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa$descriptor() {
        return _i64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64toa$handle() {
        return _i64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa$address() {
        return _i64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ui64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa_s$descriptor() {
        return _ui64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa_s$handle() {
        return _ui64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa_s$address() {
        return _ui64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ui64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa$descriptor() {
        return _ui64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa$handle() {
        return _ui64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa$address() {
        return _ui64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ecvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt_s$descriptor() {
        return _ecvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt_s$handle() {
        return _ecvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt_s$address() {
        return _ecvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _ecvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt_s", _Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt$descriptor() {
        return _ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt$handle() {
        return _ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt$address() {
        return _ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt_s$descriptor() {
        return _fcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt_s$handle() {
        return _fcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt_s$address() {
        return _fcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _fcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt_s", _Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt$descriptor() {
        return _fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt$handle() {
        return _fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt$address() {
        return _fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_gcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static FunctionDescriptor _gcvt_s$descriptor() {
        return _gcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MethodHandle _gcvt_s$handle() {
        return _gcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MemorySegment _gcvt_s$address() {
        return _gcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static int _gcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount) {
        var mh$ = _gcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt_s", _Buffer, _BufferCount, _Value, _DigitCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _gcvt$descriptor() {
        return _gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MethodHandle _gcvt$handle() {
        return _gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt$address() {
        return _gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt(double _Value, int _DigitCount, MemorySegment _Buffer) {
        var mh$ = _gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt", _Value, _DigitCount, _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("___mb_cur_max_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_func$descriptor() {
        return ___mb_cur_max_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MethodHandle ___mb_cur_max_func$handle() {
        return ___mb_cur_max_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MemorySegment ___mb_cur_max_func$address() {
        return ___mb_cur_max_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static int ___mb_cur_max_func() {
        var mh$ = ___mb_cur_max_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_func");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_l_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("___mb_cur_max_l_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_l_func$descriptor() {
        return ___mb_cur_max_l_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MethodHandle ___mb_cur_max_l_func$handle() {
        return ___mb_cur_max_l_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MemorySegment ___mb_cur_max_l_func$address() {
        return ___mb_cur_max_l_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static int ___mb_cur_max_l_func(MemorySegment _Locale) {
        var mh$ = ___mb_cur_max_l_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_l_func", _Locale);
            }
            return (int)mh$.invokeExact(_Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static int mblen(MemorySegment _Ch, long _MaxCount) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", _Ch, _MaxCount);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mblen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mblen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mblen_l$descriptor() {
        return _mblen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mblen_l$handle() {
        return _mblen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mblen_l$address() {
        return _mblen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mblen_l(MemorySegment _Ch, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mblen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mblen_l", _Ch, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static FunctionDescriptor _mbstrlen$descriptor() {
        return _mbstrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MethodHandle _mbstrlen$handle() {
        return _mbstrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MemorySegment _mbstrlen$address() {
        return _mbstrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static long _mbstrlen(MemorySegment _String) {
        var mh$ = _mbstrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstrlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrlen_l$descriptor() {
        return _mbstrlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrlen_l$handle() {
        return _mbstrlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrlen_l$address() {
        return _mbstrlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _mbstrlen_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _mbstrlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstrnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _mbstrnlen$descriptor() {
        return _mbstrnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle _mbstrnlen$handle() {
        return _mbstrnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment _mbstrnlen$address() {
        return _mbstrnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long _mbstrnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = _mbstrnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstrnlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrnlen_l$descriptor() {
        return _mbstrnlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrnlen_l$handle() {
        return _mbstrnlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrnlen_l$address() {
        return _mbstrnlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstrnlen_l(MemorySegment _String, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstrnlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen_l", _String, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_String, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static int mbtowc(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", _DstCh, _SrcCh, _SrcSizeInBytes);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbtowc_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbtowc_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbtowc_l$descriptor() {
        return _mbtowc_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbtowc_l$handle() {
        return _mbtowc_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbtowc_l$address() {
        return _mbtowc_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static int _mbtowc_l(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes, MemorySegment _Locale) {
        var mh$ = _mbtowc_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbtowc_l", _DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs_s$descriptor() {
        return mbstowcs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs_s$handle() {
        return mbstowcs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs_s$address() {
        return mbstowcs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static int mbstowcs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount) {
        var mh$ = mbstowcs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs_s", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long mbstowcs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstowcs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_s_l$descriptor() {
        return _mbstowcs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_s_l$handle() {
        return _mbstowcs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_s_l$address() {
        return _mbstowcs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mbstowcs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_s_l", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstowcs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_l$descriptor() {
        return _mbstowcs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_l$handle() {
        return _mbstowcs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_l$address() {
        return _mbstowcs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstowcs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static int wctomb(MemorySegment _MbCh, short _WCh) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", _MbCh, _WCh);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wctomb_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_l$descriptor() {
        return _wctomb_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_l$handle() {
        return _wctomb_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_l$address() {
        return _wctomb_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_l(MemorySegment _MbCh, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_l", _MbCh, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb_s$descriptor() {
        return wctomb_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb_s$handle() {
        return wctomb_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb_s$address() {
        return wctomb_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static int wctomb_s(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh) {
        var mh$ = wctomb_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb_s", _SizeConverted, _MbCh, _SizeInBytes, _WCh);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_SHORT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wctomb_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_s_l$descriptor() {
        return _wctomb_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_s_l$handle() {
        return _wctomb_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_s_l$address() {
        return _wctomb_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_s_l(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_s_l", _SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static FunctionDescriptor wcstombs_s$descriptor() {
        return wcstombs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MethodHandle wcstombs_s$handle() {
        return wcstombs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MemorySegment wcstombs_s$address() {
        return wcstombs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static int wcstombs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes) {
        var mh$ = wcstombs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs_s", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcstombs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstombs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_s_l$descriptor() {
        return _wcstombs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_s_l$handle() {
        return _wcstombs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_s_l$address() {
        return _wcstombs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static int _wcstombs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes, MemorySegment _Locale) {
        var mh$ = _wcstombs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_s_l", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstombs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_l$descriptor() {
        return _wcstombs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_l$handle() {
        return _wcstombs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_l$address() {
        return _wcstombs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcstombs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcstombs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _fullpath$descriptor() {
        return _fullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _fullpath$handle() {
        return _fullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath$address() {
        return _fullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _fullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_makepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath_s$descriptor() {
        return _makepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath_s$handle() {
        return _makepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath_s$address() {
        return _makepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static int _makepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_makepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath$descriptor() {
        return _makepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath$handle() {
        return _makepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath$address() {
        return _makepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static void _makepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_splitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static FunctionDescriptor _splitpath$descriptor() {
        return _splitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MethodHandle _splitpath$handle() {
        return _splitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MemorySegment _splitpath$address() {
        return _splitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static void _splitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _splitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_splitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _splitpath_s$descriptor() {
        return _splitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _splitpath_s$handle() {
        return _splitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _splitpath_s$address() {
        return _splitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static int _splitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _splitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv_s$descriptor() {
        return getenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle getenv_s$handle() {
        return getenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment getenv_s$address() {
        return getenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static int getenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = getenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p___argc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static FunctionDescriptor __p___argc$descriptor() {
        return __p___argc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MethodHandle __p___argc$handle() {
        return __p___argc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc$address() {
        return __p___argc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc() {
        var mh$ = __p___argc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p___argv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static FunctionDescriptor __p___argv$descriptor() {
        return __p___argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MethodHandle __p___argv$handle() {
        return __p___argv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv$address() {
        return __p___argv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv() {
        var mh$ = __p___argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___wargv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p___wargv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static FunctionDescriptor __p___wargv$descriptor() {
        return __p___wargv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MethodHandle __p___wargv$handle() {
        return __p___wargv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv$address() {
        return __p___wargv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv() {
        var mh$ = __p___wargv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___wargv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__environ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__environ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static FunctionDescriptor __p__environ$descriptor() {
        return __p__environ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MethodHandle __p__environ$handle() {
        return __p__environ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ$address() {
        return __p__environ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ() {
        var mh$ = __p__environ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__environ");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wenviron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__wenviron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static FunctionDescriptor __p__wenviron$descriptor() {
        return __p__wenviron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MethodHandle __p__wenviron$handle() {
        return __p__wenviron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron$address() {
        return __p__wenviron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron() {
        var mh$ = __p__wenviron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wenviron");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv(MemorySegment _VarName) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor _dupenv_s$descriptor() {
        return _dupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle _dupenv_s$handle() {
        return _dupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment _dupenv_s$address() {
        return _dupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static int _dupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _dupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static int system(MemorySegment _Command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor _putenv$descriptor() {
        return _putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle _putenv$handle() {
        return _putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment _putenv$address() {
        return _putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static int _putenv(MemorySegment _EnvString) {
        var mh$ = _putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static FunctionDescriptor _putenv_s$descriptor() {
        return _putenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MethodHandle _putenv_s$handle() {
        return _putenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MemorySegment _putenv_s$address() {
        return _putenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static int _putenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _putenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_searchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _searchenv_s$descriptor() {
        return _searchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _searchenv_s$handle() {
        return _searchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _searchenv_s$address() {
        return _searchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _searchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _searchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_searchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _searchenv$descriptor() {
        return _searchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MethodHandle _searchenv$handle() {
        return _searchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MemorySegment _searchenv$address() {
        return _searchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static void _searchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer) {
        var mh$ = _searchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv", _Filename, _VarName, _Buffer);
            }
            mh$.invokeExact(_Filename, _VarName, _Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _seterrormode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_seterrormode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static FunctionDescriptor _seterrormode$descriptor() {
        return _seterrormode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MethodHandle _seterrormode$handle() {
        return _seterrormode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MemorySegment _seterrormode$address() {
        return _seterrormode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static void _seterrormode(int _Mode) {
        var mh$ = _seterrormode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_seterrormode", _Mode);
            }
            mh$.invokeExact(_Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_beep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static FunctionDescriptor _beep$descriptor() {
        return _beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MethodHandle _beep$handle() {
        return _beep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MemorySegment _beep$address() {
        return _beep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static void _beep(int _Frequency, int _Duration) {
        var mh$ = _beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_beep", _Frequency, _Duration);
            }
            mh$.invokeExact(_Frequency, _Duration);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static FunctionDescriptor _sleep$descriptor() {
        return _sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MethodHandle _sleep$handle() {
        return _sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MemorySegment _sleep$address() {
        return _sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static void _sleep(int _Duration) {
        var mh$ = _sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sleep", _Duration);
            }
            mh$.invokeExact(_Duration);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt(double _Value, int _DigitCount, MemorySegment _DstBuf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", _Value, _DigitCount, _DstBuf);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _DstBuf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor itoa$descriptor() {
        return itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle itoa$handle() {
        return itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa$address() {
        return itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ltoa$descriptor() {
        return ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ltoa$handle() {
        return ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa$address() {
        return ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ultoa$descriptor() {
        return ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ultoa$handle() {
        return ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa$address() {
        return ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static int putenv(MemorySegment _EnvString) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor onexit$descriptor() {
        return onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle onexit$handle() {
        return onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit$address() {
        return onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit(MemorySegment _Func) {
        var mh$ = onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strcmp0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strcmp0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int g_strcmp0(const char *str1, const char *str2)
     * }
     */
    public static FunctionDescriptor g_strcmp0$descriptor() {
        return g_strcmp0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int g_strcmp0(const char *str1, const char *str2)
     * }
     */
    public static MethodHandle g_strcmp0$handle() {
        return g_strcmp0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int g_strcmp0(const char *str1, const char *str2)
     * }
     */
    public static MemorySegment g_strcmp0$address() {
        return g_strcmp0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int g_strcmp0(const char *str1, const char *str2)
     * }
     */
    public static int g_strcmp0(MemorySegment str1, MemorySegment str2) {
        var mh$ = g_strcmp0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strcmp0", str1, str2);
            }
            return (int)mh$.invokeExact(str1, str2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_test_minimized_result(double minimized_quantity, const char *format, ...)
     * }
     */
    public static class g_test_minimized_result {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_DOUBLE,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_minimized_result");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_minimized_result(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_test_minimized_result(double minimized_quantity, const char *format, ...)
         * }
         */
        public static g_test_minimized_result makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_minimized_result(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(double minimized_quantity, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_minimized_result", minimized_quantity, format, x2);
                }
                 spreader.invokeExact(minimized_quantity, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_test_maximized_result(double maximized_quantity, const char *format, ...)
     * }
     */
    public static class g_test_maximized_result {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_DOUBLE,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_maximized_result");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_maximized_result(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_test_maximized_result(double maximized_quantity, const char *format, ...)
         * }
         */
        public static g_test_maximized_result makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_maximized_result(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(double maximized_quantity, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_maximized_result", maximized_quantity, format, x2);
                }
                 spreader.invokeExact(maximized_quantity, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_test_init(int *argc, char ***argv, ...)
     * }
     */
    public static class g_test_init {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_init");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_init(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_test_init(int *argc, char ***argv, ...)
         * }
         */
        public static g_test_init makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_init(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment argc, MemorySegment argv, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_init", argc, argv, x2);
                }
                 spreader.invokeExact(argc, argv, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_test_subprocess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_subprocess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_test_subprocess()
     * }
     */
    public static FunctionDescriptor g_test_subprocess$descriptor() {
        return g_test_subprocess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_test_subprocess()
     * }
     */
    public static MethodHandle g_test_subprocess$handle() {
        return g_test_subprocess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_test_subprocess()
     * }
     */
    public static MemorySegment g_test_subprocess$address() {
        return g_test_subprocess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_test_subprocess()
     * }
     */
    public static int g_test_subprocess() {
        var mh$ = g_test_subprocess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_subprocess");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_run {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_run");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int g_test_run()
     * }
     */
    public static FunctionDescriptor g_test_run$descriptor() {
        return g_test_run.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int g_test_run()
     * }
     */
    public static MethodHandle g_test_run$handle() {
        return g_test_run.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int g_test_run()
     * }
     */
    public static MemorySegment g_test_run$address() {
        return g_test_run.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int g_test_run()
     * }
     */
    public static int g_test_run() {
        var mh$ = g_test_run.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_run");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_add_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_add_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_add_func(const char *testpath, GTestFunc test_func)
     * }
     */
    public static FunctionDescriptor g_test_add_func$descriptor() {
        return g_test_add_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_add_func(const char *testpath, GTestFunc test_func)
     * }
     */
    public static MethodHandle g_test_add_func$handle() {
        return g_test_add_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_add_func(const char *testpath, GTestFunc test_func)
     * }
     */
    public static MemorySegment g_test_add_func$address() {
        return g_test_add_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_add_func(const char *testpath, GTestFunc test_func)
     * }
     */
    public static void g_test_add_func(MemorySegment testpath, MemorySegment test_func) {
        var mh$ = g_test_add_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_add_func", testpath, test_func);
            }
            mh$.invokeExact(testpath, test_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_add_data_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_add_data_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_add_data_func(const char *testpath, gconstpointer test_data, GTestDataFunc test_func)
     * }
     */
    public static FunctionDescriptor g_test_add_data_func$descriptor() {
        return g_test_add_data_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_add_data_func(const char *testpath, gconstpointer test_data, GTestDataFunc test_func)
     * }
     */
    public static MethodHandle g_test_add_data_func$handle() {
        return g_test_add_data_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_add_data_func(const char *testpath, gconstpointer test_data, GTestDataFunc test_func)
     * }
     */
    public static MemorySegment g_test_add_data_func$address() {
        return g_test_add_data_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_add_data_func(const char *testpath, gconstpointer test_data, GTestDataFunc test_func)
     * }
     */
    public static void g_test_add_data_func(MemorySegment testpath, MemorySegment test_data, MemorySegment test_func) {
        var mh$ = g_test_add_data_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_add_data_func", testpath, test_data, test_func);
            }
            mh$.invokeExact(testpath, test_data, test_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_add_data_func_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_add_data_func_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_add_data_func_full(const char *testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func)
     * }
     */
    public static FunctionDescriptor g_test_add_data_func_full$descriptor() {
        return g_test_add_data_func_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_add_data_func_full(const char *testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func)
     * }
     */
    public static MethodHandle g_test_add_data_func_full$handle() {
        return g_test_add_data_func_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_add_data_func_full(const char *testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func)
     * }
     */
    public static MemorySegment g_test_add_data_func_full$address() {
        return g_test_add_data_func_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_add_data_func_full(const char *testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func)
     * }
     */
    public static void g_test_add_data_func_full(MemorySegment testpath, MemorySegment test_data, MemorySegment test_func, MemorySegment data_free_func) {
        var mh$ = g_test_add_data_func_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_add_data_func_full", testpath, test_data, test_func, data_free_func);
            }
            mh$.invokeExact(testpath, test_data, test_func, data_free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_get_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_get_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *g_test_get_path()
     * }
     */
    public static FunctionDescriptor g_test_get_path$descriptor() {
        return g_test_get_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *g_test_get_path()
     * }
     */
    public static MethodHandle g_test_get_path$handle() {
        return g_test_get_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *g_test_get_path()
     * }
     */
    public static MemorySegment g_test_get_path$address() {
        return g_test_get_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *g_test_get_path()
     * }
     */
    public static MemorySegment g_test_get_path() {
        var mh$ = g_test_get_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_get_path");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_fail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_fail()
     * }
     */
    public static FunctionDescriptor g_test_fail$descriptor() {
        return g_test_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_fail()
     * }
     */
    public static MethodHandle g_test_fail$handle() {
        return g_test_fail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_fail()
     * }
     */
    public static MemorySegment g_test_fail$address() {
        return g_test_fail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_fail()
     * }
     */
    public static void g_test_fail() {
        var mh$ = g_test_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_fail");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_test_fail_printf(const char *format, ...)
     * }
     */
    public static class g_test_fail_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_fail_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_fail_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_test_fail_printf(const char *format, ...)
         * }
         */
        public static g_test_fail_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_fail_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_fail_printf", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_test_incomplete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_incomplete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_incomplete(const gchar *msg)
     * }
     */
    public static FunctionDescriptor g_test_incomplete$descriptor() {
        return g_test_incomplete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_incomplete(const gchar *msg)
     * }
     */
    public static MethodHandle g_test_incomplete$handle() {
        return g_test_incomplete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_incomplete(const gchar *msg)
     * }
     */
    public static MemorySegment g_test_incomplete$address() {
        return g_test_incomplete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_incomplete(const gchar *msg)
     * }
     */
    public static void g_test_incomplete(MemorySegment msg) {
        var mh$ = g_test_incomplete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_incomplete", msg);
            }
            mh$.invokeExact(msg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_test_incomplete_printf(const char *format, ...)
     * }
     */
    public static class g_test_incomplete_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_incomplete_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_incomplete_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_test_incomplete_printf(const char *format, ...)
         * }
         */
        public static g_test_incomplete_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_incomplete_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_incomplete_printf", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_test_skip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_skip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_skip(const gchar *msg)
     * }
     */
    public static FunctionDescriptor g_test_skip$descriptor() {
        return g_test_skip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_skip(const gchar *msg)
     * }
     */
    public static MethodHandle g_test_skip$handle() {
        return g_test_skip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_skip(const gchar *msg)
     * }
     */
    public static MemorySegment g_test_skip$address() {
        return g_test_skip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_skip(const gchar *msg)
     * }
     */
    public static void g_test_skip(MemorySegment msg) {
        var mh$ = g_test_skip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_skip", msg);
            }
            mh$.invokeExact(msg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_test_skip_printf(const char *format, ...)
     * }
     */
    public static class g_test_skip_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_skip_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_skip_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_test_skip_printf(const char *format, ...)
         * }
         */
        public static g_test_skip_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_skip_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_skip_printf", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_test_failed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_failed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_test_failed()
     * }
     */
    public static FunctionDescriptor g_test_failed$descriptor() {
        return g_test_failed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_test_failed()
     * }
     */
    public static MethodHandle g_test_failed$handle() {
        return g_test_failed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_test_failed()
     * }
     */
    public static MemorySegment g_test_failed$address() {
        return g_test_failed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_test_failed()
     * }
     */
    public static int g_test_failed() {
        var mh$ = g_test_failed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_failed");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_set_nonfatal_assertions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_set_nonfatal_assertions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_set_nonfatal_assertions()
     * }
     */
    public static FunctionDescriptor g_test_set_nonfatal_assertions$descriptor() {
        return g_test_set_nonfatal_assertions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_set_nonfatal_assertions()
     * }
     */
    public static MethodHandle g_test_set_nonfatal_assertions$handle() {
        return g_test_set_nonfatal_assertions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_set_nonfatal_assertions()
     * }
     */
    public static MemorySegment g_test_set_nonfatal_assertions$address() {
        return g_test_set_nonfatal_assertions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_set_nonfatal_assertions()
     * }
     */
    public static void g_test_set_nonfatal_assertions() {
        var mh$ = g_test_set_nonfatal_assertions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_set_nonfatal_assertions");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_disable_crash_reporting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_disable_crash_reporting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_disable_crash_reporting()
     * }
     */
    public static FunctionDescriptor g_test_disable_crash_reporting$descriptor() {
        return g_test_disable_crash_reporting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_disable_crash_reporting()
     * }
     */
    public static MethodHandle g_test_disable_crash_reporting$handle() {
        return g_test_disable_crash_reporting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_disable_crash_reporting()
     * }
     */
    public static MemorySegment g_test_disable_crash_reporting$address() {
        return g_test_disable_crash_reporting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_disable_crash_reporting()
     * }
     */
    public static void g_test_disable_crash_reporting() {
        var mh$ = g_test_disable_crash_reporting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_disable_crash_reporting");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_test_message(const char *format, ...)
     * }
     */
    public static class g_test_message {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_message");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_message(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_test_message(const char *format, ...)
         * }
         */
        public static g_test_message makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_message(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_message", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_test_bug_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_bug_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_bug_base(const char *uri_pattern)
     * }
     */
    public static FunctionDescriptor g_test_bug_base$descriptor() {
        return g_test_bug_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_bug_base(const char *uri_pattern)
     * }
     */
    public static MethodHandle g_test_bug_base$handle() {
        return g_test_bug_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_bug_base(const char *uri_pattern)
     * }
     */
    public static MemorySegment g_test_bug_base$address() {
        return g_test_bug_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_bug_base(const char *uri_pattern)
     * }
     */
    public static void g_test_bug_base(MemorySegment uri_pattern) {
        var mh$ = g_test_bug_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_bug_base", uri_pattern);
            }
            mh$.invokeExact(uri_pattern);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_bug {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_bug");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_bug(const char *bug_uri_snippet)
     * }
     */
    public static FunctionDescriptor g_test_bug$descriptor() {
        return g_test_bug.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_bug(const char *bug_uri_snippet)
     * }
     */
    public static MethodHandle g_test_bug$handle() {
        return g_test_bug.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_bug(const char *bug_uri_snippet)
     * }
     */
    public static MemorySegment g_test_bug$address() {
        return g_test_bug.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_bug(const char *bug_uri_snippet)
     * }
     */
    public static void g_test_bug(MemorySegment bug_uri_snippet) {
        var mh$ = g_test_bug.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_bug", bug_uri_snippet);
            }
            mh$.invokeExact(bug_uri_snippet);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_summary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_summary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_summary(const char *summary)
     * }
     */
    public static FunctionDescriptor g_test_summary$descriptor() {
        return g_test_summary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_summary(const char *summary)
     * }
     */
    public static MethodHandle g_test_summary$handle() {
        return g_test_summary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_summary(const char *summary)
     * }
     */
    public static MemorySegment g_test_summary$address() {
        return g_test_summary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_summary(const char *summary)
     * }
     */
    public static void g_test_summary(MemorySegment summary) {
        var mh$ = g_test_summary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_summary", summary);
            }
            mh$.invokeExact(summary);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_timer_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_timer_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_timer_start()
     * }
     */
    public static FunctionDescriptor g_test_timer_start$descriptor() {
        return g_test_timer_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_timer_start()
     * }
     */
    public static MethodHandle g_test_timer_start$handle() {
        return g_test_timer_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_timer_start()
     * }
     */
    public static MemorySegment g_test_timer_start$address() {
        return g_test_timer_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_timer_start()
     * }
     */
    public static void g_test_timer_start() {
        var mh$ = g_test_timer_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_timer_start");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_timer_elapsed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_timer_elapsed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double g_test_timer_elapsed()
     * }
     */
    public static FunctionDescriptor g_test_timer_elapsed$descriptor() {
        return g_test_timer_elapsed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double g_test_timer_elapsed()
     * }
     */
    public static MethodHandle g_test_timer_elapsed$handle() {
        return g_test_timer_elapsed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double g_test_timer_elapsed()
     * }
     */
    public static MemorySegment g_test_timer_elapsed$address() {
        return g_test_timer_elapsed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double g_test_timer_elapsed()
     * }
     */
    public static double g_test_timer_elapsed() {
        var mh$ = g_test_timer_elapsed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_timer_elapsed");
            }
            return (double)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_timer_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_timer_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double g_test_timer_last()
     * }
     */
    public static FunctionDescriptor g_test_timer_last$descriptor() {
        return g_test_timer_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double g_test_timer_last()
     * }
     */
    public static MethodHandle g_test_timer_last$handle() {
        return g_test_timer_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double g_test_timer_last()
     * }
     */
    public static MemorySegment g_test_timer_last$address() {
        return g_test_timer_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double g_test_timer_last()
     * }
     */
    public static double g_test_timer_last() {
        var mh$ = g_test_timer_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_timer_last");
            }
            return (double)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_queue_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_queue_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_queue_free(gpointer gfree_pointer)
     * }
     */
    public static FunctionDescriptor g_test_queue_free$descriptor() {
        return g_test_queue_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_queue_free(gpointer gfree_pointer)
     * }
     */
    public static MethodHandle g_test_queue_free$handle() {
        return g_test_queue_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_queue_free(gpointer gfree_pointer)
     * }
     */
    public static MemorySegment g_test_queue_free$address() {
        return g_test_queue_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_queue_free(gpointer gfree_pointer)
     * }
     */
    public static void g_test_queue_free(MemorySegment gfree_pointer) {
        var mh$ = g_test_queue_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_queue_free", gfree_pointer);
            }
            mh$.invokeExact(gfree_pointer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_queue_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_queue_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_queue_destroy(GDestroyNotify destroy_func, gpointer destroy_data)
     * }
     */
    public static FunctionDescriptor g_test_queue_destroy$descriptor() {
        return g_test_queue_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_queue_destroy(GDestroyNotify destroy_func, gpointer destroy_data)
     * }
     */
    public static MethodHandle g_test_queue_destroy$handle() {
        return g_test_queue_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_queue_destroy(GDestroyNotify destroy_func, gpointer destroy_data)
     * }
     */
    public static MemorySegment g_test_queue_destroy$address() {
        return g_test_queue_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_queue_destroy(GDestroyNotify destroy_func, gpointer destroy_data)
     * }
     */
    public static void g_test_queue_destroy(MemorySegment destroy_func, MemorySegment destroy_data) {
        var mh$ = g_test_queue_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_queue_destroy", destroy_func, destroy_data);
            }
            mh$.invokeExact(destroy_func, destroy_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_TEST_TRAP_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_TRAP_DEFAULT = 0
     * }
     */
    public static int G_TEST_TRAP_DEFAULT() {
        return G_TEST_TRAP_DEFAULT;
    }
    private static final int G_TEST_TRAP_SILENCE_STDOUT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_TRAP_SILENCE_STDOUT = 128
     * }
     */
    public static int G_TEST_TRAP_SILENCE_STDOUT() {
        return G_TEST_TRAP_SILENCE_STDOUT;
    }
    private static final int G_TEST_TRAP_SILENCE_STDERR = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_TRAP_SILENCE_STDERR = 256
     * }
     */
    public static int G_TEST_TRAP_SILENCE_STDERR() {
        return G_TEST_TRAP_SILENCE_STDERR;
    }
    private static final int G_TEST_TRAP_INHERIT_STDIN = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_TRAP_INHERIT_STDIN = 512
     * }
     */
    public static int G_TEST_TRAP_INHERIT_STDIN() {
        return G_TEST_TRAP_INHERIT_STDIN;
    }

    private static class g_test_trap_fork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_trap_fork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_fork(guint64 usec_timeout, GTestTrapFlags test_trap_flags)
     * }
     */
    public static FunctionDescriptor g_test_trap_fork$descriptor() {
        return g_test_trap_fork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_fork(guint64 usec_timeout, GTestTrapFlags test_trap_flags)
     * }
     */
    public static MethodHandle g_test_trap_fork$handle() {
        return g_test_trap_fork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_fork(guint64 usec_timeout, GTestTrapFlags test_trap_flags)
     * }
     */
    public static MemorySegment g_test_trap_fork$address() {
        return g_test_trap_fork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_test_trap_fork(guint64 usec_timeout, GTestTrapFlags test_trap_flags)
     * }
     */
    public static int g_test_trap_fork(long usec_timeout, int test_trap_flags) {
        var mh$ = g_test_trap_fork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_trap_fork", usec_timeout, test_trap_flags);
            }
            return (int)mh$.invokeExact(usec_timeout, test_trap_flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_TEST_SUBPROCESS_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_SUBPROCESS_DEFAULT = 0
     * }
     */
    public static int G_TEST_SUBPROCESS_DEFAULT() {
        return G_TEST_SUBPROCESS_DEFAULT;
    }
    private static final int G_TEST_SUBPROCESS_INHERIT_STDIN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_SUBPROCESS_INHERIT_STDIN = 1
     * }
     */
    public static int G_TEST_SUBPROCESS_INHERIT_STDIN() {
        return G_TEST_SUBPROCESS_INHERIT_STDIN;
    }
    private static final int G_TEST_SUBPROCESS_INHERIT_STDOUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_SUBPROCESS_INHERIT_STDOUT = 2
     * }
     */
    public static int G_TEST_SUBPROCESS_INHERIT_STDOUT() {
        return G_TEST_SUBPROCESS_INHERIT_STDOUT;
    }
    private static final int G_TEST_SUBPROCESS_INHERIT_STDERR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_SUBPROCESS_INHERIT_STDERR = 4
     * }
     */
    public static int G_TEST_SUBPROCESS_INHERIT_STDERR() {
        return G_TEST_SUBPROCESS_INHERIT_STDERR;
    }

    private static class g_test_trap_subprocess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_trap_subprocess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_trap_subprocess(const char *test_path, guint64 usec_timeout, GTestSubprocessFlags test_flags)
     * }
     */
    public static FunctionDescriptor g_test_trap_subprocess$descriptor() {
        return g_test_trap_subprocess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_trap_subprocess(const char *test_path, guint64 usec_timeout, GTestSubprocessFlags test_flags)
     * }
     */
    public static MethodHandle g_test_trap_subprocess$handle() {
        return g_test_trap_subprocess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_trap_subprocess(const char *test_path, guint64 usec_timeout, GTestSubprocessFlags test_flags)
     * }
     */
    public static MemorySegment g_test_trap_subprocess$address() {
        return g_test_trap_subprocess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_trap_subprocess(const char *test_path, guint64 usec_timeout, GTestSubprocessFlags test_flags)
     * }
     */
    public static void g_test_trap_subprocess(MemorySegment test_path, long usec_timeout, int test_flags) {
        var mh$ = g_test_trap_subprocess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_trap_subprocess", test_path, usec_timeout, test_flags);
            }
            mh$.invokeExact(test_path, usec_timeout, test_flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_trap_subprocess_with_envp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_trap_subprocess_with_envp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_trap_subprocess_with_envp(const char *test_path, const char *const *envp, guint64 usec_timeout, GTestSubprocessFlags test_flags)
     * }
     */
    public static FunctionDescriptor g_test_trap_subprocess_with_envp$descriptor() {
        return g_test_trap_subprocess_with_envp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_trap_subprocess_with_envp(const char *test_path, const char *const *envp, guint64 usec_timeout, GTestSubprocessFlags test_flags)
     * }
     */
    public static MethodHandle g_test_trap_subprocess_with_envp$handle() {
        return g_test_trap_subprocess_with_envp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_trap_subprocess_with_envp(const char *test_path, const char *const *envp, guint64 usec_timeout, GTestSubprocessFlags test_flags)
     * }
     */
    public static MemorySegment g_test_trap_subprocess_with_envp$address() {
        return g_test_trap_subprocess_with_envp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_trap_subprocess_with_envp(const char *test_path, const char *const *envp, guint64 usec_timeout, GTestSubprocessFlags test_flags)
     * }
     */
    public static void g_test_trap_subprocess_with_envp(MemorySegment test_path, MemorySegment envp, long usec_timeout, int test_flags) {
        var mh$ = g_test_trap_subprocess_with_envp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_trap_subprocess_with_envp", test_path, envp, usec_timeout, test_flags);
            }
            mh$.invokeExact(test_path, envp, usec_timeout, test_flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_trap_has_passed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_trap_has_passed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_has_passed()
     * }
     */
    public static FunctionDescriptor g_test_trap_has_passed$descriptor() {
        return g_test_trap_has_passed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_has_passed()
     * }
     */
    public static MethodHandle g_test_trap_has_passed$handle() {
        return g_test_trap_has_passed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_has_passed()
     * }
     */
    public static MemorySegment g_test_trap_has_passed$address() {
        return g_test_trap_has_passed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_test_trap_has_passed()
     * }
     */
    public static int g_test_trap_has_passed() {
        var mh$ = g_test_trap_has_passed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_trap_has_passed");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_trap_reached_timeout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_trap_reached_timeout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_reached_timeout()
     * }
     */
    public static FunctionDescriptor g_test_trap_reached_timeout$descriptor() {
        return g_test_trap_reached_timeout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_reached_timeout()
     * }
     */
    public static MethodHandle g_test_trap_reached_timeout$handle() {
        return g_test_trap_reached_timeout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_test_trap_reached_timeout()
     * }
     */
    public static MemorySegment g_test_trap_reached_timeout$address() {
        return g_test_trap_reached_timeout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_test_trap_reached_timeout()
     * }
     */
    public static int g_test_trap_reached_timeout() {
        var mh$ = g_test_trap_reached_timeout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_trap_reached_timeout");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_rand_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_rand_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint32 g_test_rand_int()
     * }
     */
    public static FunctionDescriptor g_test_rand_int$descriptor() {
        return g_test_rand_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint32 g_test_rand_int()
     * }
     */
    public static MethodHandle g_test_rand_int$handle() {
        return g_test_rand_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint32 g_test_rand_int()
     * }
     */
    public static MemorySegment g_test_rand_int$address() {
        return g_test_rand_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint32 g_test_rand_int()
     * }
     */
    public static int g_test_rand_int() {
        var mh$ = g_test_rand_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_rand_int");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_rand_int_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_rand_int_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint32 g_test_rand_int_range(gint32 begin, gint32 end)
     * }
     */
    public static FunctionDescriptor g_test_rand_int_range$descriptor() {
        return g_test_rand_int_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint32 g_test_rand_int_range(gint32 begin, gint32 end)
     * }
     */
    public static MethodHandle g_test_rand_int_range$handle() {
        return g_test_rand_int_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint32 g_test_rand_int_range(gint32 begin, gint32 end)
     * }
     */
    public static MemorySegment g_test_rand_int_range$address() {
        return g_test_rand_int_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint32 g_test_rand_int_range(gint32 begin, gint32 end)
     * }
     */
    public static int g_test_rand_int_range(int begin, int end) {
        var mh$ = g_test_rand_int_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_rand_int_range", begin, end);
            }
            return (int)mh$.invokeExact(begin, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_rand_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_rand_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double g_test_rand_double()
     * }
     */
    public static FunctionDescriptor g_test_rand_double$descriptor() {
        return g_test_rand_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double g_test_rand_double()
     * }
     */
    public static MethodHandle g_test_rand_double$handle() {
        return g_test_rand_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double g_test_rand_double()
     * }
     */
    public static MemorySegment g_test_rand_double$address() {
        return g_test_rand_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double g_test_rand_double()
     * }
     */
    public static double g_test_rand_double() {
        var mh$ = g_test_rand_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_rand_double");
            }
            return (double)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_rand_double_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_rand_double_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double g_test_rand_double_range(double range_start, double range_end)
     * }
     */
    public static FunctionDescriptor g_test_rand_double_range$descriptor() {
        return g_test_rand_double_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double g_test_rand_double_range(double range_start, double range_end)
     * }
     */
    public static MethodHandle g_test_rand_double_range$handle() {
        return g_test_rand_double_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double g_test_rand_double_range(double range_start, double range_end)
     * }
     */
    public static MemorySegment g_test_rand_double_range$address() {
        return g_test_rand_double_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double g_test_rand_double_range(double range_start, double range_end)
     * }
     */
    public static double g_test_rand_double_range(double range_start, double range_end) {
        var mh$ = g_test_rand_double_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_rand_double_range", range_start, range_end);
            }
            return (double)mh$.invokeExact(range_start, range_end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_create_case {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_create_case");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTestCase *g_test_create_case(const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown)
     * }
     */
    public static FunctionDescriptor g_test_create_case$descriptor() {
        return g_test_create_case.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTestCase *g_test_create_case(const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown)
     * }
     */
    public static MethodHandle g_test_create_case$handle() {
        return g_test_create_case.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTestCase *g_test_create_case(const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown)
     * }
     */
    public static MemorySegment g_test_create_case$address() {
        return g_test_create_case.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTestCase *g_test_create_case(const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown)
     * }
     */
    public static MemorySegment g_test_create_case(MemorySegment test_name, long data_size, MemorySegment test_data, MemorySegment data_setup, MemorySegment data_test, MemorySegment data_teardown) {
        var mh$ = g_test_create_case.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_create_case", test_name, data_size, test_data, data_setup, data_test, data_teardown);
            }
            return (MemorySegment)mh$.invokeExact(test_name, data_size, test_data, data_setup, data_test, data_teardown);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_create_suite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_create_suite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTestSuite *g_test_create_suite(const char *suite_name)
     * }
     */
    public static FunctionDescriptor g_test_create_suite$descriptor() {
        return g_test_create_suite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTestSuite *g_test_create_suite(const char *suite_name)
     * }
     */
    public static MethodHandle g_test_create_suite$handle() {
        return g_test_create_suite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTestSuite *g_test_create_suite(const char *suite_name)
     * }
     */
    public static MemorySegment g_test_create_suite$address() {
        return g_test_create_suite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTestSuite *g_test_create_suite(const char *suite_name)
     * }
     */
    public static MemorySegment g_test_create_suite(MemorySegment suite_name) {
        var mh$ = g_test_create_suite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_create_suite", suite_name);
            }
            return (MemorySegment)mh$.invokeExact(suite_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_get_root {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_get_root");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTestSuite *g_test_get_root()
     * }
     */
    public static FunctionDescriptor g_test_get_root$descriptor() {
        return g_test_get_root.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTestSuite *g_test_get_root()
     * }
     */
    public static MethodHandle g_test_get_root$handle() {
        return g_test_get_root.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTestSuite *g_test_get_root()
     * }
     */
    public static MemorySegment g_test_get_root$address() {
        return g_test_get_root.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTestSuite *g_test_get_root()
     * }
     */
    public static MemorySegment g_test_get_root() {
        var mh$ = g_test_get_root.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_get_root");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_suite_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_suite_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_suite_add(GTestSuite *suite, GTestCase *test_case)
     * }
     */
    public static FunctionDescriptor g_test_suite_add$descriptor() {
        return g_test_suite_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_suite_add(GTestSuite *suite, GTestCase *test_case)
     * }
     */
    public static MethodHandle g_test_suite_add$handle() {
        return g_test_suite_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_suite_add(GTestSuite *suite, GTestCase *test_case)
     * }
     */
    public static MemorySegment g_test_suite_add$address() {
        return g_test_suite_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_suite_add(GTestSuite *suite, GTestCase *test_case)
     * }
     */
    public static void g_test_suite_add(MemorySegment suite, MemorySegment test_case) {
        var mh$ = g_test_suite_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_suite_add", suite, test_case);
            }
            mh$.invokeExact(suite, test_case);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_suite_add_suite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_suite_add_suite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_suite_add_suite(GTestSuite *suite, GTestSuite *nestedsuite)
     * }
     */
    public static FunctionDescriptor g_test_suite_add_suite$descriptor() {
        return g_test_suite_add_suite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_suite_add_suite(GTestSuite *suite, GTestSuite *nestedsuite)
     * }
     */
    public static MethodHandle g_test_suite_add_suite$handle() {
        return g_test_suite_add_suite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_suite_add_suite(GTestSuite *suite, GTestSuite *nestedsuite)
     * }
     */
    public static MemorySegment g_test_suite_add_suite$address() {
        return g_test_suite_add_suite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_suite_add_suite(GTestSuite *suite, GTestSuite *nestedsuite)
     * }
     */
    public static void g_test_suite_add_suite(MemorySegment suite, MemorySegment nestedsuite) {
        var mh$ = g_test_suite_add_suite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_suite_add_suite", suite, nestedsuite);
            }
            mh$.invokeExact(suite, nestedsuite);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_run_suite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_run_suite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int g_test_run_suite(GTestSuite *suite)
     * }
     */
    public static FunctionDescriptor g_test_run_suite$descriptor() {
        return g_test_run_suite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int g_test_run_suite(GTestSuite *suite)
     * }
     */
    public static MethodHandle g_test_run_suite$handle() {
        return g_test_run_suite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int g_test_run_suite(GTestSuite *suite)
     * }
     */
    public static MemorySegment g_test_run_suite$address() {
        return g_test_run_suite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int g_test_run_suite(GTestSuite *suite)
     * }
     */
    public static int g_test_run_suite(MemorySegment suite) {
        var mh$ = g_test_run_suite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_run_suite", suite);
            }
            return (int)mh$.invokeExact(suite);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_case_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_case_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_case_free(GTestCase *test_case)
     * }
     */
    public static FunctionDescriptor g_test_case_free$descriptor() {
        return g_test_case_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_case_free(GTestCase *test_case)
     * }
     */
    public static MethodHandle g_test_case_free$handle() {
        return g_test_case_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_case_free(GTestCase *test_case)
     * }
     */
    public static MemorySegment g_test_case_free$address() {
        return g_test_case_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_case_free(GTestCase *test_case)
     * }
     */
    public static void g_test_case_free(MemorySegment test_case) {
        var mh$ = g_test_case_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_case_free", test_case);
            }
            mh$.invokeExact(test_case);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_suite_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_suite_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_suite_free(GTestSuite *suite)
     * }
     */
    public static FunctionDescriptor g_test_suite_free$descriptor() {
        return g_test_suite_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_suite_free(GTestSuite *suite)
     * }
     */
    public static MethodHandle g_test_suite_free$handle() {
        return g_test_suite_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_suite_free(GTestSuite *suite)
     * }
     */
    public static MemorySegment g_test_suite_free$address() {
        return g_test_suite_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_suite_free(GTestSuite *suite)
     * }
     */
    public static void g_test_suite_free(MemorySegment suite) {
        var mh$ = g_test_suite_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_suite_free", suite);
            }
            mh$.invokeExact(suite);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_trap_assertions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_trap_assertions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_trap_assertions(const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern)
     * }
     */
    public static FunctionDescriptor g_test_trap_assertions$descriptor() {
        return g_test_trap_assertions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_trap_assertions(const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern)
     * }
     */
    public static MethodHandle g_test_trap_assertions$handle() {
        return g_test_trap_assertions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_trap_assertions(const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern)
     * }
     */
    public static MemorySegment g_test_trap_assertions$address() {
        return g_test_trap_assertions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_trap_assertions(const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern)
     * }
     */
    public static void g_test_trap_assertions(MemorySegment domain, MemorySegment file, int line, MemorySegment func, long assertion_flags, MemorySegment pattern) {
        var mh$ = g_test_trap_assertions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_trap_assertions", domain, file, line, func, assertion_flags, pattern);
            }
            mh$.invokeExact(domain, file, line, func, assertion_flags, pattern);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_assertion_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_assertion_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_assertion_message(const char *domain, const char *file, int line, const char *func, const char *message)
     * }
     */
    public static FunctionDescriptor g_assertion_message$descriptor() {
        return g_assertion_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_assertion_message(const char *domain, const char *file, int line, const char *func, const char *message)
     * }
     */
    public static MethodHandle g_assertion_message$handle() {
        return g_assertion_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_assertion_message(const char *domain, const char *file, int line, const char *func, const char *message)
     * }
     */
    public static MemorySegment g_assertion_message$address() {
        return g_assertion_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_assertion_message(const char *domain, const char *file, int line, const char *func, const char *message)
     * }
     */
    public static void g_assertion_message(MemorySegment domain, MemorySegment file, int line, MemorySegment func, MemorySegment message) {
        var mh$ = g_assertion_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_assertion_message", domain, file, line, func, message);
            }
            mh$.invokeExact(domain, file, line, func, message);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_assertion_message_expr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_assertion_message_expr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_assertion_message_expr(const char *domain, const char *file, int line, const char *func, const char *expr)
     * }
     */
    public static FunctionDescriptor g_assertion_message_expr$descriptor() {
        return g_assertion_message_expr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_assertion_message_expr(const char *domain, const char *file, int line, const char *func, const char *expr)
     * }
     */
    public static MethodHandle g_assertion_message_expr$handle() {
        return g_assertion_message_expr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_assertion_message_expr(const char *domain, const char *file, int line, const char *func, const char *expr)
     * }
     */
    public static MemorySegment g_assertion_message_expr$address() {
        return g_assertion_message_expr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_assertion_message_expr(const char *domain, const char *file, int line, const char *func, const char *expr)
     * }
     */
    public static void g_assertion_message_expr(MemorySegment domain, MemorySegment file, int line, MemorySegment func, MemorySegment expr) {
        var mh$ = g_assertion_message_expr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_assertion_message_expr", domain, file, line, func, expr);
            }
            mh$.invokeExact(domain, file, line, func, expr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_assertion_message_cmpstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_assertion_message_cmpstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpstr(const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2)
     * }
     */
    public static FunctionDescriptor g_assertion_message_cmpstr$descriptor() {
        return g_assertion_message_cmpstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpstr(const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2)
     * }
     */
    public static MethodHandle g_assertion_message_cmpstr$handle() {
        return g_assertion_message_cmpstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpstr(const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2)
     * }
     */
    public static MemorySegment g_assertion_message_cmpstr$address() {
        return g_assertion_message_cmpstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpstr(const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2)
     * }
     */
    public static void g_assertion_message_cmpstr(MemorySegment domain, MemorySegment file, int line, MemorySegment func, MemorySegment expr, MemorySegment arg1, MemorySegment cmp, MemorySegment arg2) {
        var mh$ = g_assertion_message_cmpstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_assertion_message_cmpstr", domain, file, line, func, expr, arg1, cmp, arg2);
            }
            mh$.invokeExact(domain, file, line, func, expr, arg1, cmp, arg2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_assertion_message_cmpstrv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_assertion_message_cmpstrv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpstrv(const char *domain, const char *file, int line, const char *func, const char *expr, const char *const *arg1, const char *const *arg2, gsize first_wrong_idx)
     * }
     */
    public static FunctionDescriptor g_assertion_message_cmpstrv$descriptor() {
        return g_assertion_message_cmpstrv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpstrv(const char *domain, const char *file, int line, const char *func, const char *expr, const char *const *arg1, const char *const *arg2, gsize first_wrong_idx)
     * }
     */
    public static MethodHandle g_assertion_message_cmpstrv$handle() {
        return g_assertion_message_cmpstrv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpstrv(const char *domain, const char *file, int line, const char *func, const char *expr, const char *const *arg1, const char *const *arg2, gsize first_wrong_idx)
     * }
     */
    public static MemorySegment g_assertion_message_cmpstrv$address() {
        return g_assertion_message_cmpstrv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpstrv(const char *domain, const char *file, int line, const char *func, const char *expr, const char *const *arg1, const char *const *arg2, gsize first_wrong_idx)
     * }
     */
    public static void g_assertion_message_cmpstrv(MemorySegment domain, MemorySegment file, int line, MemorySegment func, MemorySegment expr, MemorySegment arg1, MemorySegment arg2, long first_wrong_idx) {
        var mh$ = g_assertion_message_cmpstrv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_assertion_message_cmpstrv", domain, file, line, func, expr, arg1, arg2, first_wrong_idx);
            }
            mh$.invokeExact(domain, file, line, func, expr, arg1, arg2, first_wrong_idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_assertion_message_cmpint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_assertion_message_cmpint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpint(const char *domain, const char *file, int line, const char *func, const char *expr, guint64 arg1, const char *cmp, guint64 arg2, char numtype)
     * }
     */
    public static FunctionDescriptor g_assertion_message_cmpint$descriptor() {
        return g_assertion_message_cmpint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpint(const char *domain, const char *file, int line, const char *func, const char *expr, guint64 arg1, const char *cmp, guint64 arg2, char numtype)
     * }
     */
    public static MethodHandle g_assertion_message_cmpint$handle() {
        return g_assertion_message_cmpint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpint(const char *domain, const char *file, int line, const char *func, const char *expr, guint64 arg1, const char *cmp, guint64 arg2, char numtype)
     * }
     */
    public static MemorySegment g_assertion_message_cmpint$address() {
        return g_assertion_message_cmpint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpint(const char *domain, const char *file, int line, const char *func, const char *expr, guint64 arg1, const char *cmp, guint64 arg2, char numtype)
     * }
     */
    public static void g_assertion_message_cmpint(MemorySegment domain, MemorySegment file, int line, MemorySegment func, MemorySegment expr, long arg1, MemorySegment cmp, long arg2, byte numtype) {
        var mh$ = g_assertion_message_cmpint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_assertion_message_cmpint", domain, file, line, func, expr, arg1, cmp, arg2, numtype);
            }
            mh$.invokeExact(domain, file, line, func, expr, arg1, cmp, arg2, numtype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_assertion_message_cmpnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_DOUBLE,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_assertion_message_cmpnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpnum(const char *domain, const char *file, int line, const char *func, const char *expr, long double arg1, const char *cmp, long double arg2, char numtype)
     * }
     */
    public static FunctionDescriptor g_assertion_message_cmpnum$descriptor() {
        return g_assertion_message_cmpnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpnum(const char *domain, const char *file, int line, const char *func, const char *expr, long double arg1, const char *cmp, long double arg2, char numtype)
     * }
     */
    public static MethodHandle g_assertion_message_cmpnum$handle() {
        return g_assertion_message_cmpnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpnum(const char *domain, const char *file, int line, const char *func, const char *expr, long double arg1, const char *cmp, long double arg2, char numtype)
     * }
     */
    public static MemorySegment g_assertion_message_cmpnum$address() {
        return g_assertion_message_cmpnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_assertion_message_cmpnum(const char *domain, const char *file, int line, const char *func, const char *expr, long double arg1, const char *cmp, long double arg2, char numtype)
     * }
     */
    public static void g_assertion_message_cmpnum(MemorySegment domain, MemorySegment file, int line, MemorySegment func, MemorySegment expr, double arg1, MemorySegment cmp, double arg2, byte numtype) {
        var mh$ = g_assertion_message_cmpnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_assertion_message_cmpnum", domain, file, line, func, expr, arg1, cmp, arg2, numtype);
            }
            mh$.invokeExact(domain, file, line, func, expr, arg1, cmp, arg2, numtype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_assertion_message_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_assertion_message_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_assertion_message_error(const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code)
     * }
     */
    public static FunctionDescriptor g_assertion_message_error$descriptor() {
        return g_assertion_message_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_assertion_message_error(const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code)
     * }
     */
    public static MethodHandle g_assertion_message_error$handle() {
        return g_assertion_message_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_assertion_message_error(const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code)
     * }
     */
    public static MemorySegment g_assertion_message_error$address() {
        return g_assertion_message_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_assertion_message_error(const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code)
     * }
     */
    public static void g_assertion_message_error(MemorySegment domain, MemorySegment file, int line, MemorySegment func, MemorySegment expr, MemorySegment error, int error_domain, int error_code) {
        var mh$ = g_assertion_message_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_assertion_message_error", domain, file, line, func, expr, error, error_domain, error_code);
            }
            mh$.invokeExact(domain, file, line, func, expr, error, error_domain, error_code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_add_vtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_add_vtable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_add_vtable(const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown)
     * }
     */
    public static FunctionDescriptor g_test_add_vtable$descriptor() {
        return g_test_add_vtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_add_vtable(const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown)
     * }
     */
    public static MethodHandle g_test_add_vtable$handle() {
        return g_test_add_vtable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_add_vtable(const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown)
     * }
     */
    public static MemorySegment g_test_add_vtable$address() {
        return g_test_add_vtable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_add_vtable(const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown)
     * }
     */
    public static void g_test_add_vtable(MemorySegment testpath, long data_size, MemorySegment test_data, MemorySegment data_setup, MemorySegment data_test, MemorySegment data_teardown) {
        var mh$ = g_test_add_vtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_add_vtable", testpath, data_size, test_data, data_setup, data_test, data_teardown);
            }
            mh$.invokeExact(testpath, data_size, test_data, data_setup, data_test, data_teardown);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_config_vars$constants {
        public static final AddressLayout LAYOUT = gst_min_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_test_config_vars").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GTestConfig *const g_test_config_vars
     * }
     */
    public static AddressLayout g_test_config_vars$layout() {
        return g_test_config_vars$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const GTestConfig *const g_test_config_vars
     * }
     */
    public static MemorySegment g_test_config_vars$segment() {
        return g_test_config_vars$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GTestConfig *const g_test_config_vars
     * }
     */
    public static MemorySegment g_test_config_vars() {
        return g_test_config_vars$constants.SEGMENT.get(g_test_config_vars$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GTestConfig *const g_test_config_vars
     * }
     */
    public static void g_test_config_vars(MemorySegment varValue) {
        g_test_config_vars$constants.SEGMENT.set(g_test_config_vars$constants.LAYOUT, 0L, varValue);
    }
    private static final int G_TEST_RUN_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_RUN_SUCCESS = 0
     * }
     */
    public static int G_TEST_RUN_SUCCESS() {
        return G_TEST_RUN_SUCCESS;
    }
    private static final int G_TEST_RUN_SKIPPED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_RUN_SKIPPED = 1
     * }
     */
    public static int G_TEST_RUN_SKIPPED() {
        return G_TEST_RUN_SKIPPED;
    }
    private static final int G_TEST_RUN_FAILURE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_RUN_FAILURE = 2
     * }
     */
    public static int G_TEST_RUN_FAILURE() {
        return G_TEST_RUN_FAILURE;
    }
    private static final int G_TEST_RUN_INCOMPLETE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_RUN_INCOMPLETE = 3
     * }
     */
    public static int G_TEST_RUN_INCOMPLETE() {
        return G_TEST_RUN_INCOMPLETE;
    }
    private static final int G_TEST_LOG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_NONE = 0
     * }
     */
    public static int G_TEST_LOG_NONE() {
        return G_TEST_LOG_NONE;
    }
    private static final int G_TEST_LOG_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_ERROR = 1
     * }
     */
    public static int G_TEST_LOG_ERROR() {
        return G_TEST_LOG_ERROR;
    }
    private static final int G_TEST_LOG_START_BINARY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_START_BINARY = 2
     * }
     */
    public static int G_TEST_LOG_START_BINARY() {
        return G_TEST_LOG_START_BINARY;
    }
    private static final int G_TEST_LOG_LIST_CASE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_LIST_CASE = 3
     * }
     */
    public static int G_TEST_LOG_LIST_CASE() {
        return G_TEST_LOG_LIST_CASE;
    }
    private static final int G_TEST_LOG_SKIP_CASE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_SKIP_CASE = 4
     * }
     */
    public static int G_TEST_LOG_SKIP_CASE() {
        return G_TEST_LOG_SKIP_CASE;
    }
    private static final int G_TEST_LOG_START_CASE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_START_CASE = 5
     * }
     */
    public static int G_TEST_LOG_START_CASE() {
        return G_TEST_LOG_START_CASE;
    }
    private static final int G_TEST_LOG_STOP_CASE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_STOP_CASE = 6
     * }
     */
    public static int G_TEST_LOG_STOP_CASE() {
        return G_TEST_LOG_STOP_CASE;
    }
    private static final int G_TEST_LOG_MIN_RESULT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_MIN_RESULT = 7
     * }
     */
    public static int G_TEST_LOG_MIN_RESULT() {
        return G_TEST_LOG_MIN_RESULT;
    }
    private static final int G_TEST_LOG_MAX_RESULT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_MAX_RESULT = 8
     * }
     */
    public static int G_TEST_LOG_MAX_RESULT() {
        return G_TEST_LOG_MAX_RESULT;
    }
    private static final int G_TEST_LOG_MESSAGE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_MESSAGE = 9
     * }
     */
    public static int G_TEST_LOG_MESSAGE() {
        return G_TEST_LOG_MESSAGE;
    }
    private static final int G_TEST_LOG_START_SUITE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_START_SUITE = 10
     * }
     */
    public static int G_TEST_LOG_START_SUITE() {
        return G_TEST_LOG_START_SUITE;
    }
    private static final int G_TEST_LOG_STOP_SUITE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_LOG_STOP_SUITE = 11
     * }
     */
    public static int G_TEST_LOG_STOP_SUITE() {
        return G_TEST_LOG_STOP_SUITE;
    }

    private static class g_test_log_type_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_log_type_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *g_test_log_type_name(GTestLogType log_type)
     * }
     */
    public static FunctionDescriptor g_test_log_type_name$descriptor() {
        return g_test_log_type_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *g_test_log_type_name(GTestLogType log_type)
     * }
     */
    public static MethodHandle g_test_log_type_name$handle() {
        return g_test_log_type_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *g_test_log_type_name(GTestLogType log_type)
     * }
     */
    public static MemorySegment g_test_log_type_name$address() {
        return g_test_log_type_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *g_test_log_type_name(GTestLogType log_type)
     * }
     */
    public static MemorySegment g_test_log_type_name(int log_type) {
        var mh$ = g_test_log_type_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_log_type_name", log_type);
            }
            return (MemorySegment)mh$.invokeExact(log_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_log_buffer_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_log_buffer_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTestLogBuffer *g_test_log_buffer_new()
     * }
     */
    public static FunctionDescriptor g_test_log_buffer_new$descriptor() {
        return g_test_log_buffer_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTestLogBuffer *g_test_log_buffer_new()
     * }
     */
    public static MethodHandle g_test_log_buffer_new$handle() {
        return g_test_log_buffer_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTestLogBuffer *g_test_log_buffer_new()
     * }
     */
    public static MemorySegment g_test_log_buffer_new$address() {
        return g_test_log_buffer_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTestLogBuffer *g_test_log_buffer_new()
     * }
     */
    public static MemorySegment g_test_log_buffer_new() {
        var mh$ = g_test_log_buffer_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_log_buffer_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_log_buffer_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_log_buffer_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer)
     * }
     */
    public static FunctionDescriptor g_test_log_buffer_free$descriptor() {
        return g_test_log_buffer_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer)
     * }
     */
    public static MethodHandle g_test_log_buffer_free$handle() {
        return g_test_log_buffer_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer)
     * }
     */
    public static MemorySegment g_test_log_buffer_free$address() {
        return g_test_log_buffer_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer)
     * }
     */
    public static void g_test_log_buffer_free(MemorySegment tbuffer) {
        var mh$ = g_test_log_buffer_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_log_buffer_free", tbuffer);
            }
            mh$.invokeExact(tbuffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_log_buffer_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_log_buffer_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes)
     * }
     */
    public static FunctionDescriptor g_test_log_buffer_push$descriptor() {
        return g_test_log_buffer_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes)
     * }
     */
    public static MethodHandle g_test_log_buffer_push$handle() {
        return g_test_log_buffer_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes)
     * }
     */
    public static MemorySegment g_test_log_buffer_push$address() {
        return g_test_log_buffer_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes)
     * }
     */
    public static void g_test_log_buffer_push(MemorySegment tbuffer, int n_bytes, MemorySegment bytes) {
        var mh$ = g_test_log_buffer_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_log_buffer_push", tbuffer, n_bytes, bytes);
            }
            mh$.invokeExact(tbuffer, n_bytes, bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_log_buffer_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_log_buffer_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer)
     * }
     */
    public static FunctionDescriptor g_test_log_buffer_pop$descriptor() {
        return g_test_log_buffer_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer)
     * }
     */
    public static MethodHandle g_test_log_buffer_pop$handle() {
        return g_test_log_buffer_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer)
     * }
     */
    public static MemorySegment g_test_log_buffer_pop$address() {
        return g_test_log_buffer_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer)
     * }
     */
    public static MemorySegment g_test_log_buffer_pop(MemorySegment tbuffer) {
        var mh$ = g_test_log_buffer_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_log_buffer_pop", tbuffer);
            }
            return (MemorySegment)mh$.invokeExact(tbuffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_log_msg_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_log_msg_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_log_msg_free(GTestLogMsg *tmsg)
     * }
     */
    public static FunctionDescriptor g_test_log_msg_free$descriptor() {
        return g_test_log_msg_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_log_msg_free(GTestLogMsg *tmsg)
     * }
     */
    public static MethodHandle g_test_log_msg_free$handle() {
        return g_test_log_msg_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_log_msg_free(GTestLogMsg *tmsg)
     * }
     */
    public static MemorySegment g_test_log_msg_free$address() {
        return g_test_log_msg_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_log_msg_free(GTestLogMsg *tmsg)
     * }
     */
    public static void g_test_log_msg_free(MemorySegment tmsg) {
        var mh$ = g_test_log_msg_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_log_msg_free", tmsg);
            }
            mh$.invokeExact(tmsg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_log_set_fatal_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_log_set_fatal_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_test_log_set_fatal_handler$descriptor() {
        return g_test_log_set_fatal_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_test_log_set_fatal_handler$handle() {
        return g_test_log_set_fatal_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_test_log_set_fatal_handler$address() {
        return g_test_log_set_fatal_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func, gpointer user_data)
     * }
     */
    public static void g_test_log_set_fatal_handler(MemorySegment log_func, MemorySegment user_data) {
        var mh$ = g_test_log_set_fatal_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_log_set_fatal_handler", log_func, user_data);
            }
            mh$.invokeExact(log_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_expect_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_expect_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_expect_message(const gchar *log_domain, GLogLevelFlags log_level, const gchar *pattern)
     * }
     */
    public static FunctionDescriptor g_test_expect_message$descriptor() {
        return g_test_expect_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_expect_message(const gchar *log_domain, GLogLevelFlags log_level, const gchar *pattern)
     * }
     */
    public static MethodHandle g_test_expect_message$handle() {
        return g_test_expect_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_expect_message(const gchar *log_domain, GLogLevelFlags log_level, const gchar *pattern)
     * }
     */
    public static MemorySegment g_test_expect_message$address() {
        return g_test_expect_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_expect_message(const gchar *log_domain, GLogLevelFlags log_level, const gchar *pattern)
     * }
     */
    public static void g_test_expect_message(MemorySegment log_domain, int log_level, MemorySegment pattern) {
        var mh$ = g_test_expect_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_expect_message", log_domain, log_level, pattern);
            }
            mh$.invokeExact(log_domain, log_level, pattern);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_test_assert_expected_messages_internal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_assert_expected_messages_internal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_test_assert_expected_messages_internal(const char *domain, const char *file, int line, const char *func)
     * }
     */
    public static FunctionDescriptor g_test_assert_expected_messages_internal$descriptor() {
        return g_test_assert_expected_messages_internal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_test_assert_expected_messages_internal(const char *domain, const char *file, int line, const char *func)
     * }
     */
    public static MethodHandle g_test_assert_expected_messages_internal$handle() {
        return g_test_assert_expected_messages_internal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_test_assert_expected_messages_internal(const char *domain, const char *file, int line, const char *func)
     * }
     */
    public static MemorySegment g_test_assert_expected_messages_internal$address() {
        return g_test_assert_expected_messages_internal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_test_assert_expected_messages_internal(const char *domain, const char *file, int line, const char *func)
     * }
     */
    public static void g_test_assert_expected_messages_internal(MemorySegment domain, MemorySegment file, int line, MemorySegment func) {
        var mh$ = g_test_assert_expected_messages_internal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_assert_expected_messages_internal", domain, file, line, func);
            }
            mh$.invokeExact(domain, file, line, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_TEST_DIST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_DIST = 0
     * }
     */
    public static int G_TEST_DIST() {
        return G_TEST_DIST;
    }
    private static final int G_TEST_BUILT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TEST_BUILT = 1
     * }
     */
    public static int G_TEST_BUILT() {
        return G_TEST_BUILT;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gchar *g_test_build_filename(GTestFileType file_type, const gchar *first_path, ...)
     * }
     */
    public static class g_test_build_filename {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_build_filename");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_build_filename(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gchar *g_test_build_filename(GTestFileType file_type, const gchar *first_path, ...)
         * }
         */
        public static g_test_build_filename makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_build_filename(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(int file_type, MemorySegment first_path, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_build_filename", file_type, first_path, x2);
                }
                return (MemorySegment) spreader.invokeExact(file_type, first_path, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_test_get_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_get_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_test_get_dir(GTestFileType file_type)
     * }
     */
    public static FunctionDescriptor g_test_get_dir$descriptor() {
        return g_test_get_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_test_get_dir(GTestFileType file_type)
     * }
     */
    public static MethodHandle g_test_get_dir$handle() {
        return g_test_get_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_test_get_dir(GTestFileType file_type)
     * }
     */
    public static MemorySegment g_test_get_dir$address() {
        return g_test_get_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_test_get_dir(GTestFileType file_type)
     * }
     */
    public static MemorySegment g_test_get_dir(int file_type) {
        var mh$ = g_test_get_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_test_get_dir", file_type);
            }
            return (MemorySegment)mh$.invokeExact(file_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern const gchar *g_test_get_filename(GTestFileType file_type, const gchar *first_path, ...)
     * }
     */
    public static class g_test_get_filename {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_test_get_filename");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_test_get_filename(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern const gchar *g_test_get_filename(GTestFileType file_type, const gchar *first_path, ...)
         * }
         */
        public static g_test_get_filename makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_test_get_filename(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(int file_type, MemorySegment first_path, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_test_get_filename", file_type, first_path, x2);
                }
                return (MemorySegment) spreader.invokeExact(file_type, first_path, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_thread_pool_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GThreadPool *g_thread_pool_new(GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error)
     * }
     */
    public static FunctionDescriptor g_thread_pool_new$descriptor() {
        return g_thread_pool_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GThreadPool *g_thread_pool_new(GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error)
     * }
     */
    public static MethodHandle g_thread_pool_new$handle() {
        return g_thread_pool_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GThreadPool *g_thread_pool_new(GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error)
     * }
     */
    public static MemorySegment g_thread_pool_new$address() {
        return g_thread_pool_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GThreadPool *g_thread_pool_new(GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error)
     * }
     */
    public static MemorySegment g_thread_pool_new(MemorySegment func, MemorySegment user_data, int max_threads, int exclusive, MemorySegment error) {
        var mh$ = g_thread_pool_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_new", func, user_data, max_threads, exclusive, error);
            }
            return (MemorySegment)mh$.invokeExact(func, user_data, max_threads, exclusive, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_new_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_new_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GThreadPool *g_thread_pool_new_full(GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError **error)
     * }
     */
    public static FunctionDescriptor g_thread_pool_new_full$descriptor() {
        return g_thread_pool_new_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GThreadPool *g_thread_pool_new_full(GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError **error)
     * }
     */
    public static MethodHandle g_thread_pool_new_full$handle() {
        return g_thread_pool_new_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GThreadPool *g_thread_pool_new_full(GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError **error)
     * }
     */
    public static MemorySegment g_thread_pool_new_full$address() {
        return g_thread_pool_new_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GThreadPool *g_thread_pool_new_full(GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError **error)
     * }
     */
    public static MemorySegment g_thread_pool_new_full(MemorySegment func, MemorySegment user_data, MemorySegment item_free_func, int max_threads, int exclusive, MemorySegment error) {
        var mh$ = g_thread_pool_new_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_new_full", func, user_data, item_free_func, max_threads, exclusive, error);
            }
            return (MemorySegment)mh$.invokeExact(func, user_data, item_free_func, max_threads, exclusive, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_pool_free(GThreadPool *pool, gboolean immediate, gboolean wait_)
     * }
     */
    public static FunctionDescriptor g_thread_pool_free$descriptor() {
        return g_thread_pool_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_pool_free(GThreadPool *pool, gboolean immediate, gboolean wait_)
     * }
     */
    public static MethodHandle g_thread_pool_free$handle() {
        return g_thread_pool_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_pool_free(GThreadPool *pool, gboolean immediate, gboolean wait_)
     * }
     */
    public static MemorySegment g_thread_pool_free$address() {
        return g_thread_pool_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_pool_free(GThreadPool *pool, gboolean immediate, gboolean wait_)
     * }
     */
    public static void g_thread_pool_free(MemorySegment pool, int immediate, int wait_) {
        var mh$ = g_thread_pool_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_free", pool, immediate, wait_);
            }
            mh$.invokeExact(pool, immediate, wait_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_push(GThreadPool *pool, gpointer data, GError **error)
     * }
     */
    public static FunctionDescriptor g_thread_pool_push$descriptor() {
        return g_thread_pool_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_push(GThreadPool *pool, gpointer data, GError **error)
     * }
     */
    public static MethodHandle g_thread_pool_push$handle() {
        return g_thread_pool_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_push(GThreadPool *pool, gpointer data, GError **error)
     * }
     */
    public static MemorySegment g_thread_pool_push$address() {
        return g_thread_pool_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_push(GThreadPool *pool, gpointer data, GError **error)
     * }
     */
    public static int g_thread_pool_push(MemorySegment pool, MemorySegment data, MemorySegment error) {
        var mh$ = g_thread_pool_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_push", pool, data, error);
            }
            return (int)mh$.invokeExact(pool, data, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_unprocessed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_unprocessed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_unprocessed(GThreadPool *pool)
     * }
     */
    public static FunctionDescriptor g_thread_pool_unprocessed$descriptor() {
        return g_thread_pool_unprocessed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_unprocessed(GThreadPool *pool)
     * }
     */
    public static MethodHandle g_thread_pool_unprocessed$handle() {
        return g_thread_pool_unprocessed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_unprocessed(GThreadPool *pool)
     * }
     */
    public static MemorySegment g_thread_pool_unprocessed$address() {
        return g_thread_pool_unprocessed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_thread_pool_unprocessed(GThreadPool *pool)
     * }
     */
    public static int g_thread_pool_unprocessed(MemorySegment pool) {
        var mh$ = g_thread_pool_unprocessed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_unprocessed", pool);
            }
            return (int)mh$.invokeExact(pool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_set_sort_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_set_sort_function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_sort_function(GThreadPool *pool, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_thread_pool_set_sort_function$descriptor() {
        return g_thread_pool_set_sort_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_sort_function(GThreadPool *pool, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_thread_pool_set_sort_function$handle() {
        return g_thread_pool_set_sort_function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_sort_function(GThreadPool *pool, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_thread_pool_set_sort_function$address() {
        return g_thread_pool_set_sort_function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_pool_set_sort_function(GThreadPool *pool, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static void g_thread_pool_set_sort_function(MemorySegment pool, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_thread_pool_set_sort_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_set_sort_function", pool, func, user_data);
            }
            mh$.invokeExact(pool, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_move_to_front {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_move_to_front");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_move_to_front(GThreadPool *pool, gpointer data)
     * }
     */
    public static FunctionDescriptor g_thread_pool_move_to_front$descriptor() {
        return g_thread_pool_move_to_front.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_move_to_front(GThreadPool *pool, gpointer data)
     * }
     */
    public static MethodHandle g_thread_pool_move_to_front$handle() {
        return g_thread_pool_move_to_front.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_move_to_front(GThreadPool *pool, gpointer data)
     * }
     */
    public static MemorySegment g_thread_pool_move_to_front$address() {
        return g_thread_pool_move_to_front.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_move_to_front(GThreadPool *pool, gpointer data)
     * }
     */
    public static int g_thread_pool_move_to_front(MemorySegment pool, MemorySegment data) {
        var mh$ = g_thread_pool_move_to_front.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_move_to_front", pool, data);
            }
            return (int)mh$.invokeExact(pool, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_set_max_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_set_max_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool, gint max_threads, GError **error)
     * }
     */
    public static FunctionDescriptor g_thread_pool_set_max_threads$descriptor() {
        return g_thread_pool_set_max_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool, gint max_threads, GError **error)
     * }
     */
    public static MethodHandle g_thread_pool_set_max_threads$handle() {
        return g_thread_pool_set_max_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool, gint max_threads, GError **error)
     * }
     */
    public static MemorySegment g_thread_pool_set_max_threads$address() {
        return g_thread_pool_set_max_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool, gint max_threads, GError **error)
     * }
     */
    public static int g_thread_pool_set_max_threads(MemorySegment pool, int max_threads, MemorySegment error) {
        var mh$ = g_thread_pool_set_max_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_set_max_threads", pool, max_threads, error);
            }
            return (int)mh$.invokeExact(pool, max_threads, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_get_max_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_get_max_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_thread_pool_get_max_threads(GThreadPool *pool)
     * }
     */
    public static FunctionDescriptor g_thread_pool_get_max_threads$descriptor() {
        return g_thread_pool_get_max_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_thread_pool_get_max_threads(GThreadPool *pool)
     * }
     */
    public static MethodHandle g_thread_pool_get_max_threads$handle() {
        return g_thread_pool_get_max_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_thread_pool_get_max_threads(GThreadPool *pool)
     * }
     */
    public static MemorySegment g_thread_pool_get_max_threads$address() {
        return g_thread_pool_get_max_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_thread_pool_get_max_threads(GThreadPool *pool)
     * }
     */
    public static int g_thread_pool_get_max_threads(MemorySegment pool) {
        var mh$ = g_thread_pool_get_max_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_get_max_threads", pool);
            }
            return (int)mh$.invokeExact(pool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_get_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_get_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_num_threads(GThreadPool *pool)
     * }
     */
    public static FunctionDescriptor g_thread_pool_get_num_threads$descriptor() {
        return g_thread_pool_get_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_num_threads(GThreadPool *pool)
     * }
     */
    public static MethodHandle g_thread_pool_get_num_threads$handle() {
        return g_thread_pool_get_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_num_threads(GThreadPool *pool)
     * }
     */
    public static MemorySegment g_thread_pool_get_num_threads$address() {
        return g_thread_pool_get_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_num_threads(GThreadPool *pool)
     * }
     */
    public static int g_thread_pool_get_num_threads(MemorySegment pool) {
        var mh$ = g_thread_pool_get_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_get_num_threads", pool);
            }
            return (int)mh$.invokeExact(pool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_set_max_unused_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_set_max_unused_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_max_unused_threads(gint max_threads)
     * }
     */
    public static FunctionDescriptor g_thread_pool_set_max_unused_threads$descriptor() {
        return g_thread_pool_set_max_unused_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_max_unused_threads(gint max_threads)
     * }
     */
    public static MethodHandle g_thread_pool_set_max_unused_threads$handle() {
        return g_thread_pool_set_max_unused_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_max_unused_threads(gint max_threads)
     * }
     */
    public static MemorySegment g_thread_pool_set_max_unused_threads$address() {
        return g_thread_pool_set_max_unused_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_pool_set_max_unused_threads(gint max_threads)
     * }
     */
    public static void g_thread_pool_set_max_unused_threads(int max_threads) {
        var mh$ = g_thread_pool_set_max_unused_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_set_max_unused_threads", max_threads);
            }
            mh$.invokeExact(max_threads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_get_max_unused_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_get_max_unused_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_thread_pool_get_max_unused_threads()
     * }
     */
    public static FunctionDescriptor g_thread_pool_get_max_unused_threads$descriptor() {
        return g_thread_pool_get_max_unused_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_thread_pool_get_max_unused_threads()
     * }
     */
    public static MethodHandle g_thread_pool_get_max_unused_threads$handle() {
        return g_thread_pool_get_max_unused_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_thread_pool_get_max_unused_threads()
     * }
     */
    public static MemorySegment g_thread_pool_get_max_unused_threads$address() {
        return g_thread_pool_get_max_unused_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_thread_pool_get_max_unused_threads()
     * }
     */
    public static int g_thread_pool_get_max_unused_threads() {
        var mh$ = g_thread_pool_get_max_unused_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_get_max_unused_threads");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_get_num_unused_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_get_num_unused_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_num_unused_threads()
     * }
     */
    public static FunctionDescriptor g_thread_pool_get_num_unused_threads$descriptor() {
        return g_thread_pool_get_num_unused_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_num_unused_threads()
     * }
     */
    public static MethodHandle g_thread_pool_get_num_unused_threads$handle() {
        return g_thread_pool_get_num_unused_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_num_unused_threads()
     * }
     */
    public static MemorySegment g_thread_pool_get_num_unused_threads$address() {
        return g_thread_pool_get_num_unused_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_num_unused_threads()
     * }
     */
    public static int g_thread_pool_get_num_unused_threads() {
        var mh$ = g_thread_pool_get_num_unused_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_get_num_unused_threads");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_stop_unused_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_stop_unused_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_pool_stop_unused_threads()
     * }
     */
    public static FunctionDescriptor g_thread_pool_stop_unused_threads$descriptor() {
        return g_thread_pool_stop_unused_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_pool_stop_unused_threads()
     * }
     */
    public static MethodHandle g_thread_pool_stop_unused_threads$handle() {
        return g_thread_pool_stop_unused_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_pool_stop_unused_threads()
     * }
     */
    public static MemorySegment g_thread_pool_stop_unused_threads$address() {
        return g_thread_pool_stop_unused_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_pool_stop_unused_threads()
     * }
     */
    public static void g_thread_pool_stop_unused_threads() {
        var mh$ = g_thread_pool_stop_unused_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_stop_unused_threads");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_set_max_idle_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_set_max_idle_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_max_idle_time(guint interval)
     * }
     */
    public static FunctionDescriptor g_thread_pool_set_max_idle_time$descriptor() {
        return g_thread_pool_set_max_idle_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_max_idle_time(guint interval)
     * }
     */
    public static MethodHandle g_thread_pool_set_max_idle_time$handle() {
        return g_thread_pool_set_max_idle_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_pool_set_max_idle_time(guint interval)
     * }
     */
    public static MemorySegment g_thread_pool_set_max_idle_time$address() {
        return g_thread_pool_set_max_idle_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_pool_set_max_idle_time(guint interval)
     * }
     */
    public static void g_thread_pool_set_max_idle_time(int interval) {
        var mh$ = g_thread_pool_set_max_idle_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_set_max_idle_time", interval);
            }
            mh$.invokeExact(interval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_pool_get_max_idle_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_pool_get_max_idle_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_max_idle_time()
     * }
     */
    public static FunctionDescriptor g_thread_pool_get_max_idle_time$descriptor() {
        return g_thread_pool_get_max_idle_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_max_idle_time()
     * }
     */
    public static MethodHandle g_thread_pool_get_max_idle_time$handle() {
        return g_thread_pool_get_max_idle_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_max_idle_time()
     * }
     */
    public static MemorySegment g_thread_pool_get_max_idle_time$address() {
        return g_thread_pool_get_max_idle_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_thread_pool_get_max_idle_time()
     * }
     */
    public static int g_thread_pool_get_max_idle_time() {
        var mh$ = g_thread_pool_get_max_idle_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_pool_get_max_idle_time");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timer_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timer_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTimer *g_timer_new()
     * }
     */
    public static FunctionDescriptor g_timer_new$descriptor() {
        return g_timer_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTimer *g_timer_new()
     * }
     */
    public static MethodHandle g_timer_new$handle() {
        return g_timer_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTimer *g_timer_new()
     * }
     */
    public static MemorySegment g_timer_new$address() {
        return g_timer_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTimer *g_timer_new()
     * }
     */
    public static MemorySegment g_timer_new() {
        var mh$ = g_timer_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timer_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timer_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timer_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_timer_destroy(GTimer *timer)
     * }
     */
    public static FunctionDescriptor g_timer_destroy$descriptor() {
        return g_timer_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_timer_destroy(GTimer *timer)
     * }
     */
    public static MethodHandle g_timer_destroy$handle() {
        return g_timer_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_timer_destroy(GTimer *timer)
     * }
     */
    public static MemorySegment g_timer_destroy$address() {
        return g_timer_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_timer_destroy(GTimer *timer)
     * }
     */
    public static void g_timer_destroy(MemorySegment timer) {
        var mh$ = g_timer_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timer_destroy", timer);
            }
            mh$.invokeExact(timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timer_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timer_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_timer_start(GTimer *timer)
     * }
     */
    public static FunctionDescriptor g_timer_start$descriptor() {
        return g_timer_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_timer_start(GTimer *timer)
     * }
     */
    public static MethodHandle g_timer_start$handle() {
        return g_timer_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_timer_start(GTimer *timer)
     * }
     */
    public static MemorySegment g_timer_start$address() {
        return g_timer_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_timer_start(GTimer *timer)
     * }
     */
    public static void g_timer_start(MemorySegment timer) {
        var mh$ = g_timer_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timer_start", timer);
            }
            mh$.invokeExact(timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timer_stop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timer_stop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_timer_stop(GTimer *timer)
     * }
     */
    public static FunctionDescriptor g_timer_stop$descriptor() {
        return g_timer_stop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_timer_stop(GTimer *timer)
     * }
     */
    public static MethodHandle g_timer_stop$handle() {
        return g_timer_stop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_timer_stop(GTimer *timer)
     * }
     */
    public static MemorySegment g_timer_stop$address() {
        return g_timer_stop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_timer_stop(GTimer *timer)
     * }
     */
    public static void g_timer_stop(MemorySegment timer) {
        var mh$ = g_timer_stop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timer_stop", timer);
            }
            mh$.invokeExact(timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timer_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timer_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_timer_reset(GTimer *timer)
     * }
     */
    public static FunctionDescriptor g_timer_reset$descriptor() {
        return g_timer_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_timer_reset(GTimer *timer)
     * }
     */
    public static MethodHandle g_timer_reset$handle() {
        return g_timer_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_timer_reset(GTimer *timer)
     * }
     */
    public static MemorySegment g_timer_reset$address() {
        return g_timer_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_timer_reset(GTimer *timer)
     * }
     */
    public static void g_timer_reset(MemorySegment timer) {
        var mh$ = g_timer_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timer_reset", timer);
            }
            mh$.invokeExact(timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timer_continue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timer_continue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_timer_continue(GTimer *timer)
     * }
     */
    public static FunctionDescriptor g_timer_continue$descriptor() {
        return g_timer_continue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_timer_continue(GTimer *timer)
     * }
     */
    public static MethodHandle g_timer_continue$handle() {
        return g_timer_continue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_timer_continue(GTimer *timer)
     * }
     */
    public static MemorySegment g_timer_continue$address() {
        return g_timer_continue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_timer_continue(GTimer *timer)
     * }
     */
    public static void g_timer_continue(MemorySegment timer) {
        var mh$ = g_timer_continue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timer_continue", timer);
            }
            mh$.invokeExact(timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timer_elapsed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timer_elapsed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_timer_elapsed(GTimer *timer, gulong *microseconds)
     * }
     */
    public static FunctionDescriptor g_timer_elapsed$descriptor() {
        return g_timer_elapsed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_timer_elapsed(GTimer *timer, gulong *microseconds)
     * }
     */
    public static MethodHandle g_timer_elapsed$handle() {
        return g_timer_elapsed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_timer_elapsed(GTimer *timer, gulong *microseconds)
     * }
     */
    public static MemorySegment g_timer_elapsed$address() {
        return g_timer_elapsed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_timer_elapsed(GTimer *timer, gulong *microseconds)
     * }
     */
    public static double g_timer_elapsed(MemorySegment timer, MemorySegment microseconds) {
        var mh$ = g_timer_elapsed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timer_elapsed", timer, microseconds);
            }
            return (double)mh$.invokeExact(timer, microseconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timer_is_active {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timer_is_active");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_timer_is_active(GTimer *timer)
     * }
     */
    public static FunctionDescriptor g_timer_is_active$descriptor() {
        return g_timer_is_active.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_timer_is_active(GTimer *timer)
     * }
     */
    public static MethodHandle g_timer_is_active$handle() {
        return g_timer_is_active.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_timer_is_active(GTimer *timer)
     * }
     */
    public static MemorySegment g_timer_is_active$address() {
        return g_timer_is_active.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_timer_is_active(GTimer *timer)
     * }
     */
    public static int g_timer_is_active(MemorySegment timer) {
        var mh$ = g_timer_is_active.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timer_is_active", timer);
            }
            return (int)mh$.invokeExact(timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_usleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_usleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_usleep(gulong microseconds)
     * }
     */
    public static FunctionDescriptor g_usleep$descriptor() {
        return g_usleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_usleep(gulong microseconds)
     * }
     */
    public static MethodHandle g_usleep$handle() {
        return g_usleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_usleep(gulong microseconds)
     * }
     */
    public static MemorySegment g_usleep$address() {
        return g_usleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_usleep(gulong microseconds)
     * }
     */
    public static void g_usleep(int microseconds) {
        var mh$ = g_usleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_usleep", microseconds);
            }
            mh$.invokeExact(microseconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_val_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_val_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_time_val_add(GTimeVal *time_, glong microseconds)
     * }
     */
    public static FunctionDescriptor g_time_val_add$descriptor() {
        return g_time_val_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_time_val_add(GTimeVal *time_, glong microseconds)
     * }
     */
    public static MethodHandle g_time_val_add$handle() {
        return g_time_val_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_time_val_add(GTimeVal *time_, glong microseconds)
     * }
     */
    public static MemorySegment g_time_val_add$address() {
        return g_time_val_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_time_val_add(GTimeVal *time_, glong microseconds)
     * }
     */
    public static void g_time_val_add(MemorySegment time_, int microseconds) {
        var mh$ = g_time_val_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_val_add", time_, microseconds);
            }
            mh$.invokeExact(time_, microseconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_val_from_iso8601 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_val_from_iso8601");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_time_val_from_iso8601(const gchar *iso_date, GTimeVal *time_)
     * }
     */
    public static FunctionDescriptor g_time_val_from_iso8601$descriptor() {
        return g_time_val_from_iso8601.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_time_val_from_iso8601(const gchar *iso_date, GTimeVal *time_)
     * }
     */
    public static MethodHandle g_time_val_from_iso8601$handle() {
        return g_time_val_from_iso8601.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_time_val_from_iso8601(const gchar *iso_date, GTimeVal *time_)
     * }
     */
    public static MemorySegment g_time_val_from_iso8601$address() {
        return g_time_val_from_iso8601.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_time_val_from_iso8601(const gchar *iso_date, GTimeVal *time_)
     * }
     */
    public static int g_time_val_from_iso8601(MemorySegment iso_date, MemorySegment time_) {
        var mh$ = g_time_val_from_iso8601.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_val_from_iso8601", iso_date, time_);
            }
            return (int)mh$.invokeExact(iso_date, time_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_val_to_iso8601 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_val_to_iso8601");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_time_val_to_iso8601(GTimeVal *time_)
     * }
     */
    public static FunctionDescriptor g_time_val_to_iso8601$descriptor() {
        return g_time_val_to_iso8601.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_time_val_to_iso8601(GTimeVal *time_)
     * }
     */
    public static MethodHandle g_time_val_to_iso8601$handle() {
        return g_time_val_to_iso8601.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_time_val_to_iso8601(GTimeVal *time_)
     * }
     */
    public static MemorySegment g_time_val_to_iso8601$address() {
        return g_time_val_to_iso8601.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_time_val_to_iso8601(GTimeVal *time_)
     * }
     */
    public static MemorySegment g_time_val_to_iso8601(MemorySegment time_) {
        var mh$ = g_time_val_to_iso8601.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_val_to_iso8601", time_);
            }
            return (MemorySegment)mh$.invokeExact(time_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_trash_stack_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_trash_stack_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_trash_stack_push(GTrashStack **stack_p, gpointer data_p)
     * }
     */
    public static FunctionDescriptor g_trash_stack_push$descriptor() {
        return g_trash_stack_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_trash_stack_push(GTrashStack **stack_p, gpointer data_p)
     * }
     */
    public static MethodHandle g_trash_stack_push$handle() {
        return g_trash_stack_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_trash_stack_push(GTrashStack **stack_p, gpointer data_p)
     * }
     */
    public static MemorySegment g_trash_stack_push$address() {
        return g_trash_stack_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_trash_stack_push(GTrashStack **stack_p, gpointer data_p)
     * }
     */
    public static void g_trash_stack_push(MemorySegment stack_p, MemorySegment data_p) {
        var mh$ = g_trash_stack_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_trash_stack_push", stack_p, data_p);
            }
            mh$.invokeExact(stack_p, data_p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_trash_stack_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_trash_stack_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_trash_stack_pop(GTrashStack **stack_p)
     * }
     */
    public static FunctionDescriptor g_trash_stack_pop$descriptor() {
        return g_trash_stack_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_trash_stack_pop(GTrashStack **stack_p)
     * }
     */
    public static MethodHandle g_trash_stack_pop$handle() {
        return g_trash_stack_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_trash_stack_pop(GTrashStack **stack_p)
     * }
     */
    public static MemorySegment g_trash_stack_pop$address() {
        return g_trash_stack_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_trash_stack_pop(GTrashStack **stack_p)
     * }
     */
    public static MemorySegment g_trash_stack_pop(MemorySegment stack_p) {
        var mh$ = g_trash_stack_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_trash_stack_pop", stack_p);
            }
            return (MemorySegment)mh$.invokeExact(stack_p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_trash_stack_peek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_trash_stack_peek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_trash_stack_peek(GTrashStack **stack_p)
     * }
     */
    public static FunctionDescriptor g_trash_stack_peek$descriptor() {
        return g_trash_stack_peek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_trash_stack_peek(GTrashStack **stack_p)
     * }
     */
    public static MethodHandle g_trash_stack_peek$handle() {
        return g_trash_stack_peek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_trash_stack_peek(GTrashStack **stack_p)
     * }
     */
    public static MemorySegment g_trash_stack_peek$address() {
        return g_trash_stack_peek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_trash_stack_peek(GTrashStack **stack_p)
     * }
     */
    public static MemorySegment g_trash_stack_peek(MemorySegment stack_p) {
        var mh$ = g_trash_stack_peek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_trash_stack_peek", stack_p);
            }
            return (MemorySegment)mh$.invokeExact(stack_p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_trash_stack_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_trash_stack_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_trash_stack_height(GTrashStack **stack_p)
     * }
     */
    public static FunctionDescriptor g_trash_stack_height$descriptor() {
        return g_trash_stack_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_trash_stack_height(GTrashStack **stack_p)
     * }
     */
    public static MethodHandle g_trash_stack_height$handle() {
        return g_trash_stack_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_trash_stack_height(GTrashStack **stack_p)
     * }
     */
    public static MemorySegment g_trash_stack_height$address() {
        return g_trash_stack_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_trash_stack_height(GTrashStack **stack_p)
     * }
     */
    public static int g_trash_stack_height(MemorySegment stack_p) {
        var mh$ = g_trash_stack_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_trash_stack_height", stack_p);
            }
            return (int)mh$.invokeExact(stack_p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new(GCompareFunc key_compare_func)
     * }
     */
    public static FunctionDescriptor g_tree_new$descriptor() {
        return g_tree_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new(GCompareFunc key_compare_func)
     * }
     */
    public static MethodHandle g_tree_new$handle() {
        return g_tree_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new(GCompareFunc key_compare_func)
     * }
     */
    public static MemorySegment g_tree_new$address() {
        return g_tree_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTree *g_tree_new(GCompareFunc key_compare_func)
     * }
     */
    public static MemorySegment g_tree_new(MemorySegment key_compare_func) {
        var mh$ = g_tree_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_new", key_compare_func);
            }
            return (MemorySegment)mh$.invokeExact(key_compare_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_new_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_new_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func, gpointer key_compare_data)
     * }
     */
    public static FunctionDescriptor g_tree_new_with_data$descriptor() {
        return g_tree_new_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func, gpointer key_compare_data)
     * }
     */
    public static MethodHandle g_tree_new_with_data$handle() {
        return g_tree_new_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func, gpointer key_compare_data)
     * }
     */
    public static MemorySegment g_tree_new_with_data$address() {
        return g_tree_new_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func, gpointer key_compare_data)
     * }
     */
    public static MemorySegment g_tree_new_with_data(MemorySegment key_compare_func, MemorySegment key_compare_data) {
        var mh$ = g_tree_new_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_new_with_data", key_compare_func, key_compare_data);
            }
            return (MemorySegment)mh$.invokeExact(key_compare_func, key_compare_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_new_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_new_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func)
     * }
     */
    public static FunctionDescriptor g_tree_new_full$descriptor() {
        return g_tree_new_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func)
     * }
     */
    public static MethodHandle g_tree_new_full$handle() {
        return g_tree_new_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func)
     * }
     */
    public static MemorySegment g_tree_new_full$address() {
        return g_tree_new_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func)
     * }
     */
    public static MemorySegment g_tree_new_full(MemorySegment key_compare_func, MemorySegment key_compare_data, MemorySegment key_destroy_func, MemorySegment value_destroy_func) {
        var mh$ = g_tree_new_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_new_full", key_compare_func, key_compare_data, key_destroy_func, value_destroy_func);
            }
            return (MemorySegment)mh$.invokeExact(key_compare_func, key_compare_data, key_destroy_func, value_destroy_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_node_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_node_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_first(GTree *tree)
     * }
     */
    public static FunctionDescriptor g_tree_node_first$descriptor() {
        return g_tree_node_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_first(GTree *tree)
     * }
     */
    public static MethodHandle g_tree_node_first$handle() {
        return g_tree_node_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_first(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_node_first$address() {
        return g_tree_node_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_first(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_node_first(MemorySegment tree) {
        var mh$ = g_tree_node_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_node_first", tree);
            }
            return (MemorySegment)mh$.invokeExact(tree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_node_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_node_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_last(GTree *tree)
     * }
     */
    public static FunctionDescriptor g_tree_node_last$descriptor() {
        return g_tree_node_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_last(GTree *tree)
     * }
     */
    public static MethodHandle g_tree_node_last$handle() {
        return g_tree_node_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_last(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_node_last$address() {
        return g_tree_node_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_last(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_node_last(MemorySegment tree) {
        var mh$ = g_tree_node_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_node_last", tree);
            }
            return (MemorySegment)mh$.invokeExact(tree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_node_previous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_node_previous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_previous(GTreeNode *node)
     * }
     */
    public static FunctionDescriptor g_tree_node_previous$descriptor() {
        return g_tree_node_previous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_previous(GTreeNode *node)
     * }
     */
    public static MethodHandle g_tree_node_previous$handle() {
        return g_tree_node_previous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_previous(GTreeNode *node)
     * }
     */
    public static MemorySegment g_tree_node_previous$address() {
        return g_tree_node_previous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_previous(GTreeNode *node)
     * }
     */
    public static MemorySegment g_tree_node_previous(MemorySegment node) {
        var mh$ = g_tree_node_previous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_node_previous", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_node_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_node_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_next(GTreeNode *node)
     * }
     */
    public static FunctionDescriptor g_tree_node_next$descriptor() {
        return g_tree_node_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_next(GTreeNode *node)
     * }
     */
    public static MethodHandle g_tree_node_next$handle() {
        return g_tree_node_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_next(GTreeNode *node)
     * }
     */
    public static MemorySegment g_tree_node_next$address() {
        return g_tree_node_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_node_next(GTreeNode *node)
     * }
     */
    public static MemorySegment g_tree_node_next(MemorySegment node) {
        var mh$ = g_tree_node_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_node_next", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTree *g_tree_ref(GTree *tree)
     * }
     */
    public static FunctionDescriptor g_tree_ref$descriptor() {
        return g_tree_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTree *g_tree_ref(GTree *tree)
     * }
     */
    public static MethodHandle g_tree_ref$handle() {
        return g_tree_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTree *g_tree_ref(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_ref$address() {
        return g_tree_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTree *g_tree_ref(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_ref(MemorySegment tree) {
        var mh$ = g_tree_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_ref", tree);
            }
            return (MemorySegment)mh$.invokeExact(tree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tree_unref(GTree *tree)
     * }
     */
    public static FunctionDescriptor g_tree_unref$descriptor() {
        return g_tree_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tree_unref(GTree *tree)
     * }
     */
    public static MethodHandle g_tree_unref$handle() {
        return g_tree_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tree_unref(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_unref$address() {
        return g_tree_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tree_unref(GTree *tree)
     * }
     */
    public static void g_tree_unref(MemorySegment tree) {
        var mh$ = g_tree_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_unref", tree);
            }
            mh$.invokeExact(tree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tree_destroy(GTree *tree)
     * }
     */
    public static FunctionDescriptor g_tree_destroy$descriptor() {
        return g_tree_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tree_destroy(GTree *tree)
     * }
     */
    public static MethodHandle g_tree_destroy$handle() {
        return g_tree_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tree_destroy(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_destroy$address() {
        return g_tree_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tree_destroy(GTree *tree)
     * }
     */
    public static void g_tree_destroy(MemorySegment tree) {
        var mh$ = g_tree_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_destroy", tree);
            }
            mh$.invokeExact(tree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_insert_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_insert_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_insert_node(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static FunctionDescriptor g_tree_insert_node$descriptor() {
        return g_tree_insert_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_insert_node(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MethodHandle g_tree_insert_node$handle() {
        return g_tree_insert_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_insert_node(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MemorySegment g_tree_insert_node$address() {
        return g_tree_insert_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_insert_node(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MemorySegment g_tree_insert_node(MemorySegment tree, MemorySegment key, MemorySegment value) {
        var mh$ = g_tree_insert_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_insert_node", tree, key, value);
            }
            return (MemorySegment)mh$.invokeExact(tree, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tree_insert(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static FunctionDescriptor g_tree_insert$descriptor() {
        return g_tree_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tree_insert(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MethodHandle g_tree_insert$handle() {
        return g_tree_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tree_insert(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MemorySegment g_tree_insert$address() {
        return g_tree_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tree_insert(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static void g_tree_insert(MemorySegment tree, MemorySegment key, MemorySegment value) {
        var mh$ = g_tree_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_insert", tree, key, value);
            }
            mh$.invokeExact(tree, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_replace_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_replace_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_replace_node(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static FunctionDescriptor g_tree_replace_node$descriptor() {
        return g_tree_replace_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_replace_node(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MethodHandle g_tree_replace_node$handle() {
        return g_tree_replace_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_replace_node(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MemorySegment g_tree_replace_node$address() {
        return g_tree_replace_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_replace_node(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MemorySegment g_tree_replace_node(MemorySegment tree, MemorySegment key, MemorySegment value) {
        var mh$ = g_tree_replace_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_replace_node", tree, key, value);
            }
            return (MemorySegment)mh$.invokeExact(tree, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tree_replace(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static FunctionDescriptor g_tree_replace$descriptor() {
        return g_tree_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tree_replace(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MethodHandle g_tree_replace$handle() {
        return g_tree_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tree_replace(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static MemorySegment g_tree_replace$address() {
        return g_tree_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tree_replace(GTree *tree, gpointer key, gpointer value)
     * }
     */
    public static void g_tree_replace(MemorySegment tree, MemorySegment key, MemorySegment value) {
        var mh$ = g_tree_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_replace", tree, key, value);
            }
            mh$.invokeExact(tree, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_tree_remove(GTree *tree, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_tree_remove$descriptor() {
        return g_tree_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_tree_remove(GTree *tree, gconstpointer key)
     * }
     */
    public static MethodHandle g_tree_remove$handle() {
        return g_tree_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_tree_remove(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_remove$address() {
        return g_tree_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_tree_remove(GTree *tree, gconstpointer key)
     * }
     */
    public static int g_tree_remove(MemorySegment tree, MemorySegment key) {
        var mh$ = g_tree_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_remove", tree, key);
            }
            return (int)mh$.invokeExact(tree, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_remove_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_remove_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tree_remove_all(GTree *tree)
     * }
     */
    public static FunctionDescriptor g_tree_remove_all$descriptor() {
        return g_tree_remove_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tree_remove_all(GTree *tree)
     * }
     */
    public static MethodHandle g_tree_remove_all$handle() {
        return g_tree_remove_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tree_remove_all(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_remove_all$address() {
        return g_tree_remove_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tree_remove_all(GTree *tree)
     * }
     */
    public static void g_tree_remove_all(MemorySegment tree) {
        var mh$ = g_tree_remove_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_remove_all", tree);
            }
            mh$.invokeExact(tree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_tree_steal(GTree *tree, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_tree_steal$descriptor() {
        return g_tree_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_tree_steal(GTree *tree, gconstpointer key)
     * }
     */
    public static MethodHandle g_tree_steal$handle() {
        return g_tree_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_tree_steal(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_steal$address() {
        return g_tree_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_tree_steal(GTree *tree, gconstpointer key)
     * }
     */
    public static int g_tree_steal(MemorySegment tree, MemorySegment key) {
        var mh$ = g_tree_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_steal", tree, key);
            }
            return (int)mh$.invokeExact(tree, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_node_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_node_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_tree_node_key(GTreeNode *node)
     * }
     */
    public static FunctionDescriptor g_tree_node_key$descriptor() {
        return g_tree_node_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_tree_node_key(GTreeNode *node)
     * }
     */
    public static MethodHandle g_tree_node_key$handle() {
        return g_tree_node_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_tree_node_key(GTreeNode *node)
     * }
     */
    public static MemorySegment g_tree_node_key$address() {
        return g_tree_node_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_tree_node_key(GTreeNode *node)
     * }
     */
    public static MemorySegment g_tree_node_key(MemorySegment node) {
        var mh$ = g_tree_node_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_node_key", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_node_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_node_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_tree_node_value(GTreeNode *node)
     * }
     */
    public static FunctionDescriptor g_tree_node_value$descriptor() {
        return g_tree_node_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_tree_node_value(GTreeNode *node)
     * }
     */
    public static MethodHandle g_tree_node_value$handle() {
        return g_tree_node_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_tree_node_value(GTreeNode *node)
     * }
     */
    public static MemorySegment g_tree_node_value$address() {
        return g_tree_node_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_tree_node_value(GTreeNode *node)
     * }
     */
    public static MemorySegment g_tree_node_value(MemorySegment node) {
        var mh$ = g_tree_node_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_node_value", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_lookup_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_lookup_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_lookup_node(GTree *tree, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_tree_lookup_node$descriptor() {
        return g_tree_lookup_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_lookup_node(GTree *tree, gconstpointer key)
     * }
     */
    public static MethodHandle g_tree_lookup_node$handle() {
        return g_tree_lookup_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_lookup_node(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_lookup_node$address() {
        return g_tree_lookup_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_lookup_node(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_lookup_node(MemorySegment tree, MemorySegment key) {
        var mh$ = g_tree_lookup_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_lookup_node", tree, key);
            }
            return (MemorySegment)mh$.invokeExact(tree, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_tree_lookup(GTree *tree, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_tree_lookup$descriptor() {
        return g_tree_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_tree_lookup(GTree *tree, gconstpointer key)
     * }
     */
    public static MethodHandle g_tree_lookup$handle() {
        return g_tree_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_tree_lookup(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_lookup$address() {
        return g_tree_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_tree_lookup(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_lookup(MemorySegment tree, MemorySegment key) {
        var mh$ = g_tree_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_lookup", tree, key);
            }
            return (MemorySegment)mh$.invokeExact(tree, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_lookup_extended {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_lookup_extended");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_tree_lookup_extended(GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value)
     * }
     */
    public static FunctionDescriptor g_tree_lookup_extended$descriptor() {
        return g_tree_lookup_extended.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_tree_lookup_extended(GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value)
     * }
     */
    public static MethodHandle g_tree_lookup_extended$handle() {
        return g_tree_lookup_extended.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_tree_lookup_extended(GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value)
     * }
     */
    public static MemorySegment g_tree_lookup_extended$address() {
        return g_tree_lookup_extended.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_tree_lookup_extended(GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value)
     * }
     */
    public static int g_tree_lookup_extended(MemorySegment tree, MemorySegment lookup_key, MemorySegment orig_key, MemorySegment value) {
        var mh$ = g_tree_lookup_extended.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_lookup_extended", tree, lookup_key, orig_key, value);
            }
            return (int)mh$.invokeExact(tree, lookup_key, orig_key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tree_foreach(GTree *tree, GTraverseFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_tree_foreach$descriptor() {
        return g_tree_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tree_foreach(GTree *tree, GTraverseFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_tree_foreach$handle() {
        return g_tree_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tree_foreach(GTree *tree, GTraverseFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_tree_foreach$address() {
        return g_tree_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tree_foreach(GTree *tree, GTraverseFunc func, gpointer user_data)
     * }
     */
    public static void g_tree_foreach(MemorySegment tree, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_tree_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_foreach", tree, func, user_data);
            }
            mh$.invokeExact(tree, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_foreach_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_foreach_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tree_foreach_node(GTree *tree, GTraverseNodeFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_tree_foreach_node$descriptor() {
        return g_tree_foreach_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tree_foreach_node(GTree *tree, GTraverseNodeFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_tree_foreach_node$handle() {
        return g_tree_foreach_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tree_foreach_node(GTree *tree, GTraverseNodeFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_tree_foreach_node$address() {
        return g_tree_foreach_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tree_foreach_node(GTree *tree, GTraverseNodeFunc func, gpointer user_data)
     * }
     */
    public static void g_tree_foreach_node(MemorySegment tree, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_tree_foreach_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_foreach_node", tree, func, user_data);
            }
            mh$.invokeExact(tree, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_traverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_traverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tree_traverse(GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_tree_traverse$descriptor() {
        return g_tree_traverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tree_traverse(GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data)
     * }
     */
    public static MethodHandle g_tree_traverse$handle() {
        return g_tree_traverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tree_traverse(GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data)
     * }
     */
    public static MemorySegment g_tree_traverse$address() {
        return g_tree_traverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tree_traverse(GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data)
     * }
     */
    public static void g_tree_traverse(MemorySegment tree, MemorySegment traverse_func, int traverse_type, MemorySegment user_data) {
        var mh$ = g_tree_traverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_traverse", tree, traverse_func, traverse_type, user_data);
            }
            mh$.invokeExact(tree, traverse_func, traverse_type, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_search_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_search_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_search_node(GTree *tree, GCompareFunc search_func, gconstpointer user_data)
     * }
     */
    public static FunctionDescriptor g_tree_search_node$descriptor() {
        return g_tree_search_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_search_node(GTree *tree, GCompareFunc search_func, gconstpointer user_data)
     * }
     */
    public static MethodHandle g_tree_search_node$handle() {
        return g_tree_search_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_search_node(GTree *tree, GCompareFunc search_func, gconstpointer user_data)
     * }
     */
    public static MemorySegment g_tree_search_node$address() {
        return g_tree_search_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_search_node(GTree *tree, GCompareFunc search_func, gconstpointer user_data)
     * }
     */
    public static MemorySegment g_tree_search_node(MemorySegment tree, MemorySegment search_func, MemorySegment user_data) {
        var mh$ = g_tree_search_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_search_node", tree, search_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(tree, search_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_search {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_search");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_tree_search(GTree *tree, GCompareFunc search_func, gconstpointer user_data)
     * }
     */
    public static FunctionDescriptor g_tree_search$descriptor() {
        return g_tree_search.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_tree_search(GTree *tree, GCompareFunc search_func, gconstpointer user_data)
     * }
     */
    public static MethodHandle g_tree_search$handle() {
        return g_tree_search.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_tree_search(GTree *tree, GCompareFunc search_func, gconstpointer user_data)
     * }
     */
    public static MemorySegment g_tree_search$address() {
        return g_tree_search.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_tree_search(GTree *tree, GCompareFunc search_func, gconstpointer user_data)
     * }
     */
    public static MemorySegment g_tree_search(MemorySegment tree, MemorySegment search_func, MemorySegment user_data) {
        var mh$ = g_tree_search.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_search", tree, search_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(tree, search_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_lower_bound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_lower_bound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_lower_bound(GTree *tree, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_tree_lower_bound$descriptor() {
        return g_tree_lower_bound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_lower_bound(GTree *tree, gconstpointer key)
     * }
     */
    public static MethodHandle g_tree_lower_bound$handle() {
        return g_tree_lower_bound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_lower_bound(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_lower_bound$address() {
        return g_tree_lower_bound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_lower_bound(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_lower_bound(MemorySegment tree, MemorySegment key) {
        var mh$ = g_tree_lower_bound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_lower_bound", tree, key);
            }
            return (MemorySegment)mh$.invokeExact(tree, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_upper_bound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_upper_bound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_upper_bound(GTree *tree, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_tree_upper_bound$descriptor() {
        return g_tree_upper_bound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_upper_bound(GTree *tree, gconstpointer key)
     * }
     */
    public static MethodHandle g_tree_upper_bound$handle() {
        return g_tree_upper_bound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_upper_bound(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_upper_bound$address() {
        return g_tree_upper_bound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTreeNode *g_tree_upper_bound(GTree *tree, gconstpointer key)
     * }
     */
    public static MemorySegment g_tree_upper_bound(MemorySegment tree, MemorySegment key) {
        var mh$ = g_tree_upper_bound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_upper_bound", tree, key);
            }
            return (MemorySegment)mh$.invokeExact(tree, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_tree_height(GTree *tree)
     * }
     */
    public static FunctionDescriptor g_tree_height$descriptor() {
        return g_tree_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_tree_height(GTree *tree)
     * }
     */
    public static MethodHandle g_tree_height$handle() {
        return g_tree_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_tree_height(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_height$address() {
        return g_tree_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_tree_height(GTree *tree)
     * }
     */
    public static int g_tree_height(MemorySegment tree) {
        var mh$ = g_tree_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_height", tree);
            }
            return (int)mh$.invokeExact(tree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_nnodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_nnodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_tree_nnodes(GTree *tree)
     * }
     */
    public static FunctionDescriptor g_tree_nnodes$descriptor() {
        return g_tree_nnodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_tree_nnodes(GTree *tree)
     * }
     */
    public static MethodHandle g_tree_nnodes$handle() {
        return g_tree_nnodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_tree_nnodes(GTree *tree)
     * }
     */
    public static MemorySegment g_tree_nnodes$address() {
        return g_tree_nnodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_tree_nnodes(GTree *tree)
     * }
     */
    public static int g_tree_nnodes(MemorySegment tree) {
        var mh$ = g_tree_nnodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_nnodes", tree);
            }
            return (int)mh$.invokeExact(tree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUri *g_uri_ref(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_ref$descriptor() {
        return g_uri_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUri *g_uri_ref(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_ref$handle() {
        return g_uri_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUri *g_uri_ref(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_ref$address() {
        return g_uri_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUri *g_uri_ref(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_ref(MemorySegment uri) {
        var mh$ = g_uri_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_ref", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_uri_unref(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_unref$descriptor() {
        return g_uri_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_uri_unref(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_unref$handle() {
        return g_uri_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_uri_unref(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_unref$address() {
        return g_uri_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_uri_unref(GUri *uri)
     * }
     */
    public static void g_uri_unref(MemorySegment uri) {
        var mh$ = g_uri_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_unref", uri);
            }
            mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_URI_FLAGS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_NONE = 0
     * }
     */
    public static int G_URI_FLAGS_NONE() {
        return G_URI_FLAGS_NONE;
    }
    private static final int G_URI_FLAGS_PARSE_RELAXED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_PARSE_RELAXED = 1
     * }
     */
    public static int G_URI_FLAGS_PARSE_RELAXED() {
        return G_URI_FLAGS_PARSE_RELAXED;
    }
    private static final int G_URI_FLAGS_HAS_PASSWORD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_HAS_PASSWORD = 2
     * }
     */
    public static int G_URI_FLAGS_HAS_PASSWORD() {
        return G_URI_FLAGS_HAS_PASSWORD;
    }
    private static final int G_URI_FLAGS_HAS_AUTH_PARAMS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_HAS_AUTH_PARAMS = 4
     * }
     */
    public static int G_URI_FLAGS_HAS_AUTH_PARAMS() {
        return G_URI_FLAGS_HAS_AUTH_PARAMS;
    }
    private static final int G_URI_FLAGS_ENCODED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_ENCODED = 8
     * }
     */
    public static int G_URI_FLAGS_ENCODED() {
        return G_URI_FLAGS_ENCODED;
    }
    private static final int G_URI_FLAGS_NON_DNS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_NON_DNS = 16
     * }
     */
    public static int G_URI_FLAGS_NON_DNS() {
        return G_URI_FLAGS_NON_DNS;
    }
    private static final int G_URI_FLAGS_ENCODED_QUERY = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_ENCODED_QUERY = 32
     * }
     */
    public static int G_URI_FLAGS_ENCODED_QUERY() {
        return G_URI_FLAGS_ENCODED_QUERY;
    }
    private static final int G_URI_FLAGS_ENCODED_PATH = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_ENCODED_PATH = 64
     * }
     */
    public static int G_URI_FLAGS_ENCODED_PATH() {
        return G_URI_FLAGS_ENCODED_PATH;
    }
    private static final int G_URI_FLAGS_ENCODED_FRAGMENT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_ENCODED_FRAGMENT = 128
     * }
     */
    public static int G_URI_FLAGS_ENCODED_FRAGMENT() {
        return G_URI_FLAGS_ENCODED_FRAGMENT;
    }
    private static final int G_URI_FLAGS_SCHEME_NORMALIZE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_FLAGS_SCHEME_NORMALIZE = 256
     * }
     */
    public static int G_URI_FLAGS_SCHEME_NORMALIZE() {
        return G_URI_FLAGS_SCHEME_NORMALIZE;
    }

    private static class g_uri_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **userinfo, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_split$descriptor() {
        return g_uri_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **userinfo, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error)
     * }
     */
    public static MethodHandle g_uri_split$handle() {
        return g_uri_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **userinfo, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error)
     * }
     */
    public static MemorySegment g_uri_split$address() {
        return g_uri_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_uri_split(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **userinfo, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error)
     * }
     */
    public static int g_uri_split(MemorySegment uri_ref, int flags, MemorySegment scheme, MemorySegment userinfo, MemorySegment host, MemorySegment port, MemorySegment path, MemorySegment query, MemorySegment fragment, MemorySegment error) {
        var mh$ = g_uri_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_split", uri_ref, flags, scheme, userinfo, host, port, path, query, fragment, error);
            }
            return (int)mh$.invokeExact(uri_ref, flags, scheme, userinfo, host, port, path, query, fragment, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_split_with_user {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_split_with_user");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split_with_user(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **user, gchar **password, gchar **auth_params, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_split_with_user$descriptor() {
        return g_uri_split_with_user.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split_with_user(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **user, gchar **password, gchar **auth_params, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error)
     * }
     */
    public static MethodHandle g_uri_split_with_user$handle() {
        return g_uri_split_with_user.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split_with_user(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **user, gchar **password, gchar **auth_params, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error)
     * }
     */
    public static MemorySegment g_uri_split_with_user$address() {
        return g_uri_split_with_user.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_uri_split_with_user(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **user, gchar **password, gchar **auth_params, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error)
     * }
     */
    public static int g_uri_split_with_user(MemorySegment uri_ref, int flags, MemorySegment scheme, MemorySegment user, MemorySegment password, MemorySegment auth_params, MemorySegment host, MemorySegment port, MemorySegment path, MemorySegment query, MemorySegment fragment, MemorySegment error) {
        var mh$ = g_uri_split_with_user.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_split_with_user", uri_ref, flags, scheme, user, password, auth_params, host, port, path, query, fragment, error);
            }
            return (int)mh$.invokeExact(uri_ref, flags, scheme, user, password, auth_params, host, port, path, query, fragment, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_split_network {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_split_network");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split_network(const gchar *uri_string, GUriFlags flags, gchar **scheme, gchar **host, gint *port, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_split_network$descriptor() {
        return g_uri_split_network.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split_network(const gchar *uri_string, GUriFlags flags, gchar **scheme, gchar **host, gint *port, GError **error)
     * }
     */
    public static MethodHandle g_uri_split_network$handle() {
        return g_uri_split_network.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_uri_split_network(const gchar *uri_string, GUriFlags flags, gchar **scheme, gchar **host, gint *port, GError **error)
     * }
     */
    public static MemorySegment g_uri_split_network$address() {
        return g_uri_split_network.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_uri_split_network(const gchar *uri_string, GUriFlags flags, gchar **scheme, gchar **host, gint *port, GError **error)
     * }
     */
    public static int g_uri_split_network(MemorySegment uri_string, int flags, MemorySegment scheme, MemorySegment host, MemorySegment port, MemorySegment error) {
        var mh$ = g_uri_split_network.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_split_network", uri_string, flags, scheme, host, port, error);
            }
            return (int)mh$.invokeExact(uri_string, flags, scheme, host, port, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_uri_is_valid(const gchar *uri_string, GUriFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_is_valid$descriptor() {
        return g_uri_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_uri_is_valid(const gchar *uri_string, GUriFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_uri_is_valid$handle() {
        return g_uri_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_uri_is_valid(const gchar *uri_string, GUriFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_is_valid$address() {
        return g_uri_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_uri_is_valid(const gchar *uri_string, GUriFlags flags, GError **error)
     * }
     */
    public static int g_uri_is_valid(MemorySegment uri_string, int flags, MemorySegment error) {
        var mh$ = g_uri_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_is_valid", uri_string, flags, error);
            }
            return (int)mh$.invokeExact(uri_string, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_uri_join(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static FunctionDescriptor g_uri_join$descriptor() {
        return g_uri_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_uri_join(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MethodHandle g_uri_join$handle() {
        return g_uri_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_uri_join(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MemorySegment g_uri_join$address() {
        return g_uri_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_uri_join(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MemorySegment g_uri_join(int flags, MemorySegment scheme, MemorySegment userinfo, MemorySegment host, int port, MemorySegment path, MemorySegment query, MemorySegment fragment) {
        var mh$ = g_uri_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_join", flags, scheme, userinfo, host, port, path, query, fragment);
            }
            return (MemorySegment)mh$.invokeExact(flags, scheme, userinfo, host, port, path, query, fragment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_join_with_user {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_join_with_user");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_uri_join_with_user(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static FunctionDescriptor g_uri_join_with_user$descriptor() {
        return g_uri_join_with_user.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_uri_join_with_user(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MethodHandle g_uri_join_with_user$handle() {
        return g_uri_join_with_user.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_uri_join_with_user(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MemorySegment g_uri_join_with_user$address() {
        return g_uri_join_with_user.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_uri_join_with_user(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MemorySegment g_uri_join_with_user(int flags, MemorySegment scheme, MemorySegment user, MemorySegment password, MemorySegment auth_params, MemorySegment host, int port, MemorySegment path, MemorySegment query, MemorySegment fragment) {
        var mh$ = g_uri_join_with_user.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_join_with_user", flags, scheme, user, password, auth_params, host, port, path, query, fragment);
            }
            return (MemorySegment)mh$.invokeExact(flags, scheme, user, password, auth_params, host, port, path, query, fragment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUri *g_uri_parse(const gchar *uri_string, GUriFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_parse$descriptor() {
        return g_uri_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUri *g_uri_parse(const gchar *uri_string, GUriFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_uri_parse$handle() {
        return g_uri_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUri *g_uri_parse(const gchar *uri_string, GUriFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_parse$address() {
        return g_uri_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUri *g_uri_parse(const gchar *uri_string, GUriFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_parse(MemorySegment uri_string, int flags, MemorySegment error) {
        var mh$ = g_uri_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_parse", uri_string, flags, error);
            }
            return (MemorySegment)mh$.invokeExact(uri_string, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_parse_relative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_parse_relative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUri *g_uri_parse_relative(GUri *base_uri, const gchar *uri_ref, GUriFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_parse_relative$descriptor() {
        return g_uri_parse_relative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUri *g_uri_parse_relative(GUri *base_uri, const gchar *uri_ref, GUriFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_uri_parse_relative$handle() {
        return g_uri_parse_relative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUri *g_uri_parse_relative(GUri *base_uri, const gchar *uri_ref, GUriFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_parse_relative$address() {
        return g_uri_parse_relative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUri *g_uri_parse_relative(GUri *base_uri, const gchar *uri_ref, GUriFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_parse_relative(MemorySegment base_uri, MemorySegment uri_ref, int flags, MemorySegment error) {
        var mh$ = g_uri_parse_relative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_parse_relative", base_uri, uri_ref, flags, error);
            }
            return (MemorySegment)mh$.invokeExact(base_uri, uri_ref, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_resolve_relative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_resolve_relative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_uri_resolve_relative(const gchar *base_uri_string, const gchar *uri_ref, GUriFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_resolve_relative$descriptor() {
        return g_uri_resolve_relative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_uri_resolve_relative(const gchar *base_uri_string, const gchar *uri_ref, GUriFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_uri_resolve_relative$handle() {
        return g_uri_resolve_relative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_uri_resolve_relative(const gchar *base_uri_string, const gchar *uri_ref, GUriFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_resolve_relative$address() {
        return g_uri_resolve_relative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_uri_resolve_relative(const gchar *base_uri_string, const gchar *uri_ref, GUriFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_resolve_relative(MemorySegment base_uri_string, MemorySegment uri_ref, int flags, MemorySegment error) {
        var mh$ = g_uri_resolve_relative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_resolve_relative", base_uri_string, uri_ref, flags, error);
            }
            return (MemorySegment)mh$.invokeExact(base_uri_string, uri_ref, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_build {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_build");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUri *g_uri_build(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static FunctionDescriptor g_uri_build$descriptor() {
        return g_uri_build.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUri *g_uri_build(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MethodHandle g_uri_build$handle() {
        return g_uri_build.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUri *g_uri_build(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MemorySegment g_uri_build$address() {
        return g_uri_build.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUri *g_uri_build(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MemorySegment g_uri_build(int flags, MemorySegment scheme, MemorySegment userinfo, MemorySegment host, int port, MemorySegment path, MemorySegment query, MemorySegment fragment) {
        var mh$ = g_uri_build.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_build", flags, scheme, userinfo, host, port, path, query, fragment);
            }
            return (MemorySegment)mh$.invokeExact(flags, scheme, userinfo, host, port, path, query, fragment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_build_with_user {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_build_with_user");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUri *g_uri_build_with_user(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static FunctionDescriptor g_uri_build_with_user$descriptor() {
        return g_uri_build_with_user.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUri *g_uri_build_with_user(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MethodHandle g_uri_build_with_user$handle() {
        return g_uri_build_with_user.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUri *g_uri_build_with_user(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MemorySegment g_uri_build_with_user$address() {
        return g_uri_build_with_user.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUri *g_uri_build_with_user(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment)
     * }
     */
    public static MemorySegment g_uri_build_with_user(int flags, MemorySegment scheme, MemorySegment user, MemorySegment password, MemorySegment auth_params, MemorySegment host, int port, MemorySegment path, MemorySegment query, MemorySegment fragment) {
        var mh$ = g_uri_build_with_user.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_build_with_user", flags, scheme, user, password, auth_params, host, port, path, query, fragment);
            }
            return (MemorySegment)mh$.invokeExact(flags, scheme, user, password, auth_params, host, port, path, query, fragment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_URI_HIDE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_HIDE_NONE = 0
     * }
     */
    public static int G_URI_HIDE_NONE() {
        return G_URI_HIDE_NONE;
    }
    private static final int G_URI_HIDE_USERINFO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_HIDE_USERINFO = 1
     * }
     */
    public static int G_URI_HIDE_USERINFO() {
        return G_URI_HIDE_USERINFO;
    }
    private static final int G_URI_HIDE_PASSWORD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_HIDE_PASSWORD = 2
     * }
     */
    public static int G_URI_HIDE_PASSWORD() {
        return G_URI_HIDE_PASSWORD;
    }
    private static final int G_URI_HIDE_AUTH_PARAMS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_HIDE_AUTH_PARAMS = 4
     * }
     */
    public static int G_URI_HIDE_AUTH_PARAMS() {
        return G_URI_HIDE_AUTH_PARAMS;
    }
    private static final int G_URI_HIDE_QUERY = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_HIDE_QUERY = 8
     * }
     */
    public static int G_URI_HIDE_QUERY() {
        return G_URI_HIDE_QUERY;
    }
    private static final int G_URI_HIDE_FRAGMENT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_HIDE_FRAGMENT = 16
     * }
     */
    public static int G_URI_HIDE_FRAGMENT() {
        return G_URI_HIDE_FRAGMENT;
    }

    private static class g_uri_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_uri_to_string(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_to_string$descriptor() {
        return g_uri_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_uri_to_string(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_to_string$handle() {
        return g_uri_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_uri_to_string(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_to_string$address() {
        return g_uri_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_uri_to_string(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_to_string(MemorySegment uri) {
        var mh$ = g_uri_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_to_string", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_to_string_partial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_to_string_partial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_uri_to_string_partial(GUri *uri, GUriHideFlags flags)
     * }
     */
    public static FunctionDescriptor g_uri_to_string_partial$descriptor() {
        return g_uri_to_string_partial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_uri_to_string_partial(GUri *uri, GUriHideFlags flags)
     * }
     */
    public static MethodHandle g_uri_to_string_partial$handle() {
        return g_uri_to_string_partial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_uri_to_string_partial(GUri *uri, GUriHideFlags flags)
     * }
     */
    public static MemorySegment g_uri_to_string_partial$address() {
        return g_uri_to_string_partial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_uri_to_string_partial(GUri *uri, GUriHideFlags flags)
     * }
     */
    public static MemorySegment g_uri_to_string_partial(MemorySegment uri, int flags) {
        var mh$ = g_uri_to_string_partial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_to_string_partial", uri, flags);
            }
            return (MemorySegment)mh$.invokeExact(uri, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_scheme {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_scheme");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_scheme(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_scheme$descriptor() {
        return g_uri_get_scheme.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_scheme(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_scheme$handle() {
        return g_uri_get_scheme.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_scheme(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_scheme$address() {
        return g_uri_get_scheme.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_scheme(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_scheme(MemorySegment uri) {
        var mh$ = g_uri_get_scheme.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_scheme", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_userinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_userinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_userinfo(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_userinfo$descriptor() {
        return g_uri_get_userinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_userinfo(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_userinfo$handle() {
        return g_uri_get_userinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_userinfo(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_userinfo$address() {
        return g_uri_get_userinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_userinfo(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_userinfo(MemorySegment uri) {
        var mh$ = g_uri_get_userinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_userinfo", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_user {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_user");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_user(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_user$descriptor() {
        return g_uri_get_user.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_user(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_user$handle() {
        return g_uri_get_user.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_user(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_user$address() {
        return g_uri_get_user.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_user(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_user(MemorySegment uri) {
        var mh$ = g_uri_get_user.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_user", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_password {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_password");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_password(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_password$descriptor() {
        return g_uri_get_password.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_password(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_password$handle() {
        return g_uri_get_password.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_password(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_password$address() {
        return g_uri_get_password.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_password(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_password(MemorySegment uri) {
        var mh$ = g_uri_get_password.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_password", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_auth_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_auth_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_auth_params(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_auth_params$descriptor() {
        return g_uri_get_auth_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_auth_params(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_auth_params$handle() {
        return g_uri_get_auth_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_auth_params(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_auth_params$address() {
        return g_uri_get_auth_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_auth_params(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_auth_params(MemorySegment uri) {
        var mh$ = g_uri_get_auth_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_auth_params", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_host {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_host");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_host(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_host$descriptor() {
        return g_uri_get_host.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_host(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_host$handle() {
        return g_uri_get_host.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_host(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_host$address() {
        return g_uri_get_host.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_host(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_host(MemorySegment uri) {
        var mh$ = g_uri_get_host.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_host", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_port {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_port");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_uri_get_port(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_port$descriptor() {
        return g_uri_get_port.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_uri_get_port(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_port$handle() {
        return g_uri_get_port.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_uri_get_port(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_port$address() {
        return g_uri_get_port.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_uri_get_port(GUri *uri)
     * }
     */
    public static int g_uri_get_port(MemorySegment uri) {
        var mh$ = g_uri_get_port.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_port", uri);
            }
            return (int)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_path(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_path$descriptor() {
        return g_uri_get_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_path(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_path$handle() {
        return g_uri_get_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_path(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_path$address() {
        return g_uri_get_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_path(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_path(MemorySegment uri) {
        var mh$ = g_uri_get_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_path", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_query(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_query$descriptor() {
        return g_uri_get_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_query(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_query$handle() {
        return g_uri_get_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_query(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_query$address() {
        return g_uri_get_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_query(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_query(MemorySegment uri) {
        var mh$ = g_uri_get_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_query", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_fragment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_fragment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_fragment(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_fragment$descriptor() {
        return g_uri_get_fragment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_fragment(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_fragment$handle() {
        return g_uri_get_fragment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_fragment(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_fragment$address() {
        return g_uri_get_fragment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_uri_get_fragment(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_fragment(MemorySegment uri) {
        var mh$ = g_uri_get_fragment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_fragment", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUriFlags g_uri_get_flags(GUri *uri)
     * }
     */
    public static FunctionDescriptor g_uri_get_flags$descriptor() {
        return g_uri_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUriFlags g_uri_get_flags(GUri *uri)
     * }
     */
    public static MethodHandle g_uri_get_flags$handle() {
        return g_uri_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUriFlags g_uri_get_flags(GUri *uri)
     * }
     */
    public static MemorySegment g_uri_get_flags$address() {
        return g_uri_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUriFlags g_uri_get_flags(GUri *uri)
     * }
     */
    public static int g_uri_get_flags(MemorySegment uri) {
        var mh$ = g_uri_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_flags", uri);
            }
            return (int)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_URI_PARAMS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_PARAMS_NONE = 0
     * }
     */
    public static int G_URI_PARAMS_NONE() {
        return G_URI_PARAMS_NONE;
    }
    private static final int G_URI_PARAMS_CASE_INSENSITIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_PARAMS_CASE_INSENSITIVE = 1
     * }
     */
    public static int G_URI_PARAMS_CASE_INSENSITIVE() {
        return G_URI_PARAMS_CASE_INSENSITIVE;
    }
    private static final int G_URI_PARAMS_WWW_FORM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_PARAMS_WWW_FORM = 2
     * }
     */
    public static int G_URI_PARAMS_WWW_FORM() {
        return G_URI_PARAMS_WWW_FORM;
    }
    private static final int G_URI_PARAMS_PARSE_RELAXED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_PARAMS_PARSE_RELAXED = 4
     * }
     */
    public static int G_URI_PARAMS_PARSE_RELAXED() {
        return G_URI_PARAMS_PARSE_RELAXED;
    }

    private static class g_uri_parse_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_parse_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHashTable *g_uri_parse_params(const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_parse_params$descriptor() {
        return g_uri_parse_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHashTable *g_uri_parse_params(const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_uri_parse_params$handle() {
        return g_uri_parse_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHashTable *g_uri_parse_params(const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_parse_params$address() {
        return g_uri_parse_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHashTable *g_uri_parse_params(const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_uri_parse_params(MemorySegment params, long length, MemorySegment separators, int flags, MemorySegment error) {
        var mh$ = g_uri_parse_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_parse_params", params, length, separators, flags, error);
            }
            return (MemorySegment)mh$.invokeExact(params, length, separators, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_params_iter_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_params_iter_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_uri_params_iter_init(GUriParamsIter *iter, const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags)
     * }
     */
    public static FunctionDescriptor g_uri_params_iter_init$descriptor() {
        return g_uri_params_iter_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_uri_params_iter_init(GUriParamsIter *iter, const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags)
     * }
     */
    public static MethodHandle g_uri_params_iter_init$handle() {
        return g_uri_params_iter_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_uri_params_iter_init(GUriParamsIter *iter, const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags)
     * }
     */
    public static MemorySegment g_uri_params_iter_init$address() {
        return g_uri_params_iter_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_uri_params_iter_init(GUriParamsIter *iter, const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags)
     * }
     */
    public static void g_uri_params_iter_init(MemorySegment iter, MemorySegment params, long length, MemorySegment separators, int flags) {
        var mh$ = g_uri_params_iter_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_params_iter_init", iter, params, length, separators, flags);
            }
            mh$.invokeExact(iter, params, length, separators, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_params_iter_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_params_iter_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_uri_params_iter_next(GUriParamsIter *iter, gchar **attribute, gchar **value, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_params_iter_next$descriptor() {
        return g_uri_params_iter_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_uri_params_iter_next(GUriParamsIter *iter, gchar **attribute, gchar **value, GError **error)
     * }
     */
    public static MethodHandle g_uri_params_iter_next$handle() {
        return g_uri_params_iter_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_uri_params_iter_next(GUriParamsIter *iter, gchar **attribute, gchar **value, GError **error)
     * }
     */
    public static MemorySegment g_uri_params_iter_next$address() {
        return g_uri_params_iter_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_uri_params_iter_next(GUriParamsIter *iter, gchar **attribute, gchar **value, GError **error)
     * }
     */
    public static int g_uri_params_iter_next(MemorySegment iter, MemorySegment attribute, MemorySegment value, MemorySegment error) {
        var mh$ = g_uri_params_iter_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_params_iter_next", iter, attribute, value, error);
            }
            return (int)mh$.invokeExact(iter, attribute, value, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_uri_error_quark()
     * }
     */
    public static FunctionDescriptor g_uri_error_quark$descriptor() {
        return g_uri_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_uri_error_quark()
     * }
     */
    public static MethodHandle g_uri_error_quark$handle() {
        return g_uri_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_uri_error_quark()
     * }
     */
    public static MemorySegment g_uri_error_quark$address() {
        return g_uri_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_uri_error_quark()
     * }
     */
    public static int g_uri_error_quark() {
        var mh$ = g_uri_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_URI_ERROR_FAILED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_FAILED = 0
     * }
     */
    public static int G_URI_ERROR_FAILED() {
        return G_URI_ERROR_FAILED;
    }
    private static final int G_URI_ERROR_BAD_SCHEME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_SCHEME = 1
     * }
     */
    public static int G_URI_ERROR_BAD_SCHEME() {
        return G_URI_ERROR_BAD_SCHEME;
    }
    private static final int G_URI_ERROR_BAD_USER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_USER = 2
     * }
     */
    public static int G_URI_ERROR_BAD_USER() {
        return G_URI_ERROR_BAD_USER;
    }
    private static final int G_URI_ERROR_BAD_PASSWORD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_PASSWORD = 3
     * }
     */
    public static int G_URI_ERROR_BAD_PASSWORD() {
        return G_URI_ERROR_BAD_PASSWORD;
    }
    private static final int G_URI_ERROR_BAD_AUTH_PARAMS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_AUTH_PARAMS = 4
     * }
     */
    public static int G_URI_ERROR_BAD_AUTH_PARAMS() {
        return G_URI_ERROR_BAD_AUTH_PARAMS;
    }
    private static final int G_URI_ERROR_BAD_HOST = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_HOST = 5
     * }
     */
    public static int G_URI_ERROR_BAD_HOST() {
        return G_URI_ERROR_BAD_HOST;
    }
    private static final int G_URI_ERROR_BAD_PORT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_PORT = 6
     * }
     */
    public static int G_URI_ERROR_BAD_PORT() {
        return G_URI_ERROR_BAD_PORT;
    }
    private static final int G_URI_ERROR_BAD_PATH = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_PATH = 7
     * }
     */
    public static int G_URI_ERROR_BAD_PATH() {
        return G_URI_ERROR_BAD_PATH;
    }
    private static final int G_URI_ERROR_BAD_QUERY = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_QUERY = 8
     * }
     */
    public static int G_URI_ERROR_BAD_QUERY() {
        return G_URI_ERROR_BAD_QUERY;
    }
    private static final int G_URI_ERROR_BAD_FRAGMENT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_URI_ERROR_BAD_FRAGMENT = 9
     * }
     */
    public static int G_URI_ERROR_BAD_FRAGMENT() {
        return G_URI_ERROR_BAD_FRAGMENT;
    }

    private static class g_uri_unescape_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_unescape_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_uri_unescape_string(const char *escaped_string, const char *illegal_characters)
     * }
     */
    public static FunctionDescriptor g_uri_unescape_string$descriptor() {
        return g_uri_unescape_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_uri_unescape_string(const char *escaped_string, const char *illegal_characters)
     * }
     */
    public static MethodHandle g_uri_unescape_string$handle() {
        return g_uri_unescape_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_uri_unescape_string(const char *escaped_string, const char *illegal_characters)
     * }
     */
    public static MemorySegment g_uri_unescape_string$address() {
        return g_uri_unescape_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_uri_unescape_string(const char *escaped_string, const char *illegal_characters)
     * }
     */
    public static MemorySegment g_uri_unescape_string(MemorySegment escaped_string, MemorySegment illegal_characters) {
        var mh$ = g_uri_unescape_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_unescape_string", escaped_string, illegal_characters);
            }
            return (MemorySegment)mh$.invokeExact(escaped_string, illegal_characters);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_unescape_segment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_unescape_segment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_uri_unescape_segment(const char *escaped_string, const char *escaped_string_end, const char *illegal_characters)
     * }
     */
    public static FunctionDescriptor g_uri_unescape_segment$descriptor() {
        return g_uri_unescape_segment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_uri_unescape_segment(const char *escaped_string, const char *escaped_string_end, const char *illegal_characters)
     * }
     */
    public static MethodHandle g_uri_unescape_segment$handle() {
        return g_uri_unescape_segment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_uri_unescape_segment(const char *escaped_string, const char *escaped_string_end, const char *illegal_characters)
     * }
     */
    public static MemorySegment g_uri_unescape_segment$address() {
        return g_uri_unescape_segment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_uri_unescape_segment(const char *escaped_string, const char *escaped_string_end, const char *illegal_characters)
     * }
     */
    public static MemorySegment g_uri_unescape_segment(MemorySegment escaped_string, MemorySegment escaped_string_end, MemorySegment illegal_characters) {
        var mh$ = g_uri_unescape_segment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_unescape_segment", escaped_string, escaped_string_end, illegal_characters);
            }
            return (MemorySegment)mh$.invokeExact(escaped_string, escaped_string_end, illegal_characters);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_parse_scheme {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_parse_scheme");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_uri_parse_scheme(const char *uri)
     * }
     */
    public static FunctionDescriptor g_uri_parse_scheme$descriptor() {
        return g_uri_parse_scheme.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_uri_parse_scheme(const char *uri)
     * }
     */
    public static MethodHandle g_uri_parse_scheme$handle() {
        return g_uri_parse_scheme.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_uri_parse_scheme(const char *uri)
     * }
     */
    public static MemorySegment g_uri_parse_scheme$address() {
        return g_uri_parse_scheme.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_uri_parse_scheme(const char *uri)
     * }
     */
    public static MemorySegment g_uri_parse_scheme(MemorySegment uri) {
        var mh$ = g_uri_parse_scheme.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_parse_scheme", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_peek_scheme {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_peek_scheme");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *g_uri_peek_scheme(const char *uri)
     * }
     */
    public static FunctionDescriptor g_uri_peek_scheme$descriptor() {
        return g_uri_peek_scheme.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *g_uri_peek_scheme(const char *uri)
     * }
     */
    public static MethodHandle g_uri_peek_scheme$handle() {
        return g_uri_peek_scheme.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *g_uri_peek_scheme(const char *uri)
     * }
     */
    public static MemorySegment g_uri_peek_scheme$address() {
        return g_uri_peek_scheme.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *g_uri_peek_scheme(const char *uri)
     * }
     */
    public static MemorySegment g_uri_peek_scheme(MemorySegment uri) {
        var mh$ = g_uri_peek_scheme.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_peek_scheme", uri);
            }
            return (MemorySegment)mh$.invokeExact(uri);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_escape_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_escape_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8)
     * }
     */
    public static FunctionDescriptor g_uri_escape_string$descriptor() {
        return g_uri_escape_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8)
     * }
     */
    public static MethodHandle g_uri_escape_string$handle() {
        return g_uri_escape_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8)
     * }
     */
    public static MemorySegment g_uri_escape_string$address() {
        return g_uri_escape_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8)
     * }
     */
    public static MemorySegment g_uri_escape_string(MemorySegment unescaped, MemorySegment reserved_chars_allowed, int allow_utf8) {
        var mh$ = g_uri_escape_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_escape_string", unescaped, reserved_chars_allowed, allow_utf8);
            }
            return (MemorySegment)mh$.invokeExact(unescaped, reserved_chars_allowed, allow_utf8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_unescape_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_unescape_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_uri_unescape_bytes(const char *escaped_string, gssize length, const char *illegal_characters, GError **error)
     * }
     */
    public static FunctionDescriptor g_uri_unescape_bytes$descriptor() {
        return g_uri_unescape_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_uri_unescape_bytes(const char *escaped_string, gssize length, const char *illegal_characters, GError **error)
     * }
     */
    public static MethodHandle g_uri_unescape_bytes$handle() {
        return g_uri_unescape_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_uri_unescape_bytes(const char *escaped_string, gssize length, const char *illegal_characters, GError **error)
     * }
     */
    public static MemorySegment g_uri_unescape_bytes$address() {
        return g_uri_unescape_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_uri_unescape_bytes(const char *escaped_string, gssize length, const char *illegal_characters, GError **error)
     * }
     */
    public static MemorySegment g_uri_unescape_bytes(MemorySegment escaped_string, long length, MemorySegment illegal_characters, MemorySegment error) {
        var mh$ = g_uri_unescape_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_unescape_bytes", escaped_string, length, illegal_characters, error);
            }
            return (MemorySegment)mh$.invokeExact(escaped_string, length, illegal_characters, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_escape_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_escape_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_uri_escape_bytes(const guint8 *unescaped, gsize length, const char *reserved_chars_allowed)
     * }
     */
    public static FunctionDescriptor g_uri_escape_bytes$descriptor() {
        return g_uri_escape_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_uri_escape_bytes(const guint8 *unescaped, gsize length, const char *reserved_chars_allowed)
     * }
     */
    public static MethodHandle g_uri_escape_bytes$handle() {
        return g_uri_escape_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_uri_escape_bytes(const guint8 *unescaped, gsize length, const char *reserved_chars_allowed)
     * }
     */
    public static MemorySegment g_uri_escape_bytes$address() {
        return g_uri_escape_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_uri_escape_bytes(const guint8 *unescaped, gsize length, const char *reserved_chars_allowed)
     * }
     */
    public static MemorySegment g_uri_escape_bytes(MemorySegment unescaped, long length, MemorySegment reserved_chars_allowed) {
        var mh$ = g_uri_escape_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_escape_bytes", unescaped, length, reserved_chars_allowed);
            }
            return (MemorySegment)mh$.invokeExact(unescaped, length, reserved_chars_allowed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uuid_string_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uuid_string_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_uuid_string_is_valid(const gchar *str)
     * }
     */
    public static FunctionDescriptor g_uuid_string_is_valid$descriptor() {
        return g_uuid_string_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_uuid_string_is_valid(const gchar *str)
     * }
     */
    public static MethodHandle g_uuid_string_is_valid$handle() {
        return g_uuid_string_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_uuid_string_is_valid(const gchar *str)
     * }
     */
    public static MemorySegment g_uuid_string_is_valid$address() {
        return g_uuid_string_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_uuid_string_is_valid(const gchar *str)
     * }
     */
    public static int g_uuid_string_is_valid(MemorySegment str) {
        var mh$ = g_uuid_string_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uuid_string_is_valid", str);
            }
            return (int)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uuid_string_random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uuid_string_random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_uuid_string_random()
     * }
     */
    public static FunctionDescriptor g_uuid_string_random$descriptor() {
        return g_uuid_string_random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_uuid_string_random()
     * }
     */
    public static MethodHandle g_uuid_string_random$handle() {
        return g_uuid_string_random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_uuid_string_random()
     * }
     */
    public static MemorySegment g_uuid_string_random$address() {
        return g_uuid_string_random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_uuid_string_random()
     * }
     */
    public static MemorySegment g_uuid_string_random() {
        var mh$ = g_uuid_string_random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uuid_string_random");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glib_major_version$constants {
        public static final OfInt LAYOUT = gst_min_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("glib_major_version").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const guint glib_major_version
     * }
     */
    public static OfInt glib_major_version$layout() {
        return glib_major_version$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const guint glib_major_version
     * }
     */
    public static MemorySegment glib_major_version$segment() {
        return glib_major_version$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const guint glib_major_version
     * }
     */
    public static int glib_major_version() {
        return glib_major_version$constants.SEGMENT.get(glib_major_version$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const guint glib_major_version
     * }
     */
    public static void glib_major_version(int varValue) {
        glib_major_version$constants.SEGMENT.set(glib_major_version$constants.LAYOUT, 0L, varValue);
    }

    private static class glib_minor_version$constants {
        public static final OfInt LAYOUT = gst_min_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("glib_minor_version").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const guint glib_minor_version
     * }
     */
    public static OfInt glib_minor_version$layout() {
        return glib_minor_version$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const guint glib_minor_version
     * }
     */
    public static MemorySegment glib_minor_version$segment() {
        return glib_minor_version$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const guint glib_minor_version
     * }
     */
    public static int glib_minor_version() {
        return glib_minor_version$constants.SEGMENT.get(glib_minor_version$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const guint glib_minor_version
     * }
     */
    public static void glib_minor_version(int varValue) {
        glib_minor_version$constants.SEGMENT.set(glib_minor_version$constants.LAYOUT, 0L, varValue);
    }

    private static class glib_micro_version$constants {
        public static final OfInt LAYOUT = gst_min_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("glib_micro_version").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const guint glib_micro_version
     * }
     */
    public static OfInt glib_micro_version$layout() {
        return glib_micro_version$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const guint glib_micro_version
     * }
     */
    public static MemorySegment glib_micro_version$segment() {
        return glib_micro_version$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const guint glib_micro_version
     * }
     */
    public static int glib_micro_version() {
        return glib_micro_version$constants.SEGMENT.get(glib_micro_version$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const guint glib_micro_version
     * }
     */
    public static void glib_micro_version(int varValue) {
        glib_micro_version$constants.SEGMENT.set(glib_micro_version$constants.LAYOUT, 0L, varValue);
    }

    private static class glib_interface_age$constants {
        public static final OfInt LAYOUT = gst_min_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("glib_interface_age").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const guint glib_interface_age
     * }
     */
    public static OfInt glib_interface_age$layout() {
        return glib_interface_age$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const guint glib_interface_age
     * }
     */
    public static MemorySegment glib_interface_age$segment() {
        return glib_interface_age$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const guint glib_interface_age
     * }
     */
    public static int glib_interface_age() {
        return glib_interface_age$constants.SEGMENT.get(glib_interface_age$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const guint glib_interface_age
     * }
     */
    public static void glib_interface_age(int varValue) {
        glib_interface_age$constants.SEGMENT.set(glib_interface_age$constants.LAYOUT, 0L, varValue);
    }

    private static class glib_binary_age$constants {
        public static final OfInt LAYOUT = gst_min_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("glib_binary_age").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const guint glib_binary_age
     * }
     */
    public static OfInt glib_binary_age$layout() {
        return glib_binary_age$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const guint glib_binary_age
     * }
     */
    public static MemorySegment glib_binary_age$segment() {
        return glib_binary_age$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const guint glib_binary_age
     * }
     */
    public static int glib_binary_age() {
        return glib_binary_age$constants.SEGMENT.get(glib_binary_age$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const guint glib_binary_age
     * }
     */
    public static void glib_binary_age(int varValue) {
        glib_binary_age$constants.SEGMENT.set(glib_binary_age$constants.LAYOUT, 0L, varValue);
    }

    private static class glib_check_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("glib_check_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *glib_check_version(guint required_major, guint required_minor, guint required_micro)
     * }
     */
    public static FunctionDescriptor glib_check_version$descriptor() {
        return glib_check_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *glib_check_version(guint required_major, guint required_minor, guint required_micro)
     * }
     */
    public static MethodHandle glib_check_version$handle() {
        return glib_check_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *glib_check_version(guint required_major, guint required_minor, guint required_micro)
     * }
     */
    public static MemorySegment glib_check_version$address() {
        return glib_check_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *glib_check_version(guint required_major, guint required_minor, guint required_micro)
     * }
     */
    public static MemorySegment glib_check_version(int required_major, int required_minor, int required_micro) {
        var mh$ = glib_check_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glib_check_version", required_major, required_minor, required_micro);
            }
            return (MemorySegment)mh$.invokeExact(required_major, required_minor, required_micro);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_win32_ftruncate(gint f, guint size)
     * }
     */
    public static FunctionDescriptor g_win32_ftruncate$descriptor() {
        return g_win32_ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_win32_ftruncate(gint f, guint size)
     * }
     */
    public static MethodHandle g_win32_ftruncate$handle() {
        return g_win32_ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_win32_ftruncate(gint f, guint size)
     * }
     */
    public static MemorySegment g_win32_ftruncate$address() {
        return g_win32_ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_win32_ftruncate(gint f, guint size)
     * }
     */
    public static int g_win32_ftruncate(int f, int size) {
        var mh$ = g_win32_ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_ftruncate", f, size);
            }
            return (int)mh$.invokeExact(f, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_getlocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_getlocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_win32_getlocale()
     * }
     */
    public static FunctionDescriptor g_win32_getlocale$descriptor() {
        return g_win32_getlocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_win32_getlocale()
     * }
     */
    public static MethodHandle g_win32_getlocale$handle() {
        return g_win32_getlocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_win32_getlocale()
     * }
     */
    public static MemorySegment g_win32_getlocale$address() {
        return g_win32_getlocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_win32_getlocale()
     * }
     */
    public static MemorySegment g_win32_getlocale() {
        var mh$ = g_win32_getlocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_getlocale");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_error_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_error_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_win32_error_message(gint error)
     * }
     */
    public static FunctionDescriptor g_win32_error_message$descriptor() {
        return g_win32_error_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_win32_error_message(gint error)
     * }
     */
    public static MethodHandle g_win32_error_message$handle() {
        return g_win32_error_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_win32_error_message(gint error)
     * }
     */
    public static MemorySegment g_win32_error_message$address() {
        return g_win32_error_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_win32_error_message(gint error)
     * }
     */
    public static MemorySegment g_win32_error_message(int error) {
        var mh$ = g_win32_error_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_error_message", error);
            }
            return (MemorySegment)mh$.invokeExact(error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_get_package_installation_directory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_get_package_installation_directory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_directory(const gchar *package, const gchar *dll_name)
     * }
     */
    public static FunctionDescriptor g_win32_get_package_installation_directory$descriptor() {
        return g_win32_get_package_installation_directory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_directory(const gchar *package, const gchar *dll_name)
     * }
     */
    public static MethodHandle g_win32_get_package_installation_directory$handle() {
        return g_win32_get_package_installation_directory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_directory(const gchar *package, const gchar *dll_name)
     * }
     */
    public static MemorySegment g_win32_get_package_installation_directory$address() {
        return g_win32_get_package_installation_directory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_directory(const gchar *package, const gchar *dll_name)
     * }
     */
    public static MemorySegment g_win32_get_package_installation_directory(MemorySegment package_, MemorySegment dll_name) {
        var mh$ = g_win32_get_package_installation_directory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_get_package_installation_directory", package_, dll_name);
            }
            return (MemorySegment)mh$.invokeExact(package_, dll_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_get_package_installation_subdirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_get_package_installation_subdirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_subdirectory(const gchar *package, const gchar *dll_name, const gchar *subdir)
     * }
     */
    public static FunctionDescriptor g_win32_get_package_installation_subdirectory$descriptor() {
        return g_win32_get_package_installation_subdirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_subdirectory(const gchar *package, const gchar *dll_name, const gchar *subdir)
     * }
     */
    public static MethodHandle g_win32_get_package_installation_subdirectory$handle() {
        return g_win32_get_package_installation_subdirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_subdirectory(const gchar *package, const gchar *dll_name, const gchar *subdir)
     * }
     */
    public static MemorySegment g_win32_get_package_installation_subdirectory$address() {
        return g_win32_get_package_installation_subdirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_subdirectory(const gchar *package, const gchar *dll_name, const gchar *subdir)
     * }
     */
    public static MemorySegment g_win32_get_package_installation_subdirectory(MemorySegment package_, MemorySegment dll_name, MemorySegment subdir) {
        var mh$ = g_win32_get_package_installation_subdirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_get_package_installation_subdirectory", package_, dll_name, subdir);
            }
            return (MemorySegment)mh$.invokeExact(package_, dll_name, subdir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_get_package_installation_directory_of_module {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_get_package_installation_directory_of_module");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_directory_of_module(gpointer hmodule)
     * }
     */
    public static FunctionDescriptor g_win32_get_package_installation_directory_of_module$descriptor() {
        return g_win32_get_package_installation_directory_of_module.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_directory_of_module(gpointer hmodule)
     * }
     */
    public static MethodHandle g_win32_get_package_installation_directory_of_module$handle() {
        return g_win32_get_package_installation_directory_of_module.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_directory_of_module(gpointer hmodule)
     * }
     */
    public static MemorySegment g_win32_get_package_installation_directory_of_module$address() {
        return g_win32_get_package_installation_directory_of_module.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_win32_get_package_installation_directory_of_module(gpointer hmodule)
     * }
     */
    public static MemorySegment g_win32_get_package_installation_directory_of_module(MemorySegment hmodule) {
        var mh$ = g_win32_get_package_installation_directory_of_module.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_get_package_installation_directory_of_module", hmodule);
            }
            return (MemorySegment)mh$.invokeExact(hmodule);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_get_windows_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_get_windows_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_win32_get_windows_version()
     * }
     */
    public static FunctionDescriptor g_win32_get_windows_version$descriptor() {
        return g_win32_get_windows_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_win32_get_windows_version()
     * }
     */
    public static MethodHandle g_win32_get_windows_version$handle() {
        return g_win32_get_windows_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_win32_get_windows_version()
     * }
     */
    public static MemorySegment g_win32_get_windows_version$address() {
        return g_win32_get_windows_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_win32_get_windows_version()
     * }
     */
    public static int g_win32_get_windows_version() {
        var mh$ = g_win32_get_windows_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_get_windows_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_locale_filename_from_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_locale_filename_from_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_win32_locale_filename_from_utf8(const gchar *utf8filename)
     * }
     */
    public static FunctionDescriptor g_win32_locale_filename_from_utf8$descriptor() {
        return g_win32_locale_filename_from_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_win32_locale_filename_from_utf8(const gchar *utf8filename)
     * }
     */
    public static MethodHandle g_win32_locale_filename_from_utf8$handle() {
        return g_win32_locale_filename_from_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_win32_locale_filename_from_utf8(const gchar *utf8filename)
     * }
     */
    public static MemorySegment g_win32_locale_filename_from_utf8$address() {
        return g_win32_locale_filename_from_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_win32_locale_filename_from_utf8(const gchar *utf8filename)
     * }
     */
    public static MemorySegment g_win32_locale_filename_from_utf8(MemorySegment utf8filename) {
        var mh$ = g_win32_locale_filename_from_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_locale_filename_from_utf8", utf8filename);
            }
            return (MemorySegment)mh$.invokeExact(utf8filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_win32_get_command_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_get_command_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_win32_get_command_line()
     * }
     */
    public static FunctionDescriptor g_win32_get_command_line$descriptor() {
        return g_win32_get_command_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_win32_get_command_line()
     * }
     */
    public static MethodHandle g_win32_get_command_line$handle() {
        return g_win32_get_command_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_win32_get_command_line()
     * }
     */
    public static MemorySegment g_win32_get_command_line$address() {
        return g_win32_get_command_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_win32_get_command_line()
     * }
     */
    public static MemorySegment g_win32_get_command_line() {
        var mh$ = g_win32_get_command_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_get_command_line");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_WIN32_OS_ANY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_WIN32_OS_ANY = 0
     * }
     */
    public static int G_WIN32_OS_ANY() {
        return G_WIN32_OS_ANY;
    }
    private static final int G_WIN32_OS_WORKSTATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_WIN32_OS_WORKSTATION = 1
     * }
     */
    public static int G_WIN32_OS_WORKSTATION() {
        return G_WIN32_OS_WORKSTATION;
    }
    private static final int G_WIN32_OS_SERVER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_WIN32_OS_SERVER = 2
     * }
     */
    public static int G_WIN32_OS_SERVER() {
        return G_WIN32_OS_SERVER;
    }

    private static class g_win32_check_windows_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_win32_check_windows_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_win32_check_windows_version(const gint major, const gint minor, const gint spver, const GWin32OSType os_type)
     * }
     */
    public static FunctionDescriptor g_win32_check_windows_version$descriptor() {
        return g_win32_check_windows_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_win32_check_windows_version(const gint major, const gint minor, const gint spver, const GWin32OSType os_type)
     * }
     */
    public static MethodHandle g_win32_check_windows_version$handle() {
        return g_win32_check_windows_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_win32_check_windows_version(const gint major, const gint minor, const gint spver, const GWin32OSType os_type)
     * }
     */
    public static MemorySegment g_win32_check_windows_version$address() {
        return g_win32_check_windows_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_win32_check_windows_version(const gint major, const gint minor, const gint spver, const GWin32OSType os_type)
     * }
     */
    public static int g_win32_check_windows_version(int major, int minor, int spver, int os_type) {
        var mh$ = g_win32_check_windows_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_win32_check_windows_version", major, minor, spver, os_type);
            }
            return (int)mh$.invokeExact(major, minor, spver, os_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMemChunk *g_mem_chunk_new(const gchar *name, gint atom_size, gsize area_size, gint type)
     * }
     */
    public static FunctionDescriptor g_mem_chunk_new$descriptor() {
        return g_mem_chunk_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMemChunk *g_mem_chunk_new(const gchar *name, gint atom_size, gsize area_size, gint type)
     * }
     */
    public static MethodHandle g_mem_chunk_new$handle() {
        return g_mem_chunk_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMemChunk *g_mem_chunk_new(const gchar *name, gint atom_size, gsize area_size, gint type)
     * }
     */
    public static MemorySegment g_mem_chunk_new$address() {
        return g_mem_chunk_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMemChunk *g_mem_chunk_new(const gchar *name, gint atom_size, gsize area_size, gint type)
     * }
     */
    public static MemorySegment g_mem_chunk_new(MemorySegment name, int atom_size, long area_size, int type) {
        var mh$ = g_mem_chunk_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_new", name, atom_size, area_size, type);
            }
            return (MemorySegment)mh$.invokeExact(name, atom_size, area_size, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_destroy(GMemChunk *mem_chunk)
     * }
     */
    public static FunctionDescriptor g_mem_chunk_destroy$descriptor() {
        return g_mem_chunk_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_destroy(GMemChunk *mem_chunk)
     * }
     */
    public static MethodHandle g_mem_chunk_destroy$handle() {
        return g_mem_chunk_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_destroy(GMemChunk *mem_chunk)
     * }
     */
    public static MemorySegment g_mem_chunk_destroy$address() {
        return g_mem_chunk_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mem_chunk_destroy(GMemChunk *mem_chunk)
     * }
     */
    public static void g_mem_chunk_destroy(MemorySegment mem_chunk) {
        var mh$ = g_mem_chunk_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_destroy", mem_chunk);
            }
            mh$.invokeExact(mem_chunk);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk)
     * }
     */
    public static FunctionDescriptor g_mem_chunk_alloc$descriptor() {
        return g_mem_chunk_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk)
     * }
     */
    public static MethodHandle g_mem_chunk_alloc$handle() {
        return g_mem_chunk_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk)
     * }
     */
    public static MemorySegment g_mem_chunk_alloc$address() {
        return g_mem_chunk_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk)
     * }
     */
    public static MemorySegment g_mem_chunk_alloc(MemorySegment mem_chunk) {
        var mh$ = g_mem_chunk_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_alloc", mem_chunk);
            }
            return (MemorySegment)mh$.invokeExact(mem_chunk);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_alloc0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_alloc0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk)
     * }
     */
    public static FunctionDescriptor g_mem_chunk_alloc0$descriptor() {
        return g_mem_chunk_alloc0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk)
     * }
     */
    public static MethodHandle g_mem_chunk_alloc0$handle() {
        return g_mem_chunk_alloc0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk)
     * }
     */
    public static MemorySegment g_mem_chunk_alloc0$address() {
        return g_mem_chunk_alloc0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk)
     * }
     */
    public static MemorySegment g_mem_chunk_alloc0(MemorySegment mem_chunk) {
        var mh$ = g_mem_chunk_alloc0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_alloc0", mem_chunk);
            }
            return (MemorySegment)mh$.invokeExact(mem_chunk);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_free(GMemChunk *mem_chunk, gpointer mem)
     * }
     */
    public static FunctionDescriptor g_mem_chunk_free$descriptor() {
        return g_mem_chunk_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_free(GMemChunk *mem_chunk, gpointer mem)
     * }
     */
    public static MethodHandle g_mem_chunk_free$handle() {
        return g_mem_chunk_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_free(GMemChunk *mem_chunk, gpointer mem)
     * }
     */
    public static MemorySegment g_mem_chunk_free$address() {
        return g_mem_chunk_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mem_chunk_free(GMemChunk *mem_chunk, gpointer mem)
     * }
     */
    public static void g_mem_chunk_free(MemorySegment mem_chunk, MemorySegment mem) {
        var mh$ = g_mem_chunk_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_free", mem_chunk, mem);
            }
            mh$.invokeExact(mem_chunk, mem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_clean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_clean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_clean(GMemChunk *mem_chunk)
     * }
     */
    public static FunctionDescriptor g_mem_chunk_clean$descriptor() {
        return g_mem_chunk_clean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_clean(GMemChunk *mem_chunk)
     * }
     */
    public static MethodHandle g_mem_chunk_clean$handle() {
        return g_mem_chunk_clean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_clean(GMemChunk *mem_chunk)
     * }
     */
    public static MemorySegment g_mem_chunk_clean$address() {
        return g_mem_chunk_clean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mem_chunk_clean(GMemChunk *mem_chunk)
     * }
     */
    public static void g_mem_chunk_clean(MemorySegment mem_chunk) {
        var mh$ = g_mem_chunk_clean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_clean", mem_chunk);
            }
            mh$.invokeExact(mem_chunk);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_reset(GMemChunk *mem_chunk)
     * }
     */
    public static FunctionDescriptor g_mem_chunk_reset$descriptor() {
        return g_mem_chunk_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_reset(GMemChunk *mem_chunk)
     * }
     */
    public static MethodHandle g_mem_chunk_reset$handle() {
        return g_mem_chunk_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_reset(GMemChunk *mem_chunk)
     * }
     */
    public static MemorySegment g_mem_chunk_reset$address() {
        return g_mem_chunk_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mem_chunk_reset(GMemChunk *mem_chunk)
     * }
     */
    public static void g_mem_chunk_reset(MemorySegment mem_chunk) {
        var mh$ = g_mem_chunk_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_reset", mem_chunk);
            }
            mh$.invokeExact(mem_chunk);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_print(GMemChunk *mem_chunk)
     * }
     */
    public static FunctionDescriptor g_mem_chunk_print$descriptor() {
        return g_mem_chunk_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_print(GMemChunk *mem_chunk)
     * }
     */
    public static MethodHandle g_mem_chunk_print$handle() {
        return g_mem_chunk_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_print(GMemChunk *mem_chunk)
     * }
     */
    public static MemorySegment g_mem_chunk_print$address() {
        return g_mem_chunk_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mem_chunk_print(GMemChunk *mem_chunk)
     * }
     */
    public static void g_mem_chunk_print(MemorySegment mem_chunk) {
        var mh$ = g_mem_chunk_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_print", mem_chunk);
            }
            mh$.invokeExact(mem_chunk);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_chunk_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_chunk_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_info()
     * }
     */
    public static FunctionDescriptor g_mem_chunk_info$descriptor() {
        return g_mem_chunk_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_info()
     * }
     */
    public static MethodHandle g_mem_chunk_info$handle() {
        return g_mem_chunk_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mem_chunk_info()
     * }
     */
    public static MemorySegment g_mem_chunk_info$address() {
        return g_mem_chunk_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mem_chunk_info()
     * }
     */
    public static void g_mem_chunk_info() {
        var mh$ = g_mem_chunk_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_chunk_info");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_blow_chunks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_blow_chunks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_blow_chunks()
     * }
     */
    public static FunctionDescriptor g_blow_chunks$descriptor() {
        return g_blow_chunks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_blow_chunks()
     * }
     */
    public static MethodHandle g_blow_chunks$handle() {
        return g_blow_chunks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_blow_chunks()
     * }
     */
    public static MemorySegment g_blow_chunks$address() {
        return g_blow_chunks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_blow_chunks()
     * }
     */
    public static void g_blow_chunks() {
        var mh$ = g_blow_chunks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_blow_chunks");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_allocator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_allocator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GAllocator *g_allocator_new(const gchar *name, guint n_preallocs)
     * }
     */
    public static FunctionDescriptor g_allocator_new$descriptor() {
        return g_allocator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GAllocator *g_allocator_new(const gchar *name, guint n_preallocs)
     * }
     */
    public static MethodHandle g_allocator_new$handle() {
        return g_allocator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GAllocator *g_allocator_new(const gchar *name, guint n_preallocs)
     * }
     */
    public static MemorySegment g_allocator_new$address() {
        return g_allocator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GAllocator *g_allocator_new(const gchar *name, guint n_preallocs)
     * }
     */
    public static MemorySegment g_allocator_new(MemorySegment name, int n_preallocs) {
        var mh$ = g_allocator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_allocator_new", name, n_preallocs);
            }
            return (MemorySegment)mh$.invokeExact(name, n_preallocs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_allocator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_allocator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_allocator_free(GAllocator *allocator)
     * }
     */
    public static FunctionDescriptor g_allocator_free$descriptor() {
        return g_allocator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_allocator_free(GAllocator *allocator)
     * }
     */
    public static MethodHandle g_allocator_free$handle() {
        return g_allocator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_allocator_free(GAllocator *allocator)
     * }
     */
    public static MemorySegment g_allocator_free$address() {
        return g_allocator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_allocator_free(GAllocator *allocator)
     * }
     */
    public static void g_allocator_free(MemorySegment allocator) {
        var mh$ = g_allocator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_allocator_free", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_push_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_push_allocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_list_push_allocator(GAllocator *allocator)
     * }
     */
    public static FunctionDescriptor g_list_push_allocator$descriptor() {
        return g_list_push_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_list_push_allocator(GAllocator *allocator)
     * }
     */
    public static MethodHandle g_list_push_allocator$handle() {
        return g_list_push_allocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_list_push_allocator(GAllocator *allocator)
     * }
     */
    public static MemorySegment g_list_push_allocator$address() {
        return g_list_push_allocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_list_push_allocator(GAllocator *allocator)
     * }
     */
    public static void g_list_push_allocator(MemorySegment allocator) {
        var mh$ = g_list_push_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_push_allocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_pop_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_pop_allocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_list_pop_allocator()
     * }
     */
    public static FunctionDescriptor g_list_pop_allocator$descriptor() {
        return g_list_pop_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_list_pop_allocator()
     * }
     */
    public static MethodHandle g_list_pop_allocator$handle() {
        return g_list_pop_allocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_list_pop_allocator()
     * }
     */
    public static MemorySegment g_list_pop_allocator$address() {
        return g_list_pop_allocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_list_pop_allocator()
     * }
     */
    public static void g_list_pop_allocator() {
        var mh$ = g_list_pop_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_pop_allocator");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_push_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_push_allocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slist_push_allocator(GAllocator *allocator)
     * }
     */
    public static FunctionDescriptor g_slist_push_allocator$descriptor() {
        return g_slist_push_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slist_push_allocator(GAllocator *allocator)
     * }
     */
    public static MethodHandle g_slist_push_allocator$handle() {
        return g_slist_push_allocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slist_push_allocator(GAllocator *allocator)
     * }
     */
    public static MemorySegment g_slist_push_allocator$address() {
        return g_slist_push_allocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slist_push_allocator(GAllocator *allocator)
     * }
     */
    public static void g_slist_push_allocator(MemorySegment allocator) {
        var mh$ = g_slist_push_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_push_allocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_pop_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_pop_allocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slist_pop_allocator()
     * }
     */
    public static FunctionDescriptor g_slist_pop_allocator$descriptor() {
        return g_slist_pop_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slist_pop_allocator()
     * }
     */
    public static MethodHandle g_slist_pop_allocator$handle() {
        return g_slist_pop_allocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slist_pop_allocator()
     * }
     */
    public static MemorySegment g_slist_pop_allocator$address() {
        return g_slist_pop_allocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slist_pop_allocator()
     * }
     */
    public static void g_slist_pop_allocator() {
        var mh$ = g_slist_pop_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_pop_allocator");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_push_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_push_allocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_node_push_allocator(GAllocator *allocator)
     * }
     */
    public static FunctionDescriptor g_node_push_allocator$descriptor() {
        return g_node_push_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_node_push_allocator(GAllocator *allocator)
     * }
     */
    public static MethodHandle g_node_push_allocator$handle() {
        return g_node_push_allocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_node_push_allocator(GAllocator *allocator)
     * }
     */
    public static MemorySegment g_node_push_allocator$address() {
        return g_node_push_allocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_node_push_allocator(GAllocator *allocator)
     * }
     */
    public static void g_node_push_allocator(MemorySegment allocator) {
        var mh$ = g_node_push_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_push_allocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_pop_allocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_pop_allocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_node_pop_allocator()
     * }
     */
    public static FunctionDescriptor g_node_pop_allocator$descriptor() {
        return g_node_pop_allocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_node_pop_allocator()
     * }
     */
    public static MethodHandle g_node_pop_allocator$handle() {
        return g_node_pop_allocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_node_pop_allocator()
     * }
     */
    public static MemorySegment g_node_pop_allocator$address() {
        return g_node_pop_allocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_node_pop_allocator()
     * }
     */
    public static void g_node_pop_allocator() {
        var mh$ = g_node_pop_allocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_pop_allocator");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cache_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cache_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GCache *g_cache_new(GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func)
     * }
     */
    public static FunctionDescriptor g_cache_new$descriptor() {
        return g_cache_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GCache *g_cache_new(GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func)
     * }
     */
    public static MethodHandle g_cache_new$handle() {
        return g_cache_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GCache *g_cache_new(GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func)
     * }
     */
    public static MemorySegment g_cache_new$address() {
        return g_cache_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GCache *g_cache_new(GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func)
     * }
     */
    public static MemorySegment g_cache_new(MemorySegment value_new_func, MemorySegment value_destroy_func, MemorySegment key_dup_func, MemorySegment key_destroy_func, MemorySegment hash_key_func, MemorySegment hash_value_func, MemorySegment key_equal_func) {
        var mh$ = g_cache_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cache_new", value_new_func, value_destroy_func, key_dup_func, key_destroy_func, hash_key_func, hash_value_func, key_equal_func);
            }
            return (MemorySegment)mh$.invokeExact(value_new_func, value_destroy_func, key_dup_func, key_destroy_func, hash_key_func, hash_value_func, key_equal_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cache_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cache_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cache_destroy(GCache *cache)
     * }
     */
    public static FunctionDescriptor g_cache_destroy$descriptor() {
        return g_cache_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cache_destroy(GCache *cache)
     * }
     */
    public static MethodHandle g_cache_destroy$handle() {
        return g_cache_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cache_destroy(GCache *cache)
     * }
     */
    public static MemorySegment g_cache_destroy$address() {
        return g_cache_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cache_destroy(GCache *cache)
     * }
     */
    public static void g_cache_destroy(MemorySegment cache) {
        var mh$ = g_cache_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cache_destroy", cache);
            }
            mh$.invokeExact(cache);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cache_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cache_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_cache_insert(GCache *cache, gpointer key)
     * }
     */
    public static FunctionDescriptor g_cache_insert$descriptor() {
        return g_cache_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_cache_insert(GCache *cache, gpointer key)
     * }
     */
    public static MethodHandle g_cache_insert$handle() {
        return g_cache_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_cache_insert(GCache *cache, gpointer key)
     * }
     */
    public static MemorySegment g_cache_insert$address() {
        return g_cache_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_cache_insert(GCache *cache, gpointer key)
     * }
     */
    public static MemorySegment g_cache_insert(MemorySegment cache, MemorySegment key) {
        var mh$ = g_cache_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cache_insert", cache, key);
            }
            return (MemorySegment)mh$.invokeExact(cache, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cache_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cache_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cache_remove(GCache *cache, gconstpointer value)
     * }
     */
    public static FunctionDescriptor g_cache_remove$descriptor() {
        return g_cache_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cache_remove(GCache *cache, gconstpointer value)
     * }
     */
    public static MethodHandle g_cache_remove$handle() {
        return g_cache_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cache_remove(GCache *cache, gconstpointer value)
     * }
     */
    public static MemorySegment g_cache_remove$address() {
        return g_cache_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cache_remove(GCache *cache, gconstpointer value)
     * }
     */
    public static void g_cache_remove(MemorySegment cache, MemorySegment value) {
        var mh$ = g_cache_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cache_remove", cache, value);
            }
            mh$.invokeExact(cache, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cache_key_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cache_key_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cache_key_foreach(GCache *cache, GHFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_cache_key_foreach$descriptor() {
        return g_cache_key_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cache_key_foreach(GCache *cache, GHFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_cache_key_foreach$handle() {
        return g_cache_key_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cache_key_foreach(GCache *cache, GHFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_cache_key_foreach$address() {
        return g_cache_key_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cache_key_foreach(GCache *cache, GHFunc func, gpointer user_data)
     * }
     */
    public static void g_cache_key_foreach(MemorySegment cache, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_cache_key_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cache_key_foreach", cache, func, user_data);
            }
            mh$.invokeExact(cache, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cache_value_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cache_value_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cache_value_foreach(GCache *cache, GHFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_cache_value_foreach$descriptor() {
        return g_cache_value_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cache_value_foreach(GCache *cache, GHFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_cache_value_foreach$handle() {
        return g_cache_value_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cache_value_foreach(GCache *cache, GHFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_cache_value_foreach$address() {
        return g_cache_value_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cache_value_foreach(GCache *cache, GHFunc func, gpointer user_data)
     * }
     */
    public static void g_cache_value_foreach(MemorySegment cache, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_cache_value_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cache_value_foreach", cache, func, user_data);
            }
            mh$.invokeExact(cache, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_completion_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_completion_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GCompletion *g_completion_new(GCompletionFunc func)
     * }
     */
    public static FunctionDescriptor g_completion_new$descriptor() {
        return g_completion_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GCompletion *g_completion_new(GCompletionFunc func)
     * }
     */
    public static MethodHandle g_completion_new$handle() {
        return g_completion_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GCompletion *g_completion_new(GCompletionFunc func)
     * }
     */
    public static MemorySegment g_completion_new$address() {
        return g_completion_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GCompletion *g_completion_new(GCompletionFunc func)
     * }
     */
    public static MemorySegment g_completion_new(MemorySegment func) {
        var mh$ = g_completion_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_completion_new", func);
            }
            return (MemorySegment)mh$.invokeExact(func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_completion_add_items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_completion_add_items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_completion_add_items(GCompletion *cmp, GList *items)
     * }
     */
    public static FunctionDescriptor g_completion_add_items$descriptor() {
        return g_completion_add_items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_completion_add_items(GCompletion *cmp, GList *items)
     * }
     */
    public static MethodHandle g_completion_add_items$handle() {
        return g_completion_add_items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_completion_add_items(GCompletion *cmp, GList *items)
     * }
     */
    public static MemorySegment g_completion_add_items$address() {
        return g_completion_add_items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_completion_add_items(GCompletion *cmp, GList *items)
     * }
     */
    public static void g_completion_add_items(MemorySegment cmp, MemorySegment items) {
        var mh$ = g_completion_add_items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_completion_add_items", cmp, items);
            }
            mh$.invokeExact(cmp, items);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_completion_remove_items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_completion_remove_items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_completion_remove_items(GCompletion *cmp, GList *items)
     * }
     */
    public static FunctionDescriptor g_completion_remove_items$descriptor() {
        return g_completion_remove_items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_completion_remove_items(GCompletion *cmp, GList *items)
     * }
     */
    public static MethodHandle g_completion_remove_items$handle() {
        return g_completion_remove_items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_completion_remove_items(GCompletion *cmp, GList *items)
     * }
     */
    public static MemorySegment g_completion_remove_items$address() {
        return g_completion_remove_items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_completion_remove_items(GCompletion *cmp, GList *items)
     * }
     */
    public static void g_completion_remove_items(MemorySegment cmp, MemorySegment items) {
        var mh$ = g_completion_remove_items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_completion_remove_items", cmp, items);
            }
            mh$.invokeExact(cmp, items);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_completion_clear_items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_completion_clear_items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_completion_clear_items(GCompletion *cmp)
     * }
     */
    public static FunctionDescriptor g_completion_clear_items$descriptor() {
        return g_completion_clear_items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_completion_clear_items(GCompletion *cmp)
     * }
     */
    public static MethodHandle g_completion_clear_items$handle() {
        return g_completion_clear_items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_completion_clear_items(GCompletion *cmp)
     * }
     */
    public static MemorySegment g_completion_clear_items$address() {
        return g_completion_clear_items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_completion_clear_items(GCompletion *cmp)
     * }
     */
    public static void g_completion_clear_items(MemorySegment cmp) {
        var mh$ = g_completion_clear_items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_completion_clear_items", cmp);
            }
            mh$.invokeExact(cmp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_completion_complete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_completion_complete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_completion_complete(GCompletion *cmp, const gchar *prefix, gchar **new_prefix)
     * }
     */
    public static FunctionDescriptor g_completion_complete$descriptor() {
        return g_completion_complete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_completion_complete(GCompletion *cmp, const gchar *prefix, gchar **new_prefix)
     * }
     */
    public static MethodHandle g_completion_complete$handle() {
        return g_completion_complete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_completion_complete(GCompletion *cmp, const gchar *prefix, gchar **new_prefix)
     * }
     */
    public static MemorySegment g_completion_complete$address() {
        return g_completion_complete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_completion_complete(GCompletion *cmp, const gchar *prefix, gchar **new_prefix)
     * }
     */
    public static MemorySegment g_completion_complete(MemorySegment cmp, MemorySegment prefix, MemorySegment new_prefix) {
        var mh$ = g_completion_complete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_completion_complete", cmp, prefix, new_prefix);
            }
            return (MemorySegment)mh$.invokeExact(cmp, prefix, new_prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_completion_complete_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_completion_complete_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_completion_complete_utf8(GCompletion *cmp, const gchar *prefix, gchar **new_prefix)
     * }
     */
    public static FunctionDescriptor g_completion_complete_utf8$descriptor() {
        return g_completion_complete_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_completion_complete_utf8(GCompletion *cmp, const gchar *prefix, gchar **new_prefix)
     * }
     */
    public static MethodHandle g_completion_complete_utf8$handle() {
        return g_completion_complete_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_completion_complete_utf8(GCompletion *cmp, const gchar *prefix, gchar **new_prefix)
     * }
     */
    public static MemorySegment g_completion_complete_utf8$address() {
        return g_completion_complete_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_completion_complete_utf8(GCompletion *cmp, const gchar *prefix, gchar **new_prefix)
     * }
     */
    public static MemorySegment g_completion_complete_utf8(MemorySegment cmp, MemorySegment prefix, MemorySegment new_prefix) {
        var mh$ = g_completion_complete_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_completion_complete_utf8", cmp, prefix, new_prefix);
            }
            return (MemorySegment)mh$.invokeExact(cmp, prefix, new_prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_completion_set_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_completion_set_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_completion_set_compare(GCompletion *cmp, GCompletionStrncmpFunc strncmp_func)
     * }
     */
    public static FunctionDescriptor g_completion_set_compare$descriptor() {
        return g_completion_set_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_completion_set_compare(GCompletion *cmp, GCompletionStrncmpFunc strncmp_func)
     * }
     */
    public static MethodHandle g_completion_set_compare$handle() {
        return g_completion_set_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_completion_set_compare(GCompletion *cmp, GCompletionStrncmpFunc strncmp_func)
     * }
     */
    public static MemorySegment g_completion_set_compare$address() {
        return g_completion_set_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_completion_set_compare(GCompletion *cmp, GCompletionStrncmpFunc strncmp_func)
     * }
     */
    public static void g_completion_set_compare(MemorySegment cmp, MemorySegment strncmp_func) {
        var mh$ = g_completion_set_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_completion_set_compare", cmp, strncmp_func);
            }
            mh$.invokeExact(cmp, strncmp_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_completion_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_completion_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_completion_free(GCompletion *cmp)
     * }
     */
    public static FunctionDescriptor g_completion_free$descriptor() {
        return g_completion_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_completion_free(GCompletion *cmp)
     * }
     */
    public static MethodHandle g_completion_free$handle() {
        return g_completion_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_completion_free(GCompletion *cmp)
     * }
     */
    public static MemorySegment g_completion_free$address() {
        return g_completion_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_completion_free(GCompletion *cmp)
     * }
     */
    public static void g_completion_free(MemorySegment cmp) {
        var mh$ = g_completion_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_completion_free", cmp);
            }
            mh$.invokeExact(cmp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_relation_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRelation *g_relation_new(gint fields)
     * }
     */
    public static FunctionDescriptor g_relation_new$descriptor() {
        return g_relation_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRelation *g_relation_new(gint fields)
     * }
     */
    public static MethodHandle g_relation_new$handle() {
        return g_relation_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRelation *g_relation_new(gint fields)
     * }
     */
    public static MemorySegment g_relation_new$address() {
        return g_relation_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRelation *g_relation_new(gint fields)
     * }
     */
    public static MemorySegment g_relation_new(int fields) {
        var mh$ = g_relation_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_relation_new", fields);
            }
            return (MemorySegment)mh$.invokeExact(fields);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_relation_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_relation_destroy(GRelation *relation)
     * }
     */
    public static FunctionDescriptor g_relation_destroy$descriptor() {
        return g_relation_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_relation_destroy(GRelation *relation)
     * }
     */
    public static MethodHandle g_relation_destroy$handle() {
        return g_relation_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_relation_destroy(GRelation *relation)
     * }
     */
    public static MemorySegment g_relation_destroy$address() {
        return g_relation_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_relation_destroy(GRelation *relation)
     * }
     */
    public static void g_relation_destroy(MemorySegment relation) {
        var mh$ = g_relation_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_relation_destroy", relation);
            }
            mh$.invokeExact(relation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_relation_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_relation_index(GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func)
     * }
     */
    public static FunctionDescriptor g_relation_index$descriptor() {
        return g_relation_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_relation_index(GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func)
     * }
     */
    public static MethodHandle g_relation_index$handle() {
        return g_relation_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_relation_index(GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func)
     * }
     */
    public static MemorySegment g_relation_index$address() {
        return g_relation_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_relation_index(GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func)
     * }
     */
    public static void g_relation_index(MemorySegment relation, int field, MemorySegment hash_func, MemorySegment key_equal_func) {
        var mh$ = g_relation_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_relation_index", relation, field, hash_func, key_equal_func);
            }
            mh$.invokeExact(relation, field, hash_func, key_equal_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_relation_insert(GRelation *relation, ...)
     * }
     */
    public static class g_relation_insert {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_insert");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_relation_insert(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_relation_insert(GRelation *relation, ...)
         * }
         */
        public static g_relation_insert makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_relation_insert(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment relation, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_relation_insert", relation, x1);
                }
                 spreader.invokeExact(relation, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_relation_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_relation_delete(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static FunctionDescriptor g_relation_delete$descriptor() {
        return g_relation_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_relation_delete(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static MethodHandle g_relation_delete$handle() {
        return g_relation_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_relation_delete(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static MemorySegment g_relation_delete$address() {
        return g_relation_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_relation_delete(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static int g_relation_delete(MemorySegment relation, MemorySegment key, int field) {
        var mh$ = g_relation_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_relation_delete", relation, key, field);
            }
            return (int)mh$.invokeExact(relation, key, field);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_relation_select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTuples *g_relation_select(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static FunctionDescriptor g_relation_select$descriptor() {
        return g_relation_select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTuples *g_relation_select(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static MethodHandle g_relation_select$handle() {
        return g_relation_select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTuples *g_relation_select(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static MemorySegment g_relation_select$address() {
        return g_relation_select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTuples *g_relation_select(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static MemorySegment g_relation_select(MemorySegment relation, MemorySegment key, int field) {
        var mh$ = g_relation_select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_relation_select", relation, key, field);
            }
            return (MemorySegment)mh$.invokeExact(relation, key, field);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_relation_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_relation_count(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static FunctionDescriptor g_relation_count$descriptor() {
        return g_relation_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_relation_count(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static MethodHandle g_relation_count$handle() {
        return g_relation_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_relation_count(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static MemorySegment g_relation_count$address() {
        return g_relation_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_relation_count(GRelation *relation, gconstpointer key, gint field)
     * }
     */
    public static int g_relation_count(MemorySegment relation, MemorySegment key, int field) {
        var mh$ = g_relation_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_relation_count", relation, key, field);
            }
            return (int)mh$.invokeExact(relation, key, field);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gboolean g_relation_exists(GRelation *relation, ...)
     * }
     */
    public static class g_relation_exists {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_exists");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_relation_exists(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gboolean g_relation_exists(GRelation *relation, ...)
         * }
         */
        public static g_relation_exists makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_relation_exists(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment relation, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_relation_exists", relation, x1);
                }
                return (int) spreader.invokeExact(relation, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_relation_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_relation_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_relation_print(GRelation *relation)
     * }
     */
    public static FunctionDescriptor g_relation_print$descriptor() {
        return g_relation_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_relation_print(GRelation *relation)
     * }
     */
    public static MethodHandle g_relation_print$handle() {
        return g_relation_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_relation_print(GRelation *relation)
     * }
     */
    public static MemorySegment g_relation_print$address() {
        return g_relation_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_relation_print(GRelation *relation)
     * }
     */
    public static void g_relation_print(MemorySegment relation) {
        var mh$ = g_relation_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_relation_print", relation);
            }
            mh$.invokeExact(relation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tuples_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tuples_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_tuples_destroy(GTuples *tuples)
     * }
     */
    public static FunctionDescriptor g_tuples_destroy$descriptor() {
        return g_tuples_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_tuples_destroy(GTuples *tuples)
     * }
     */
    public static MethodHandle g_tuples_destroy$handle() {
        return g_tuples_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_tuples_destroy(GTuples *tuples)
     * }
     */
    public static MemorySegment g_tuples_destroy$address() {
        return g_tuples_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_tuples_destroy(GTuples *tuples)
     * }
     */
    public static void g_tuples_destroy(MemorySegment tuples) {
        var mh$ = g_tuples_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tuples_destroy", tuples);
            }
            mh$.invokeExact(tuples);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tuples_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tuples_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_tuples_index(GTuples *tuples, gint index_, gint field)
     * }
     */
    public static FunctionDescriptor g_tuples_index$descriptor() {
        return g_tuples_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_tuples_index(GTuples *tuples, gint index_, gint field)
     * }
     */
    public static MethodHandle g_tuples_index$handle() {
        return g_tuples_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_tuples_index(GTuples *tuples, gint index_, gint field)
     * }
     */
    public static MemorySegment g_tuples_index$address() {
        return g_tuples_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_tuples_index(GTuples *tuples, gint index_, gint field)
     * }
     */
    public static MemorySegment g_tuples_index(MemorySegment tuples, int index_, int field) {
        var mh$ = g_tuples_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tuples_index", tuples, index_, field);
            }
            return (MemorySegment)mh$.invokeExact(tuples, index_, field);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_THREAD_PRIORITY_LOW = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_THREAD_PRIORITY_LOW = 0
     * }
     */
    public static int G_THREAD_PRIORITY_LOW() {
        return G_THREAD_PRIORITY_LOW;
    }
    private static final int G_THREAD_PRIORITY_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_THREAD_PRIORITY_NORMAL = 1
     * }
     */
    public static int G_THREAD_PRIORITY_NORMAL() {
        return G_THREAD_PRIORITY_NORMAL;
    }
    private static final int G_THREAD_PRIORITY_HIGH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_THREAD_PRIORITY_HIGH = 2
     * }
     */
    public static int G_THREAD_PRIORITY_HIGH() {
        return G_THREAD_PRIORITY_HIGH;
    }
    private static final int G_THREAD_PRIORITY_URGENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_THREAD_PRIORITY_URGENT = 3
     * }
     */
    public static int G_THREAD_PRIORITY_URGENT() {
        return G_THREAD_PRIORITY_URGENT;
    }

    private static class g_thread_functions_for_glib_use$constants {
        public static final GroupLayout LAYOUT = _GThreadFunctions.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_thread_functions_for_glib_use").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern GThreadFunctions g_thread_functions_for_glib_use
     * }
     */
    public static GroupLayout g_thread_functions_for_glib_use$layout() {
        return g_thread_functions_for_glib_use$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern GThreadFunctions g_thread_functions_for_glib_use
     * }
     */
    public static MemorySegment g_thread_functions_for_glib_use() {
        return g_thread_functions_for_glib_use$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern GThreadFunctions g_thread_functions_for_glib_use
     * }
     */
    public static void g_thread_functions_for_glib_use(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, g_thread_functions_for_glib_use$constants.SEGMENT, 0L, g_thread_functions_for_glib_use$constants.LAYOUT.byteSize());
    }

    private static class g_thread_use_default_impl$constants {
        public static final OfInt LAYOUT = gst_min_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_thread_use_default_impl").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern gboolean g_thread_use_default_impl
     * }
     */
    public static OfInt g_thread_use_default_impl$layout() {
        return g_thread_use_default_impl$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern gboolean g_thread_use_default_impl
     * }
     */
    public static MemorySegment g_thread_use_default_impl$segment() {
        return g_thread_use_default_impl$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern gboolean g_thread_use_default_impl
     * }
     */
    public static int g_thread_use_default_impl() {
        return g_thread_use_default_impl$constants.SEGMENT.get(g_thread_use_default_impl$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern gboolean g_thread_use_default_impl
     * }
     */
    public static void g_thread_use_default_impl(int varValue) {
        g_thread_use_default_impl$constants.SEGMENT.set(g_thread_use_default_impl$constants.LAYOUT, 0L, varValue);
    }

    private static class g_thread_gettime$constants {
        public static final AddressLayout LAYOUT = gst_min_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_thread_gettime").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern guint64 (*g_thread_gettime)(void)
     * }
     */
    public static AddressLayout g_thread_gettime$layout() {
        return g_thread_gettime$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern guint64 (*g_thread_gettime)(void)
     * }
     */
    public static MemorySegment g_thread_gettime$segment() {
        return g_thread_gettime$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern guint64 (*g_thread_gettime)(void)
     * }
     */
    public static MemorySegment g_thread_gettime() {
        return g_thread_gettime$constants.SEGMENT.get(g_thread_gettime$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern guint64 (*g_thread_gettime)(void)
     * }
     */
    public static void g_thread_gettime(MemorySegment varValue) {
        g_thread_gettime$constants.SEGMENT.set(g_thread_gettime$constants.LAYOUT, 0L, varValue);
    }

    private static class g_thread_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GThread *g_thread_create(GThreadFunc func, gpointer data, gboolean joinable, GError **error)
     * }
     */
    public static FunctionDescriptor g_thread_create$descriptor() {
        return g_thread_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GThread *g_thread_create(GThreadFunc func, gpointer data, gboolean joinable, GError **error)
     * }
     */
    public static MethodHandle g_thread_create$handle() {
        return g_thread_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GThread *g_thread_create(GThreadFunc func, gpointer data, gboolean joinable, GError **error)
     * }
     */
    public static MemorySegment g_thread_create$address() {
        return g_thread_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GThread *g_thread_create(GThreadFunc func, gpointer data, gboolean joinable, GError **error)
     * }
     */
    public static MemorySegment g_thread_create(MemorySegment func, MemorySegment data, int joinable, MemorySegment error) {
        var mh$ = g_thread_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_create", func, data, joinable, error);
            }
            return (MemorySegment)mh$.invokeExact(func, data, joinable, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_create_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_create_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GThread *g_thread_create_full(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error)
     * }
     */
    public static FunctionDescriptor g_thread_create_full$descriptor() {
        return g_thread_create_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GThread *g_thread_create_full(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error)
     * }
     */
    public static MethodHandle g_thread_create_full$handle() {
        return g_thread_create_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GThread *g_thread_create_full(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error)
     * }
     */
    public static MemorySegment g_thread_create_full$address() {
        return g_thread_create_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GThread *g_thread_create_full(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error)
     * }
     */
    public static MemorySegment g_thread_create_full(MemorySegment func, MemorySegment data, int stack_size, int joinable, int bound, int priority, MemorySegment error) {
        var mh$ = g_thread_create_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_create_full", func, data, stack_size, joinable, bound, priority, error);
            }
            return (MemorySegment)mh$.invokeExact(func, data, stack_size, joinable, bound, priority, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_set_priority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_set_priority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_set_priority(GThread *thread, GThreadPriority priority)
     * }
     */
    public static FunctionDescriptor g_thread_set_priority$descriptor() {
        return g_thread_set_priority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_set_priority(GThread *thread, GThreadPriority priority)
     * }
     */
    public static MethodHandle g_thread_set_priority$handle() {
        return g_thread_set_priority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_set_priority(GThread *thread, GThreadPriority priority)
     * }
     */
    public static MemorySegment g_thread_set_priority$address() {
        return g_thread_set_priority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_set_priority(GThread *thread, GThreadPriority priority)
     * }
     */
    public static void g_thread_set_priority(MemorySegment thread, int priority) {
        var mh$ = g_thread_set_priority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_set_priority", thread, priority);
            }
            mh$.invokeExact(thread, priority);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_foreach(GFunc thread_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_thread_foreach$descriptor() {
        return g_thread_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_foreach(GFunc thread_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_thread_foreach$handle() {
        return g_thread_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_foreach(GFunc thread_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_thread_foreach$address() {
        return g_thread_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_foreach(GFunc thread_func, gpointer user_data)
     * }
     */
    public static void g_thread_foreach(MemorySegment thread_func, MemorySegment user_data) {
        var mh$ = g_thread_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_foreach", thread_func, user_data);
            }
            mh$.invokeExact(thread_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_mutex_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_mutex_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_mutex_init(GStaticMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_mutex_init$descriptor() {
        return g_static_mutex_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_mutex_init(GStaticMutex *mutex)
     * }
     */
    public static MethodHandle g_static_mutex_init$handle() {
        return g_static_mutex_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_mutex_init(GStaticMutex *mutex)
     * }
     */
    public static MemorySegment g_static_mutex_init$address() {
        return g_static_mutex_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_mutex_init(GStaticMutex *mutex)
     * }
     */
    public static void g_static_mutex_init(MemorySegment mutex) {
        var mh$ = g_static_mutex_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_mutex_init", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_mutex_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_mutex_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_mutex_free(GStaticMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_mutex_free$descriptor() {
        return g_static_mutex_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_mutex_free(GStaticMutex *mutex)
     * }
     */
    public static MethodHandle g_static_mutex_free$handle() {
        return g_static_mutex_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_mutex_free(GStaticMutex *mutex)
     * }
     */
    public static MemorySegment g_static_mutex_free$address() {
        return g_static_mutex_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_mutex_free(GStaticMutex *mutex)
     * }
     */
    public static void g_static_mutex_free(MemorySegment mutex) {
        var mh$ = g_static_mutex_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_mutex_free", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_mutex_get_mutex_impl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_mutex_get_mutex_impl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_mutex_get_mutex_impl$descriptor() {
        return g_static_mutex_get_mutex_impl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex)
     * }
     */
    public static MethodHandle g_static_mutex_get_mutex_impl$handle() {
        return g_static_mutex_get_mutex_impl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex)
     * }
     */
    public static MemorySegment g_static_mutex_get_mutex_impl$address() {
        return g_static_mutex_get_mutex_impl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex)
     * }
     */
    public static MemorySegment g_static_mutex_get_mutex_impl(MemorySegment mutex) {
        var mh$ = g_static_mutex_get_mutex_impl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_mutex_get_mutex_impl", mutex);
            }
            return (MemorySegment)mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rec_mutex_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rec_mutex_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_init(GStaticRecMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_rec_mutex_init$descriptor() {
        return g_static_rec_mutex_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_init(GStaticRecMutex *mutex)
     * }
     */
    public static MethodHandle g_static_rec_mutex_init$handle() {
        return g_static_rec_mutex_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_init(GStaticRecMutex *mutex)
     * }
     */
    public static MemorySegment g_static_rec_mutex_init$address() {
        return g_static_rec_mutex_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_init(GStaticRecMutex *mutex)
     * }
     */
    public static void g_static_rec_mutex_init(MemorySegment mutex) {
        var mh$ = g_static_rec_mutex_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rec_mutex_init", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rec_mutex_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rec_mutex_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_rec_mutex_lock$descriptor() {
        return g_static_rec_mutex_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex)
     * }
     */
    public static MethodHandle g_static_rec_mutex_lock$handle() {
        return g_static_rec_mutex_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex)
     * }
     */
    public static MemorySegment g_static_rec_mutex_lock$address() {
        return g_static_rec_mutex_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex)
     * }
     */
    public static void g_static_rec_mutex_lock(MemorySegment mutex) {
        var mh$ = g_static_rec_mutex_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rec_mutex_lock", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rec_mutex_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rec_mutex_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_rec_mutex_trylock$descriptor() {
        return g_static_rec_mutex_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex)
     * }
     */
    public static MethodHandle g_static_rec_mutex_trylock$handle() {
        return g_static_rec_mutex_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex)
     * }
     */
    public static MemorySegment g_static_rec_mutex_trylock$address() {
        return g_static_rec_mutex_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex)
     * }
     */
    public static int g_static_rec_mutex_trylock(MemorySegment mutex) {
        var mh$ = g_static_rec_mutex_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rec_mutex_trylock", mutex);
            }
            return (int)mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rec_mutex_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rec_mutex_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_rec_mutex_unlock$descriptor() {
        return g_static_rec_mutex_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex)
     * }
     */
    public static MethodHandle g_static_rec_mutex_unlock$handle() {
        return g_static_rec_mutex_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex)
     * }
     */
    public static MemorySegment g_static_rec_mutex_unlock$address() {
        return g_static_rec_mutex_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex)
     * }
     */
    public static void g_static_rec_mutex_unlock(MemorySegment mutex) {
        var mh$ = g_static_rec_mutex_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rec_mutex_unlock", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rec_mutex_lock_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rec_mutex_lock_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex, guint depth)
     * }
     */
    public static FunctionDescriptor g_static_rec_mutex_lock_full$descriptor() {
        return g_static_rec_mutex_lock_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex, guint depth)
     * }
     */
    public static MethodHandle g_static_rec_mutex_lock_full$handle() {
        return g_static_rec_mutex_lock_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex, guint depth)
     * }
     */
    public static MemorySegment g_static_rec_mutex_lock_full$address() {
        return g_static_rec_mutex_lock_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex, guint depth)
     * }
     */
    public static void g_static_rec_mutex_lock_full(MemorySegment mutex, int depth) {
        var mh$ = g_static_rec_mutex_lock_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rec_mutex_lock_full", mutex, depth);
            }
            mh$.invokeExact(mutex, depth);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rec_mutex_unlock_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rec_mutex_unlock_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_rec_mutex_unlock_full$descriptor() {
        return g_static_rec_mutex_unlock_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex)
     * }
     */
    public static MethodHandle g_static_rec_mutex_unlock_full$handle() {
        return g_static_rec_mutex_unlock_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex)
     * }
     */
    public static MemorySegment g_static_rec_mutex_unlock_full$address() {
        return g_static_rec_mutex_unlock_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex)
     * }
     */
    public static int g_static_rec_mutex_unlock_full(MemorySegment mutex) {
        var mh$ = g_static_rec_mutex_unlock_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rec_mutex_unlock_full", mutex);
            }
            return (int)mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rec_mutex_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rec_mutex_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_free(GStaticRecMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_static_rec_mutex_free$descriptor() {
        return g_static_rec_mutex_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_free(GStaticRecMutex *mutex)
     * }
     */
    public static MethodHandle g_static_rec_mutex_free$handle() {
        return g_static_rec_mutex_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_free(GStaticRecMutex *mutex)
     * }
     */
    public static MemorySegment g_static_rec_mutex_free$address() {
        return g_static_rec_mutex_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rec_mutex_free(GStaticRecMutex *mutex)
     * }
     */
    public static void g_static_rec_mutex_free(MemorySegment mutex) {
        var mh$ = g_static_rec_mutex_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rec_mutex_free", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rw_lock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rw_lock_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_init(GStaticRWLock *lock)
     * }
     */
    public static FunctionDescriptor g_static_rw_lock_init$descriptor() {
        return g_static_rw_lock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_init(GStaticRWLock *lock)
     * }
     */
    public static MethodHandle g_static_rw_lock_init$handle() {
        return g_static_rw_lock_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_init(GStaticRWLock *lock)
     * }
     */
    public static MemorySegment g_static_rw_lock_init$address() {
        return g_static_rw_lock_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rw_lock_init(GStaticRWLock *lock)
     * }
     */
    public static void g_static_rw_lock_init(MemorySegment lock) {
        var mh$ = g_static_rw_lock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rw_lock_init", lock);
            }
            mh$.invokeExact(lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rw_lock_reader_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rw_lock_reader_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock)
     * }
     */
    public static FunctionDescriptor g_static_rw_lock_reader_lock$descriptor() {
        return g_static_rw_lock_reader_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock)
     * }
     */
    public static MethodHandle g_static_rw_lock_reader_lock$handle() {
        return g_static_rw_lock_reader_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock)
     * }
     */
    public static MemorySegment g_static_rw_lock_reader_lock$address() {
        return g_static_rw_lock_reader_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock)
     * }
     */
    public static void g_static_rw_lock_reader_lock(MemorySegment lock) {
        var mh$ = g_static_rw_lock_reader_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rw_lock_reader_lock", lock);
            }
            mh$.invokeExact(lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rw_lock_reader_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rw_lock_reader_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock)
     * }
     */
    public static FunctionDescriptor g_static_rw_lock_reader_trylock$descriptor() {
        return g_static_rw_lock_reader_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock)
     * }
     */
    public static MethodHandle g_static_rw_lock_reader_trylock$handle() {
        return g_static_rw_lock_reader_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock)
     * }
     */
    public static MemorySegment g_static_rw_lock_reader_trylock$address() {
        return g_static_rw_lock_reader_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock)
     * }
     */
    public static int g_static_rw_lock_reader_trylock(MemorySegment lock) {
        var mh$ = g_static_rw_lock_reader_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rw_lock_reader_trylock", lock);
            }
            return (int)mh$.invokeExact(lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rw_lock_reader_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rw_lock_reader_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock)
     * }
     */
    public static FunctionDescriptor g_static_rw_lock_reader_unlock$descriptor() {
        return g_static_rw_lock_reader_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock)
     * }
     */
    public static MethodHandle g_static_rw_lock_reader_unlock$handle() {
        return g_static_rw_lock_reader_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock)
     * }
     */
    public static MemorySegment g_static_rw_lock_reader_unlock$address() {
        return g_static_rw_lock_reader_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock)
     * }
     */
    public static void g_static_rw_lock_reader_unlock(MemorySegment lock) {
        var mh$ = g_static_rw_lock_reader_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rw_lock_reader_unlock", lock);
            }
            mh$.invokeExact(lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rw_lock_writer_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rw_lock_writer_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock)
     * }
     */
    public static FunctionDescriptor g_static_rw_lock_writer_lock$descriptor() {
        return g_static_rw_lock_writer_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock)
     * }
     */
    public static MethodHandle g_static_rw_lock_writer_lock$handle() {
        return g_static_rw_lock_writer_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock)
     * }
     */
    public static MemorySegment g_static_rw_lock_writer_lock$address() {
        return g_static_rw_lock_writer_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock)
     * }
     */
    public static void g_static_rw_lock_writer_lock(MemorySegment lock) {
        var mh$ = g_static_rw_lock_writer_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rw_lock_writer_lock", lock);
            }
            mh$.invokeExact(lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rw_lock_writer_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rw_lock_writer_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock)
     * }
     */
    public static FunctionDescriptor g_static_rw_lock_writer_trylock$descriptor() {
        return g_static_rw_lock_writer_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock)
     * }
     */
    public static MethodHandle g_static_rw_lock_writer_trylock$handle() {
        return g_static_rw_lock_writer_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock)
     * }
     */
    public static MemorySegment g_static_rw_lock_writer_trylock$address() {
        return g_static_rw_lock_writer_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock)
     * }
     */
    public static int g_static_rw_lock_writer_trylock(MemorySegment lock) {
        var mh$ = g_static_rw_lock_writer_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rw_lock_writer_trylock", lock);
            }
            return (int)mh$.invokeExact(lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rw_lock_writer_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rw_lock_writer_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock)
     * }
     */
    public static FunctionDescriptor g_static_rw_lock_writer_unlock$descriptor() {
        return g_static_rw_lock_writer_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock)
     * }
     */
    public static MethodHandle g_static_rw_lock_writer_unlock$handle() {
        return g_static_rw_lock_writer_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock)
     * }
     */
    public static MemorySegment g_static_rw_lock_writer_unlock$address() {
        return g_static_rw_lock_writer_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock)
     * }
     */
    public static void g_static_rw_lock_writer_unlock(MemorySegment lock) {
        var mh$ = g_static_rw_lock_writer_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rw_lock_writer_unlock", lock);
            }
            mh$.invokeExact(lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_rw_lock_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_rw_lock_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_free(GStaticRWLock *lock)
     * }
     */
    public static FunctionDescriptor g_static_rw_lock_free$descriptor() {
        return g_static_rw_lock_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_free(GStaticRWLock *lock)
     * }
     */
    public static MethodHandle g_static_rw_lock_free$handle() {
        return g_static_rw_lock_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_rw_lock_free(GStaticRWLock *lock)
     * }
     */
    public static MemorySegment g_static_rw_lock_free$address() {
        return g_static_rw_lock_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_rw_lock_free(GStaticRWLock *lock)
     * }
     */
    public static void g_static_rw_lock_free(MemorySegment lock) {
        var mh$ = g_static_rw_lock_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_rw_lock_free", lock);
            }
            mh$.invokeExact(lock);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_private_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_private_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPrivate *g_private_new(GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_private_new$descriptor() {
        return g_private_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPrivate *g_private_new(GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_private_new$handle() {
        return g_private_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPrivate *g_private_new(GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_private_new$address() {
        return g_private_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPrivate *g_private_new(GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_private_new(MemorySegment notify) {
        var mh$ = g_private_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_private_new", notify);
            }
            return (MemorySegment)mh$.invokeExact(notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_private_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_private_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_private_init(GStaticPrivate *private_key)
     * }
     */
    public static FunctionDescriptor g_static_private_init$descriptor() {
        return g_static_private_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_private_init(GStaticPrivate *private_key)
     * }
     */
    public static MethodHandle g_static_private_init$handle() {
        return g_static_private_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_private_init(GStaticPrivate *private_key)
     * }
     */
    public static MemorySegment g_static_private_init$address() {
        return g_static_private_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_private_init(GStaticPrivate *private_key)
     * }
     */
    public static void g_static_private_init(MemorySegment private_key) {
        var mh$ = g_static_private_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_private_init", private_key);
            }
            mh$.invokeExact(private_key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_private_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_private_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_static_private_get(GStaticPrivate *private_key)
     * }
     */
    public static FunctionDescriptor g_static_private_get$descriptor() {
        return g_static_private_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_static_private_get(GStaticPrivate *private_key)
     * }
     */
    public static MethodHandle g_static_private_get$handle() {
        return g_static_private_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_static_private_get(GStaticPrivate *private_key)
     * }
     */
    public static MemorySegment g_static_private_get$address() {
        return g_static_private_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_static_private_get(GStaticPrivate *private_key)
     * }
     */
    public static MemorySegment g_static_private_get(MemorySegment private_key) {
        var mh$ = g_static_private_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_private_get", private_key);
            }
            return (MemorySegment)mh$.invokeExact(private_key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_private_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_private_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_private_set(GStaticPrivate *private_key, gpointer data, GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_static_private_set$descriptor() {
        return g_static_private_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_private_set(GStaticPrivate *private_key, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_static_private_set$handle() {
        return g_static_private_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_private_set(GStaticPrivate *private_key, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_static_private_set$address() {
        return g_static_private_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_private_set(GStaticPrivate *private_key, gpointer data, GDestroyNotify notify)
     * }
     */
    public static void g_static_private_set(MemorySegment private_key, MemorySegment data, MemorySegment notify) {
        var mh$ = g_static_private_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_private_set", private_key, data, notify);
            }
            mh$.invokeExact(private_key, data, notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_static_private_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_static_private_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_static_private_free(GStaticPrivate *private_key)
     * }
     */
    public static FunctionDescriptor g_static_private_free$descriptor() {
        return g_static_private_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_static_private_free(GStaticPrivate *private_key)
     * }
     */
    public static MethodHandle g_static_private_free$handle() {
        return g_static_private_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_static_private_free(GStaticPrivate *private_key)
     * }
     */
    public static MemorySegment g_static_private_free$address() {
        return g_static_private_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_static_private_free(GStaticPrivate *private_key)
     * }
     */
    public static void g_static_private_free(MemorySegment private_key) {
        var mh$ = g_static_private_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_static_private_free", private_key);
            }
            mh$.invokeExact(private_key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_once_init_enter_impl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_once_init_enter_impl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter_impl(volatile gsize *location)
     * }
     */
    public static FunctionDescriptor g_once_init_enter_impl$descriptor() {
        return g_once_init_enter_impl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter_impl(volatile gsize *location)
     * }
     */
    public static MethodHandle g_once_init_enter_impl$handle() {
        return g_once_init_enter_impl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter_impl(volatile gsize *location)
     * }
     */
    public static MemorySegment g_once_init_enter_impl$address() {
        return g_once_init_enter_impl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_once_init_enter_impl(volatile gsize *location)
     * }
     */
    public static int g_once_init_enter_impl(MemorySegment location) {
        var mh$ = g_once_init_enter_impl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_once_init_enter_impl", location);
            }
            return (int)mh$.invokeExact(location);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_init(gpointer vtable)
     * }
     */
    public static FunctionDescriptor g_thread_init$descriptor() {
        return g_thread_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_init(gpointer vtable)
     * }
     */
    public static MethodHandle g_thread_init$handle() {
        return g_thread_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_init(gpointer vtable)
     * }
     */
    public static MemorySegment g_thread_init$address() {
        return g_thread_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_init(gpointer vtable)
     * }
     */
    public static void g_thread_init(MemorySegment vtable) {
        var mh$ = g_thread_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_init", vtable);
            }
            mh$.invokeExact(vtable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_init_with_errorcheck_mutexes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_init_with_errorcheck_mutexes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable)
     * }
     */
    public static FunctionDescriptor g_thread_init_with_errorcheck_mutexes$descriptor() {
        return g_thread_init_with_errorcheck_mutexes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable)
     * }
     */
    public static MethodHandle g_thread_init_with_errorcheck_mutexes$handle() {
        return g_thread_init_with_errorcheck_mutexes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable)
     * }
     */
    public static MemorySegment g_thread_init_with_errorcheck_mutexes$address() {
        return g_thread_init_with_errorcheck_mutexes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable)
     * }
     */
    public static void g_thread_init_with_errorcheck_mutexes(MemorySegment vtable) {
        var mh$ = g_thread_init_with_errorcheck_mutexes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_init_with_errorcheck_mutexes", vtable);
            }
            mh$.invokeExact(vtable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_get_initialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_get_initialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_thread_get_initialized()
     * }
     */
    public static FunctionDescriptor g_thread_get_initialized$descriptor() {
        return g_thread_get_initialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_thread_get_initialized()
     * }
     */
    public static MethodHandle g_thread_get_initialized$handle() {
        return g_thread_get_initialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_thread_get_initialized()
     * }
     */
    public static MemorySegment g_thread_get_initialized$address() {
        return g_thread_get_initialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_thread_get_initialized()
     * }
     */
    public static int g_thread_get_initialized() {
        var mh$ = g_thread_get_initialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_get_initialized");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_threads_got_initialized$constants {
        public static final OfInt LAYOUT = gst_min_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_threads_got_initialized").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern gboolean g_threads_got_initialized
     * }
     */
    public static OfInt g_threads_got_initialized$layout() {
        return g_threads_got_initialized$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern gboolean g_threads_got_initialized
     * }
     */
    public static MemorySegment g_threads_got_initialized$segment() {
        return g_threads_got_initialized$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern gboolean g_threads_got_initialized
     * }
     */
    public static int g_threads_got_initialized() {
        return g_threads_got_initialized$constants.SEGMENT.get(g_threads_got_initialized$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern gboolean g_threads_got_initialized
     * }
     */
    public static void g_threads_got_initialized(int varValue) {
        g_threads_got_initialized$constants.SEGMENT.set(g_threads_got_initialized$constants.LAYOUT, 0L, varValue);
    }

    private static class g_mutex_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mutex_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMutex *g_mutex_new()
     * }
     */
    public static FunctionDescriptor g_mutex_new$descriptor() {
        return g_mutex_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMutex *g_mutex_new()
     * }
     */
    public static MethodHandle g_mutex_new$handle() {
        return g_mutex_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMutex *g_mutex_new()
     * }
     */
    public static MemorySegment g_mutex_new$address() {
        return g_mutex_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMutex *g_mutex_new()
     * }
     */
    public static MemorySegment g_mutex_new() {
        var mh$ = g_mutex_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mutex_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mutex_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mutex_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mutex_free(GMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_mutex_free$descriptor() {
        return g_mutex_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mutex_free(GMutex *mutex)
     * }
     */
    public static MethodHandle g_mutex_free$handle() {
        return g_mutex_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mutex_free(GMutex *mutex)
     * }
     */
    public static MemorySegment g_mutex_free$address() {
        return g_mutex_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mutex_free(GMutex *mutex)
     * }
     */
    public static void g_mutex_free(MemorySegment mutex) {
        var mh$ = g_mutex_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mutex_free", mutex);
            }
            mh$.invokeExact(mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GCond *g_cond_new()
     * }
     */
    public static FunctionDescriptor g_cond_new$descriptor() {
        return g_cond_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GCond *g_cond_new()
     * }
     */
    public static MethodHandle g_cond_new$handle() {
        return g_cond_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GCond *g_cond_new()
     * }
     */
    public static MemorySegment g_cond_new$address() {
        return g_cond_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GCond *g_cond_new()
     * }
     */
    public static MemorySegment g_cond_new() {
        var mh$ = g_cond_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cond_free(GCond *cond)
     * }
     */
    public static FunctionDescriptor g_cond_free$descriptor() {
        return g_cond_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cond_free(GCond *cond)
     * }
     */
    public static MethodHandle g_cond_free$handle() {
        return g_cond_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cond_free(GCond *cond)
     * }
     */
    public static MemorySegment g_cond_free$address() {
        return g_cond_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cond_free(GCond *cond)
     * }
     */
    public static void g_cond_free(MemorySegment cond) {
        var mh$ = g_cond_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_free", cond);
            }
            mh$.invokeExact(cond);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cond_timed_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cond_timed_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_cond_timed_wait(GCond *cond, GMutex *mutex, GTimeVal *abs_time)
     * }
     */
    public static FunctionDescriptor g_cond_timed_wait$descriptor() {
        return g_cond_timed_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_cond_timed_wait(GCond *cond, GMutex *mutex, GTimeVal *abs_time)
     * }
     */
    public static MethodHandle g_cond_timed_wait$handle() {
        return g_cond_timed_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_cond_timed_wait(GCond *cond, GMutex *mutex, GTimeVal *abs_time)
     * }
     */
    public static MemorySegment g_cond_timed_wait$address() {
        return g_cond_timed_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_cond_timed_wait(GCond *cond, GMutex *mutex, GTimeVal *abs_time)
     * }
     */
    public static int g_cond_timed_wait(MemorySegment cond, MemorySegment mutex, MemorySegment abs_time) {
        var mh$ = g_cond_timed_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cond_timed_wait", cond, mutex, abs_time);
            }
            return (int)mh$.invokeExact(cond, mutex, abs_time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef GAsyncQueue *GAsyncQueue_autoptr
     * }
     */
    public static final AddressLayout GAsyncQueue_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GAsyncQueue_listautoptr
     * }
     */
    public static final AddressLayout GAsyncQueue_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GAsyncQueue_slistautoptr
     * }
     */
    public static final AddressLayout GAsyncQueue_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GAsyncQueue_queueautoptr
     * }
     */
    public static final AddressLayout GAsyncQueue_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GBookmarkFile *GBookmarkFile_autoptr
     * }
     */
    public static final AddressLayout GBookmarkFile_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GBookmarkFile_listautoptr
     * }
     */
    public static final AddressLayout GBookmarkFile_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GBookmarkFile_slistautoptr
     * }
     */
    public static final AddressLayout GBookmarkFile_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GBookmarkFile_queueautoptr
     * }
     */
    public static final AddressLayout GBookmarkFile_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GBytes *GBytes_autoptr
     * }
     */
    public static final AddressLayout GBytes_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GBytes_listautoptr
     * }
     */
    public static final AddressLayout GBytes_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GBytes_slistautoptr
     * }
     */
    public static final AddressLayout GBytes_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GBytes_queueautoptr
     * }
     */
    public static final AddressLayout GBytes_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GChecksum *GChecksum_autoptr
     * }
     */
    public static final AddressLayout GChecksum_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GChecksum_listautoptr
     * }
     */
    public static final AddressLayout GChecksum_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GChecksum_slistautoptr
     * }
     */
    public static final AddressLayout GChecksum_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GChecksum_queueautoptr
     * }
     */
    public static final AddressLayout GChecksum_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GDateTime *GDateTime_autoptr
     * }
     */
    public static final AddressLayout GDateTime_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GDateTime_listautoptr
     * }
     */
    public static final AddressLayout GDateTime_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GDateTime_slistautoptr
     * }
     */
    public static final AddressLayout GDateTime_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GDateTime_queueautoptr
     * }
     */
    public static final AddressLayout GDateTime_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GDate *GDate_autoptr
     * }
     */
    public static final AddressLayout GDate_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GDate_listautoptr
     * }
     */
    public static final AddressLayout GDate_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GDate_slistautoptr
     * }
     */
    public static final AddressLayout GDate_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GDate_queueautoptr
     * }
     */
    public static final AddressLayout GDate_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GDir *GDir_autoptr
     * }
     */
    public static final AddressLayout GDir_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GDir_listautoptr
     * }
     */
    public static final AddressLayout GDir_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GDir_slistautoptr
     * }
     */
    public static final AddressLayout GDir_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GDir_queueautoptr
     * }
     */
    public static final AddressLayout GDir_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GError *GError_autoptr
     * }
     */
    public static final AddressLayout GError_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GError_listautoptr
     * }
     */
    public static final AddressLayout GError_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GError_slistautoptr
     * }
     */
    public static final AddressLayout GError_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GError_queueautoptr
     * }
     */
    public static final AddressLayout GError_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GHashTable *GHashTable_autoptr
     * }
     */
    public static final AddressLayout GHashTable_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GHashTable_listautoptr
     * }
     */
    public static final AddressLayout GHashTable_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GHashTable_slistautoptr
     * }
     */
    public static final AddressLayout GHashTable_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GHashTable_queueautoptr
     * }
     */
    public static final AddressLayout GHashTable_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GHmac *GHmac_autoptr
     * }
     */
    public static final AddressLayout GHmac_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GHmac_listautoptr
     * }
     */
    public static final AddressLayout GHmac_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GHmac_slistautoptr
     * }
     */
    public static final AddressLayout GHmac_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GHmac_queueautoptr
     * }
     */
    public static final AddressLayout GHmac_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GIOChannel *GIOChannel_autoptr
     * }
     */
    public static final AddressLayout GIOChannel_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GIOChannel_listautoptr
     * }
     */
    public static final AddressLayout GIOChannel_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GIOChannel_slistautoptr
     * }
     */
    public static final AddressLayout GIOChannel_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GIOChannel_queueautoptr
     * }
     */
    public static final AddressLayout GIOChannel_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GKeyFile *GKeyFile_autoptr
     * }
     */
    public static final AddressLayout GKeyFile_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GKeyFile_listautoptr
     * }
     */
    public static final AddressLayout GKeyFile_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GKeyFile_slistautoptr
     * }
     */
    public static final AddressLayout GKeyFile_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GKeyFile_queueautoptr
     * }
     */
    public static final AddressLayout GKeyFile_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GList_autoptr
     * }
     */
    public static final AddressLayout GList_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GList_listautoptr
     * }
     */
    public static final AddressLayout GList_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GList_slistautoptr
     * }
     */
    public static final AddressLayout GList_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GList_queueautoptr
     * }
     */
    public static final AddressLayout GList_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GArray *GArray_autoptr
     * }
     */
    public static final AddressLayout GArray_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GArray_listautoptr
     * }
     */
    public static final AddressLayout GArray_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GArray_slistautoptr
     * }
     */
    public static final AddressLayout GArray_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GArray_queueautoptr
     * }
     */
    public static final AddressLayout GArray_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GPtrArray *GPtrArray_autoptr
     * }
     */
    public static final AddressLayout GPtrArray_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GPtrArray_listautoptr
     * }
     */
    public static final AddressLayout GPtrArray_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GPtrArray_slistautoptr
     * }
     */
    public static final AddressLayout GPtrArray_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GPtrArray_queueautoptr
     * }
     */
    public static final AddressLayout GPtrArray_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GByteArray *GByteArray_autoptr
     * }
     */
    public static final AddressLayout GByteArray_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GByteArray_listautoptr
     * }
     */
    public static final AddressLayout GByteArray_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GByteArray_slistautoptr
     * }
     */
    public static final AddressLayout GByteArray_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GByteArray_queueautoptr
     * }
     */
    public static final AddressLayout GByteArray_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GMainContext *GMainContext_autoptr
     * }
     */
    public static final AddressLayout GMainContext_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GMainContext_listautoptr
     * }
     */
    public static final AddressLayout GMainContext_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GMainContext_slistautoptr
     * }
     */
    public static final AddressLayout GMainContext_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GMainContext_queueautoptr
     * }
     */
    public static final AddressLayout GMainContext_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GMainContextPusher *GMainContextPusher_autoptr
     * }
     */
    public static final AddressLayout GMainContextPusher_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GMainContextPusher_listautoptr
     * }
     */
    public static final AddressLayout GMainContextPusher_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GMainContextPusher_slistautoptr
     * }
     */
    public static final AddressLayout GMainContextPusher_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GMainContextPusher_queueautoptr
     * }
     */
    public static final AddressLayout GMainContextPusher_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GMainLoop *GMainLoop_autoptr
     * }
     */
    public static final AddressLayout GMainLoop_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GMainLoop_listautoptr
     * }
     */
    public static final AddressLayout GMainLoop_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GMainLoop_slistautoptr
     * }
     */
    public static final AddressLayout GMainLoop_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GMainLoop_queueautoptr
     * }
     */
    public static final AddressLayout GMainLoop_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSource *GSource_autoptr
     * }
     */
    public static final AddressLayout GSource_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GSource_listautoptr
     * }
     */
    public static final AddressLayout GSource_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GSource_slistautoptr
     * }
     */
    public static final AddressLayout GSource_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GSource_queueautoptr
     * }
     */
    public static final AddressLayout GSource_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GMappedFile *GMappedFile_autoptr
     * }
     */
    public static final AddressLayout GMappedFile_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GMappedFile_listautoptr
     * }
     */
    public static final AddressLayout GMappedFile_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GMappedFile_slistautoptr
     * }
     */
    public static final AddressLayout GMappedFile_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GMappedFile_queueautoptr
     * }
     */
    public static final AddressLayout GMappedFile_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GMarkupParseContext *GMarkupParseContext_autoptr
     * }
     */
    public static final AddressLayout GMarkupParseContext_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GMarkupParseContext_listautoptr
     * }
     */
    public static final AddressLayout GMarkupParseContext_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GMarkupParseContext_slistautoptr
     * }
     */
    public static final AddressLayout GMarkupParseContext_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GMarkupParseContext_queueautoptr
     * }
     */
    public static final AddressLayout GMarkupParseContext_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GNode *GNode_autoptr
     * }
     */
    public static final AddressLayout GNode_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GNode_listautoptr
     * }
     */
    public static final AddressLayout GNode_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GNode_slistautoptr
     * }
     */
    public static final AddressLayout GNode_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GNode_queueautoptr
     * }
     */
    public static final AddressLayout GNode_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GOptionContext *GOptionContext_autoptr
     * }
     */
    public static final AddressLayout GOptionContext_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GOptionContext_listautoptr
     * }
     */
    public static final AddressLayout GOptionContext_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GOptionContext_slistautoptr
     * }
     */
    public static final AddressLayout GOptionContext_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GOptionContext_queueautoptr
     * }
     */
    public static final AddressLayout GOptionContext_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GOptionGroup *GOptionGroup_autoptr
     * }
     */
    public static final AddressLayout GOptionGroup_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GOptionGroup_listautoptr
     * }
     */
    public static final AddressLayout GOptionGroup_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GOptionGroup_slistautoptr
     * }
     */
    public static final AddressLayout GOptionGroup_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GOptionGroup_queueautoptr
     * }
     */
    public static final AddressLayout GOptionGroup_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GPatternSpec *GPatternSpec_autoptr
     * }
     */
    public static final AddressLayout GPatternSpec_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GPatternSpec_listautoptr
     * }
     */
    public static final AddressLayout GPatternSpec_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GPatternSpec_slistautoptr
     * }
     */
    public static final AddressLayout GPatternSpec_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GPatternSpec_queueautoptr
     * }
     */
    public static final AddressLayout GPatternSpec_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GQueue_autoptr
     * }
     */
    public static final AddressLayout GQueue_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GQueue_listautoptr
     * }
     */
    public static final AddressLayout GQueue_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GQueue_slistautoptr
     * }
     */
    public static final AddressLayout GQueue_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GQueue_queueautoptr
     * }
     */
    public static final AddressLayout GQueue_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GRand *GRand_autoptr
     * }
     */
    public static final AddressLayout GRand_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GRand_listautoptr
     * }
     */
    public static final AddressLayout GRand_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GRand_slistautoptr
     * }
     */
    public static final AddressLayout GRand_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GRand_queueautoptr
     * }
     */
    public static final AddressLayout GRand_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GRegex *GRegex_autoptr
     * }
     */
    public static final AddressLayout GRegex_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GRegex_listautoptr
     * }
     */
    public static final AddressLayout GRegex_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GRegex_slistautoptr
     * }
     */
    public static final AddressLayout GRegex_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GRegex_queueautoptr
     * }
     */
    public static final AddressLayout GRegex_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GMatchInfo *GMatchInfo_autoptr
     * }
     */
    public static final AddressLayout GMatchInfo_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GMatchInfo_listautoptr
     * }
     */
    public static final AddressLayout GMatchInfo_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GMatchInfo_slistautoptr
     * }
     */
    public static final AddressLayout GMatchInfo_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GMatchInfo_queueautoptr
     * }
     */
    public static final AddressLayout GMatchInfo_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GScanner *GScanner_autoptr
     * }
     */
    public static final AddressLayout GScanner_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GScanner_listautoptr
     * }
     */
    public static final AddressLayout GScanner_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GScanner_slistautoptr
     * }
     */
    public static final AddressLayout GScanner_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GScanner_queueautoptr
     * }
     */
    public static final AddressLayout GScanner_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSequence *GSequence_autoptr
     * }
     */
    public static final AddressLayout GSequence_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GSequence_listautoptr
     * }
     */
    public static final AddressLayout GSequence_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GSequence_slistautoptr
     * }
     */
    public static final AddressLayout GSequence_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GSequence_queueautoptr
     * }
     */
    public static final AddressLayout GSequence_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GSList_autoptr
     * }
     */
    public static final AddressLayout GSList_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GSList_listautoptr
     * }
     */
    public static final AddressLayout GSList_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GSList_slistautoptr
     * }
     */
    public static final AddressLayout GSList_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GSList_queueautoptr
     * }
     */
    public static final AddressLayout GSList_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GString *GString_autoptr
     * }
     */
    public static final AddressLayout GString_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GString_listautoptr
     * }
     */
    public static final AddressLayout GString_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GString_slistautoptr
     * }
     */
    public static final AddressLayout GString_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GString_queueautoptr
     * }
     */
    public static final AddressLayout GString_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GStringChunk *GStringChunk_autoptr
     * }
     */
    public static final AddressLayout GStringChunk_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GStringChunk_listautoptr
     * }
     */
    public static final AddressLayout GStringChunk_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GStringChunk_slistautoptr
     * }
     */
    public static final AddressLayout GStringChunk_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GStringChunk_queueautoptr
     * }
     */
    public static final AddressLayout GStringChunk_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GStrvBuilder *GStrvBuilder_autoptr
     * }
     */
    public static final AddressLayout GStrvBuilder_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GStrvBuilder_listautoptr
     * }
     */
    public static final AddressLayout GStrvBuilder_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GStrvBuilder_slistautoptr
     * }
     */
    public static final AddressLayout GStrvBuilder_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GStrvBuilder_queueautoptr
     * }
     */
    public static final AddressLayout GStrvBuilder_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GThread *GThread_autoptr
     * }
     */
    public static final AddressLayout GThread_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GThread_listautoptr
     * }
     */
    public static final AddressLayout GThread_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GThread_slistautoptr
     * }
     */
    public static final AddressLayout GThread_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GThread_queueautoptr
     * }
     */
    public static final AddressLayout GThread_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GMutexLocker *GMutexLocker_autoptr
     * }
     */
    public static final AddressLayout GMutexLocker_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GMutexLocker_listautoptr
     * }
     */
    public static final AddressLayout GMutexLocker_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GMutexLocker_slistautoptr
     * }
     */
    public static final AddressLayout GMutexLocker_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GMutexLocker_queueautoptr
     * }
     */
    public static final AddressLayout GMutexLocker_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GRecMutexLocker *GRecMutexLocker_autoptr
     * }
     */
    public static final AddressLayout GRecMutexLocker_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GRecMutexLocker_listautoptr
     * }
     */
    public static final AddressLayout GRecMutexLocker_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GRecMutexLocker_slistautoptr
     * }
     */
    public static final AddressLayout GRecMutexLocker_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GRecMutexLocker_queueautoptr
     * }
     */
    public static final AddressLayout GRecMutexLocker_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GRWLockWriterLocker *GRWLockWriterLocker_autoptr
     * }
     */
    public static final AddressLayout GRWLockWriterLocker_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GRWLockWriterLocker_listautoptr
     * }
     */
    public static final AddressLayout GRWLockWriterLocker_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GRWLockWriterLocker_slistautoptr
     * }
     */
    public static final AddressLayout GRWLockWriterLocker_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GRWLockWriterLocker_queueautoptr
     * }
     */
    public static final AddressLayout GRWLockWriterLocker_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GRWLockReaderLocker *GRWLockReaderLocker_autoptr
     * }
     */
    public static final AddressLayout GRWLockReaderLocker_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GRWLockReaderLocker_listautoptr
     * }
     */
    public static final AddressLayout GRWLockReaderLocker_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GRWLockReaderLocker_slistautoptr
     * }
     */
    public static final AddressLayout GRWLockReaderLocker_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GRWLockReaderLocker_queueautoptr
     * }
     */
    public static final AddressLayout GRWLockReaderLocker_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GTimer *GTimer_autoptr
     * }
     */
    public static final AddressLayout GTimer_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GTimer_listautoptr
     * }
     */
    public static final AddressLayout GTimer_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GTimer_slistautoptr
     * }
     */
    public static final AddressLayout GTimer_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GTimer_queueautoptr
     * }
     */
    public static final AddressLayout GTimer_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GTimeZone *GTimeZone_autoptr
     * }
     */
    public static final AddressLayout GTimeZone_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GTimeZone_listautoptr
     * }
     */
    public static final AddressLayout GTimeZone_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GTimeZone_slistautoptr
     * }
     */
    public static final AddressLayout GTimeZone_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GTimeZone_queueautoptr
     * }
     */
    public static final AddressLayout GTimeZone_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GTree *GTree_autoptr
     * }
     */
    public static final AddressLayout GTree_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GTree_listautoptr
     * }
     */
    public static final AddressLayout GTree_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GTree_slistautoptr
     * }
     */
    public static final AddressLayout GTree_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GTree_queueautoptr
     * }
     */
    public static final AddressLayout GTree_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GVariant *GVariant_autoptr
     * }
     */
    public static final AddressLayout GVariant_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GVariant_listautoptr
     * }
     */
    public static final AddressLayout GVariant_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GVariant_slistautoptr
     * }
     */
    public static final AddressLayout GVariant_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GVariant_queueautoptr
     * }
     */
    public static final AddressLayout GVariant_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GVariantBuilder *GVariantBuilder_autoptr
     * }
     */
    public static final AddressLayout GVariantBuilder_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GVariantBuilder_listautoptr
     * }
     */
    public static final AddressLayout GVariantBuilder_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GVariantBuilder_slistautoptr
     * }
     */
    public static final AddressLayout GVariantBuilder_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GVariantBuilder_queueautoptr
     * }
     */
    public static final AddressLayout GVariantBuilder_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GVariantIter *GVariantIter_autoptr
     * }
     */
    public static final AddressLayout GVariantIter_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GVariantIter_listautoptr
     * }
     */
    public static final AddressLayout GVariantIter_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GVariantIter_slistautoptr
     * }
     */
    public static final AddressLayout GVariantIter_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GVariantIter_queueautoptr
     * }
     */
    public static final AddressLayout GVariantIter_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GVariantDict *GVariantDict_autoptr
     * }
     */
    public static final AddressLayout GVariantDict_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GVariantDict_listautoptr
     * }
     */
    public static final AddressLayout GVariantDict_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GVariantDict_slistautoptr
     * }
     */
    public static final AddressLayout GVariantDict_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GVariantDict_queueautoptr
     * }
     */
    public static final AddressLayout GVariantDict_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GVariantType *GVariantType_autoptr
     * }
     */
    public static final AddressLayout GVariantType_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GVariantType_listautoptr
     * }
     */
    public static final AddressLayout GVariantType_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GVariantType_slistautoptr
     * }
     */
    public static final AddressLayout GVariantType_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GVariantType_queueautoptr
     * }
     */
    public static final AddressLayout GVariantType_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GRefString *GRefString_autoptr
     * }
     */
    public static final AddressLayout GRefString_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GRefString_listautoptr
     * }
     */
    public static final AddressLayout GRefString_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GRefString_slistautoptr
     * }
     */
    public static final AddressLayout GRefString_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GRefString_queueautoptr
     * }
     */
    public static final AddressLayout GRefString_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GUri *GUri_autoptr
     * }
     */
    public static final AddressLayout GUri_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GUri_listautoptr
     * }
     */
    public static final AddressLayout GUri_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GUri_slistautoptr
     * }
     */
    public static final AddressLayout GUri_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GUri_queueautoptr
     * }
     */
    public static final AddressLayout GUri_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GPathBuf *GPathBuf_autoptr
     * }
     */
    public static final AddressLayout GPathBuf_autoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GList *GPathBuf_listautoptr
     * }
     */
    public static final AddressLayout GPathBuf_listautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GSList *GPathBuf_slistautoptr
     * }
     */
    public static final AddressLayout GPathBuf_slistautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GQueue *GPathBuf_queueautoptr
     * }
     */
    public static final AddressLayout GPathBuf_queueautoptr = gst_min_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef gsize GType
     * }
     */
    public static final OfLong GType = gst_min_h.C_LONG_LONG;
    private static final int G_TYPE_DEBUG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_DEBUG_NONE = 0
     * }
     */
    public static int G_TYPE_DEBUG_NONE() {
        return G_TYPE_DEBUG_NONE;
    }
    private static final int G_TYPE_DEBUG_OBJECTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_DEBUG_OBJECTS = 1
     * }
     */
    public static int G_TYPE_DEBUG_OBJECTS() {
        return G_TYPE_DEBUG_OBJECTS;
    }
    private static final int G_TYPE_DEBUG_SIGNALS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_DEBUG_SIGNALS = 2
     * }
     */
    public static int G_TYPE_DEBUG_SIGNALS() {
        return G_TYPE_DEBUG_SIGNALS;
    }
    private static final int G_TYPE_DEBUG_INSTANCE_COUNT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_DEBUG_INSTANCE_COUNT = 4
     * }
     */
    public static int G_TYPE_DEBUG_INSTANCE_COUNT() {
        return G_TYPE_DEBUG_INSTANCE_COUNT;
    }
    private static final int G_TYPE_DEBUG_MASK = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_DEBUG_MASK = 7
     * }
     */
    public static int G_TYPE_DEBUG_MASK() {
        return G_TYPE_DEBUG_MASK;
    }

    private static class g_type_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_init()
     * }
     */
    public static FunctionDescriptor g_type_init$descriptor() {
        return g_type_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_init()
     * }
     */
    public static MethodHandle g_type_init$handle() {
        return g_type_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_init()
     * }
     */
    public static MemorySegment g_type_init$address() {
        return g_type_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_init()
     * }
     */
    public static void g_type_init() {
        var mh$ = g_type_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_init");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_init_with_debug_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_init_with_debug_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_init_with_debug_flags(GTypeDebugFlags debug_flags)
     * }
     */
    public static FunctionDescriptor g_type_init_with_debug_flags$descriptor() {
        return g_type_init_with_debug_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_init_with_debug_flags(GTypeDebugFlags debug_flags)
     * }
     */
    public static MethodHandle g_type_init_with_debug_flags$handle() {
        return g_type_init_with_debug_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_init_with_debug_flags(GTypeDebugFlags debug_flags)
     * }
     */
    public static MemorySegment g_type_init_with_debug_flags$address() {
        return g_type_init_with_debug_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_init_with_debug_flags(GTypeDebugFlags debug_flags)
     * }
     */
    public static void g_type_init_with_debug_flags(int debug_flags) {
        var mh$ = g_type_init_with_debug_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_init_with_debug_flags", debug_flags);
            }
            mh$.invokeExact(debug_flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name(GType type)
     * }
     */
    public static FunctionDescriptor g_type_name$descriptor() {
        return g_type_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name(GType type)
     * }
     */
    public static MethodHandle g_type_name$handle() {
        return g_type_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name(GType type)
     * }
     */
    public static MemorySegment g_type_name$address() {
        return g_type_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_type_name(GType type)
     * }
     */
    public static MemorySegment g_type_name(long type) {
        var mh$ = g_type_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_qname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_qname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_type_qname(GType type)
     * }
     */
    public static FunctionDescriptor g_type_qname$descriptor() {
        return g_type_qname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_type_qname(GType type)
     * }
     */
    public static MethodHandle g_type_qname$handle() {
        return g_type_qname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_type_qname(GType type)
     * }
     */
    public static MemorySegment g_type_qname$address() {
        return g_type_qname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_type_qname(GType type)
     * }
     */
    public static int g_type_qname(long type) {
        var mh$ = g_type_qname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_qname", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_from_name(const gchar *name)
     * }
     */
    public static FunctionDescriptor g_type_from_name$descriptor() {
        return g_type_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_from_name(const gchar *name)
     * }
     */
    public static MethodHandle g_type_from_name$handle() {
        return g_type_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_from_name(const gchar *name)
     * }
     */
    public static MemorySegment g_type_from_name$address() {
        return g_type_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_from_name(const gchar *name)
     * }
     */
    public static long g_type_from_name(MemorySegment name) {
        var mh$ = g_type_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_from_name", name);
            }
            return (long)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_parent(GType type)
     * }
     */
    public static FunctionDescriptor g_type_parent$descriptor() {
        return g_type_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_parent(GType type)
     * }
     */
    public static MethodHandle g_type_parent$handle() {
        return g_type_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_parent(GType type)
     * }
     */
    public static MemorySegment g_type_parent$address() {
        return g_type_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_parent(GType type)
     * }
     */
    public static long g_type_parent(long type) {
        var mh$ = g_type_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_parent", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_type_depth(GType type)
     * }
     */
    public static FunctionDescriptor g_type_depth$descriptor() {
        return g_type_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_type_depth(GType type)
     * }
     */
    public static MethodHandle g_type_depth$handle() {
        return g_type_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_type_depth(GType type)
     * }
     */
    public static MemorySegment g_type_depth$address() {
        return g_type_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_type_depth(GType type)
     * }
     */
    public static int g_type_depth(long type) {
        var mh$ = g_type_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_depth", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_next_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_next_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_next_base(GType leaf_type, GType root_type)
     * }
     */
    public static FunctionDescriptor g_type_next_base$descriptor() {
        return g_type_next_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_next_base(GType leaf_type, GType root_type)
     * }
     */
    public static MethodHandle g_type_next_base$handle() {
        return g_type_next_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_next_base(GType leaf_type, GType root_type)
     * }
     */
    public static MemorySegment g_type_next_base$address() {
        return g_type_next_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_next_base(GType leaf_type, GType root_type)
     * }
     */
    public static long g_type_next_base(long leaf_type, long root_type) {
        var mh$ = g_type_next_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_next_base", leaf_type, root_type);
            }
            return (long)mh$.invokeExact(leaf_type, root_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_is_a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_is_a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_is_a(GType type, GType is_a_type)
     * }
     */
    public static FunctionDescriptor g_type_is_a$descriptor() {
        return g_type_is_a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_is_a(GType type, GType is_a_type)
     * }
     */
    public static MethodHandle g_type_is_a$handle() {
        return g_type_is_a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_is_a(GType type, GType is_a_type)
     * }
     */
    public static MemorySegment g_type_is_a$address() {
        return g_type_is_a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_is_a(GType type, GType is_a_type)
     * }
     */
    public static int g_type_is_a(long type, long is_a_type) {
        var mh$ = g_type_is_a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_is_a", type, is_a_type);
            }
            return (int)mh$.invokeExact(type, is_a_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_ref(GType type)
     * }
     */
    public static FunctionDescriptor g_type_class_ref$descriptor() {
        return g_type_class_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_ref(GType type)
     * }
     */
    public static MethodHandle g_type_class_ref$handle() {
        return g_type_class_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_ref(GType type)
     * }
     */
    public static MemorySegment g_type_class_ref$address() {
        return g_type_class_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_class_ref(GType type)
     * }
     */
    public static MemorySegment g_type_class_ref(long type) {
        var mh$ = g_type_class_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_ref", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_peek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_peek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek(GType type)
     * }
     */
    public static FunctionDescriptor g_type_class_peek$descriptor() {
        return g_type_class_peek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek(GType type)
     * }
     */
    public static MethodHandle g_type_class_peek$handle() {
        return g_type_class_peek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek(GType type)
     * }
     */
    public static MemorySegment g_type_class_peek$address() {
        return g_type_class_peek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek(GType type)
     * }
     */
    public static MemorySegment g_type_class_peek(long type) {
        var mh$ = g_type_class_peek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_peek", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_peek_static {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_peek_static");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek_static(GType type)
     * }
     */
    public static FunctionDescriptor g_type_class_peek_static$descriptor() {
        return g_type_class_peek_static.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek_static(GType type)
     * }
     */
    public static MethodHandle g_type_class_peek_static$handle() {
        return g_type_class_peek_static.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek_static(GType type)
     * }
     */
    public static MemorySegment g_type_class_peek_static$address() {
        return g_type_class_peek_static.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek_static(GType type)
     * }
     */
    public static MemorySegment g_type_class_peek_static(long type) {
        var mh$ = g_type_class_peek_static.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_peek_static", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_class_unref(gpointer g_class)
     * }
     */
    public static FunctionDescriptor g_type_class_unref$descriptor() {
        return g_type_class_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_class_unref(gpointer g_class)
     * }
     */
    public static MethodHandle g_type_class_unref$handle() {
        return g_type_class_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_class_unref(gpointer g_class)
     * }
     */
    public static MemorySegment g_type_class_unref$address() {
        return g_type_class_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_class_unref(gpointer g_class)
     * }
     */
    public static void g_type_class_unref(MemorySegment g_class) {
        var mh$ = g_type_class_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_unref", g_class);
            }
            mh$.invokeExact(g_class);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_peek_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_peek_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek_parent(gpointer g_class)
     * }
     */
    public static FunctionDescriptor g_type_class_peek_parent$descriptor() {
        return g_type_class_peek_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek_parent(gpointer g_class)
     * }
     */
    public static MethodHandle g_type_class_peek_parent$handle() {
        return g_type_class_peek_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek_parent(gpointer g_class)
     * }
     */
    public static MemorySegment g_type_class_peek_parent$address() {
        return g_type_class_peek_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_class_peek_parent(gpointer g_class)
     * }
     */
    public static MemorySegment g_type_class_peek_parent(MemorySegment g_class) {
        var mh$ = g_type_class_peek_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_peek_parent", g_class);
            }
            return (MemorySegment)mh$.invokeExact(g_class);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_interface_peek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_interface_peek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_interface_peek(gpointer instance_class, GType iface_type)
     * }
     */
    public static FunctionDescriptor g_type_interface_peek$descriptor() {
        return g_type_interface_peek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_interface_peek(gpointer instance_class, GType iface_type)
     * }
     */
    public static MethodHandle g_type_interface_peek$handle() {
        return g_type_interface_peek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_interface_peek(gpointer instance_class, GType iface_type)
     * }
     */
    public static MemorySegment g_type_interface_peek$address() {
        return g_type_interface_peek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_interface_peek(gpointer instance_class, GType iface_type)
     * }
     */
    public static MemorySegment g_type_interface_peek(MemorySegment instance_class, long iface_type) {
        var mh$ = g_type_interface_peek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_interface_peek", instance_class, iface_type);
            }
            return (MemorySegment)mh$.invokeExact(instance_class, iface_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_interface_peek_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_interface_peek_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_interface_peek_parent(gpointer g_iface)
     * }
     */
    public static FunctionDescriptor g_type_interface_peek_parent$descriptor() {
        return g_type_interface_peek_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_interface_peek_parent(gpointer g_iface)
     * }
     */
    public static MethodHandle g_type_interface_peek_parent$handle() {
        return g_type_interface_peek_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_interface_peek_parent(gpointer g_iface)
     * }
     */
    public static MemorySegment g_type_interface_peek_parent$address() {
        return g_type_interface_peek_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_interface_peek_parent(gpointer g_iface)
     * }
     */
    public static MemorySegment g_type_interface_peek_parent(MemorySegment g_iface) {
        var mh$ = g_type_interface_peek_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_interface_peek_parent", g_iface);
            }
            return (MemorySegment)mh$.invokeExact(g_iface);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_default_interface_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_default_interface_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_default_interface_ref(GType g_type)
     * }
     */
    public static FunctionDescriptor g_type_default_interface_ref$descriptor() {
        return g_type_default_interface_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_default_interface_ref(GType g_type)
     * }
     */
    public static MethodHandle g_type_default_interface_ref$handle() {
        return g_type_default_interface_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_default_interface_ref(GType g_type)
     * }
     */
    public static MemorySegment g_type_default_interface_ref$address() {
        return g_type_default_interface_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_default_interface_ref(GType g_type)
     * }
     */
    public static MemorySegment g_type_default_interface_ref(long g_type) {
        var mh$ = g_type_default_interface_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_default_interface_ref", g_type);
            }
            return (MemorySegment)mh$.invokeExact(g_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_default_interface_peek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_default_interface_peek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_default_interface_peek(GType g_type)
     * }
     */
    public static FunctionDescriptor g_type_default_interface_peek$descriptor() {
        return g_type_default_interface_peek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_default_interface_peek(GType g_type)
     * }
     */
    public static MethodHandle g_type_default_interface_peek$handle() {
        return g_type_default_interface_peek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_default_interface_peek(GType g_type)
     * }
     */
    public static MemorySegment g_type_default_interface_peek$address() {
        return g_type_default_interface_peek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_default_interface_peek(GType g_type)
     * }
     */
    public static MemorySegment g_type_default_interface_peek(long g_type) {
        var mh$ = g_type_default_interface_peek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_default_interface_peek", g_type);
            }
            return (MemorySegment)mh$.invokeExact(g_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_default_interface_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_default_interface_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_default_interface_unref(gpointer g_iface)
     * }
     */
    public static FunctionDescriptor g_type_default_interface_unref$descriptor() {
        return g_type_default_interface_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_default_interface_unref(gpointer g_iface)
     * }
     */
    public static MethodHandle g_type_default_interface_unref$handle() {
        return g_type_default_interface_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_default_interface_unref(gpointer g_iface)
     * }
     */
    public static MemorySegment g_type_default_interface_unref$address() {
        return g_type_default_interface_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_default_interface_unref(gpointer g_iface)
     * }
     */
    public static void g_type_default_interface_unref(MemorySegment g_iface) {
        var mh$ = g_type_default_interface_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_default_interface_unref", g_iface);
            }
            mh$.invokeExact(g_iface);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_children {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_children");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType *g_type_children(GType type, guint *n_children)
     * }
     */
    public static FunctionDescriptor g_type_children$descriptor() {
        return g_type_children.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType *g_type_children(GType type, guint *n_children)
     * }
     */
    public static MethodHandle g_type_children$handle() {
        return g_type_children.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType *g_type_children(GType type, guint *n_children)
     * }
     */
    public static MemorySegment g_type_children$address() {
        return g_type_children.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType *g_type_children(GType type, guint *n_children)
     * }
     */
    public static MemorySegment g_type_children(long type, MemorySegment n_children) {
        var mh$ = g_type_children.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_children", type, n_children);
            }
            return (MemorySegment)mh$.invokeExact(type, n_children);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_interfaces {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_interfaces");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType *g_type_interfaces(GType type, guint *n_interfaces)
     * }
     */
    public static FunctionDescriptor g_type_interfaces$descriptor() {
        return g_type_interfaces.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType *g_type_interfaces(GType type, guint *n_interfaces)
     * }
     */
    public static MethodHandle g_type_interfaces$handle() {
        return g_type_interfaces.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType *g_type_interfaces(GType type, guint *n_interfaces)
     * }
     */
    public static MemorySegment g_type_interfaces$address() {
        return g_type_interfaces.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType *g_type_interfaces(GType type, guint *n_interfaces)
     * }
     */
    public static MemorySegment g_type_interfaces(long type, MemorySegment n_interfaces) {
        var mh$ = g_type_interfaces.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_interfaces", type, n_interfaces);
            }
            return (MemorySegment)mh$.invokeExact(type, n_interfaces);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_set_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_set_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_set_qdata(GType type, GQuark quark, gpointer data)
     * }
     */
    public static FunctionDescriptor g_type_set_qdata$descriptor() {
        return g_type_set_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_set_qdata(GType type, GQuark quark, gpointer data)
     * }
     */
    public static MethodHandle g_type_set_qdata$handle() {
        return g_type_set_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_set_qdata(GType type, GQuark quark, gpointer data)
     * }
     */
    public static MemorySegment g_type_set_qdata$address() {
        return g_type_set_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_set_qdata(GType type, GQuark quark, gpointer data)
     * }
     */
    public static void g_type_set_qdata(long type, int quark, MemorySegment data) {
        var mh$ = g_type_set_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_set_qdata", type, quark, data);
            }
            mh$.invokeExact(type, quark, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_get_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_get_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_get_qdata(GType type, GQuark quark)
     * }
     */
    public static FunctionDescriptor g_type_get_qdata$descriptor() {
        return g_type_get_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_get_qdata(GType type, GQuark quark)
     * }
     */
    public static MethodHandle g_type_get_qdata$handle() {
        return g_type_get_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_get_qdata(GType type, GQuark quark)
     * }
     */
    public static MemorySegment g_type_get_qdata$address() {
        return g_type_get_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_get_qdata(GType type, GQuark quark)
     * }
     */
    public static MemorySegment g_type_get_qdata(long type, int quark) {
        var mh$ = g_type_get_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_get_qdata", type, quark);
            }
            return (MemorySegment)mh$.invokeExact(type, quark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_query(GType type, GTypeQuery *query)
     * }
     */
    public static FunctionDescriptor g_type_query$descriptor() {
        return g_type_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_query(GType type, GTypeQuery *query)
     * }
     */
    public static MethodHandle g_type_query$handle() {
        return g_type_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_query(GType type, GTypeQuery *query)
     * }
     */
    public static MemorySegment g_type_query$address() {
        return g_type_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_query(GType type, GTypeQuery *query)
     * }
     */
    public static void g_type_query(long type, MemorySegment query) {
        var mh$ = g_type_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_query", type, query);
            }
            mh$.invokeExact(type, query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_get_instance_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_get_instance_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int g_type_get_instance_count(GType type)
     * }
     */
    public static FunctionDescriptor g_type_get_instance_count$descriptor() {
        return g_type_get_instance_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int g_type_get_instance_count(GType type)
     * }
     */
    public static MethodHandle g_type_get_instance_count$handle() {
        return g_type_get_instance_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int g_type_get_instance_count(GType type)
     * }
     */
    public static MemorySegment g_type_get_instance_count$address() {
        return g_type_get_instance_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int g_type_get_instance_count(GType type)
     * }
     */
    public static int g_type_get_instance_count(long type) {
        var mh$ = g_type_get_instance_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_get_instance_count", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_TYPE_FLAG_CLASSED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_CLASSED = 1
     * }
     */
    public static int G_TYPE_FLAG_CLASSED() {
        return G_TYPE_FLAG_CLASSED;
    }
    private static final int G_TYPE_FLAG_INSTANTIATABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_INSTANTIATABLE = 2
     * }
     */
    public static int G_TYPE_FLAG_INSTANTIATABLE() {
        return G_TYPE_FLAG_INSTANTIATABLE;
    }
    private static final int G_TYPE_FLAG_DERIVABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_DERIVABLE = 4
     * }
     */
    public static int G_TYPE_FLAG_DERIVABLE() {
        return G_TYPE_FLAG_DERIVABLE;
    }
    private static final int G_TYPE_FLAG_DEEP_DERIVABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_DEEP_DERIVABLE = 8
     * }
     */
    public static int G_TYPE_FLAG_DEEP_DERIVABLE() {
        return G_TYPE_FLAG_DEEP_DERIVABLE;
    }
    private static final int G_TYPE_FLAG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_NONE = 0
     * }
     */
    public static int G_TYPE_FLAG_NONE() {
        return G_TYPE_FLAG_NONE;
    }
    private static final int G_TYPE_FLAG_ABSTRACT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_ABSTRACT = 16
     * }
     */
    public static int G_TYPE_FLAG_ABSTRACT() {
        return G_TYPE_FLAG_ABSTRACT;
    }
    private static final int G_TYPE_FLAG_VALUE_ABSTRACT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_VALUE_ABSTRACT = 32
     * }
     */
    public static int G_TYPE_FLAG_VALUE_ABSTRACT() {
        return G_TYPE_FLAG_VALUE_ABSTRACT;
    }
    private static final int G_TYPE_FLAG_FINAL = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_FINAL = 64
     * }
     */
    public static int G_TYPE_FLAG_FINAL() {
        return G_TYPE_FLAG_FINAL;
    }
    private static final int G_TYPE_FLAG_DEPRECATED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TYPE_FLAG_DEPRECATED = 128
     * }
     */
    public static int G_TYPE_FLAG_DEPRECATED() {
        return G_TYPE_FLAG_DEPRECATED;
    }

    private static class g_type_register_static {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_register_static");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_register_static(GType parent_type, const gchar *type_name, const GTypeInfo *info, GTypeFlags flags)
     * }
     */
    public static FunctionDescriptor g_type_register_static$descriptor() {
        return g_type_register_static.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_register_static(GType parent_type, const gchar *type_name, const GTypeInfo *info, GTypeFlags flags)
     * }
     */
    public static MethodHandle g_type_register_static$handle() {
        return g_type_register_static.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_register_static(GType parent_type, const gchar *type_name, const GTypeInfo *info, GTypeFlags flags)
     * }
     */
    public static MemorySegment g_type_register_static$address() {
        return g_type_register_static.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_register_static(GType parent_type, const gchar *type_name, const GTypeInfo *info, GTypeFlags flags)
     * }
     */
    public static long g_type_register_static(long parent_type, MemorySegment type_name, MemorySegment info, int flags) {
        var mh$ = g_type_register_static.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_register_static", parent_type, type_name, info, flags);
            }
            return (long)mh$.invokeExact(parent_type, type_name, info, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_register_static_simple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_register_static_simple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_register_static_simple(GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags)
     * }
     */
    public static FunctionDescriptor g_type_register_static_simple$descriptor() {
        return g_type_register_static_simple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_register_static_simple(GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags)
     * }
     */
    public static MethodHandle g_type_register_static_simple$handle() {
        return g_type_register_static_simple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_register_static_simple(GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags)
     * }
     */
    public static MemorySegment g_type_register_static_simple$address() {
        return g_type_register_static_simple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_register_static_simple(GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags)
     * }
     */
    public static long g_type_register_static_simple(long parent_type, MemorySegment type_name, int class_size, MemorySegment class_init, int instance_size, MemorySegment instance_init, int flags) {
        var mh$ = g_type_register_static_simple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_register_static_simple", parent_type, type_name, class_size, class_init, instance_size, instance_init, flags);
            }
            return (long)mh$.invokeExact(parent_type, type_name, class_size, class_init, instance_size, instance_init, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_register_dynamic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_register_dynamic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_register_dynamic(GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags)
     * }
     */
    public static FunctionDescriptor g_type_register_dynamic$descriptor() {
        return g_type_register_dynamic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_register_dynamic(GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags)
     * }
     */
    public static MethodHandle g_type_register_dynamic$handle() {
        return g_type_register_dynamic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_register_dynamic(GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags)
     * }
     */
    public static MemorySegment g_type_register_dynamic$address() {
        return g_type_register_dynamic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_register_dynamic(GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags)
     * }
     */
    public static long g_type_register_dynamic(long parent_type, MemorySegment type_name, MemorySegment plugin, int flags) {
        var mh$ = g_type_register_dynamic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_register_dynamic", parent_type, type_name, plugin, flags);
            }
            return (long)mh$.invokeExact(parent_type, type_name, plugin, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_register_fundamental {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_register_fundamental");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_register_fundamental(GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags)
     * }
     */
    public static FunctionDescriptor g_type_register_fundamental$descriptor() {
        return g_type_register_fundamental.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_register_fundamental(GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags)
     * }
     */
    public static MethodHandle g_type_register_fundamental$handle() {
        return g_type_register_fundamental.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_register_fundamental(GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags)
     * }
     */
    public static MemorySegment g_type_register_fundamental$address() {
        return g_type_register_fundamental.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_register_fundamental(GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags)
     * }
     */
    public static long g_type_register_fundamental(long type_id, MemorySegment type_name, MemorySegment info, MemorySegment finfo, int flags) {
        var mh$ = g_type_register_fundamental.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_register_fundamental", type_id, type_name, info, finfo, flags);
            }
            return (long)mh$.invokeExact(type_id, type_name, info, finfo, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_add_interface_static {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_add_interface_static");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_static(GType instance_type, GType interface_type, const GInterfaceInfo *info)
     * }
     */
    public static FunctionDescriptor g_type_add_interface_static$descriptor() {
        return g_type_add_interface_static.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_static(GType instance_type, GType interface_type, const GInterfaceInfo *info)
     * }
     */
    public static MethodHandle g_type_add_interface_static$handle() {
        return g_type_add_interface_static.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_static(GType instance_type, GType interface_type, const GInterfaceInfo *info)
     * }
     */
    public static MemorySegment g_type_add_interface_static$address() {
        return g_type_add_interface_static.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_add_interface_static(GType instance_type, GType interface_type, const GInterfaceInfo *info)
     * }
     */
    public static void g_type_add_interface_static(long instance_type, long interface_type, MemorySegment info) {
        var mh$ = g_type_add_interface_static.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_add_interface_static", instance_type, interface_type, info);
            }
            mh$.invokeExact(instance_type, interface_type, info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_add_interface_dynamic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_add_interface_dynamic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_dynamic(GType instance_type, GType interface_type, GTypePlugin *plugin)
     * }
     */
    public static FunctionDescriptor g_type_add_interface_dynamic$descriptor() {
        return g_type_add_interface_dynamic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_dynamic(GType instance_type, GType interface_type, GTypePlugin *plugin)
     * }
     */
    public static MethodHandle g_type_add_interface_dynamic$handle() {
        return g_type_add_interface_dynamic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_dynamic(GType instance_type, GType interface_type, GTypePlugin *plugin)
     * }
     */
    public static MemorySegment g_type_add_interface_dynamic$address() {
        return g_type_add_interface_dynamic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_add_interface_dynamic(GType instance_type, GType interface_type, GTypePlugin *plugin)
     * }
     */
    public static void g_type_add_interface_dynamic(long instance_type, long interface_type, MemorySegment plugin) {
        var mh$ = g_type_add_interface_dynamic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_add_interface_dynamic", instance_type, interface_type, plugin);
            }
            mh$.invokeExact(instance_type, interface_type, plugin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_interface_add_prerequisite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_interface_add_prerequisite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_interface_add_prerequisite(GType interface_type, GType prerequisite_type)
     * }
     */
    public static FunctionDescriptor g_type_interface_add_prerequisite$descriptor() {
        return g_type_interface_add_prerequisite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_interface_add_prerequisite(GType interface_type, GType prerequisite_type)
     * }
     */
    public static MethodHandle g_type_interface_add_prerequisite$handle() {
        return g_type_interface_add_prerequisite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_interface_add_prerequisite(GType interface_type, GType prerequisite_type)
     * }
     */
    public static MemorySegment g_type_interface_add_prerequisite$address() {
        return g_type_interface_add_prerequisite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_interface_add_prerequisite(GType interface_type, GType prerequisite_type)
     * }
     */
    public static void g_type_interface_add_prerequisite(long interface_type, long prerequisite_type) {
        var mh$ = g_type_interface_add_prerequisite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_interface_add_prerequisite", interface_type, prerequisite_type);
            }
            mh$.invokeExact(interface_type, prerequisite_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_interface_prerequisites {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_interface_prerequisites");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType *g_type_interface_prerequisites(GType interface_type, guint *n_prerequisites)
     * }
     */
    public static FunctionDescriptor g_type_interface_prerequisites$descriptor() {
        return g_type_interface_prerequisites.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType *g_type_interface_prerequisites(GType interface_type, guint *n_prerequisites)
     * }
     */
    public static MethodHandle g_type_interface_prerequisites$handle() {
        return g_type_interface_prerequisites.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType *g_type_interface_prerequisites(GType interface_type, guint *n_prerequisites)
     * }
     */
    public static MemorySegment g_type_interface_prerequisites$address() {
        return g_type_interface_prerequisites.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType *g_type_interface_prerequisites(GType interface_type, guint *n_prerequisites)
     * }
     */
    public static MemorySegment g_type_interface_prerequisites(long interface_type, MemorySegment n_prerequisites) {
        var mh$ = g_type_interface_prerequisites.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_interface_prerequisites", interface_type, n_prerequisites);
            }
            return (MemorySegment)mh$.invokeExact(interface_type, n_prerequisites);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_interface_instantiatable_prerequisite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_interface_instantiatable_prerequisite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_interface_instantiatable_prerequisite(GType interface_type)
     * }
     */
    public static FunctionDescriptor g_type_interface_instantiatable_prerequisite$descriptor() {
        return g_type_interface_instantiatable_prerequisite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_interface_instantiatable_prerequisite(GType interface_type)
     * }
     */
    public static MethodHandle g_type_interface_instantiatable_prerequisite$handle() {
        return g_type_interface_instantiatable_prerequisite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_interface_instantiatable_prerequisite(GType interface_type)
     * }
     */
    public static MemorySegment g_type_interface_instantiatable_prerequisite$address() {
        return g_type_interface_instantiatable_prerequisite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_interface_instantiatable_prerequisite(GType interface_type)
     * }
     */
    public static long g_type_interface_instantiatable_prerequisite(long interface_type) {
        var mh$ = g_type_interface_instantiatable_prerequisite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_interface_instantiatable_prerequisite", interface_type);
            }
            return (long)mh$.invokeExact(interface_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_add_private {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_add_private");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_class_add_private(gpointer g_class, gsize private_size)
     * }
     */
    public static FunctionDescriptor g_type_class_add_private$descriptor() {
        return g_type_class_add_private.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_class_add_private(gpointer g_class, gsize private_size)
     * }
     */
    public static MethodHandle g_type_class_add_private$handle() {
        return g_type_class_add_private.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_class_add_private(gpointer g_class, gsize private_size)
     * }
     */
    public static MemorySegment g_type_class_add_private$address() {
        return g_type_class_add_private.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_class_add_private(gpointer g_class, gsize private_size)
     * }
     */
    public static void g_type_class_add_private(MemorySegment g_class, long private_size) {
        var mh$ = g_type_class_add_private.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_add_private", g_class, private_size);
            }
            mh$.invokeExact(g_class, private_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_add_instance_private {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_add_instance_private");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_type_add_instance_private(GType class_type, gsize private_size)
     * }
     */
    public static FunctionDescriptor g_type_add_instance_private$descriptor() {
        return g_type_add_instance_private.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_type_add_instance_private(GType class_type, gsize private_size)
     * }
     */
    public static MethodHandle g_type_add_instance_private$handle() {
        return g_type_add_instance_private.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_type_add_instance_private(GType class_type, gsize private_size)
     * }
     */
    public static MemorySegment g_type_add_instance_private$address() {
        return g_type_add_instance_private.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_type_add_instance_private(GType class_type, gsize private_size)
     * }
     */
    public static int g_type_add_instance_private(long class_type, long private_size) {
        var mh$ = g_type_add_instance_private.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_add_instance_private", class_type, private_size);
            }
            return (int)mh$.invokeExact(class_type, private_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_instance_get_private {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_instance_get_private");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_instance_get_private(GTypeInstance *instance, GType private_type)
     * }
     */
    public static FunctionDescriptor g_type_instance_get_private$descriptor() {
        return g_type_instance_get_private.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_instance_get_private(GTypeInstance *instance, GType private_type)
     * }
     */
    public static MethodHandle g_type_instance_get_private$handle() {
        return g_type_instance_get_private.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_instance_get_private(GTypeInstance *instance, GType private_type)
     * }
     */
    public static MemorySegment g_type_instance_get_private$address() {
        return g_type_instance_get_private.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_instance_get_private(GTypeInstance *instance, GType private_type)
     * }
     */
    public static MemorySegment g_type_instance_get_private(MemorySegment instance, long private_type) {
        var mh$ = g_type_instance_get_private.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_instance_get_private", instance, private_type);
            }
            return (MemorySegment)mh$.invokeExact(instance, private_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_adjust_private_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_adjust_private_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_class_adjust_private_offset(gpointer g_class, gint *private_size_or_offset)
     * }
     */
    public static FunctionDescriptor g_type_class_adjust_private_offset$descriptor() {
        return g_type_class_adjust_private_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_class_adjust_private_offset(gpointer g_class, gint *private_size_or_offset)
     * }
     */
    public static MethodHandle g_type_class_adjust_private_offset$handle() {
        return g_type_class_adjust_private_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_class_adjust_private_offset(gpointer g_class, gint *private_size_or_offset)
     * }
     */
    public static MemorySegment g_type_class_adjust_private_offset$address() {
        return g_type_class_adjust_private_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_class_adjust_private_offset(gpointer g_class, gint *private_size_or_offset)
     * }
     */
    public static void g_type_class_adjust_private_offset(MemorySegment g_class, MemorySegment private_size_or_offset) {
        var mh$ = g_type_class_adjust_private_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_adjust_private_offset", g_class, private_size_or_offset);
            }
            mh$.invokeExact(g_class, private_size_or_offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_add_class_private {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_add_class_private");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_add_class_private(GType class_type, gsize private_size)
     * }
     */
    public static FunctionDescriptor g_type_add_class_private$descriptor() {
        return g_type_add_class_private.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_add_class_private(GType class_type, gsize private_size)
     * }
     */
    public static MethodHandle g_type_add_class_private$handle() {
        return g_type_add_class_private.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_add_class_private(GType class_type, gsize private_size)
     * }
     */
    public static MemorySegment g_type_add_class_private$address() {
        return g_type_add_class_private.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_add_class_private(GType class_type, gsize private_size)
     * }
     */
    public static void g_type_add_class_private(long class_type, long private_size) {
        var mh$ = g_type_add_class_private.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_add_class_private", class_type, private_size);
            }
            mh$.invokeExact(class_type, private_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_get_private {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_get_private");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_get_private(GTypeClass *klass, GType private_type)
     * }
     */
    public static FunctionDescriptor g_type_class_get_private$descriptor() {
        return g_type_class_get_private.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_get_private(GTypeClass *klass, GType private_type)
     * }
     */
    public static MethodHandle g_type_class_get_private$handle() {
        return g_type_class_get_private.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_type_class_get_private(GTypeClass *klass, GType private_type)
     * }
     */
    public static MemorySegment g_type_class_get_private$address() {
        return g_type_class_get_private.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_type_class_get_private(GTypeClass *klass, GType private_type)
     * }
     */
    public static MemorySegment g_type_class_get_private(MemorySegment klass, long private_type) {
        var mh$ = g_type_class_get_private.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_get_private", klass, private_type);
            }
            return (MemorySegment)mh$.invokeExact(klass, private_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_get_instance_private_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_get_instance_private_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_type_class_get_instance_private_offset(gpointer g_class)
     * }
     */
    public static FunctionDescriptor g_type_class_get_instance_private_offset$descriptor() {
        return g_type_class_get_instance_private_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_type_class_get_instance_private_offset(gpointer g_class)
     * }
     */
    public static MethodHandle g_type_class_get_instance_private_offset$handle() {
        return g_type_class_get_instance_private_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_type_class_get_instance_private_offset(gpointer g_class)
     * }
     */
    public static MemorySegment g_type_class_get_instance_private_offset$address() {
        return g_type_class_get_instance_private_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_type_class_get_instance_private_offset(gpointer g_class)
     * }
     */
    public static int g_type_class_get_instance_private_offset(MemorySegment g_class) {
        var mh$ = g_type_class_get_instance_private_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_get_instance_private_offset", g_class);
            }
            return (int)mh$.invokeExact(g_class);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_ensure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_ensure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_ensure(GType type)
     * }
     */
    public static FunctionDescriptor g_type_ensure$descriptor() {
        return g_type_ensure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_ensure(GType type)
     * }
     */
    public static MethodHandle g_type_ensure$handle() {
        return g_type_ensure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_ensure(GType type)
     * }
     */
    public static MemorySegment g_type_ensure$address() {
        return g_type_ensure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_ensure(GType type)
     * }
     */
    public static void g_type_ensure(long type) {
        var mh$ = g_type_ensure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_ensure", type);
            }
            mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_get_type_registration_serial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_get_type_registration_serial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_type_get_type_registration_serial()
     * }
     */
    public static FunctionDescriptor g_type_get_type_registration_serial$descriptor() {
        return g_type_get_type_registration_serial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_type_get_type_registration_serial()
     * }
     */
    public static MethodHandle g_type_get_type_registration_serial$handle() {
        return g_type_get_type_registration_serial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_type_get_type_registration_serial()
     * }
     */
    public static MemorySegment g_type_get_type_registration_serial$address() {
        return g_type_get_type_registration_serial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_type_get_type_registration_serial()
     * }
     */
    public static int g_type_get_type_registration_serial() {
        var mh$ = g_type_get_type_registration_serial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_get_type_registration_serial");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_get_plugin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_get_plugin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTypePlugin *g_type_get_plugin(GType type)
     * }
     */
    public static FunctionDescriptor g_type_get_plugin$descriptor() {
        return g_type_get_plugin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTypePlugin *g_type_get_plugin(GType type)
     * }
     */
    public static MethodHandle g_type_get_plugin$handle() {
        return g_type_get_plugin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTypePlugin *g_type_get_plugin(GType type)
     * }
     */
    public static MemorySegment g_type_get_plugin$address() {
        return g_type_get_plugin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTypePlugin *g_type_get_plugin(GType type)
     * }
     */
    public static MemorySegment g_type_get_plugin(long type) {
        var mh$ = g_type_get_plugin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_get_plugin", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_interface_get_plugin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_interface_get_plugin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTypePlugin *g_type_interface_get_plugin(GType instance_type, GType interface_type)
     * }
     */
    public static FunctionDescriptor g_type_interface_get_plugin$descriptor() {
        return g_type_interface_get_plugin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTypePlugin *g_type_interface_get_plugin(GType instance_type, GType interface_type)
     * }
     */
    public static MethodHandle g_type_interface_get_plugin$handle() {
        return g_type_interface_get_plugin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTypePlugin *g_type_interface_get_plugin(GType instance_type, GType interface_type)
     * }
     */
    public static MemorySegment g_type_interface_get_plugin$address() {
        return g_type_interface_get_plugin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTypePlugin *g_type_interface_get_plugin(GType instance_type, GType interface_type)
     * }
     */
    public static MemorySegment g_type_interface_get_plugin(long instance_type, long interface_type) {
        var mh$ = g_type_interface_get_plugin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_interface_get_plugin", instance_type, interface_type);
            }
            return (MemorySegment)mh$.invokeExact(instance_type, interface_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_fundamental_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_fundamental_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_fundamental_next()
     * }
     */
    public static FunctionDescriptor g_type_fundamental_next$descriptor() {
        return g_type_fundamental_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_fundamental_next()
     * }
     */
    public static MethodHandle g_type_fundamental_next$handle() {
        return g_type_fundamental_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_fundamental_next()
     * }
     */
    public static MemorySegment g_type_fundamental_next$address() {
        return g_type_fundamental_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_fundamental_next()
     * }
     */
    public static long g_type_fundamental_next() {
        var mh$ = g_type_fundamental_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_fundamental_next");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_fundamental {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_fundamental");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_type_fundamental(GType type_id)
     * }
     */
    public static FunctionDescriptor g_type_fundamental$descriptor() {
        return g_type_fundamental.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_type_fundamental(GType type_id)
     * }
     */
    public static MethodHandle g_type_fundamental$handle() {
        return g_type_fundamental.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_type_fundamental(GType type_id)
     * }
     */
    public static MemorySegment g_type_fundamental$address() {
        return g_type_fundamental.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_type_fundamental(GType type_id)
     * }
     */
    public static long g_type_fundamental(long type_id) {
        var mh$ = g_type_fundamental.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_fundamental", type_id);
            }
            return (long)mh$.invokeExact(type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_create_instance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_create_instance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTypeInstance *g_type_create_instance(GType type)
     * }
     */
    public static FunctionDescriptor g_type_create_instance$descriptor() {
        return g_type_create_instance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTypeInstance *g_type_create_instance(GType type)
     * }
     */
    public static MethodHandle g_type_create_instance$handle() {
        return g_type_create_instance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTypeInstance *g_type_create_instance(GType type)
     * }
     */
    public static MemorySegment g_type_create_instance$address() {
        return g_type_create_instance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTypeInstance *g_type_create_instance(GType type)
     * }
     */
    public static MemorySegment g_type_create_instance(long type) {
        var mh$ = g_type_create_instance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_create_instance", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_free_instance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_free_instance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_free_instance(GTypeInstance *instance)
     * }
     */
    public static FunctionDescriptor g_type_free_instance$descriptor() {
        return g_type_free_instance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_free_instance(GTypeInstance *instance)
     * }
     */
    public static MethodHandle g_type_free_instance$handle() {
        return g_type_free_instance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_free_instance(GTypeInstance *instance)
     * }
     */
    public static MemorySegment g_type_free_instance$address() {
        return g_type_free_instance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_free_instance(GTypeInstance *instance)
     * }
     */
    public static void g_type_free_instance(MemorySegment instance) {
        var mh$ = g_type_free_instance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_free_instance", instance);
            }
            mh$.invokeExact(instance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_add_class_cache_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_add_class_cache_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_add_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func)
     * }
     */
    public static FunctionDescriptor g_type_add_class_cache_func$descriptor() {
        return g_type_add_class_cache_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_add_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func)
     * }
     */
    public static MethodHandle g_type_add_class_cache_func$handle() {
        return g_type_add_class_cache_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_add_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func)
     * }
     */
    public static MemorySegment g_type_add_class_cache_func$address() {
        return g_type_add_class_cache_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_add_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func)
     * }
     */
    public static void g_type_add_class_cache_func(MemorySegment cache_data, MemorySegment cache_func) {
        var mh$ = g_type_add_class_cache_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_add_class_cache_func", cache_data, cache_func);
            }
            mh$.invokeExact(cache_data, cache_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_remove_class_cache_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_remove_class_cache_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_remove_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func)
     * }
     */
    public static FunctionDescriptor g_type_remove_class_cache_func$descriptor() {
        return g_type_remove_class_cache_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_remove_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func)
     * }
     */
    public static MethodHandle g_type_remove_class_cache_func$handle() {
        return g_type_remove_class_cache_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_remove_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func)
     * }
     */
    public static MemorySegment g_type_remove_class_cache_func$address() {
        return g_type_remove_class_cache_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_remove_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func)
     * }
     */
    public static void g_type_remove_class_cache_func(MemorySegment cache_data, MemorySegment cache_func) {
        var mh$ = g_type_remove_class_cache_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_remove_class_cache_func", cache_data, cache_func);
            }
            mh$.invokeExact(cache_data, cache_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_class_unref_uncached {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_class_unref_uncached");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_class_unref_uncached(gpointer g_class)
     * }
     */
    public static FunctionDescriptor g_type_class_unref_uncached$descriptor() {
        return g_type_class_unref_uncached.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_class_unref_uncached(gpointer g_class)
     * }
     */
    public static MethodHandle g_type_class_unref_uncached$handle() {
        return g_type_class_unref_uncached.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_class_unref_uncached(gpointer g_class)
     * }
     */
    public static MemorySegment g_type_class_unref_uncached$address() {
        return g_type_class_unref_uncached.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_class_unref_uncached(gpointer g_class)
     * }
     */
    public static void g_type_class_unref_uncached(MemorySegment g_class) {
        var mh$ = g_type_class_unref_uncached.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_class_unref_uncached", g_class);
            }
            mh$.invokeExact(g_class);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_add_interface_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_add_interface_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func)
     * }
     */
    public static FunctionDescriptor g_type_add_interface_check$descriptor() {
        return g_type_add_interface_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func)
     * }
     */
    public static MethodHandle g_type_add_interface_check$handle() {
        return g_type_add_interface_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_add_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func)
     * }
     */
    public static MemorySegment g_type_add_interface_check$address() {
        return g_type_add_interface_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_add_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func)
     * }
     */
    public static void g_type_add_interface_check(MemorySegment check_data, MemorySegment check_func) {
        var mh$ = g_type_add_interface_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_add_interface_check", check_data, check_func);
            }
            mh$.invokeExact(check_data, check_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_remove_interface_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_remove_interface_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_type_remove_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func)
     * }
     */
    public static FunctionDescriptor g_type_remove_interface_check$descriptor() {
        return g_type_remove_interface_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_type_remove_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func)
     * }
     */
    public static MethodHandle g_type_remove_interface_check$handle() {
        return g_type_remove_interface_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_type_remove_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func)
     * }
     */
    public static MemorySegment g_type_remove_interface_check$address() {
        return g_type_remove_interface_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_type_remove_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func)
     * }
     */
    public static void g_type_remove_interface_check(MemorySegment check_data, MemorySegment check_func) {
        var mh$ = g_type_remove_interface_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_remove_interface_check", check_data, check_func);
            }
            mh$.invokeExact(check_data, check_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_value_table_peek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_value_table_peek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTypeValueTable *g_type_value_table_peek(GType type)
     * }
     */
    public static FunctionDescriptor g_type_value_table_peek$descriptor() {
        return g_type_value_table_peek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTypeValueTable *g_type_value_table_peek(GType type)
     * }
     */
    public static MethodHandle g_type_value_table_peek$handle() {
        return g_type_value_table_peek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTypeValueTable *g_type_value_table_peek(GType type)
     * }
     */
    public static MemorySegment g_type_value_table_peek$address() {
        return g_type_value_table_peek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTypeValueTable *g_type_value_table_peek(GType type)
     * }
     */
    public static MemorySegment g_type_value_table_peek(long type) {
        var mh$ = g_type_value_table_peek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_value_table_peek", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_instance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_instance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance(GTypeInstance *instance)
     * }
     */
    public static FunctionDescriptor g_type_check_instance$descriptor() {
        return g_type_check_instance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance(GTypeInstance *instance)
     * }
     */
    public static MethodHandle g_type_check_instance$handle() {
        return g_type_check_instance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance(GTypeInstance *instance)
     * }
     */
    public static MemorySegment g_type_check_instance$address() {
        return g_type_check_instance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance(GTypeInstance *instance)
     * }
     */
    public static int g_type_check_instance(MemorySegment instance) {
        var mh$ = g_type_check_instance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_instance", instance);
            }
            return (int)mh$.invokeExact(instance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_instance_cast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_instance_cast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTypeInstance *g_type_check_instance_cast(GTypeInstance *instance, GType iface_type)
     * }
     */
    public static FunctionDescriptor g_type_check_instance_cast$descriptor() {
        return g_type_check_instance_cast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTypeInstance *g_type_check_instance_cast(GTypeInstance *instance, GType iface_type)
     * }
     */
    public static MethodHandle g_type_check_instance_cast$handle() {
        return g_type_check_instance_cast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTypeInstance *g_type_check_instance_cast(GTypeInstance *instance, GType iface_type)
     * }
     */
    public static MemorySegment g_type_check_instance_cast$address() {
        return g_type_check_instance_cast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTypeInstance *g_type_check_instance_cast(GTypeInstance *instance, GType iface_type)
     * }
     */
    public static MemorySegment g_type_check_instance_cast(MemorySegment instance, long iface_type) {
        var mh$ = g_type_check_instance_cast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_instance_cast", instance, iface_type);
            }
            return (MemorySegment)mh$.invokeExact(instance, iface_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_instance_is_a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_instance_is_a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance_is_a(GTypeInstance *instance, GType iface_type)
     * }
     */
    public static FunctionDescriptor g_type_check_instance_is_a$descriptor() {
        return g_type_check_instance_is_a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance_is_a(GTypeInstance *instance, GType iface_type)
     * }
     */
    public static MethodHandle g_type_check_instance_is_a$handle() {
        return g_type_check_instance_is_a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance_is_a(GTypeInstance *instance, GType iface_type)
     * }
     */
    public static MemorySegment g_type_check_instance_is_a$address() {
        return g_type_check_instance_is_a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance_is_a(GTypeInstance *instance, GType iface_type)
     * }
     */
    public static int g_type_check_instance_is_a(MemorySegment instance, long iface_type) {
        var mh$ = g_type_check_instance_is_a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_instance_is_a", instance, iface_type);
            }
            return (int)mh$.invokeExact(instance, iface_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_instance_is_fundamentally_a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_instance_is_fundamentally_a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance_is_fundamentally_a(GTypeInstance *instance, GType fundamental_type)
     * }
     */
    public static FunctionDescriptor g_type_check_instance_is_fundamentally_a$descriptor() {
        return g_type_check_instance_is_fundamentally_a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance_is_fundamentally_a(GTypeInstance *instance, GType fundamental_type)
     * }
     */
    public static MethodHandle g_type_check_instance_is_fundamentally_a$handle() {
        return g_type_check_instance_is_fundamentally_a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance_is_fundamentally_a(GTypeInstance *instance, GType fundamental_type)
     * }
     */
    public static MemorySegment g_type_check_instance_is_fundamentally_a$address() {
        return g_type_check_instance_is_fundamentally_a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_check_instance_is_fundamentally_a(GTypeInstance *instance, GType fundamental_type)
     * }
     */
    public static int g_type_check_instance_is_fundamentally_a(MemorySegment instance, long fundamental_type) {
        var mh$ = g_type_check_instance_is_fundamentally_a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_instance_is_fundamentally_a", instance, fundamental_type);
            }
            return (int)mh$.invokeExact(instance, fundamental_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_class_cast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_class_cast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTypeClass *g_type_check_class_cast(GTypeClass *g_class, GType is_a_type)
     * }
     */
    public static FunctionDescriptor g_type_check_class_cast$descriptor() {
        return g_type_check_class_cast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTypeClass *g_type_check_class_cast(GTypeClass *g_class, GType is_a_type)
     * }
     */
    public static MethodHandle g_type_check_class_cast$handle() {
        return g_type_check_class_cast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTypeClass *g_type_check_class_cast(GTypeClass *g_class, GType is_a_type)
     * }
     */
    public static MemorySegment g_type_check_class_cast$address() {
        return g_type_check_class_cast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTypeClass *g_type_check_class_cast(GTypeClass *g_class, GType is_a_type)
     * }
     */
    public static MemorySegment g_type_check_class_cast(MemorySegment g_class, long is_a_type) {
        var mh$ = g_type_check_class_cast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_class_cast", g_class, is_a_type);
            }
            return (MemorySegment)mh$.invokeExact(g_class, is_a_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_class_is_a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_class_is_a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_class_is_a(GTypeClass *g_class, GType is_a_type)
     * }
     */
    public static FunctionDescriptor g_type_check_class_is_a$descriptor() {
        return g_type_check_class_is_a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_class_is_a(GTypeClass *g_class, GType is_a_type)
     * }
     */
    public static MethodHandle g_type_check_class_is_a$handle() {
        return g_type_check_class_is_a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_class_is_a(GTypeClass *g_class, GType is_a_type)
     * }
     */
    public static MemorySegment g_type_check_class_is_a$address() {
        return g_type_check_class_is_a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_check_class_is_a(GTypeClass *g_class, GType is_a_type)
     * }
     */
    public static int g_type_check_class_is_a(MemorySegment g_class, long is_a_type) {
        var mh$ = g_type_check_class_is_a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_class_is_a", g_class, is_a_type);
            }
            return (int)mh$.invokeExact(g_class, is_a_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_is_value_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_is_value_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_is_value_type(GType type)
     * }
     */
    public static FunctionDescriptor g_type_check_is_value_type$descriptor() {
        return g_type_check_is_value_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_is_value_type(GType type)
     * }
     */
    public static MethodHandle g_type_check_is_value_type$handle() {
        return g_type_check_is_value_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_is_value_type(GType type)
     * }
     */
    public static MemorySegment g_type_check_is_value_type$address() {
        return g_type_check_is_value_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_check_is_value_type(GType type)
     * }
     */
    public static int g_type_check_is_value_type(long type) {
        var mh$ = g_type_check_is_value_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_is_value_type", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_value(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_type_check_value$descriptor() {
        return g_type_check_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_value(const GValue *value)
     * }
     */
    public static MethodHandle g_type_check_value$handle() {
        return g_type_check_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_value(const GValue *value)
     * }
     */
    public static MemorySegment g_type_check_value$address() {
        return g_type_check_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_check_value(const GValue *value)
     * }
     */
    public static int g_type_check_value(MemorySegment value) {
        var mh$ = g_type_check_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_value", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_check_value_holds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_check_value_holds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_value_holds(const GValue *value, GType type)
     * }
     */
    public static FunctionDescriptor g_type_check_value_holds$descriptor() {
        return g_type_check_value_holds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_value_holds(const GValue *value, GType type)
     * }
     */
    public static MethodHandle g_type_check_value_holds$handle() {
        return g_type_check_value_holds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_check_value_holds(const GValue *value, GType type)
     * }
     */
    public static MemorySegment g_type_check_value_holds$address() {
        return g_type_check_value_holds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_check_value_holds(const GValue *value, GType type)
     * }
     */
    public static int g_type_check_value_holds(MemorySegment value, long type) {
        var mh$ = g_type_check_value_holds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_check_value_holds", value, type);
            }
            return (int)mh$.invokeExact(value, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_test_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_test_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_type_test_flags(GType type, guint flags)
     * }
     */
    public static FunctionDescriptor g_type_test_flags$descriptor() {
        return g_type_test_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_type_test_flags(GType type, guint flags)
     * }
     */
    public static MethodHandle g_type_test_flags$handle() {
        return g_type_test_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_type_test_flags(GType type, guint flags)
     * }
     */
    public static MemorySegment g_type_test_flags$address() {
        return g_type_test_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_type_test_flags(GType type, guint flags)
     * }
     */
    public static int g_type_test_flags(long type, int flags) {
        var mh$ = g_type_test_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_test_flags", type, flags);
            }
            return (int)mh$.invokeExact(type, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_name_from_instance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_name_from_instance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name_from_instance(GTypeInstance *instance)
     * }
     */
    public static FunctionDescriptor g_type_name_from_instance$descriptor() {
        return g_type_name_from_instance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name_from_instance(GTypeInstance *instance)
     * }
     */
    public static MethodHandle g_type_name_from_instance$handle() {
        return g_type_name_from_instance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name_from_instance(GTypeInstance *instance)
     * }
     */
    public static MemorySegment g_type_name_from_instance$address() {
        return g_type_name_from_instance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_type_name_from_instance(GTypeInstance *instance)
     * }
     */
    public static MemorySegment g_type_name_from_instance(MemorySegment instance) {
        var mh$ = g_type_name_from_instance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_name_from_instance", instance);
            }
            return (MemorySegment)mh$.invokeExact(instance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_type_name_from_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_type_name_from_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name_from_class(GTypeClass *g_class)
     * }
     */
    public static FunctionDescriptor g_type_name_from_class$descriptor() {
        return g_type_name_from_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name_from_class(GTypeClass *g_class)
     * }
     */
    public static MethodHandle g_type_name_from_class$handle() {
        return g_type_name_from_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_type_name_from_class(GTypeClass *g_class)
     * }
     */
    public static MemorySegment g_type_name_from_class$address() {
        return g_type_name_from_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_type_name_from_class(GTypeClass *g_class)
     * }
     */
    public static MemorySegment g_type_name_from_class(MemorySegment g_class) {
        var mh$ = g_type_name_from_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_type_name_from_class", g_class);
            }
            return (MemorySegment)mh$.invokeExact(g_class);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GValue *g_value_init(GValue *value, GType g_type)
     * }
     */
    public static FunctionDescriptor g_value_init$descriptor() {
        return g_value_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GValue *g_value_init(GValue *value, GType g_type)
     * }
     */
    public static MethodHandle g_value_init$handle() {
        return g_value_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GValue *g_value_init(GValue *value, GType g_type)
     * }
     */
    public static MemorySegment g_value_init$address() {
        return g_value_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GValue *g_value_init(GValue *value, GType g_type)
     * }
     */
    public static MemorySegment g_value_init(MemorySegment value, long g_type) {
        var mh$ = g_value_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_init", value, g_type);
            }
            return (MemorySegment)mh$.invokeExact(value, g_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_copy(const GValue *src_value, GValue *dest_value)
     * }
     */
    public static FunctionDescriptor g_value_copy$descriptor() {
        return g_value_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_copy(const GValue *src_value, GValue *dest_value)
     * }
     */
    public static MethodHandle g_value_copy$handle() {
        return g_value_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_copy(const GValue *src_value, GValue *dest_value)
     * }
     */
    public static MemorySegment g_value_copy$address() {
        return g_value_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_copy(const GValue *src_value, GValue *dest_value)
     * }
     */
    public static void g_value_copy(MemorySegment src_value, MemorySegment dest_value) {
        var mh$ = g_value_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_copy", src_value, dest_value);
            }
            mh$.invokeExact(src_value, dest_value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GValue *g_value_reset(GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_reset$descriptor() {
        return g_value_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GValue *g_value_reset(GValue *value)
     * }
     */
    public static MethodHandle g_value_reset$handle() {
        return g_value_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GValue *g_value_reset(GValue *value)
     * }
     */
    public static MemorySegment g_value_reset$address() {
        return g_value_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GValue *g_value_reset(GValue *value)
     * }
     */
    public static MemorySegment g_value_reset(MemorySegment value) {
        var mh$ = g_value_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_reset", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_unset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_unset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_unset(GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_unset$descriptor() {
        return g_value_unset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_unset(GValue *value)
     * }
     */
    public static MethodHandle g_value_unset$handle() {
        return g_value_unset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_unset(GValue *value)
     * }
     */
    public static MemorySegment g_value_unset$address() {
        return g_value_unset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_unset(GValue *value)
     * }
     */
    public static void g_value_unset(MemorySegment value) {
        var mh$ = g_value_unset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_unset", value);
            }
            mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_set_instance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_set_instance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_set_instance(GValue *value, gpointer instance)
     * }
     */
    public static FunctionDescriptor g_value_set_instance$descriptor() {
        return g_value_set_instance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_set_instance(GValue *value, gpointer instance)
     * }
     */
    public static MethodHandle g_value_set_instance$handle() {
        return g_value_set_instance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_set_instance(GValue *value, gpointer instance)
     * }
     */
    public static MemorySegment g_value_set_instance$address() {
        return g_value_set_instance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_set_instance(GValue *value, gpointer instance)
     * }
     */
    public static void g_value_set_instance(MemorySegment value, MemorySegment instance) {
        var mh$ = g_value_set_instance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_set_instance", value, instance);
            }
            mh$.invokeExact(value, instance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_init_from_instance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_init_from_instance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_init_from_instance(GValue *value, gpointer instance)
     * }
     */
    public static FunctionDescriptor g_value_init_from_instance$descriptor() {
        return g_value_init_from_instance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_init_from_instance(GValue *value, gpointer instance)
     * }
     */
    public static MethodHandle g_value_init_from_instance$handle() {
        return g_value_init_from_instance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_init_from_instance(GValue *value, gpointer instance)
     * }
     */
    public static MemorySegment g_value_init_from_instance$address() {
        return g_value_init_from_instance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_init_from_instance(GValue *value, gpointer instance)
     * }
     */
    public static void g_value_init_from_instance(MemorySegment value, MemorySegment instance) {
        var mh$ = g_value_init_from_instance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_init_from_instance", value, instance);
            }
            mh$.invokeExact(value, instance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_fits_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_fits_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_value_fits_pointer(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_fits_pointer$descriptor() {
        return g_value_fits_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_value_fits_pointer(const GValue *value)
     * }
     */
    public static MethodHandle g_value_fits_pointer$handle() {
        return g_value_fits_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_value_fits_pointer(const GValue *value)
     * }
     */
    public static MemorySegment g_value_fits_pointer$address() {
        return g_value_fits_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_value_fits_pointer(const GValue *value)
     * }
     */
    public static int g_value_fits_pointer(MemorySegment value) {
        var mh$ = g_value_fits_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_fits_pointer", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_peek_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_peek_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_value_peek_pointer(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_peek_pointer$descriptor() {
        return g_value_peek_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_value_peek_pointer(const GValue *value)
     * }
     */
    public static MethodHandle g_value_peek_pointer$handle() {
        return g_value_peek_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_value_peek_pointer(const GValue *value)
     * }
     */
    public static MemorySegment g_value_peek_pointer$address() {
        return g_value_peek_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_value_peek_pointer(const GValue *value)
     * }
     */
    public static MemorySegment g_value_peek_pointer(MemorySegment value) {
        var mh$ = g_value_peek_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_peek_pointer", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_type_compatible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_type_compatible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_value_type_compatible(GType src_type, GType dest_type)
     * }
     */
    public static FunctionDescriptor g_value_type_compatible$descriptor() {
        return g_value_type_compatible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_value_type_compatible(GType src_type, GType dest_type)
     * }
     */
    public static MethodHandle g_value_type_compatible$handle() {
        return g_value_type_compatible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_value_type_compatible(GType src_type, GType dest_type)
     * }
     */
    public static MemorySegment g_value_type_compatible$address() {
        return g_value_type_compatible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_value_type_compatible(GType src_type, GType dest_type)
     * }
     */
    public static int g_value_type_compatible(long src_type, long dest_type) {
        var mh$ = g_value_type_compatible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_type_compatible", src_type, dest_type);
            }
            return (int)mh$.invokeExact(src_type, dest_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_type_transformable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_type_transformable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_value_type_transformable(GType src_type, GType dest_type)
     * }
     */
    public static FunctionDescriptor g_value_type_transformable$descriptor() {
        return g_value_type_transformable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_value_type_transformable(GType src_type, GType dest_type)
     * }
     */
    public static MethodHandle g_value_type_transformable$handle() {
        return g_value_type_transformable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_value_type_transformable(GType src_type, GType dest_type)
     * }
     */
    public static MemorySegment g_value_type_transformable$address() {
        return g_value_type_transformable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_value_type_transformable(GType src_type, GType dest_type)
     * }
     */
    public static int g_value_type_transformable(long src_type, long dest_type) {
        var mh$ = g_value_type_transformable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_type_transformable", src_type, dest_type);
            }
            return (int)mh$.invokeExact(src_type, dest_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_value_transform(const GValue *src_value, GValue *dest_value)
     * }
     */
    public static FunctionDescriptor g_value_transform$descriptor() {
        return g_value_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_value_transform(const GValue *src_value, GValue *dest_value)
     * }
     */
    public static MethodHandle g_value_transform$handle() {
        return g_value_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_value_transform(const GValue *src_value, GValue *dest_value)
     * }
     */
    public static MemorySegment g_value_transform$address() {
        return g_value_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_value_transform(const GValue *src_value, GValue *dest_value)
     * }
     */
    public static int g_value_transform(MemorySegment src_value, MemorySegment dest_value) {
        var mh$ = g_value_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_transform", src_value, dest_value);
            }
            return (int)mh$.invokeExact(src_value, dest_value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_register_transform_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_register_transform_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_register_transform_func(GType src_type, GType dest_type, GValueTransform transform_func)
     * }
     */
    public static FunctionDescriptor g_value_register_transform_func$descriptor() {
        return g_value_register_transform_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_register_transform_func(GType src_type, GType dest_type, GValueTransform transform_func)
     * }
     */
    public static MethodHandle g_value_register_transform_func$handle() {
        return g_value_register_transform_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_register_transform_func(GType src_type, GType dest_type, GValueTransform transform_func)
     * }
     */
    public static MemorySegment g_value_register_transform_func$address() {
        return g_value_register_transform_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_register_transform_func(GType src_type, GType dest_type, GValueTransform transform_func)
     * }
     */
    public static void g_value_register_transform_func(long src_type, long dest_type, MemorySegment transform_func) {
        var mh$ = g_value_register_transform_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_register_transform_func", src_type, dest_type, transform_func);
            }
            mh$.invokeExact(src_type, dest_type, transform_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_PARAM_READABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_READABLE = 1
     * }
     */
    public static int G_PARAM_READABLE() {
        return G_PARAM_READABLE;
    }
    private static final int G_PARAM_WRITABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_WRITABLE = 2
     * }
     */
    public static int G_PARAM_WRITABLE() {
        return G_PARAM_WRITABLE;
    }
    private static final int G_PARAM_READWRITE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_READWRITE = 3
     * }
     */
    public static int G_PARAM_READWRITE() {
        return G_PARAM_READWRITE;
    }
    private static final int G_PARAM_CONSTRUCT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_CONSTRUCT = 4
     * }
     */
    public static int G_PARAM_CONSTRUCT() {
        return G_PARAM_CONSTRUCT;
    }
    private static final int G_PARAM_CONSTRUCT_ONLY = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_CONSTRUCT_ONLY = 8
     * }
     */
    public static int G_PARAM_CONSTRUCT_ONLY() {
        return G_PARAM_CONSTRUCT_ONLY;
    }
    private static final int G_PARAM_LAX_VALIDATION = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_LAX_VALIDATION = 16
     * }
     */
    public static int G_PARAM_LAX_VALIDATION() {
        return G_PARAM_LAX_VALIDATION;
    }
    private static final int G_PARAM_STATIC_NAME = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_STATIC_NAME = 32
     * }
     */
    public static int G_PARAM_STATIC_NAME() {
        return G_PARAM_STATIC_NAME;
    }
    private static final int G_PARAM_PRIVATE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_PRIVATE = 32
     * }
     */
    public static int G_PARAM_PRIVATE() {
        return G_PARAM_PRIVATE;
    }
    private static final int G_PARAM_STATIC_NICK = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_STATIC_NICK = 64
     * }
     */
    public static int G_PARAM_STATIC_NICK() {
        return G_PARAM_STATIC_NICK;
    }
    private static final int G_PARAM_STATIC_BLURB = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_STATIC_BLURB = 128
     * }
     */
    public static int G_PARAM_STATIC_BLURB() {
        return G_PARAM_STATIC_BLURB;
    }
    private static final int G_PARAM_EXPLICIT_NOTIFY = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_EXPLICIT_NOTIFY = 1073741824
     * }
     */
    public static int G_PARAM_EXPLICIT_NOTIFY() {
        return G_PARAM_EXPLICIT_NOTIFY;
    }
    private static final int G_PARAM_DEPRECATED = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PARAM_DEPRECATED = -2147483648
     * }
     */
    public static int G_PARAM_DEPRECATED() {
        return G_PARAM_DEPRECATED;
    }

    private static class g_param_spec_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_ref(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_ref$descriptor() {
        return g_param_spec_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_ref(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_ref$handle() {
        return g_param_spec_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_ref(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_ref$address() {
        return g_param_spec_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_ref(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_ref(MemorySegment pspec) {
        var mh$ = g_param_spec_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_ref", pspec);
            }
            return (MemorySegment)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_param_spec_unref(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_unref$descriptor() {
        return g_param_spec_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_param_spec_unref(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_unref$handle() {
        return g_param_spec_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_param_spec_unref(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_unref$address() {
        return g_param_spec_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_param_spec_unref(GParamSpec *pspec)
     * }
     */
    public static void g_param_spec_unref(MemorySegment pspec) {
        var mh$ = g_param_spec_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_unref", pspec);
            }
            mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_sink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_sink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_param_spec_sink(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_sink$descriptor() {
        return g_param_spec_sink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_param_spec_sink(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_sink$handle() {
        return g_param_spec_sink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_param_spec_sink(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_sink$address() {
        return g_param_spec_sink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_param_spec_sink(GParamSpec *pspec)
     * }
     */
    public static void g_param_spec_sink(MemorySegment pspec) {
        var mh$ = g_param_spec_sink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_sink", pspec);
            }
            mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_ref_sink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_ref_sink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_ref_sink(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_ref_sink$descriptor() {
        return g_param_spec_ref_sink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_ref_sink(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_ref_sink$handle() {
        return g_param_spec_ref_sink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_ref_sink(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_ref_sink$address() {
        return g_param_spec_ref_sink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_ref_sink(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_ref_sink(MemorySegment pspec) {
        var mh$ = g_param_spec_ref_sink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_ref_sink", pspec);
            }
            return (MemorySegment)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_get_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_get_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_get_qdata(GParamSpec *pspec, GQuark quark)
     * }
     */
    public static FunctionDescriptor g_param_spec_get_qdata$descriptor() {
        return g_param_spec_get_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_get_qdata(GParamSpec *pspec, GQuark quark)
     * }
     */
    public static MethodHandle g_param_spec_get_qdata$handle() {
        return g_param_spec_get_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_get_qdata(GParamSpec *pspec, GQuark quark)
     * }
     */
    public static MemorySegment g_param_spec_get_qdata$address() {
        return g_param_spec_get_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_param_spec_get_qdata(GParamSpec *pspec, GQuark quark)
     * }
     */
    public static MemorySegment g_param_spec_get_qdata(MemorySegment pspec, int quark) {
        var mh$ = g_param_spec_get_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_get_qdata", pspec, quark);
            }
            return (MemorySegment)mh$.invokeExact(pspec, quark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_set_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_set_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_param_spec_set_qdata(GParamSpec *pspec, GQuark quark, gpointer data)
     * }
     */
    public static FunctionDescriptor g_param_spec_set_qdata$descriptor() {
        return g_param_spec_set_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_param_spec_set_qdata(GParamSpec *pspec, GQuark quark, gpointer data)
     * }
     */
    public static MethodHandle g_param_spec_set_qdata$handle() {
        return g_param_spec_set_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_param_spec_set_qdata(GParamSpec *pspec, GQuark quark, gpointer data)
     * }
     */
    public static MemorySegment g_param_spec_set_qdata$address() {
        return g_param_spec_set_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_param_spec_set_qdata(GParamSpec *pspec, GQuark quark, gpointer data)
     * }
     */
    public static void g_param_spec_set_qdata(MemorySegment pspec, int quark, MemorySegment data) {
        var mh$ = g_param_spec_set_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_set_qdata", pspec, quark, data);
            }
            mh$.invokeExact(pspec, quark, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_set_qdata_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_set_qdata_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_param_spec_set_qdata_full(GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static FunctionDescriptor g_param_spec_set_qdata_full$descriptor() {
        return g_param_spec_set_qdata_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_param_spec_set_qdata_full(GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static MethodHandle g_param_spec_set_qdata_full$handle() {
        return g_param_spec_set_qdata_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_param_spec_set_qdata_full(GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_param_spec_set_qdata_full$address() {
        return g_param_spec_set_qdata_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_param_spec_set_qdata_full(GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static void g_param_spec_set_qdata_full(MemorySegment pspec, int quark, MemorySegment data, MemorySegment destroy) {
        var mh$ = g_param_spec_set_qdata_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_set_qdata_full", pspec, quark, data, destroy);
            }
            mh$.invokeExact(pspec, quark, data, destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_steal_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_steal_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_steal_qdata(GParamSpec *pspec, GQuark quark)
     * }
     */
    public static FunctionDescriptor g_param_spec_steal_qdata$descriptor() {
        return g_param_spec_steal_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_steal_qdata(GParamSpec *pspec, GQuark quark)
     * }
     */
    public static MethodHandle g_param_spec_steal_qdata$handle() {
        return g_param_spec_steal_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_steal_qdata(GParamSpec *pspec, GQuark quark)
     * }
     */
    public static MemorySegment g_param_spec_steal_qdata$address() {
        return g_param_spec_steal_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_param_spec_steal_qdata(GParamSpec *pspec, GQuark quark)
     * }
     */
    public static MemorySegment g_param_spec_steal_qdata(MemorySegment pspec, int quark) {
        var mh$ = g_param_spec_steal_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_steal_qdata", pspec, quark);
            }
            return (MemorySegment)mh$.invokeExact(pspec, quark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_get_redirect_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_get_redirect_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_get_redirect_target(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_get_redirect_target$descriptor() {
        return g_param_spec_get_redirect_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_get_redirect_target(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_get_redirect_target$handle() {
        return g_param_spec_get_redirect_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_get_redirect_target(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_redirect_target$address() {
        return g_param_spec_get_redirect_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_get_redirect_target(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_redirect_target(MemorySegment pspec) {
        var mh$ = g_param_spec_get_redirect_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_get_redirect_target", pspec);
            }
            return (MemorySegment)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_value_set_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_value_set_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_param_value_set_default(GParamSpec *pspec, GValue *value)
     * }
     */
    public static FunctionDescriptor g_param_value_set_default$descriptor() {
        return g_param_value_set_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_param_value_set_default(GParamSpec *pspec, GValue *value)
     * }
     */
    public static MethodHandle g_param_value_set_default$handle() {
        return g_param_value_set_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_param_value_set_default(GParamSpec *pspec, GValue *value)
     * }
     */
    public static MemorySegment g_param_value_set_default$address() {
        return g_param_value_set_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_param_value_set_default(GParamSpec *pspec, GValue *value)
     * }
     */
    public static void g_param_value_set_default(MemorySegment pspec, MemorySegment value) {
        var mh$ = g_param_value_set_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_value_set_default", pspec, value);
            }
            mh$.invokeExact(pspec, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_value_defaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_value_defaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_defaults(GParamSpec *pspec, const GValue *value)
     * }
     */
    public static FunctionDescriptor g_param_value_defaults$descriptor() {
        return g_param_value_defaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_defaults(GParamSpec *pspec, const GValue *value)
     * }
     */
    public static MethodHandle g_param_value_defaults$handle() {
        return g_param_value_defaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_defaults(GParamSpec *pspec, const GValue *value)
     * }
     */
    public static MemorySegment g_param_value_defaults$address() {
        return g_param_value_defaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_param_value_defaults(GParamSpec *pspec, const GValue *value)
     * }
     */
    public static int g_param_value_defaults(MemorySegment pspec, MemorySegment value) {
        var mh$ = g_param_value_defaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_value_defaults", pspec, value);
            }
            return (int)mh$.invokeExact(pspec, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_value_validate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_value_validate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_validate(GParamSpec *pspec, GValue *value)
     * }
     */
    public static FunctionDescriptor g_param_value_validate$descriptor() {
        return g_param_value_validate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_validate(GParamSpec *pspec, GValue *value)
     * }
     */
    public static MethodHandle g_param_value_validate$handle() {
        return g_param_value_validate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_validate(GParamSpec *pspec, GValue *value)
     * }
     */
    public static MemorySegment g_param_value_validate$address() {
        return g_param_value_validate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_param_value_validate(GParamSpec *pspec, GValue *value)
     * }
     */
    public static int g_param_value_validate(MemorySegment pspec, MemorySegment value) {
        var mh$ = g_param_value_validate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_value_validate", pspec, value);
            }
            return (int)mh$.invokeExact(pspec, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_value_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_value_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_is_valid(GParamSpec *pspec, const GValue *value)
     * }
     */
    public static FunctionDescriptor g_param_value_is_valid$descriptor() {
        return g_param_value_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_is_valid(GParamSpec *pspec, const GValue *value)
     * }
     */
    public static MethodHandle g_param_value_is_valid$handle() {
        return g_param_value_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_is_valid(GParamSpec *pspec, const GValue *value)
     * }
     */
    public static MemorySegment g_param_value_is_valid$address() {
        return g_param_value_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_param_value_is_valid(GParamSpec *pspec, const GValue *value)
     * }
     */
    public static int g_param_value_is_valid(MemorySegment pspec, MemorySegment value) {
        var mh$ = g_param_value_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_value_is_valid", pspec, value);
            }
            return (int)mh$.invokeExact(pspec, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_value_convert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_value_convert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_convert(GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation)
     * }
     */
    public static FunctionDescriptor g_param_value_convert$descriptor() {
        return g_param_value_convert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_convert(GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation)
     * }
     */
    public static MethodHandle g_param_value_convert$handle() {
        return g_param_value_convert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_param_value_convert(GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation)
     * }
     */
    public static MemorySegment g_param_value_convert$address() {
        return g_param_value_convert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_param_value_convert(GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation)
     * }
     */
    public static int g_param_value_convert(MemorySegment pspec, MemorySegment src_value, MemorySegment dest_value, int strict_validation) {
        var mh$ = g_param_value_convert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_value_convert", pspec, src_value, dest_value, strict_validation);
            }
            return (int)mh$.invokeExact(pspec, src_value, dest_value, strict_validation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_values_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_values_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_param_values_cmp(GParamSpec *pspec, const GValue *value1, const GValue *value2)
     * }
     */
    public static FunctionDescriptor g_param_values_cmp$descriptor() {
        return g_param_values_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_param_values_cmp(GParamSpec *pspec, const GValue *value1, const GValue *value2)
     * }
     */
    public static MethodHandle g_param_values_cmp$handle() {
        return g_param_values_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_param_values_cmp(GParamSpec *pspec, const GValue *value1, const GValue *value2)
     * }
     */
    public static MemorySegment g_param_values_cmp$address() {
        return g_param_values_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_param_values_cmp(GParamSpec *pspec, const GValue *value1, const GValue *value2)
     * }
     */
    public static int g_param_values_cmp(MemorySegment pspec, MemorySegment value1, MemorySegment value2) {
        var mh$ = g_param_values_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_values_cmp", pspec, value1, value2);
            }
            return (int)mh$.invokeExact(pspec, value1, value2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_name(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_get_name$descriptor() {
        return g_param_spec_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_name(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_get_name$handle() {
        return g_param_spec_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_name(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_name$address() {
        return g_param_spec_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_name(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_name(MemorySegment pspec) {
        var mh$ = g_param_spec_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_get_name", pspec);
            }
            return (MemorySegment)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_get_nick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_get_nick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_nick(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_get_nick$descriptor() {
        return g_param_spec_get_nick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_nick(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_get_nick$handle() {
        return g_param_spec_get_nick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_nick(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_nick$address() {
        return g_param_spec_get_nick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_nick(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_nick(MemorySegment pspec) {
        var mh$ = g_param_spec_get_nick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_get_nick", pspec);
            }
            return (MemorySegment)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_get_blurb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_get_blurb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_blurb(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_get_blurb$descriptor() {
        return g_param_spec_get_blurb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_blurb(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_get_blurb$handle() {
        return g_param_spec_get_blurb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_blurb(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_blurb$address() {
        return g_param_spec_get_blurb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_param_spec_get_blurb(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_blurb(MemorySegment pspec) {
        var mh$ = g_param_spec_get_blurb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_get_blurb", pspec);
            }
            return (MemorySegment)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_set_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_set_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_set_param(GValue *value, GParamSpec *param)
     * }
     */
    public static FunctionDescriptor g_value_set_param$descriptor() {
        return g_value_set_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_set_param(GValue *value, GParamSpec *param)
     * }
     */
    public static MethodHandle g_value_set_param$handle() {
        return g_value_set_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_set_param(GValue *value, GParamSpec *param)
     * }
     */
    public static MemorySegment g_value_set_param$address() {
        return g_value_set_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_set_param(GValue *value, GParamSpec *param)
     * }
     */
    public static void g_value_set_param(MemorySegment value, MemorySegment param) {
        var mh$ = g_value_set_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_set_param", value, param);
            }
            mh$.invokeExact(value, param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_get_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_get_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec *g_value_get_param(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_get_param$descriptor() {
        return g_value_get_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec *g_value_get_param(const GValue *value)
     * }
     */
    public static MethodHandle g_value_get_param$handle() {
        return g_value_get_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec *g_value_get_param(const GValue *value)
     * }
     */
    public static MemorySegment g_value_get_param$address() {
        return g_value_get_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec *g_value_get_param(const GValue *value)
     * }
     */
    public static MemorySegment g_value_get_param(MemorySegment value) {
        var mh$ = g_value_get_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_get_param", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_dup_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_dup_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec *g_value_dup_param(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_dup_param$descriptor() {
        return g_value_dup_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec *g_value_dup_param(const GValue *value)
     * }
     */
    public static MethodHandle g_value_dup_param$handle() {
        return g_value_dup_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec *g_value_dup_param(const GValue *value)
     * }
     */
    public static MemorySegment g_value_dup_param$address() {
        return g_value_dup_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec *g_value_dup_param(const GValue *value)
     * }
     */
    public static MemorySegment g_value_dup_param(MemorySegment value) {
        var mh$ = g_value_dup_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_dup_param", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_take_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_take_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_take_param(GValue *value, GParamSpec *param)
     * }
     */
    public static FunctionDescriptor g_value_take_param$descriptor() {
        return g_value_take_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_take_param(GValue *value, GParamSpec *param)
     * }
     */
    public static MethodHandle g_value_take_param$handle() {
        return g_value_take_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_take_param(GValue *value, GParamSpec *param)
     * }
     */
    public static MemorySegment g_value_take_param$address() {
        return g_value_take_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_take_param(GValue *value, GParamSpec *param)
     * }
     */
    public static void g_value_take_param(MemorySegment value, MemorySegment param) {
        var mh$ = g_value_take_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_take_param", value, param);
            }
            mh$.invokeExact(value, param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_set_param_take_ownership {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_set_param_take_ownership");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_set_param_take_ownership(GValue *value, GParamSpec *param)
     * }
     */
    public static FunctionDescriptor g_value_set_param_take_ownership$descriptor() {
        return g_value_set_param_take_ownership.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_set_param_take_ownership(GValue *value, GParamSpec *param)
     * }
     */
    public static MethodHandle g_value_set_param_take_ownership$handle() {
        return g_value_set_param_take_ownership.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_set_param_take_ownership(GValue *value, GParamSpec *param)
     * }
     */
    public static MemorySegment g_value_set_param_take_ownership$address() {
        return g_value_set_param_take_ownership.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_set_param_take_ownership(GValue *value, GParamSpec *param)
     * }
     */
    public static void g_value_set_param_take_ownership(MemorySegment value, MemorySegment param) {
        var mh$ = g_value_set_param_take_ownership.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_set_param_take_ownership", value, param);
            }
            mh$.invokeExact(value, param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_get_default_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_get_default_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GValue *g_param_spec_get_default_value(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_get_default_value$descriptor() {
        return g_param_spec_get_default_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GValue *g_param_spec_get_default_value(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_get_default_value$handle() {
        return g_param_spec_get_default_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GValue *g_param_spec_get_default_value(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_default_value$address() {
        return g_param_spec_get_default_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GValue *g_param_spec_get_default_value(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_default_value(MemorySegment pspec) {
        var mh$ = g_param_spec_get_default_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_get_default_value", pspec);
            }
            return (MemorySegment)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_get_name_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_get_name_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_param_spec_get_name_quark(GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_get_name_quark$descriptor() {
        return g_param_spec_get_name_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_param_spec_get_name_quark(GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_get_name_quark$handle() {
        return g_param_spec_get_name_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_param_spec_get_name_quark(GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_get_name_quark$address() {
        return g_param_spec_get_name_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_param_spec_get_name_quark(GParamSpec *pspec)
     * }
     */
    public static int g_param_spec_get_name_quark(MemorySegment pspec) {
        var mh$ = g_param_spec_get_name_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_get_name_quark", pspec);
            }
            return (int)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_type_register_static {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_type_register_static");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_param_type_register_static(const gchar *name, const GParamSpecTypeInfo *pspec_info)
     * }
     */
    public static FunctionDescriptor g_param_type_register_static$descriptor() {
        return g_param_type_register_static.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_param_type_register_static(const gchar *name, const GParamSpecTypeInfo *pspec_info)
     * }
     */
    public static MethodHandle g_param_type_register_static$handle() {
        return g_param_type_register_static.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_param_type_register_static(const gchar *name, const GParamSpecTypeInfo *pspec_info)
     * }
     */
    public static MemorySegment g_param_type_register_static$address() {
        return g_param_type_register_static.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_param_type_register_static(const gchar *name, const GParamSpecTypeInfo *pspec_info)
     * }
     */
    public static long g_param_type_register_static(MemorySegment name, MemorySegment pspec_info) {
        var mh$ = g_param_type_register_static.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_type_register_static", name, pspec_info);
            }
            return (long)mh$.invokeExact(name, pspec_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_is_valid_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_is_valid_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_param_spec_is_valid_name(const gchar *name)
     * }
     */
    public static FunctionDescriptor g_param_spec_is_valid_name$descriptor() {
        return g_param_spec_is_valid_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_param_spec_is_valid_name(const gchar *name)
     * }
     */
    public static MethodHandle g_param_spec_is_valid_name$handle() {
        return g_param_spec_is_valid_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_param_spec_is_valid_name(const gchar *name)
     * }
     */
    public static MemorySegment g_param_spec_is_valid_name$address() {
        return g_param_spec_is_valid_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_param_spec_is_valid_name(const gchar *name)
     * }
     */
    public static int g_param_spec_is_valid_name(MemorySegment name) {
        var mh$ = g_param_spec_is_valid_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_is_valid_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _g_param_type_register_static_constant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_g_param_type_register_static_constant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GType _g_param_type_register_static_constant(const gchar *name, const GParamSpecTypeInfo *pspec_info, GType opt_type)
     * }
     */
    public static FunctionDescriptor _g_param_type_register_static_constant$descriptor() {
        return _g_param_type_register_static_constant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GType _g_param_type_register_static_constant(const gchar *name, const GParamSpecTypeInfo *pspec_info, GType opt_type)
     * }
     */
    public static MethodHandle _g_param_type_register_static_constant$handle() {
        return _g_param_type_register_static_constant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GType _g_param_type_register_static_constant(const gchar *name, const GParamSpecTypeInfo *pspec_info, GType opt_type)
     * }
     */
    public static MemorySegment _g_param_type_register_static_constant$address() {
        return _g_param_type_register_static_constant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GType _g_param_type_register_static_constant(const gchar *name, const GParamSpecTypeInfo *pspec_info, GType opt_type)
     * }
     */
    public static long _g_param_type_register_static_constant(MemorySegment name, MemorySegment pspec_info, long opt_type) {
        var mh$ = _g_param_type_register_static_constant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_g_param_type_register_static_constant", name, pspec_info, opt_type);
            }
            return (long)mh$.invokeExact(name, pspec_info, opt_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_internal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_internal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_internal(GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags)
     * }
     */
    public static FunctionDescriptor g_param_spec_internal$descriptor() {
        return g_param_spec_internal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_internal(GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags)
     * }
     */
    public static MethodHandle g_param_spec_internal$handle() {
        return g_param_spec_internal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_param_spec_internal(GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags)
     * }
     */
    public static MemorySegment g_param_spec_internal$address() {
        return g_param_spec_internal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_param_spec_internal(GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags)
     * }
     */
    public static MemorySegment g_param_spec_internal(long param_type, MemorySegment name, MemorySegment nick, MemorySegment blurb, int flags) {
        var mh$ = g_param_spec_internal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_internal", param_type, name, nick, blurb, flags);
            }
            return (MemorySegment)mh$.invokeExact(param_type, name, nick, blurb, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_pool_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_pool_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpecPool *g_param_spec_pool_new(gboolean type_prefixing)
     * }
     */
    public static FunctionDescriptor g_param_spec_pool_new$descriptor() {
        return g_param_spec_pool_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpecPool *g_param_spec_pool_new(gboolean type_prefixing)
     * }
     */
    public static MethodHandle g_param_spec_pool_new$handle() {
        return g_param_spec_pool_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpecPool *g_param_spec_pool_new(gboolean type_prefixing)
     * }
     */
    public static MemorySegment g_param_spec_pool_new$address() {
        return g_param_spec_pool_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpecPool *g_param_spec_pool_new(gboolean type_prefixing)
     * }
     */
    public static MemorySegment g_param_spec_pool_new(int type_prefixing) {
        var mh$ = g_param_spec_pool_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_pool_new", type_prefixing);
            }
            return (MemorySegment)mh$.invokeExact(type_prefixing);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_pool_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_pool_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_insert(GParamSpecPool *pool, GParamSpec *pspec, GType owner_type)
     * }
     */
    public static FunctionDescriptor g_param_spec_pool_insert$descriptor() {
        return g_param_spec_pool_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_insert(GParamSpecPool *pool, GParamSpec *pspec, GType owner_type)
     * }
     */
    public static MethodHandle g_param_spec_pool_insert$handle() {
        return g_param_spec_pool_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_insert(GParamSpecPool *pool, GParamSpec *pspec, GType owner_type)
     * }
     */
    public static MemorySegment g_param_spec_pool_insert$address() {
        return g_param_spec_pool_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_param_spec_pool_insert(GParamSpecPool *pool, GParamSpec *pspec, GType owner_type)
     * }
     */
    public static void g_param_spec_pool_insert(MemorySegment pool, MemorySegment pspec, long owner_type) {
        var mh$ = g_param_spec_pool_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_pool_insert", pool, pspec, owner_type);
            }
            mh$.invokeExact(pool, pspec, owner_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_pool_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_pool_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_remove(GParamSpecPool *pool, GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_param_spec_pool_remove$descriptor() {
        return g_param_spec_pool_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_remove(GParamSpecPool *pool, GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_param_spec_pool_remove$handle() {
        return g_param_spec_pool_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_remove(GParamSpecPool *pool, GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_param_spec_pool_remove$address() {
        return g_param_spec_pool_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_param_spec_pool_remove(GParamSpecPool *pool, GParamSpec *pspec)
     * }
     */
    public static void g_param_spec_pool_remove(MemorySegment pool, MemorySegment pspec) {
        var mh$ = g_param_spec_pool_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_pool_remove", pool, pspec);
            }
            mh$.invokeExact(pool, pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_pool_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_pool_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_pool_lookup(GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors)
     * }
     */
    public static FunctionDescriptor g_param_spec_pool_lookup$descriptor() {
        return g_param_spec_pool_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_pool_lookup(GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors)
     * }
     */
    public static MethodHandle g_param_spec_pool_lookup$handle() {
        return g_param_spec_pool_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_pool_lookup(GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors)
     * }
     */
    public static MemorySegment g_param_spec_pool_lookup$address() {
        return g_param_spec_pool_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec *g_param_spec_pool_lookup(GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors)
     * }
     */
    public static MemorySegment g_param_spec_pool_lookup(MemorySegment pool, MemorySegment param_name, long owner_type, int walk_ancestors) {
        var mh$ = g_param_spec_pool_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_pool_lookup", pool, param_name, owner_type, walk_ancestors);
            }
            return (MemorySegment)mh$.invokeExact(pool, param_name, owner_type, walk_ancestors);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_pool_list_owned {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_pool_list_owned");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_param_spec_pool_list_owned(GParamSpecPool *pool, GType owner_type)
     * }
     */
    public static FunctionDescriptor g_param_spec_pool_list_owned$descriptor() {
        return g_param_spec_pool_list_owned.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_param_spec_pool_list_owned(GParamSpecPool *pool, GType owner_type)
     * }
     */
    public static MethodHandle g_param_spec_pool_list_owned$handle() {
        return g_param_spec_pool_list_owned.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_param_spec_pool_list_owned(GParamSpecPool *pool, GType owner_type)
     * }
     */
    public static MemorySegment g_param_spec_pool_list_owned$address() {
        return g_param_spec_pool_list_owned.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_param_spec_pool_list_owned(GParamSpecPool *pool, GType owner_type)
     * }
     */
    public static MemorySegment g_param_spec_pool_list_owned(MemorySegment pool, long owner_type) {
        var mh$ = g_param_spec_pool_list_owned.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_pool_list_owned", pool, owner_type);
            }
            return (MemorySegment)mh$.invokeExact(pool, owner_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_pool_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_pool_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec **g_param_spec_pool_list(GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p)
     * }
     */
    public static FunctionDescriptor g_param_spec_pool_list$descriptor() {
        return g_param_spec_pool_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec **g_param_spec_pool_list(GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p)
     * }
     */
    public static MethodHandle g_param_spec_pool_list$handle() {
        return g_param_spec_pool_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec **g_param_spec_pool_list(GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p)
     * }
     */
    public static MemorySegment g_param_spec_pool_list$address() {
        return g_param_spec_pool_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec **g_param_spec_pool_list(GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p)
     * }
     */
    public static MemorySegment g_param_spec_pool_list(MemorySegment pool, long owner_type, MemorySegment n_pspecs_p) {
        var mh$ = g_param_spec_pool_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_pool_list", pool, owner_type, n_pspecs_p);
            }
            return (MemorySegment)mh$.invokeExact(pool, owner_type, n_pspecs_p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_param_spec_pool_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_param_spec_pool_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_free(GParamSpecPool *pool)
     * }
     */
    public static FunctionDescriptor g_param_spec_pool_free$descriptor() {
        return g_param_spec_pool_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_free(GParamSpecPool *pool)
     * }
     */
    public static MethodHandle g_param_spec_pool_free$handle() {
        return g_param_spec_pool_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_param_spec_pool_free(GParamSpecPool *pool)
     * }
     */
    public static MemorySegment g_param_spec_pool_free$address() {
        return g_param_spec_pool_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_param_spec_pool_free(GParamSpecPool *pool)
     * }
     */
    public static void g_param_spec_pool_free(MemorySegment pool) {
        var mh$ = g_param_spec_pool_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_param_spec_pool_free", pool);
            }
            mh$.invokeExact(pool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_new$descriptor() {
        return g_cclosure_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data)
     * }
     */
    public static MethodHandle g_cclosure_new$handle() {
        return g_cclosure_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data)
     * }
     */
    public static MemorySegment g_cclosure_new$address() {
        return g_cclosure_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data)
     * }
     */
    public static MemorySegment g_cclosure_new(MemorySegment callback_func, MemorySegment user_data, MemorySegment destroy_data) {
        var mh$ = g_cclosure_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_new", callback_func, user_data, destroy_data);
            }
            return (MemorySegment)mh$.invokeExact(callback_func, user_data, destroy_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_new_swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_new_swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_swap(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_new_swap$descriptor() {
        return g_cclosure_new_swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_swap(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data)
     * }
     */
    public static MethodHandle g_cclosure_new_swap$handle() {
        return g_cclosure_new_swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_swap(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data)
     * }
     */
    public static MemorySegment g_cclosure_new_swap$address() {
        return g_cclosure_new_swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_swap(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data)
     * }
     */
    public static MemorySegment g_cclosure_new_swap(MemorySegment callback_func, MemorySegment user_data, MemorySegment destroy_data) {
        var mh$ = g_cclosure_new_swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_new_swap", callback_func, user_data, destroy_data);
            }
            return (MemorySegment)mh$.invokeExact(callback_func, user_data, destroy_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_type_cclosure_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_type_cclosure_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GClosure *g_signal_type_cclosure_new(GType itype, guint struct_offset)
     * }
     */
    public static FunctionDescriptor g_signal_type_cclosure_new$descriptor() {
        return g_signal_type_cclosure_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GClosure *g_signal_type_cclosure_new(GType itype, guint struct_offset)
     * }
     */
    public static MethodHandle g_signal_type_cclosure_new$handle() {
        return g_signal_type_cclosure_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GClosure *g_signal_type_cclosure_new(GType itype, guint struct_offset)
     * }
     */
    public static MemorySegment g_signal_type_cclosure_new$address() {
        return g_signal_type_cclosure_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GClosure *g_signal_type_cclosure_new(GType itype, guint struct_offset)
     * }
     */
    public static MemorySegment g_signal_type_cclosure_new(long itype, int struct_offset) {
        var mh$ = g_signal_type_cclosure_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_type_cclosure_new", itype, struct_offset);
            }
            return (MemorySegment)mh$.invokeExact(itype, struct_offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_ref(GClosure *closure)
     * }
     */
    public static FunctionDescriptor g_closure_ref$descriptor() {
        return g_closure_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_ref(GClosure *closure)
     * }
     */
    public static MethodHandle g_closure_ref$handle() {
        return g_closure_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_ref(GClosure *closure)
     * }
     */
    public static MemorySegment g_closure_ref$address() {
        return g_closure_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GClosure *g_closure_ref(GClosure *closure)
     * }
     */
    public static MemorySegment g_closure_ref(MemorySegment closure) {
        var mh$ = g_closure_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_ref", closure);
            }
            return (MemorySegment)mh$.invokeExact(closure);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_sink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_sink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_sink(GClosure *closure)
     * }
     */
    public static FunctionDescriptor g_closure_sink$descriptor() {
        return g_closure_sink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_sink(GClosure *closure)
     * }
     */
    public static MethodHandle g_closure_sink$handle() {
        return g_closure_sink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_sink(GClosure *closure)
     * }
     */
    public static MemorySegment g_closure_sink$address() {
        return g_closure_sink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_sink(GClosure *closure)
     * }
     */
    public static void g_closure_sink(MemorySegment closure) {
        var mh$ = g_closure_sink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_sink", closure);
            }
            mh$.invokeExact(closure);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_unref(GClosure *closure)
     * }
     */
    public static FunctionDescriptor g_closure_unref$descriptor() {
        return g_closure_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_unref(GClosure *closure)
     * }
     */
    public static MethodHandle g_closure_unref$handle() {
        return g_closure_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_unref(GClosure *closure)
     * }
     */
    public static MemorySegment g_closure_unref$address() {
        return g_closure_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_unref(GClosure *closure)
     * }
     */
    public static void g_closure_unref(MemorySegment closure) {
        var mh$ = g_closure_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_unref", closure);
            }
            mh$.invokeExact(closure);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_new_simple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_new_simple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_new_simple(guint sizeof_closure, gpointer data)
     * }
     */
    public static FunctionDescriptor g_closure_new_simple$descriptor() {
        return g_closure_new_simple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_new_simple(guint sizeof_closure, gpointer data)
     * }
     */
    public static MethodHandle g_closure_new_simple$handle() {
        return g_closure_new_simple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_new_simple(guint sizeof_closure, gpointer data)
     * }
     */
    public static MemorySegment g_closure_new_simple$address() {
        return g_closure_new_simple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GClosure *g_closure_new_simple(guint sizeof_closure, gpointer data)
     * }
     */
    public static MemorySegment g_closure_new_simple(int sizeof_closure, MemorySegment data) {
        var mh$ = g_closure_new_simple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_new_simple", sizeof_closure, data);
            }
            return (MemorySegment)mh$.invokeExact(sizeof_closure, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_add_finalize_notifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_add_finalize_notifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_add_finalize_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static FunctionDescriptor g_closure_add_finalize_notifier$descriptor() {
        return g_closure_add_finalize_notifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_add_finalize_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static MethodHandle g_closure_add_finalize_notifier$handle() {
        return g_closure_add_finalize_notifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_add_finalize_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static MemorySegment g_closure_add_finalize_notifier$address() {
        return g_closure_add_finalize_notifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_add_finalize_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static void g_closure_add_finalize_notifier(MemorySegment closure, MemorySegment notify_data, MemorySegment notify_func) {
        var mh$ = g_closure_add_finalize_notifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_add_finalize_notifier", closure, notify_data, notify_func);
            }
            mh$.invokeExact(closure, notify_data, notify_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_remove_finalize_notifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_remove_finalize_notifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_remove_finalize_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static FunctionDescriptor g_closure_remove_finalize_notifier$descriptor() {
        return g_closure_remove_finalize_notifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_remove_finalize_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static MethodHandle g_closure_remove_finalize_notifier$handle() {
        return g_closure_remove_finalize_notifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_remove_finalize_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static MemorySegment g_closure_remove_finalize_notifier$address() {
        return g_closure_remove_finalize_notifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_remove_finalize_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static void g_closure_remove_finalize_notifier(MemorySegment closure, MemorySegment notify_data, MemorySegment notify_func) {
        var mh$ = g_closure_remove_finalize_notifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_remove_finalize_notifier", closure, notify_data, notify_func);
            }
            mh$.invokeExact(closure, notify_data, notify_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_add_invalidate_notifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_add_invalidate_notifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_add_invalidate_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static FunctionDescriptor g_closure_add_invalidate_notifier$descriptor() {
        return g_closure_add_invalidate_notifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_add_invalidate_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static MethodHandle g_closure_add_invalidate_notifier$handle() {
        return g_closure_add_invalidate_notifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_add_invalidate_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static MemorySegment g_closure_add_invalidate_notifier$address() {
        return g_closure_add_invalidate_notifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_add_invalidate_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static void g_closure_add_invalidate_notifier(MemorySegment closure, MemorySegment notify_data, MemorySegment notify_func) {
        var mh$ = g_closure_add_invalidate_notifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_add_invalidate_notifier", closure, notify_data, notify_func);
            }
            mh$.invokeExact(closure, notify_data, notify_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_remove_invalidate_notifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_remove_invalidate_notifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_remove_invalidate_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static FunctionDescriptor g_closure_remove_invalidate_notifier$descriptor() {
        return g_closure_remove_invalidate_notifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_remove_invalidate_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static MethodHandle g_closure_remove_invalidate_notifier$handle() {
        return g_closure_remove_invalidate_notifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_remove_invalidate_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static MemorySegment g_closure_remove_invalidate_notifier$address() {
        return g_closure_remove_invalidate_notifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_remove_invalidate_notifier(GClosure *closure, gpointer notify_data, GClosureNotify notify_func)
     * }
     */
    public static void g_closure_remove_invalidate_notifier(MemorySegment closure, MemorySegment notify_data, MemorySegment notify_func) {
        var mh$ = g_closure_remove_invalidate_notifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_remove_invalidate_notifier", closure, notify_data, notify_func);
            }
            mh$.invokeExact(closure, notify_data, notify_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_add_marshal_guards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_add_marshal_guards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_add_marshal_guards(GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify)
     * }
     */
    public static FunctionDescriptor g_closure_add_marshal_guards$descriptor() {
        return g_closure_add_marshal_guards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_add_marshal_guards(GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify)
     * }
     */
    public static MethodHandle g_closure_add_marshal_guards$handle() {
        return g_closure_add_marshal_guards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_add_marshal_guards(GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify)
     * }
     */
    public static MemorySegment g_closure_add_marshal_guards$address() {
        return g_closure_add_marshal_guards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_add_marshal_guards(GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify)
     * }
     */
    public static void g_closure_add_marshal_guards(MemorySegment closure, MemorySegment pre_marshal_data, MemorySegment pre_marshal_notify, MemorySegment post_marshal_data, MemorySegment post_marshal_notify) {
        var mh$ = g_closure_add_marshal_guards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_add_marshal_guards", closure, pre_marshal_data, pre_marshal_notify, post_marshal_data, post_marshal_notify);
            }
            mh$.invokeExact(closure, pre_marshal_data, pre_marshal_notify, post_marshal_data, post_marshal_notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_set_marshal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_set_marshal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_set_marshal(GClosure *closure, GClosureMarshal marshal)
     * }
     */
    public static FunctionDescriptor g_closure_set_marshal$descriptor() {
        return g_closure_set_marshal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_set_marshal(GClosure *closure, GClosureMarshal marshal)
     * }
     */
    public static MethodHandle g_closure_set_marshal$handle() {
        return g_closure_set_marshal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_set_marshal(GClosure *closure, GClosureMarshal marshal)
     * }
     */
    public static MemorySegment g_closure_set_marshal$address() {
        return g_closure_set_marshal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_set_marshal(GClosure *closure, GClosureMarshal marshal)
     * }
     */
    public static void g_closure_set_marshal(MemorySegment closure, MemorySegment marshal) {
        var mh$ = g_closure_set_marshal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_set_marshal", closure, marshal);
            }
            mh$.invokeExact(closure, marshal);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_set_meta_marshal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_set_meta_marshal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_set_meta_marshal(GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal)
     * }
     */
    public static FunctionDescriptor g_closure_set_meta_marshal$descriptor() {
        return g_closure_set_meta_marshal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_set_meta_marshal(GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal)
     * }
     */
    public static MethodHandle g_closure_set_meta_marshal$handle() {
        return g_closure_set_meta_marshal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_set_meta_marshal(GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal)
     * }
     */
    public static MemorySegment g_closure_set_meta_marshal$address() {
        return g_closure_set_meta_marshal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_set_meta_marshal(GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal)
     * }
     */
    public static void g_closure_set_meta_marshal(MemorySegment closure, MemorySegment marshal_data, MemorySegment meta_marshal) {
        var mh$ = g_closure_set_meta_marshal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_set_meta_marshal", closure, marshal_data, meta_marshal);
            }
            mh$.invokeExact(closure, marshal_data, meta_marshal);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_invalidate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_invalidate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_invalidate(GClosure *closure)
     * }
     */
    public static FunctionDescriptor g_closure_invalidate$descriptor() {
        return g_closure_invalidate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_invalidate(GClosure *closure)
     * }
     */
    public static MethodHandle g_closure_invalidate$handle() {
        return g_closure_invalidate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_invalidate(GClosure *closure)
     * }
     */
    public static MemorySegment g_closure_invalidate$address() {
        return g_closure_invalidate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_invalidate(GClosure *closure)
     * }
     */
    public static void g_closure_invalidate(MemorySegment closure) {
        var mh$ = g_closure_invalidate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_invalidate", closure);
            }
            mh$.invokeExact(closure);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_invoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_invoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_closure_invoke(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint)
     * }
     */
    public static FunctionDescriptor g_closure_invoke$descriptor() {
        return g_closure_invoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_closure_invoke(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint)
     * }
     */
    public static MethodHandle g_closure_invoke$handle() {
        return g_closure_invoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_closure_invoke(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint)
     * }
     */
    public static MemorySegment g_closure_invoke$address() {
        return g_closure_invoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_closure_invoke(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint)
     * }
     */
    public static void g_closure_invoke(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint) {
        var mh$ = g_closure_invoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_invoke", closure, return_value, n_param_values, param_values, invocation_hint);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_generic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_generic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_generic(GClosure *closure, GValue *return_gvalue, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_generic$descriptor() {
        return g_cclosure_marshal_generic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_generic(GClosure *closure, GValue *return_gvalue, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_generic$handle() {
        return g_cclosure_marshal_generic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_generic(GClosure *closure, GValue *return_gvalue, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_generic$address() {
        return g_cclosure_marshal_generic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_generic(GClosure *closure, GValue *return_gvalue, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_generic(MemorySegment closure, MemorySegment return_gvalue, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_generic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_generic", closure, return_gvalue, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_gvalue, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_generic_va {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_generic_va");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_generic_va(GClosure *closure, GValue *return_value, gpointer instance, va_list args_list, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_generic_va$descriptor() {
        return g_cclosure_marshal_generic_va.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_generic_va(GClosure *closure, GValue *return_value, gpointer instance, va_list args_list, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_generic_va$handle() {
        return g_cclosure_marshal_generic_va.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_generic_va(GClosure *closure, GValue *return_value, gpointer instance, va_list args_list, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_generic_va$address() {
        return g_cclosure_marshal_generic_va.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_generic_va(GClosure *closure, GValue *return_value, gpointer instance, va_list args_list, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_generic_va(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args_list, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_generic_va.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_generic_va", closure, return_value, instance, args_list, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args_list, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__VOID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__VOID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VOID(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__VOID$descriptor() {
        return g_cclosure_marshal_VOID__VOID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VOID(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__VOID$handle() {
        return g_cclosure_marshal_VOID__VOID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VOID(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__VOID$address() {
        return g_cclosure_marshal_VOID__VOID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VOID(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__VOID(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__VOID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__VOID", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__VOIDv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__VOIDv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VOIDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__VOIDv$descriptor() {
        return g_cclosure_marshal_VOID__VOIDv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VOIDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__VOIDv$handle() {
        return g_cclosure_marshal_VOID__VOIDv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VOIDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__VOIDv$address() {
        return g_cclosure_marshal_VOID__VOIDv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VOIDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__VOIDv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__VOIDv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__VOIDv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__BOOLEAN {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__BOOLEAN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOOLEAN(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__BOOLEAN$descriptor() {
        return g_cclosure_marshal_VOID__BOOLEAN.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOOLEAN(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__BOOLEAN$handle() {
        return g_cclosure_marshal_VOID__BOOLEAN.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOOLEAN(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__BOOLEAN$address() {
        return g_cclosure_marshal_VOID__BOOLEAN.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOOLEAN(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__BOOLEAN(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__BOOLEAN.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__BOOLEAN", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__BOOLEANv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__BOOLEANv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOOLEANv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__BOOLEANv$descriptor() {
        return g_cclosure_marshal_VOID__BOOLEANv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOOLEANv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__BOOLEANv$handle() {
        return g_cclosure_marshal_VOID__BOOLEANv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOOLEANv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__BOOLEANv$address() {
        return g_cclosure_marshal_VOID__BOOLEANv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOOLEANv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__BOOLEANv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__BOOLEANv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__BOOLEANv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__CHAR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__CHAR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__CHAR(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__CHAR$descriptor() {
        return g_cclosure_marshal_VOID__CHAR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__CHAR(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__CHAR$handle() {
        return g_cclosure_marshal_VOID__CHAR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__CHAR(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__CHAR$address() {
        return g_cclosure_marshal_VOID__CHAR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__CHAR(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__CHAR(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__CHAR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__CHAR", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__CHARv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__CHARv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__CHARv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__CHARv$descriptor() {
        return g_cclosure_marshal_VOID__CHARv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__CHARv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__CHARv$handle() {
        return g_cclosure_marshal_VOID__CHARv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__CHARv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__CHARv$address() {
        return g_cclosure_marshal_VOID__CHARv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__CHARv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__CHARv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__CHARv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__CHARv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__UCHAR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__UCHAR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UCHAR(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__UCHAR$descriptor() {
        return g_cclosure_marshal_VOID__UCHAR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UCHAR(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__UCHAR$handle() {
        return g_cclosure_marshal_VOID__UCHAR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UCHAR(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__UCHAR$address() {
        return g_cclosure_marshal_VOID__UCHAR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UCHAR(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__UCHAR(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__UCHAR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__UCHAR", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__UCHARv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__UCHARv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UCHARv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__UCHARv$descriptor() {
        return g_cclosure_marshal_VOID__UCHARv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UCHARv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__UCHARv$handle() {
        return g_cclosure_marshal_VOID__UCHARv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UCHARv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__UCHARv$address() {
        return g_cclosure_marshal_VOID__UCHARv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UCHARv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__UCHARv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__UCHARv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__UCHARv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__INT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__INT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__INT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__INT$descriptor() {
        return g_cclosure_marshal_VOID__INT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__INT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__INT$handle() {
        return g_cclosure_marshal_VOID__INT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__INT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__INT$address() {
        return g_cclosure_marshal_VOID__INT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__INT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__INT(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__INT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__INT", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__INTv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__INTv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__INTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__INTv$descriptor() {
        return g_cclosure_marshal_VOID__INTv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__INTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__INTv$handle() {
        return g_cclosure_marshal_VOID__INTv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__INTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__INTv$address() {
        return g_cclosure_marshal_VOID__INTv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__INTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__INTv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__INTv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__INTv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__UINT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__UINT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__UINT$descriptor() {
        return g_cclosure_marshal_VOID__UINT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__UINT$handle() {
        return g_cclosure_marshal_VOID__UINT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__UINT$address() {
        return g_cclosure_marshal_VOID__UINT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__UINT(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__UINT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__UINT", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__UINTv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__UINTv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__UINTv$descriptor() {
        return g_cclosure_marshal_VOID__UINTv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__UINTv$handle() {
        return g_cclosure_marshal_VOID__UINTv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__UINTv$address() {
        return g_cclosure_marshal_VOID__UINTv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__UINTv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__UINTv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__UINTv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__LONG {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__LONG");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__LONG(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__LONG$descriptor() {
        return g_cclosure_marshal_VOID__LONG.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__LONG(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__LONG$handle() {
        return g_cclosure_marshal_VOID__LONG.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__LONG(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__LONG$address() {
        return g_cclosure_marshal_VOID__LONG.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__LONG(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__LONG(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__LONG.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__LONG", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__LONGv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__LONGv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__LONGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__LONGv$descriptor() {
        return g_cclosure_marshal_VOID__LONGv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__LONGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__LONGv$handle() {
        return g_cclosure_marshal_VOID__LONGv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__LONGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__LONGv$address() {
        return g_cclosure_marshal_VOID__LONGv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__LONGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__LONGv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__LONGv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__LONGv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__ULONG {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__ULONG");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ULONG(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__ULONG$descriptor() {
        return g_cclosure_marshal_VOID__ULONG.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ULONG(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__ULONG$handle() {
        return g_cclosure_marshal_VOID__ULONG.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ULONG(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__ULONG$address() {
        return g_cclosure_marshal_VOID__ULONG.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ULONG(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__ULONG(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__ULONG.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__ULONG", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__ULONGv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__ULONGv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ULONGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__ULONGv$descriptor() {
        return g_cclosure_marshal_VOID__ULONGv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ULONGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__ULONGv$handle() {
        return g_cclosure_marshal_VOID__ULONGv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ULONGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__ULONGv$address() {
        return g_cclosure_marshal_VOID__ULONGv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ULONGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__ULONGv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__ULONGv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__ULONGv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__ENUM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__ENUM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ENUM(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__ENUM$descriptor() {
        return g_cclosure_marshal_VOID__ENUM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ENUM(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__ENUM$handle() {
        return g_cclosure_marshal_VOID__ENUM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ENUM(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__ENUM$address() {
        return g_cclosure_marshal_VOID__ENUM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ENUM(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__ENUM(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__ENUM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__ENUM", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__ENUMv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__ENUMv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ENUMv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__ENUMv$descriptor() {
        return g_cclosure_marshal_VOID__ENUMv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ENUMv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__ENUMv$handle() {
        return g_cclosure_marshal_VOID__ENUMv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ENUMv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__ENUMv$address() {
        return g_cclosure_marshal_VOID__ENUMv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__ENUMv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__ENUMv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__ENUMv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__ENUMv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__FLAGS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__FLAGS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLAGS(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__FLAGS$descriptor() {
        return g_cclosure_marshal_VOID__FLAGS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLAGS(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__FLAGS$handle() {
        return g_cclosure_marshal_VOID__FLAGS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLAGS(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__FLAGS$address() {
        return g_cclosure_marshal_VOID__FLAGS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLAGS(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__FLAGS(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__FLAGS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__FLAGS", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__FLAGSv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__FLAGSv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLAGSv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__FLAGSv$descriptor() {
        return g_cclosure_marshal_VOID__FLAGSv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLAGSv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__FLAGSv$handle() {
        return g_cclosure_marshal_VOID__FLAGSv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLAGSv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__FLAGSv$address() {
        return g_cclosure_marshal_VOID__FLAGSv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLAGSv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__FLAGSv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__FLAGSv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__FLAGSv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__FLOAT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__FLOAT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLOAT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__FLOAT$descriptor() {
        return g_cclosure_marshal_VOID__FLOAT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLOAT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__FLOAT$handle() {
        return g_cclosure_marshal_VOID__FLOAT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLOAT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__FLOAT$address() {
        return g_cclosure_marshal_VOID__FLOAT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLOAT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__FLOAT(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__FLOAT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__FLOAT", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__FLOATv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__FLOATv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLOATv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__FLOATv$descriptor() {
        return g_cclosure_marshal_VOID__FLOATv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLOATv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__FLOATv$handle() {
        return g_cclosure_marshal_VOID__FLOATv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLOATv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__FLOATv$address() {
        return g_cclosure_marshal_VOID__FLOATv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__FLOATv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__FLOATv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__FLOATv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__FLOATv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__DOUBLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__DOUBLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__DOUBLE(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__DOUBLE$descriptor() {
        return g_cclosure_marshal_VOID__DOUBLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__DOUBLE(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__DOUBLE$handle() {
        return g_cclosure_marshal_VOID__DOUBLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__DOUBLE(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__DOUBLE$address() {
        return g_cclosure_marshal_VOID__DOUBLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__DOUBLE(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__DOUBLE(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__DOUBLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__DOUBLE", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__DOUBLEv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__DOUBLEv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__DOUBLEv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__DOUBLEv$descriptor() {
        return g_cclosure_marshal_VOID__DOUBLEv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__DOUBLEv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__DOUBLEv$handle() {
        return g_cclosure_marshal_VOID__DOUBLEv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__DOUBLEv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__DOUBLEv$address() {
        return g_cclosure_marshal_VOID__DOUBLEv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__DOUBLEv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__DOUBLEv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__DOUBLEv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__DOUBLEv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__STRING {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__STRING");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__STRING(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__STRING$descriptor() {
        return g_cclosure_marshal_VOID__STRING.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__STRING(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__STRING$handle() {
        return g_cclosure_marshal_VOID__STRING.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__STRING(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__STRING$address() {
        return g_cclosure_marshal_VOID__STRING.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__STRING(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__STRING(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__STRING.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__STRING", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__STRINGv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__STRINGv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__STRINGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__STRINGv$descriptor() {
        return g_cclosure_marshal_VOID__STRINGv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__STRINGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__STRINGv$handle() {
        return g_cclosure_marshal_VOID__STRINGv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__STRINGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__STRINGv$address() {
        return g_cclosure_marshal_VOID__STRINGv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__STRINGv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__STRINGv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__STRINGv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__STRINGv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__PARAM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__PARAM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__PARAM(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__PARAM$descriptor() {
        return g_cclosure_marshal_VOID__PARAM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__PARAM(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__PARAM$handle() {
        return g_cclosure_marshal_VOID__PARAM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__PARAM(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__PARAM$address() {
        return g_cclosure_marshal_VOID__PARAM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__PARAM(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__PARAM(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__PARAM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__PARAM", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__PARAMv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__PARAMv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__PARAMv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__PARAMv$descriptor() {
        return g_cclosure_marshal_VOID__PARAMv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__PARAMv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__PARAMv$handle() {
        return g_cclosure_marshal_VOID__PARAMv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__PARAMv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__PARAMv$address() {
        return g_cclosure_marshal_VOID__PARAMv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__PARAMv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__PARAMv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__PARAMv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__PARAMv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__BOXED {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__BOXED");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOXED(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__BOXED$descriptor() {
        return g_cclosure_marshal_VOID__BOXED.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOXED(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__BOXED$handle() {
        return g_cclosure_marshal_VOID__BOXED.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOXED(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__BOXED$address() {
        return g_cclosure_marshal_VOID__BOXED.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOXED(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__BOXED(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__BOXED.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__BOXED", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__BOXEDv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__BOXEDv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOXEDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__BOXEDv$descriptor() {
        return g_cclosure_marshal_VOID__BOXEDv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOXEDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__BOXEDv$handle() {
        return g_cclosure_marshal_VOID__BOXEDv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOXEDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__BOXEDv$address() {
        return g_cclosure_marshal_VOID__BOXEDv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__BOXEDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__BOXEDv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__BOXEDv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__BOXEDv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__POINTER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__POINTER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__POINTER$descriptor() {
        return g_cclosure_marshal_VOID__POINTER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__POINTER$handle() {
        return g_cclosure_marshal_VOID__POINTER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__POINTER$address() {
        return g_cclosure_marshal_VOID__POINTER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__POINTER(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__POINTER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__POINTER", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__POINTERv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__POINTERv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__POINTERv$descriptor() {
        return g_cclosure_marshal_VOID__POINTERv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__POINTERv$handle() {
        return g_cclosure_marshal_VOID__POINTERv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__POINTERv$address() {
        return g_cclosure_marshal_VOID__POINTERv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__POINTERv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__POINTERv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__POINTERv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__OBJECT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__OBJECT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__OBJECT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__OBJECT$descriptor() {
        return g_cclosure_marshal_VOID__OBJECT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__OBJECT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__OBJECT$handle() {
        return g_cclosure_marshal_VOID__OBJECT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__OBJECT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__OBJECT$address() {
        return g_cclosure_marshal_VOID__OBJECT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__OBJECT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__OBJECT(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__OBJECT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__OBJECT", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__OBJECTv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__OBJECTv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__OBJECTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__OBJECTv$descriptor() {
        return g_cclosure_marshal_VOID__OBJECTv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__OBJECTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__OBJECTv$handle() {
        return g_cclosure_marshal_VOID__OBJECTv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__OBJECTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__OBJECTv$address() {
        return g_cclosure_marshal_VOID__OBJECTv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__OBJECTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__OBJECTv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__OBJECTv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__OBJECTv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__VARIANT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__VARIANT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VARIANT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__VARIANT$descriptor() {
        return g_cclosure_marshal_VOID__VARIANT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VARIANT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__VARIANT$handle() {
        return g_cclosure_marshal_VOID__VARIANT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VARIANT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__VARIANT$address() {
        return g_cclosure_marshal_VOID__VARIANT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VARIANT(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__VARIANT(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__VARIANT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__VARIANT", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__VARIANTv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__VARIANTv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VARIANTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__VARIANTv$descriptor() {
        return g_cclosure_marshal_VOID__VARIANTv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VARIANTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__VARIANTv$handle() {
        return g_cclosure_marshal_VOID__VARIANTv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VARIANTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__VARIANTv$address() {
        return g_cclosure_marshal_VOID__VARIANTv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__VARIANTv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__VARIANTv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__VARIANTv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__VARIANTv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__UINT_POINTER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__UINT_POINTER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT_POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__UINT_POINTER$descriptor() {
        return g_cclosure_marshal_VOID__UINT_POINTER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT_POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__UINT_POINTER$handle() {
        return g_cclosure_marshal_VOID__UINT_POINTER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT_POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__UINT_POINTER$address() {
        return g_cclosure_marshal_VOID__UINT_POINTER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT_POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_VOID__UINT_POINTER(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_VOID__UINT_POINTER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__UINT_POINTER", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_VOID__UINT_POINTERv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_VOID__UINT_POINTERv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT_POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_VOID__UINT_POINTERv$descriptor() {
        return g_cclosure_marshal_VOID__UINT_POINTERv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT_POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_VOID__UINT_POINTERv$handle() {
        return g_cclosure_marshal_VOID__UINT_POINTERv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT_POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_VOID__UINT_POINTERv$address() {
        return g_cclosure_marshal_VOID__UINT_POINTERv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_VOID__UINT_POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_VOID__UINT_POINTERv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_VOID__UINT_POINTERv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_VOID__UINT_POINTERv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_BOOLEAN__FLAGS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_BOOLEAN__FLAGS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__FLAGS(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_BOOLEAN__FLAGS$descriptor() {
        return g_cclosure_marshal_BOOLEAN__FLAGS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__FLAGS(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_BOOLEAN__FLAGS$handle() {
        return g_cclosure_marshal_BOOLEAN__FLAGS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__FLAGS(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_BOOLEAN__FLAGS$address() {
        return g_cclosure_marshal_BOOLEAN__FLAGS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__FLAGS(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_BOOLEAN__FLAGS(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_BOOLEAN__FLAGS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_BOOLEAN__FLAGS", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_BOOLEAN__FLAGSv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_BOOLEAN__FLAGSv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__FLAGSv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_BOOLEAN__FLAGSv$descriptor() {
        return g_cclosure_marshal_BOOLEAN__FLAGSv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__FLAGSv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_BOOLEAN__FLAGSv$handle() {
        return g_cclosure_marshal_BOOLEAN__FLAGSv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__FLAGSv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_BOOLEAN__FLAGSv$address() {
        return g_cclosure_marshal_BOOLEAN__FLAGSv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__FLAGSv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_BOOLEAN__FLAGSv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_BOOLEAN__FLAGSv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_BOOLEAN__FLAGSv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_STRING__OBJECT_POINTER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_STRING__OBJECT_POINTER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_STRING__OBJECT_POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_STRING__OBJECT_POINTER$descriptor() {
        return g_cclosure_marshal_STRING__OBJECT_POINTER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_STRING__OBJECT_POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_STRING__OBJECT_POINTER$handle() {
        return g_cclosure_marshal_STRING__OBJECT_POINTER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_STRING__OBJECT_POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_STRING__OBJECT_POINTER$address() {
        return g_cclosure_marshal_STRING__OBJECT_POINTER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_STRING__OBJECT_POINTER(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_STRING__OBJECT_POINTER(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_STRING__OBJECT_POINTER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_STRING__OBJECT_POINTER", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_STRING__OBJECT_POINTERv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_STRING__OBJECT_POINTERv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_STRING__OBJECT_POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_STRING__OBJECT_POINTERv$descriptor() {
        return g_cclosure_marshal_STRING__OBJECT_POINTERv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_STRING__OBJECT_POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_STRING__OBJECT_POINTERv$handle() {
        return g_cclosure_marshal_STRING__OBJECT_POINTERv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_STRING__OBJECT_POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_STRING__OBJECT_POINTERv$address() {
        return g_cclosure_marshal_STRING__OBJECT_POINTERv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_STRING__OBJECT_POINTERv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_STRING__OBJECT_POINTERv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_STRING__OBJECT_POINTERv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_STRING__OBJECT_POINTERv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_BOOLEAN__BOXED_BOXED {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_BOOLEAN__BOXED_BOXED");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXED(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_BOOLEAN__BOXED_BOXED$descriptor() {
        return g_cclosure_marshal_BOOLEAN__BOXED_BOXED.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXED(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_cclosure_marshal_BOOLEAN__BOXED_BOXED$handle() {
        return g_cclosure_marshal_BOOLEAN__BOXED_BOXED.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXED(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_cclosure_marshal_BOOLEAN__BOXED_BOXED$address() {
        return g_cclosure_marshal_BOOLEAN__BOXED_BOXED.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXED(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data)
     * }
     */
    public static void g_cclosure_marshal_BOOLEAN__BOXED_BOXED(MemorySegment closure, MemorySegment return_value, int n_param_values, MemorySegment param_values, MemorySegment invocation_hint, MemorySegment marshal_data) {
        var mh$ = g_cclosure_marshal_BOOLEAN__BOXED_BOXED.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_BOOLEAN__BOXED_BOXED", closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
            }
            mh$.invokeExact(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv$descriptor() {
        return g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv$handle() {
        return g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv$address() {
        return g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types)
     * }
     */
    public static void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(MemorySegment closure, MemorySegment return_value, MemorySegment instance, MemorySegment args, MemorySegment marshal_data, int n_params, MemorySegment param_types) {
        var mh$ = g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv", closure, return_value, instance, args, marshal_data, n_params, param_types);
            }
            mh$.invokeExact(closure, return_value, instance, args, marshal_data, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_SIGNAL_RUN_FIRST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_RUN_FIRST = 1
     * }
     */
    public static int G_SIGNAL_RUN_FIRST() {
        return G_SIGNAL_RUN_FIRST;
    }
    private static final int G_SIGNAL_RUN_LAST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_RUN_LAST = 2
     * }
     */
    public static int G_SIGNAL_RUN_LAST() {
        return G_SIGNAL_RUN_LAST;
    }
    private static final int G_SIGNAL_RUN_CLEANUP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_RUN_CLEANUP = 4
     * }
     */
    public static int G_SIGNAL_RUN_CLEANUP() {
        return G_SIGNAL_RUN_CLEANUP;
    }
    private static final int G_SIGNAL_NO_RECURSE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_NO_RECURSE = 8
     * }
     */
    public static int G_SIGNAL_NO_RECURSE() {
        return G_SIGNAL_NO_RECURSE;
    }
    private static final int G_SIGNAL_DETAILED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_DETAILED = 16
     * }
     */
    public static int G_SIGNAL_DETAILED() {
        return G_SIGNAL_DETAILED;
    }
    private static final int G_SIGNAL_ACTION = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_ACTION = 32
     * }
     */
    public static int G_SIGNAL_ACTION() {
        return G_SIGNAL_ACTION;
    }
    private static final int G_SIGNAL_NO_HOOKS = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_NO_HOOKS = 64
     * }
     */
    public static int G_SIGNAL_NO_HOOKS() {
        return G_SIGNAL_NO_HOOKS;
    }
    private static final int G_SIGNAL_MUST_COLLECT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_MUST_COLLECT = 128
     * }
     */
    public static int G_SIGNAL_MUST_COLLECT() {
        return G_SIGNAL_MUST_COLLECT;
    }
    private static final int G_SIGNAL_DEPRECATED = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_DEPRECATED = 256
     * }
     */
    public static int G_SIGNAL_DEPRECATED() {
        return G_SIGNAL_DEPRECATED;
    }
    private static final int G_SIGNAL_ACCUMULATOR_FIRST_RUN = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_ACCUMULATOR_FIRST_RUN = 131072
     * }
     */
    public static int G_SIGNAL_ACCUMULATOR_FIRST_RUN() {
        return G_SIGNAL_ACCUMULATOR_FIRST_RUN;
    }
    private static final int G_CONNECT_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONNECT_DEFAULT = 0
     * }
     */
    public static int G_CONNECT_DEFAULT() {
        return G_CONNECT_DEFAULT;
    }
    private static final int G_CONNECT_AFTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONNECT_AFTER = 1
     * }
     */
    public static int G_CONNECT_AFTER() {
        return G_CONNECT_AFTER;
    }
    private static final int G_CONNECT_SWAPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONNECT_SWAPPED = 2
     * }
     */
    public static int G_CONNECT_SWAPPED() {
        return G_CONNECT_SWAPPED;
    }
    private static final int G_SIGNAL_MATCH_ID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_MATCH_ID = 1
     * }
     */
    public static int G_SIGNAL_MATCH_ID() {
        return G_SIGNAL_MATCH_ID;
    }
    private static final int G_SIGNAL_MATCH_DETAIL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_MATCH_DETAIL = 2
     * }
     */
    public static int G_SIGNAL_MATCH_DETAIL() {
        return G_SIGNAL_MATCH_DETAIL;
    }
    private static final int G_SIGNAL_MATCH_CLOSURE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_MATCH_CLOSURE = 4
     * }
     */
    public static int G_SIGNAL_MATCH_CLOSURE() {
        return G_SIGNAL_MATCH_CLOSURE;
    }
    private static final int G_SIGNAL_MATCH_FUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_MATCH_FUNC = 8
     * }
     */
    public static int G_SIGNAL_MATCH_FUNC() {
        return G_SIGNAL_MATCH_FUNC;
    }
    private static final int G_SIGNAL_MATCH_DATA = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_MATCH_DATA = 16
     * }
     */
    public static int G_SIGNAL_MATCH_DATA() {
        return G_SIGNAL_MATCH_DATA;
    }
    private static final int G_SIGNAL_MATCH_UNBLOCKED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SIGNAL_MATCH_UNBLOCKED = 32
     * }
     */
    public static int G_SIGNAL_MATCH_UNBLOCKED() {
        return G_SIGNAL_MATCH_UNBLOCKED;
    }

    private static class g_signal_newv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_newv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_signal_newv(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types)
     * }
     */
    public static FunctionDescriptor g_signal_newv$descriptor() {
        return g_signal_newv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_signal_newv(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types)
     * }
     */
    public static MethodHandle g_signal_newv$handle() {
        return g_signal_newv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_signal_newv(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types)
     * }
     */
    public static MemorySegment g_signal_newv$address() {
        return g_signal_newv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_signal_newv(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types)
     * }
     */
    public static int g_signal_newv(MemorySegment signal_name, long itype, int signal_flags, MemorySegment class_closure, MemorySegment accumulator, MemorySegment accu_data, MemorySegment c_marshaller, long return_type, int n_params, MemorySegment param_types) {
        var mh$ = g_signal_newv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_newv", signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, param_types);
            }
            return (int)mh$.invokeExact(signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, param_types);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_new_valist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_new_valist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_signal_new_valist(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args)
     * }
     */
    public static FunctionDescriptor g_signal_new_valist$descriptor() {
        return g_signal_new_valist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_signal_new_valist(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args)
     * }
     */
    public static MethodHandle g_signal_new_valist$handle() {
        return g_signal_new_valist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_signal_new_valist(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args)
     * }
     */
    public static MemorySegment g_signal_new_valist$address() {
        return g_signal_new_valist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_signal_new_valist(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args)
     * }
     */
    public static int g_signal_new_valist(MemorySegment signal_name, long itype, int signal_flags, MemorySegment class_closure, MemorySegment accumulator, MemorySegment accu_data, MemorySegment c_marshaller, long return_type, int n_params, MemorySegment args) {
        var mh$ = g_signal_new_valist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_new_valist", signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, args);
            }
            return (int)mh$.invokeExact(signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern guint g_signal_new(const gchar *signal_name, GType itype, GSignalFlags signal_flags, guint class_offset, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, ...)
     * }
     */
    public static class g_signal_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_LONG_LONG,
                gst_min_h.C_INT,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_LONG_LONG,
                gst_min_h.C_INT
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_signal_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern guint g_signal_new(const gchar *signal_name, GType itype, GSignalFlags signal_flags, guint class_offset, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, ...)
         * }
         */
        public static g_signal_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_signal_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment signal_name, long itype, int signal_flags, int class_offset, MemorySegment accumulator, MemorySegment accu_data, MemorySegment c_marshaller, long return_type, int n_params, Object... x9) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_signal_new", signal_name, itype, signal_flags, class_offset, accumulator, accu_data, c_marshaller, return_type, n_params, x9);
                }
                return (int) spreader.invokeExact(signal_name, itype, signal_flags, class_offset, accumulator, accu_data, c_marshaller, return_type, n_params, x9);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern guint g_signal_new_class_handler(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GCallback class_handler, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, ...)
     * }
     */
    public static class g_signal_new_class_handler {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_LONG_LONG,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_LONG_LONG,
                gst_min_h.C_INT
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_new_class_handler");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_signal_new_class_handler(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern guint g_signal_new_class_handler(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GCallback class_handler, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, ...)
         * }
         */
        public static g_signal_new_class_handler makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_signal_new_class_handler(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment signal_name, long itype, int signal_flags, MemorySegment class_handler, MemorySegment accumulator, MemorySegment accu_data, MemorySegment c_marshaller, long return_type, int n_params, Object... x9) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_signal_new_class_handler", signal_name, itype, signal_flags, class_handler, accumulator, accu_data, c_marshaller, return_type, n_params, x9);
                }
                return (int) spreader.invokeExact(signal_name, itype, signal_flags, class_handler, accumulator, accu_data, c_marshaller, return_type, n_params, x9);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_signal_set_va_marshaller {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_set_va_marshaller");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_set_va_marshaller(guint signal_id, GType instance_type, GSignalCVaMarshaller va_marshaller)
     * }
     */
    public static FunctionDescriptor g_signal_set_va_marshaller$descriptor() {
        return g_signal_set_va_marshaller.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_set_va_marshaller(guint signal_id, GType instance_type, GSignalCVaMarshaller va_marshaller)
     * }
     */
    public static MethodHandle g_signal_set_va_marshaller$handle() {
        return g_signal_set_va_marshaller.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_set_va_marshaller(guint signal_id, GType instance_type, GSignalCVaMarshaller va_marshaller)
     * }
     */
    public static MemorySegment g_signal_set_va_marshaller$address() {
        return g_signal_set_va_marshaller.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_set_va_marshaller(guint signal_id, GType instance_type, GSignalCVaMarshaller va_marshaller)
     * }
     */
    public static void g_signal_set_va_marshaller(int signal_id, long instance_type, MemorySegment va_marshaller) {
        var mh$ = g_signal_set_va_marshaller.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_set_va_marshaller", signal_id, instance_type, va_marshaller);
            }
            mh$.invokeExact(signal_id, instance_type, va_marshaller);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_emitv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_emitv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_emitv(const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value)
     * }
     */
    public static FunctionDescriptor g_signal_emitv$descriptor() {
        return g_signal_emitv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_emitv(const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value)
     * }
     */
    public static MethodHandle g_signal_emitv$handle() {
        return g_signal_emitv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_emitv(const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value)
     * }
     */
    public static MemorySegment g_signal_emitv$address() {
        return g_signal_emitv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_emitv(const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value)
     * }
     */
    public static void g_signal_emitv(MemorySegment instance_and_params, int signal_id, int detail, MemorySegment return_value) {
        var mh$ = g_signal_emitv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_emitv", instance_and_params, signal_id, detail, return_value);
            }
            mh$.invokeExact(instance_and_params, signal_id, detail, return_value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_emit_valist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_emit_valist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_emit_valist(gpointer instance, guint signal_id, GQuark detail, va_list var_args)
     * }
     */
    public static FunctionDescriptor g_signal_emit_valist$descriptor() {
        return g_signal_emit_valist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_emit_valist(gpointer instance, guint signal_id, GQuark detail, va_list var_args)
     * }
     */
    public static MethodHandle g_signal_emit_valist$handle() {
        return g_signal_emit_valist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_emit_valist(gpointer instance, guint signal_id, GQuark detail, va_list var_args)
     * }
     */
    public static MemorySegment g_signal_emit_valist$address() {
        return g_signal_emit_valist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_emit_valist(gpointer instance, guint signal_id, GQuark detail, va_list var_args)
     * }
     */
    public static void g_signal_emit_valist(MemorySegment instance, int signal_id, int detail, MemorySegment var_args) {
        var mh$ = g_signal_emit_valist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_emit_valist", instance, signal_id, detail, var_args);
            }
            mh$.invokeExact(instance, signal_id, detail, var_args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_signal_emit(gpointer instance, guint signal_id, GQuark detail, ...)
     * }
     */
    public static class g_signal_emit {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_INT,
                gst_min_h.C_INT
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_emit");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_signal_emit(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_signal_emit(gpointer instance, guint signal_id, GQuark detail, ...)
         * }
         */
        public static g_signal_emit makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_signal_emit(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment instance, int signal_id, int detail, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_signal_emit", instance, signal_id, detail, x3);
                }
                 spreader.invokeExact(instance, signal_id, detail, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_signal_emit_by_name(gpointer instance, const gchar *detailed_signal, ...)
     * }
     */
    public static class g_signal_emit_by_name {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_emit_by_name");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_signal_emit_by_name(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_signal_emit_by_name(gpointer instance, const gchar *detailed_signal, ...)
         * }
         */
        public static g_signal_emit_by_name makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_signal_emit_by_name(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment instance, MemorySegment detailed_signal, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_signal_emit_by_name", instance, detailed_signal, x2);
                }
                 spreader.invokeExact(instance, detailed_signal, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_signal_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_signal_lookup(const gchar *name, GType itype)
     * }
     */
    public static FunctionDescriptor g_signal_lookup$descriptor() {
        return g_signal_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_signal_lookup(const gchar *name, GType itype)
     * }
     */
    public static MethodHandle g_signal_lookup$handle() {
        return g_signal_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_signal_lookup(const gchar *name, GType itype)
     * }
     */
    public static MemorySegment g_signal_lookup$address() {
        return g_signal_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_signal_lookup(const gchar *name, GType itype)
     * }
     */
    public static int g_signal_lookup(MemorySegment name, long itype) {
        var mh$ = g_signal_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_lookup", name, itype);
            }
            return (int)mh$.invokeExact(name, itype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_signal_name(guint signal_id)
     * }
     */
    public static FunctionDescriptor g_signal_name$descriptor() {
        return g_signal_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_signal_name(guint signal_id)
     * }
     */
    public static MethodHandle g_signal_name$handle() {
        return g_signal_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_signal_name(guint signal_id)
     * }
     */
    public static MemorySegment g_signal_name$address() {
        return g_signal_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_signal_name(guint signal_id)
     * }
     */
    public static MemorySegment g_signal_name(int signal_id) {
        var mh$ = g_signal_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_name", signal_id);
            }
            return (MemorySegment)mh$.invokeExact(signal_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_query(guint signal_id, GSignalQuery *query)
     * }
     */
    public static FunctionDescriptor g_signal_query$descriptor() {
        return g_signal_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_query(guint signal_id, GSignalQuery *query)
     * }
     */
    public static MethodHandle g_signal_query$handle() {
        return g_signal_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_query(guint signal_id, GSignalQuery *query)
     * }
     */
    public static MemorySegment g_signal_query$address() {
        return g_signal_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_query(guint signal_id, GSignalQuery *query)
     * }
     */
    public static void g_signal_query(int signal_id, MemorySegment query) {
        var mh$ = g_signal_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_query", signal_id, query);
            }
            mh$.invokeExact(signal_id, query);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_list_ids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_list_ids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint *g_signal_list_ids(GType itype, guint *n_ids)
     * }
     */
    public static FunctionDescriptor g_signal_list_ids$descriptor() {
        return g_signal_list_ids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint *g_signal_list_ids(GType itype, guint *n_ids)
     * }
     */
    public static MethodHandle g_signal_list_ids$handle() {
        return g_signal_list_ids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint *g_signal_list_ids(GType itype, guint *n_ids)
     * }
     */
    public static MemorySegment g_signal_list_ids$address() {
        return g_signal_list_ids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint *g_signal_list_ids(GType itype, guint *n_ids)
     * }
     */
    public static MemorySegment g_signal_list_ids(long itype, MemorySegment n_ids) {
        var mh$ = g_signal_list_ids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_list_ids", itype, n_ids);
            }
            return (MemorySegment)mh$.invokeExact(itype, n_ids);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_is_valid_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_is_valid_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_signal_is_valid_name(const gchar *name)
     * }
     */
    public static FunctionDescriptor g_signal_is_valid_name$descriptor() {
        return g_signal_is_valid_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_signal_is_valid_name(const gchar *name)
     * }
     */
    public static MethodHandle g_signal_is_valid_name$handle() {
        return g_signal_is_valid_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_signal_is_valid_name(const gchar *name)
     * }
     */
    public static MemorySegment g_signal_is_valid_name$address() {
        return g_signal_is_valid_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_signal_is_valid_name(const gchar *name)
     * }
     */
    public static int g_signal_is_valid_name(MemorySegment name) {
        var mh$ = g_signal_is_valid_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_is_valid_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_parse_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_parse_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_signal_parse_name(const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark)
     * }
     */
    public static FunctionDescriptor g_signal_parse_name$descriptor() {
        return g_signal_parse_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_signal_parse_name(const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark)
     * }
     */
    public static MethodHandle g_signal_parse_name$handle() {
        return g_signal_parse_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_signal_parse_name(const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark)
     * }
     */
    public static MemorySegment g_signal_parse_name$address() {
        return g_signal_parse_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_signal_parse_name(const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark)
     * }
     */
    public static int g_signal_parse_name(MemorySegment detailed_signal, long itype, MemorySegment signal_id_p, MemorySegment detail_p, int force_detail_quark) {
        var mh$ = g_signal_parse_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_parse_name", detailed_signal, itype, signal_id_p, detail_p, force_detail_quark);
            }
            return (int)mh$.invokeExact(detailed_signal, itype, signal_id_p, detail_p, force_detail_quark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_get_invocation_hint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_get_invocation_hint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSignalInvocationHint *g_signal_get_invocation_hint(gpointer instance)
     * }
     */
    public static FunctionDescriptor g_signal_get_invocation_hint$descriptor() {
        return g_signal_get_invocation_hint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSignalInvocationHint *g_signal_get_invocation_hint(gpointer instance)
     * }
     */
    public static MethodHandle g_signal_get_invocation_hint$handle() {
        return g_signal_get_invocation_hint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSignalInvocationHint *g_signal_get_invocation_hint(gpointer instance)
     * }
     */
    public static MemorySegment g_signal_get_invocation_hint$address() {
        return g_signal_get_invocation_hint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSignalInvocationHint *g_signal_get_invocation_hint(gpointer instance)
     * }
     */
    public static MemorySegment g_signal_get_invocation_hint(MemorySegment instance) {
        var mh$ = g_signal_get_invocation_hint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_get_invocation_hint", instance);
            }
            return (MemorySegment)mh$.invokeExact(instance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_stop_emission {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_stop_emission");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_stop_emission(gpointer instance, guint signal_id, GQuark detail)
     * }
     */
    public static FunctionDescriptor g_signal_stop_emission$descriptor() {
        return g_signal_stop_emission.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_stop_emission(gpointer instance, guint signal_id, GQuark detail)
     * }
     */
    public static MethodHandle g_signal_stop_emission$handle() {
        return g_signal_stop_emission.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_stop_emission(gpointer instance, guint signal_id, GQuark detail)
     * }
     */
    public static MemorySegment g_signal_stop_emission$address() {
        return g_signal_stop_emission.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_stop_emission(gpointer instance, guint signal_id, GQuark detail)
     * }
     */
    public static void g_signal_stop_emission(MemorySegment instance, int signal_id, int detail) {
        var mh$ = g_signal_stop_emission.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_stop_emission", instance, signal_id, detail);
            }
            mh$.invokeExact(instance, signal_id, detail);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_stop_emission_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_stop_emission_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_stop_emission_by_name(gpointer instance, const gchar *detailed_signal)
     * }
     */
    public static FunctionDescriptor g_signal_stop_emission_by_name$descriptor() {
        return g_signal_stop_emission_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_stop_emission_by_name(gpointer instance, const gchar *detailed_signal)
     * }
     */
    public static MethodHandle g_signal_stop_emission_by_name$handle() {
        return g_signal_stop_emission_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_stop_emission_by_name(gpointer instance, const gchar *detailed_signal)
     * }
     */
    public static MemorySegment g_signal_stop_emission_by_name$address() {
        return g_signal_stop_emission_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_stop_emission_by_name(gpointer instance, const gchar *detailed_signal)
     * }
     */
    public static void g_signal_stop_emission_by_name(MemorySegment instance, MemorySegment detailed_signal) {
        var mh$ = g_signal_stop_emission_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_stop_emission_by_name", instance, detailed_signal);
            }
            mh$.invokeExact(instance, detailed_signal);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_add_emission_hook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_add_emission_hook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gulong g_signal_add_emission_hook(guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy)
     * }
     */
    public static FunctionDescriptor g_signal_add_emission_hook$descriptor() {
        return g_signal_add_emission_hook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gulong g_signal_add_emission_hook(guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy)
     * }
     */
    public static MethodHandle g_signal_add_emission_hook$handle() {
        return g_signal_add_emission_hook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gulong g_signal_add_emission_hook(guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy)
     * }
     */
    public static MemorySegment g_signal_add_emission_hook$address() {
        return g_signal_add_emission_hook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gulong g_signal_add_emission_hook(guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy)
     * }
     */
    public static int g_signal_add_emission_hook(int signal_id, int detail, MemorySegment hook_func, MemorySegment hook_data, MemorySegment data_destroy) {
        var mh$ = g_signal_add_emission_hook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_add_emission_hook", signal_id, detail, hook_func, hook_data, data_destroy);
            }
            return (int)mh$.invokeExact(signal_id, detail, hook_func, hook_data, data_destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_remove_emission_hook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_remove_emission_hook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_remove_emission_hook(guint signal_id, gulong hook_id)
     * }
     */
    public static FunctionDescriptor g_signal_remove_emission_hook$descriptor() {
        return g_signal_remove_emission_hook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_remove_emission_hook(guint signal_id, gulong hook_id)
     * }
     */
    public static MethodHandle g_signal_remove_emission_hook$handle() {
        return g_signal_remove_emission_hook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_remove_emission_hook(guint signal_id, gulong hook_id)
     * }
     */
    public static MemorySegment g_signal_remove_emission_hook$address() {
        return g_signal_remove_emission_hook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_remove_emission_hook(guint signal_id, gulong hook_id)
     * }
     */
    public static void g_signal_remove_emission_hook(int signal_id, int hook_id) {
        var mh$ = g_signal_remove_emission_hook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_remove_emission_hook", signal_id, hook_id);
            }
            mh$.invokeExact(signal_id, hook_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_has_handler_pending {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_has_handler_pending");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_signal_has_handler_pending(gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked)
     * }
     */
    public static FunctionDescriptor g_signal_has_handler_pending$descriptor() {
        return g_signal_has_handler_pending.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_signal_has_handler_pending(gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked)
     * }
     */
    public static MethodHandle g_signal_has_handler_pending$handle() {
        return g_signal_has_handler_pending.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_signal_has_handler_pending(gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked)
     * }
     */
    public static MemorySegment g_signal_has_handler_pending$address() {
        return g_signal_has_handler_pending.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_signal_has_handler_pending(gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked)
     * }
     */
    public static int g_signal_has_handler_pending(MemorySegment instance, int signal_id, int detail, int may_be_blocked) {
        var mh$ = g_signal_has_handler_pending.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_has_handler_pending", instance, signal_id, detail, may_be_blocked);
            }
            return (int)mh$.invokeExact(instance, signal_id, detail, may_be_blocked);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_connect_closure_by_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_connect_closure_by_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_closure_by_id(gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after)
     * }
     */
    public static FunctionDescriptor g_signal_connect_closure_by_id$descriptor() {
        return g_signal_connect_closure_by_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_closure_by_id(gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after)
     * }
     */
    public static MethodHandle g_signal_connect_closure_by_id$handle() {
        return g_signal_connect_closure_by_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_closure_by_id(gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after)
     * }
     */
    public static MemorySegment g_signal_connect_closure_by_id$address() {
        return g_signal_connect_closure_by_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gulong g_signal_connect_closure_by_id(gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after)
     * }
     */
    public static int g_signal_connect_closure_by_id(MemorySegment instance, int signal_id, int detail, MemorySegment closure, int after) {
        var mh$ = g_signal_connect_closure_by_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_connect_closure_by_id", instance, signal_id, detail, closure, after);
            }
            return (int)mh$.invokeExact(instance, signal_id, detail, closure, after);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_connect_closure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_connect_closure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_closure(gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after)
     * }
     */
    public static FunctionDescriptor g_signal_connect_closure$descriptor() {
        return g_signal_connect_closure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_closure(gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after)
     * }
     */
    public static MethodHandle g_signal_connect_closure$handle() {
        return g_signal_connect_closure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_closure(gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after)
     * }
     */
    public static MemorySegment g_signal_connect_closure$address() {
        return g_signal_connect_closure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gulong g_signal_connect_closure(gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after)
     * }
     */
    public static int g_signal_connect_closure(MemorySegment instance, MemorySegment detailed_signal, MemorySegment closure, int after) {
        var mh$ = g_signal_connect_closure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_connect_closure", instance, detailed_signal, closure, after);
            }
            return (int)mh$.invokeExact(instance, detailed_signal, closure, after);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_connect_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_connect_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_data(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags)
     * }
     */
    public static FunctionDescriptor g_signal_connect_data$descriptor() {
        return g_signal_connect_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_data(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags)
     * }
     */
    public static MethodHandle g_signal_connect_data$handle() {
        return g_signal_connect_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_data(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags)
     * }
     */
    public static MemorySegment g_signal_connect_data$address() {
        return g_signal_connect_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gulong g_signal_connect_data(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags)
     * }
     */
    public static int g_signal_connect_data(MemorySegment instance, MemorySegment detailed_signal, MemorySegment c_handler, MemorySegment data, MemorySegment destroy_data, int connect_flags) {
        var mh$ = g_signal_connect_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_connect_data", instance, detailed_signal, c_handler, data, destroy_data, connect_flags);
            }
            return (int)mh$.invokeExact(instance, detailed_signal, c_handler, data, destroy_data, connect_flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handler_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handler_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_handler_block(gpointer instance, gulong handler_id)
     * }
     */
    public static FunctionDescriptor g_signal_handler_block$descriptor() {
        return g_signal_handler_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_handler_block(gpointer instance, gulong handler_id)
     * }
     */
    public static MethodHandle g_signal_handler_block$handle() {
        return g_signal_handler_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_handler_block(gpointer instance, gulong handler_id)
     * }
     */
    public static MemorySegment g_signal_handler_block$address() {
        return g_signal_handler_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_handler_block(gpointer instance, gulong handler_id)
     * }
     */
    public static void g_signal_handler_block(MemorySegment instance, int handler_id) {
        var mh$ = g_signal_handler_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handler_block", instance, handler_id);
            }
            mh$.invokeExact(instance, handler_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handler_unblock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handler_unblock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_handler_unblock(gpointer instance, gulong handler_id)
     * }
     */
    public static FunctionDescriptor g_signal_handler_unblock$descriptor() {
        return g_signal_handler_unblock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_handler_unblock(gpointer instance, gulong handler_id)
     * }
     */
    public static MethodHandle g_signal_handler_unblock$handle() {
        return g_signal_handler_unblock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_handler_unblock(gpointer instance, gulong handler_id)
     * }
     */
    public static MemorySegment g_signal_handler_unblock$address() {
        return g_signal_handler_unblock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_handler_unblock(gpointer instance, gulong handler_id)
     * }
     */
    public static void g_signal_handler_unblock(MemorySegment instance, int handler_id) {
        var mh$ = g_signal_handler_unblock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handler_unblock", instance, handler_id);
            }
            mh$.invokeExact(instance, handler_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handler_disconnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handler_disconnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_handler_disconnect(gpointer instance, gulong handler_id)
     * }
     */
    public static FunctionDescriptor g_signal_handler_disconnect$descriptor() {
        return g_signal_handler_disconnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_handler_disconnect(gpointer instance, gulong handler_id)
     * }
     */
    public static MethodHandle g_signal_handler_disconnect$handle() {
        return g_signal_handler_disconnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_handler_disconnect(gpointer instance, gulong handler_id)
     * }
     */
    public static MemorySegment g_signal_handler_disconnect$address() {
        return g_signal_handler_disconnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_handler_disconnect(gpointer instance, gulong handler_id)
     * }
     */
    public static void g_signal_handler_disconnect(MemorySegment instance, int handler_id) {
        var mh$ = g_signal_handler_disconnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handler_disconnect", instance, handler_id);
            }
            mh$.invokeExact(instance, handler_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handler_is_connected {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handler_is_connected");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_signal_handler_is_connected(gpointer instance, gulong handler_id)
     * }
     */
    public static FunctionDescriptor g_signal_handler_is_connected$descriptor() {
        return g_signal_handler_is_connected.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_signal_handler_is_connected(gpointer instance, gulong handler_id)
     * }
     */
    public static MethodHandle g_signal_handler_is_connected$handle() {
        return g_signal_handler_is_connected.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_signal_handler_is_connected(gpointer instance, gulong handler_id)
     * }
     */
    public static MemorySegment g_signal_handler_is_connected$address() {
        return g_signal_handler_is_connected.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_signal_handler_is_connected(gpointer instance, gulong handler_id)
     * }
     */
    public static int g_signal_handler_is_connected(MemorySegment instance, int handler_id) {
        var mh$ = g_signal_handler_is_connected.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handler_is_connected", instance, handler_id);
            }
            return (int)mh$.invokeExact(instance, handler_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handler_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handler_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gulong g_signal_handler_find(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_signal_handler_find$descriptor() {
        return g_signal_handler_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gulong g_signal_handler_find(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static MethodHandle g_signal_handler_find$handle() {
        return g_signal_handler_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gulong g_signal_handler_find(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static MemorySegment g_signal_handler_find$address() {
        return g_signal_handler_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gulong g_signal_handler_find(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static int g_signal_handler_find(MemorySegment instance, int mask, int signal_id, int detail, MemorySegment closure, MemorySegment func, MemorySegment data) {
        var mh$ = g_signal_handler_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handler_find", instance, mask, signal_id, detail, closure, func, data);
            }
            return (int)mh$.invokeExact(instance, mask, signal_id, detail, closure, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handlers_block_matched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handlers_block_matched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_block_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_signal_handlers_block_matched$descriptor() {
        return g_signal_handlers_block_matched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_block_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static MethodHandle g_signal_handlers_block_matched$handle() {
        return g_signal_handlers_block_matched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_block_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static MemorySegment g_signal_handlers_block_matched$address() {
        return g_signal_handlers_block_matched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_signal_handlers_block_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static int g_signal_handlers_block_matched(MemorySegment instance, int mask, int signal_id, int detail, MemorySegment closure, MemorySegment func, MemorySegment data) {
        var mh$ = g_signal_handlers_block_matched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handlers_block_matched", instance, mask, signal_id, detail, closure, func, data);
            }
            return (int)mh$.invokeExact(instance, mask, signal_id, detail, closure, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handlers_unblock_matched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handlers_unblock_matched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_unblock_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_signal_handlers_unblock_matched$descriptor() {
        return g_signal_handlers_unblock_matched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_unblock_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static MethodHandle g_signal_handlers_unblock_matched$handle() {
        return g_signal_handlers_unblock_matched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_unblock_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static MemorySegment g_signal_handlers_unblock_matched$address() {
        return g_signal_handlers_unblock_matched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_signal_handlers_unblock_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static int g_signal_handlers_unblock_matched(MemorySegment instance, int mask, int signal_id, int detail, MemorySegment closure, MemorySegment func, MemorySegment data) {
        var mh$ = g_signal_handlers_unblock_matched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handlers_unblock_matched", instance, mask, signal_id, detail, closure, func, data);
            }
            return (int)mh$.invokeExact(instance, mask, signal_id, detail, closure, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handlers_disconnect_matched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handlers_disconnect_matched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_disconnect_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_signal_handlers_disconnect_matched$descriptor() {
        return g_signal_handlers_disconnect_matched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_disconnect_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static MethodHandle g_signal_handlers_disconnect_matched$handle() {
        return g_signal_handlers_disconnect_matched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_signal_handlers_disconnect_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static MemorySegment g_signal_handlers_disconnect_matched$address() {
        return g_signal_handlers_disconnect_matched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_signal_handlers_disconnect_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data)
     * }
     */
    public static int g_signal_handlers_disconnect_matched(MemorySegment instance, int mask, int signal_id, int detail, MemorySegment closure, MemorySegment func, MemorySegment data) {
        var mh$ = g_signal_handlers_disconnect_matched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handlers_disconnect_matched", instance, mask, signal_id, detail, closure, func, data);
            }
            return (int)mh$.invokeExact(instance, mask, signal_id, detail, closure, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_clear_signal_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_clear_signal_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_clear_signal_handler(gulong *handler_id_ptr, gpointer instance)
     * }
     */
    public static FunctionDescriptor g_clear_signal_handler$descriptor() {
        return g_clear_signal_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_clear_signal_handler(gulong *handler_id_ptr, gpointer instance)
     * }
     */
    public static MethodHandle g_clear_signal_handler$handle() {
        return g_clear_signal_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_clear_signal_handler(gulong *handler_id_ptr, gpointer instance)
     * }
     */
    public static MemorySegment g_clear_signal_handler$address() {
        return g_clear_signal_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_clear_signal_handler(gulong *handler_id_ptr, gpointer instance)
     * }
     */
    public static void g_clear_signal_handler(MemorySegment handler_id_ptr, MemorySegment instance) {
        var mh$ = g_clear_signal_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_clear_signal_handler", handler_id_ptr, instance);
            }
            mh$.invokeExact(handler_id_ptr, instance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_override_class_closure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_override_class_closure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_override_class_closure(guint signal_id, GType instance_type, GClosure *class_closure)
     * }
     */
    public static FunctionDescriptor g_signal_override_class_closure$descriptor() {
        return g_signal_override_class_closure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_override_class_closure(guint signal_id, GType instance_type, GClosure *class_closure)
     * }
     */
    public static MethodHandle g_signal_override_class_closure$handle() {
        return g_signal_override_class_closure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_override_class_closure(guint signal_id, GType instance_type, GClosure *class_closure)
     * }
     */
    public static MemorySegment g_signal_override_class_closure$address() {
        return g_signal_override_class_closure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_override_class_closure(guint signal_id, GType instance_type, GClosure *class_closure)
     * }
     */
    public static void g_signal_override_class_closure(int signal_id, long instance_type, MemorySegment class_closure) {
        var mh$ = g_signal_override_class_closure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_override_class_closure", signal_id, instance_type, class_closure);
            }
            mh$.invokeExact(signal_id, instance_type, class_closure);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_override_class_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_override_class_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_override_class_handler(const gchar *signal_name, GType instance_type, GCallback class_handler)
     * }
     */
    public static FunctionDescriptor g_signal_override_class_handler$descriptor() {
        return g_signal_override_class_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_override_class_handler(const gchar *signal_name, GType instance_type, GCallback class_handler)
     * }
     */
    public static MethodHandle g_signal_override_class_handler$handle() {
        return g_signal_override_class_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_override_class_handler(const gchar *signal_name, GType instance_type, GCallback class_handler)
     * }
     */
    public static MemorySegment g_signal_override_class_handler$address() {
        return g_signal_override_class_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_override_class_handler(const gchar *signal_name, GType instance_type, GCallback class_handler)
     * }
     */
    public static void g_signal_override_class_handler(MemorySegment signal_name, long instance_type, MemorySegment class_handler) {
        var mh$ = g_signal_override_class_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_override_class_handler", signal_name, instance_type, class_handler);
            }
            mh$.invokeExact(signal_name, instance_type, class_handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_chain_from_overridden {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_chain_from_overridden");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_chain_from_overridden(const GValue *instance_and_params, GValue *return_value)
     * }
     */
    public static FunctionDescriptor g_signal_chain_from_overridden$descriptor() {
        return g_signal_chain_from_overridden.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_chain_from_overridden(const GValue *instance_and_params, GValue *return_value)
     * }
     */
    public static MethodHandle g_signal_chain_from_overridden$handle() {
        return g_signal_chain_from_overridden.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_chain_from_overridden(const GValue *instance_and_params, GValue *return_value)
     * }
     */
    public static MemorySegment g_signal_chain_from_overridden$address() {
        return g_signal_chain_from_overridden.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_chain_from_overridden(const GValue *instance_and_params, GValue *return_value)
     * }
     */
    public static void g_signal_chain_from_overridden(MemorySegment instance_and_params, MemorySegment return_value) {
        var mh$ = g_signal_chain_from_overridden.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_chain_from_overridden", instance_and_params, return_value);
            }
            mh$.invokeExact(instance_and_params, return_value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_signal_chain_from_overridden_handler(gpointer instance, ...)
     * }
     */
    public static class g_signal_chain_from_overridden_handler {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_chain_from_overridden_handler");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_signal_chain_from_overridden_handler(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_signal_chain_from_overridden_handler(gpointer instance, ...)
         * }
         */
        public static g_signal_chain_from_overridden_handler makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_signal_chain_from_overridden_handler(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment instance, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_signal_chain_from_overridden_handler", instance, x1);
                }
                 spreader.invokeExact(instance, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_signal_accumulator_true_handled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_accumulator_true_handled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_signal_accumulator_true_handled(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy)
     * }
     */
    public static FunctionDescriptor g_signal_accumulator_true_handled$descriptor() {
        return g_signal_accumulator_true_handled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_signal_accumulator_true_handled(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy)
     * }
     */
    public static MethodHandle g_signal_accumulator_true_handled$handle() {
        return g_signal_accumulator_true_handled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_signal_accumulator_true_handled(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy)
     * }
     */
    public static MemorySegment g_signal_accumulator_true_handled$address() {
        return g_signal_accumulator_true_handled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_signal_accumulator_true_handled(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy)
     * }
     */
    public static int g_signal_accumulator_true_handled(MemorySegment ihint, MemorySegment return_accu, MemorySegment handler_return, MemorySegment dummy) {
        var mh$ = g_signal_accumulator_true_handled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_accumulator_true_handled", ihint, return_accu, handler_return, dummy);
            }
            return (int)mh$.invokeExact(ihint, return_accu, handler_return, dummy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_accumulator_first_wins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_accumulator_first_wins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_signal_accumulator_first_wins(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy)
     * }
     */
    public static FunctionDescriptor g_signal_accumulator_first_wins$descriptor() {
        return g_signal_accumulator_first_wins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_signal_accumulator_first_wins(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy)
     * }
     */
    public static MethodHandle g_signal_accumulator_first_wins$handle() {
        return g_signal_accumulator_first_wins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_signal_accumulator_first_wins(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy)
     * }
     */
    public static MemorySegment g_signal_accumulator_first_wins$address() {
        return g_signal_accumulator_first_wins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_signal_accumulator_first_wins(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy)
     * }
     */
    public static int g_signal_accumulator_first_wins(MemorySegment ihint, MemorySegment return_accu, MemorySegment handler_return, MemorySegment dummy) {
        var mh$ = g_signal_accumulator_first_wins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_accumulator_first_wins", ihint, return_accu, handler_return, dummy);
            }
            return (int)mh$.invokeExact(ihint, return_accu, handler_return, dummy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_handlers_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_handlers_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_signal_handlers_destroy(gpointer instance)
     * }
     */
    public static FunctionDescriptor g_signal_handlers_destroy$descriptor() {
        return g_signal_handlers_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_signal_handlers_destroy(gpointer instance)
     * }
     */
    public static MethodHandle g_signal_handlers_destroy$handle() {
        return g_signal_handlers_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_signal_handlers_destroy(gpointer instance)
     * }
     */
    public static MemorySegment g_signal_handlers_destroy$address() {
        return g_signal_handlers_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_signal_handlers_destroy(gpointer instance)
     * }
     */
    public static void g_signal_handlers_destroy(MemorySegment instance) {
        var mh$ = g_signal_handlers_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_handlers_destroy", instance);
            }
            mh$.invokeExact(instance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _g_signals_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_g_signals_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _g_signals_destroy(GType itype)
     * }
     */
    public static FunctionDescriptor _g_signals_destroy$descriptor() {
        return _g_signals_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _g_signals_destroy(GType itype)
     * }
     */
    public static MethodHandle _g_signals_destroy$handle() {
        return _g_signals_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _g_signals_destroy(GType itype)
     * }
     */
    public static MemorySegment _g_signals_destroy$address() {
        return _g_signals_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _g_signals_destroy(GType itype)
     * }
     */
    public static void _g_signals_destroy(long itype) {
        var mh$ = _g_signals_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_g_signals_destroy", itype);
            }
            mh$.invokeExact(itype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_date_get_type()
     * }
     */
    public static FunctionDescriptor g_date_get_type$descriptor() {
        return g_date_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_date_get_type()
     * }
     */
    public static MethodHandle g_date_get_type$handle() {
        return g_date_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_date_get_type()
     * }
     */
    public static MemorySegment g_date_get_type$address() {
        return g_date_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_date_get_type()
     * }
     */
    public static long g_date_get_type() {
        var mh$ = g_date_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_strv_get_type()
     * }
     */
    public static FunctionDescriptor g_strv_get_type$descriptor() {
        return g_strv_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_strv_get_type()
     * }
     */
    public static MethodHandle g_strv_get_type$handle() {
        return g_strv_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_strv_get_type()
     * }
     */
    public static MemorySegment g_strv_get_type$address() {
        return g_strv_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_strv_get_type()
     * }
     */
    public static long g_strv_get_type() {
        var mh$ = g_strv_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_gstring_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_gstring_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_gstring_get_type()
     * }
     */
    public static FunctionDescriptor g_gstring_get_type$descriptor() {
        return g_gstring_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_gstring_get_type()
     * }
     */
    public static MethodHandle g_gstring_get_type$handle() {
        return g_gstring_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_gstring_get_type()
     * }
     */
    public static MemorySegment g_gstring_get_type$address() {
        return g_gstring_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_gstring_get_type()
     * }
     */
    public static long g_gstring_get_type() {
        var mh$ = g_gstring_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_gstring_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_hash_table_get_type()
     * }
     */
    public static FunctionDescriptor g_hash_table_get_type$descriptor() {
        return g_hash_table_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_hash_table_get_type()
     * }
     */
    public static MethodHandle g_hash_table_get_type$handle() {
        return g_hash_table_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_hash_table_get_type()
     * }
     */
    public static MemorySegment g_hash_table_get_type$address() {
        return g_hash_table_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_hash_table_get_type()
     * }
     */
    public static long g_hash_table_get_type() {
        var mh$ = g_hash_table_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_array_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_array_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_array_get_type()
     * }
     */
    public static FunctionDescriptor g_array_get_type$descriptor() {
        return g_array_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_array_get_type()
     * }
     */
    public static MethodHandle g_array_get_type$handle() {
        return g_array_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_array_get_type()
     * }
     */
    public static MemorySegment g_array_get_type$address() {
        return g_array_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_array_get_type()
     * }
     */
    public static long g_array_get_type() {
        var mh$ = g_array_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_array_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_byte_array_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_byte_array_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_byte_array_get_type()
     * }
     */
    public static FunctionDescriptor g_byte_array_get_type$descriptor() {
        return g_byte_array_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_byte_array_get_type()
     * }
     */
    public static MethodHandle g_byte_array_get_type$handle() {
        return g_byte_array_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_byte_array_get_type()
     * }
     */
    public static MemorySegment g_byte_array_get_type$address() {
        return g_byte_array_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_byte_array_get_type()
     * }
     */
    public static long g_byte_array_get_type() {
        var mh$ = g_byte_array_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_byte_array_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ptr_array_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ptr_array_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_ptr_array_get_type()
     * }
     */
    public static FunctionDescriptor g_ptr_array_get_type$descriptor() {
        return g_ptr_array_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_ptr_array_get_type()
     * }
     */
    public static MethodHandle g_ptr_array_get_type$handle() {
        return g_ptr_array_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_ptr_array_get_type()
     * }
     */
    public static MemorySegment g_ptr_array_get_type$address() {
        return g_ptr_array_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_ptr_array_get_type()
     * }
     */
    public static long g_ptr_array_get_type() {
        var mh$ = g_ptr_array_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ptr_array_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_bytes_get_type()
     * }
     */
    public static FunctionDescriptor g_bytes_get_type$descriptor() {
        return g_bytes_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_bytes_get_type()
     * }
     */
    public static MethodHandle g_bytes_get_type$handle() {
        return g_bytes_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_bytes_get_type()
     * }
     */
    public static MemorySegment g_bytes_get_type$address() {
        return g_bytes_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_bytes_get_type()
     * }
     */
    public static long g_bytes_get_type() {
        var mh$ = g_bytes_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_get_gtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_get_gtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_variant_type_get_gtype()
     * }
     */
    public static FunctionDescriptor g_variant_type_get_gtype$descriptor() {
        return g_variant_type_get_gtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_variant_type_get_gtype()
     * }
     */
    public static MethodHandle g_variant_type_get_gtype$handle() {
        return g_variant_type_get_gtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_variant_type_get_gtype()
     * }
     */
    public static MemorySegment g_variant_type_get_gtype$address() {
        return g_variant_type_get_gtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_variant_type_get_gtype()
     * }
     */
    public static long g_variant_type_get_gtype() {
        var mh$ = g_variant_type_get_gtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_get_gtype");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_regex_get_type()
     * }
     */
    public static FunctionDescriptor g_regex_get_type$descriptor() {
        return g_regex_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_regex_get_type()
     * }
     */
    public static MethodHandle g_regex_get_type$handle() {
        return g_regex_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_regex_get_type()
     * }
     */
    public static MemorySegment g_regex_get_type$address() {
        return g_regex_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_regex_get_type()
     * }
     */
    public static long g_regex_get_type() {
        var mh$ = g_regex_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_match_info_get_type()
     * }
     */
    public static FunctionDescriptor g_match_info_get_type$descriptor() {
        return g_match_info_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_match_info_get_type()
     * }
     */
    public static MethodHandle g_match_info_get_type$handle() {
        return g_match_info_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_match_info_get_type()
     * }
     */
    public static MemorySegment g_match_info_get_type$address() {
        return g_match_info_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_match_info_get_type()
     * }
     */
    public static long g_match_info_get_type() {
        var mh$ = g_match_info_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_error_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_error_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_error_get_type()
     * }
     */
    public static FunctionDescriptor g_error_get_type$descriptor() {
        return g_error_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_error_get_type()
     * }
     */
    public static MethodHandle g_error_get_type$handle() {
        return g_error_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_error_get_type()
     * }
     */
    public static MemorySegment g_error_get_type$address() {
        return g_error_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_error_get_type()
     * }
     */
    public static long g_error_get_type() {
        var mh$ = g_error_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_error_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_time_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_time_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_date_time_get_type()
     * }
     */
    public static FunctionDescriptor g_date_time_get_type$descriptor() {
        return g_date_time_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_date_time_get_type()
     * }
     */
    public static MethodHandle g_date_time_get_type$handle() {
        return g_date_time_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_date_time_get_type()
     * }
     */
    public static MemorySegment g_date_time_get_type$address() {
        return g_date_time_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_date_time_get_type()
     * }
     */
    public static long g_date_time_get_type() {
        var mh$ = g_date_time_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_time_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_time_zone_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_time_zone_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_time_zone_get_type()
     * }
     */
    public static FunctionDescriptor g_time_zone_get_type$descriptor() {
        return g_time_zone_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_time_zone_get_type()
     * }
     */
    public static MethodHandle g_time_zone_get_type$handle() {
        return g_time_zone_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_time_zone_get_type()
     * }
     */
    public static MemorySegment g_time_zone_get_type$address() {
        return g_time_zone_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_time_zone_get_type()
     * }
     */
    public static long g_time_zone_get_type() {
        var mh$ = g_time_zone_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_time_zone_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_io_channel_get_type()
     * }
     */
    public static FunctionDescriptor g_io_channel_get_type$descriptor() {
        return g_io_channel_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_io_channel_get_type()
     * }
     */
    public static MethodHandle g_io_channel_get_type$handle() {
        return g_io_channel_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_io_channel_get_type()
     * }
     */
    public static MemorySegment g_io_channel_get_type$address() {
        return g_io_channel_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_io_channel_get_type()
     * }
     */
    public static long g_io_channel_get_type() {
        var mh$ = g_io_channel_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_condition_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_condition_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_io_condition_get_type()
     * }
     */
    public static FunctionDescriptor g_io_condition_get_type$descriptor() {
        return g_io_condition_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_io_condition_get_type()
     * }
     */
    public static MethodHandle g_io_condition_get_type$handle() {
        return g_io_condition_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_io_condition_get_type()
     * }
     */
    public static MemorySegment g_io_condition_get_type$address() {
        return g_io_condition_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_io_condition_get_type()
     * }
     */
    public static long g_io_condition_get_type() {
        var mh$ = g_io_condition_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_condition_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_variant_builder_get_type()
     * }
     */
    public static FunctionDescriptor g_variant_builder_get_type$descriptor() {
        return g_variant_builder_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_variant_builder_get_type()
     * }
     */
    public static MethodHandle g_variant_builder_get_type$handle() {
        return g_variant_builder_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_variant_builder_get_type()
     * }
     */
    public static MemorySegment g_variant_builder_get_type$address() {
        return g_variant_builder_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_variant_builder_get_type()
     * }
     */
    public static long g_variant_builder_get_type() {
        var mh$ = g_variant_builder_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_variant_dict_get_type()
     * }
     */
    public static FunctionDescriptor g_variant_dict_get_type$descriptor() {
        return g_variant_dict_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_variant_dict_get_type()
     * }
     */
    public static MethodHandle g_variant_dict_get_type$handle() {
        return g_variant_dict_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_variant_dict_get_type()
     * }
     */
    public static MemorySegment g_variant_dict_get_type$address() {
        return g_variant_dict_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_variant_dict_get_type()
     * }
     */
    public static long g_variant_dict_get_type() {
        var mh$ = g_variant_dict_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_key_file_get_type()
     * }
     */
    public static FunctionDescriptor g_key_file_get_type$descriptor() {
        return g_key_file_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_key_file_get_type()
     * }
     */
    public static MethodHandle g_key_file_get_type$handle() {
        return g_key_file_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_key_file_get_type()
     * }
     */
    public static MemorySegment g_key_file_get_type$address() {
        return g_key_file_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_key_file_get_type()
     * }
     */
    public static long g_key_file_get_type() {
        var mh$ = g_key_file_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_loop_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_loop_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_main_loop_get_type()
     * }
     */
    public static FunctionDescriptor g_main_loop_get_type$descriptor() {
        return g_main_loop_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_main_loop_get_type()
     * }
     */
    public static MethodHandle g_main_loop_get_type$handle() {
        return g_main_loop_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_main_loop_get_type()
     * }
     */
    public static MemorySegment g_main_loop_get_type$address() {
        return g_main_loop_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_main_loop_get_type()
     * }
     */
    public static long g_main_loop_get_type() {
        var mh$ = g_main_loop_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_loop_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_main_context_get_type()
     * }
     */
    public static FunctionDescriptor g_main_context_get_type$descriptor() {
        return g_main_context_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_main_context_get_type()
     * }
     */
    public static MethodHandle g_main_context_get_type$handle() {
        return g_main_context_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_main_context_get_type()
     * }
     */
    public static MemorySegment g_main_context_get_type$address() {
        return g_main_context_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_main_context_get_type()
     * }
     */
    public static long g_main_context_get_type() {
        var mh$ = g_main_context_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_source_get_type()
     * }
     */
    public static FunctionDescriptor g_source_get_type$descriptor() {
        return g_source_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_source_get_type()
     * }
     */
    public static MethodHandle g_source_get_type$handle() {
        return g_source_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_source_get_type()
     * }
     */
    public static MemorySegment g_source_get_type$address() {
        return g_source_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_source_get_type()
     * }
     */
    public static long g_source_get_type() {
        var mh$ = g_source_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pollfd_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pollfd_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_pollfd_get_type()
     * }
     */
    public static FunctionDescriptor g_pollfd_get_type$descriptor() {
        return g_pollfd_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_pollfd_get_type()
     * }
     */
    public static MethodHandle g_pollfd_get_type$handle() {
        return g_pollfd_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_pollfd_get_type()
     * }
     */
    public static MemorySegment g_pollfd_get_type$address() {
        return g_pollfd_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_pollfd_get_type()
     * }
     */
    public static long g_pollfd_get_type() {
        var mh$ = g_pollfd_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pollfd_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_thread_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_thread_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_thread_get_type()
     * }
     */
    public static FunctionDescriptor g_thread_get_type$descriptor() {
        return g_thread_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_thread_get_type()
     * }
     */
    public static MethodHandle g_thread_get_type$handle() {
        return g_thread_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_thread_get_type()
     * }
     */
    public static MemorySegment g_thread_get_type$address() {
        return g_thread_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_thread_get_type()
     * }
     */
    public static long g_thread_get_type() {
        var mh$ = g_thread_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_thread_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_checksum_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_checksum_get_type()
     * }
     */
    public static FunctionDescriptor g_checksum_get_type$descriptor() {
        return g_checksum_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_checksum_get_type()
     * }
     */
    public static MethodHandle g_checksum_get_type$handle() {
        return g_checksum_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_checksum_get_type()
     * }
     */
    public static MemorySegment g_checksum_get_type$address() {
        return g_checksum_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_checksum_get_type()
     * }
     */
    public static long g_checksum_get_type() {
        var mh$ = g_checksum_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_markup_parse_context_get_type()
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_get_type$descriptor() {
        return g_markup_parse_context_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_markup_parse_context_get_type()
     * }
     */
    public static MethodHandle g_markup_parse_context_get_type$handle() {
        return g_markup_parse_context_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_markup_parse_context_get_type()
     * }
     */
    public static MemorySegment g_markup_parse_context_get_type$address() {
        return g_markup_parse_context_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_markup_parse_context_get_type()
     * }
     */
    public static long g_markup_parse_context_get_type() {
        var mh$ = g_markup_parse_context_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_mapped_file_get_type()
     * }
     */
    public static FunctionDescriptor g_mapped_file_get_type$descriptor() {
        return g_mapped_file_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_mapped_file_get_type()
     * }
     */
    public static MethodHandle g_mapped_file_get_type$handle() {
        return g_mapped_file_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_mapped_file_get_type()
     * }
     */
    public static MemorySegment g_mapped_file_get_type$address() {
        return g_mapped_file_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_mapped_file_get_type()
     * }
     */
    public static long g_mapped_file_get_type() {
        var mh$ = g_mapped_file_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_option_group_get_type()
     * }
     */
    public static FunctionDescriptor g_option_group_get_type$descriptor() {
        return g_option_group_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_option_group_get_type()
     * }
     */
    public static MethodHandle g_option_group_get_type$handle() {
        return g_option_group_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_option_group_get_type()
     * }
     */
    public static MemorySegment g_option_group_get_type$address() {
        return g_option_group_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_option_group_get_type()
     * }
     */
    public static long g_option_group_get_type() {
        var mh$ = g_option_group_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_uri_get_type()
     * }
     */
    public static FunctionDescriptor g_uri_get_type$descriptor() {
        return g_uri_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_uri_get_type()
     * }
     */
    public static MethodHandle g_uri_get_type$handle() {
        return g_uri_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_uri_get_type()
     * }
     */
    public static MemorySegment g_uri_get_type$address() {
        return g_uri_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_uri_get_type()
     * }
     */
    public static long g_uri_get_type() {
        var mh$ = g_uri_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_tree_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_tree_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_tree_get_type()
     * }
     */
    public static FunctionDescriptor g_tree_get_type$descriptor() {
        return g_tree_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_tree_get_type()
     * }
     */
    public static MethodHandle g_tree_get_type$handle() {
        return g_tree_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_tree_get_type()
     * }
     */
    public static MemorySegment g_tree_get_type$address() {
        return g_tree_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_tree_get_type()
     * }
     */
    public static long g_tree_get_type() {
        var mh$ = g_tree_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_tree_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_spec_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_spec_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_pattern_spec_get_type()
     * }
     */
    public static FunctionDescriptor g_pattern_spec_get_type$descriptor() {
        return g_pattern_spec_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_pattern_spec_get_type()
     * }
     */
    public static MethodHandle g_pattern_spec_get_type$handle() {
        return g_pattern_spec_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_pattern_spec_get_type()
     * }
     */
    public static MemorySegment g_pattern_spec_get_type$address() {
        return g_pattern_spec_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_pattern_spec_get_type()
     * }
     */
    public static long g_pattern_spec_get_type() {
        var mh$ = g_pattern_spec_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_spec_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bookmark_file_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bookmark_file_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_bookmark_file_get_type()
     * }
     */
    public static FunctionDescriptor g_bookmark_file_get_type$descriptor() {
        return g_bookmark_file_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_bookmark_file_get_type()
     * }
     */
    public static MethodHandle g_bookmark_file_get_type$handle() {
        return g_bookmark_file_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_bookmark_file_get_type()
     * }
     */
    public static MemorySegment g_bookmark_file_get_type$address() {
        return g_bookmark_file_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_bookmark_file_get_type()
     * }
     */
    public static long g_bookmark_file_get_type() {
        var mh$ = g_bookmark_file_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bookmark_file_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hmac_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hmac_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_hmac_get_type()
     * }
     */
    public static FunctionDescriptor g_hmac_get_type$descriptor() {
        return g_hmac_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_hmac_get_type()
     * }
     */
    public static MethodHandle g_hmac_get_type$handle() {
        return g_hmac_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_hmac_get_type()
     * }
     */
    public static MemorySegment g_hmac_get_type$address() {
        return g_hmac_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_hmac_get_type()
     * }
     */
    public static long g_hmac_get_type() {
        var mh$ = g_hmac_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hmac_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dir_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dir_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_dir_get_type()
     * }
     */
    public static FunctionDescriptor g_dir_get_type$descriptor() {
        return g_dir_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_dir_get_type()
     * }
     */
    public static MethodHandle g_dir_get_type$handle() {
        return g_dir_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_dir_get_type()
     * }
     */
    public static MemorySegment g_dir_get_type$address() {
        return g_dir_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_dir_get_type()
     * }
     */
    public static long g_dir_get_type() {
        var mh$ = g_dir_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dir_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_rand_get_type()
     * }
     */
    public static FunctionDescriptor g_rand_get_type$descriptor() {
        return g_rand_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_rand_get_type()
     * }
     */
    public static MethodHandle g_rand_get_type$handle() {
        return g_rand_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_rand_get_type()
     * }
     */
    public static MemorySegment g_rand_get_type$address() {
        return g_rand_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_rand_get_type()
     * }
     */
    public static long g_rand_get_type() {
        var mh$ = g_rand_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_builder_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_strv_builder_get_type()
     * }
     */
    public static FunctionDescriptor g_strv_builder_get_type$descriptor() {
        return g_strv_builder_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_strv_builder_get_type()
     * }
     */
    public static MethodHandle g_strv_builder_get_type$handle() {
        return g_strv_builder_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_strv_builder_get_type()
     * }
     */
    public static MemorySegment g_strv_builder_get_type$address() {
        return g_strv_builder_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_strv_builder_get_type()
     * }
     */
    public static long g_strv_builder_get_type() {
        var mh$ = g_strv_builder_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_builder_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_gtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_gtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_variant_get_gtype()
     * }
     */
    public static FunctionDescriptor g_variant_get_gtype$descriptor() {
        return g_variant_get_gtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_variant_get_gtype()
     * }
     */
    public static MethodHandle g_variant_get_gtype$handle() {
        return g_variant_get_gtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_variant_get_gtype()
     * }
     */
    public static MemorySegment g_variant_get_gtype$address() {
        return g_variant_get_gtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_variant_get_gtype()
     * }
     */
    public static long g_variant_get_gtype() {
        var mh$ = g_variant_get_gtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_gtype");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_boxed_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_boxed_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_boxed_copy(GType boxed_type, gconstpointer src_boxed)
     * }
     */
    public static FunctionDescriptor g_boxed_copy$descriptor() {
        return g_boxed_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_boxed_copy(GType boxed_type, gconstpointer src_boxed)
     * }
     */
    public static MethodHandle g_boxed_copy$handle() {
        return g_boxed_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_boxed_copy(GType boxed_type, gconstpointer src_boxed)
     * }
     */
    public static MemorySegment g_boxed_copy$address() {
        return g_boxed_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_boxed_copy(GType boxed_type, gconstpointer src_boxed)
     * }
     */
    public static MemorySegment g_boxed_copy(long boxed_type, MemorySegment src_boxed) {
        var mh$ = g_boxed_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_boxed_copy", boxed_type, src_boxed);
            }
            return (MemorySegment)mh$.invokeExact(boxed_type, src_boxed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_boxed_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_boxed_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_boxed_free(GType boxed_type, gpointer boxed)
     * }
     */
    public static FunctionDescriptor g_boxed_free$descriptor() {
        return g_boxed_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_boxed_free(GType boxed_type, gpointer boxed)
     * }
     */
    public static MethodHandle g_boxed_free$handle() {
        return g_boxed_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_boxed_free(GType boxed_type, gpointer boxed)
     * }
     */
    public static MemorySegment g_boxed_free$address() {
        return g_boxed_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_boxed_free(GType boxed_type, gpointer boxed)
     * }
     */
    public static void g_boxed_free(long boxed_type, MemorySegment boxed) {
        var mh$ = g_boxed_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_boxed_free", boxed_type, boxed);
            }
            mh$.invokeExact(boxed_type, boxed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_set_boxed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_set_boxed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_set_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static FunctionDescriptor g_value_set_boxed$descriptor() {
        return g_value_set_boxed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_set_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static MethodHandle g_value_set_boxed$handle() {
        return g_value_set_boxed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_set_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static MemorySegment g_value_set_boxed$address() {
        return g_value_set_boxed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_set_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static void g_value_set_boxed(MemorySegment value, MemorySegment v_boxed) {
        var mh$ = g_value_set_boxed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_set_boxed", value, v_boxed);
            }
            mh$.invokeExact(value, v_boxed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_set_static_boxed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_set_static_boxed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_set_static_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static FunctionDescriptor g_value_set_static_boxed$descriptor() {
        return g_value_set_static_boxed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_set_static_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static MethodHandle g_value_set_static_boxed$handle() {
        return g_value_set_static_boxed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_set_static_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static MemorySegment g_value_set_static_boxed$address() {
        return g_value_set_static_boxed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_set_static_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static void g_value_set_static_boxed(MemorySegment value, MemorySegment v_boxed) {
        var mh$ = g_value_set_static_boxed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_set_static_boxed", value, v_boxed);
            }
            mh$.invokeExact(value, v_boxed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_take_boxed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_take_boxed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_take_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static FunctionDescriptor g_value_take_boxed$descriptor() {
        return g_value_take_boxed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_take_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static MethodHandle g_value_take_boxed$handle() {
        return g_value_take_boxed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_take_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static MemorySegment g_value_take_boxed$address() {
        return g_value_take_boxed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_take_boxed(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static void g_value_take_boxed(MemorySegment value, MemorySegment v_boxed) {
        var mh$ = g_value_take_boxed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_take_boxed", value, v_boxed);
            }
            mh$.invokeExact(value, v_boxed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_set_boxed_take_ownership {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_set_boxed_take_ownership");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_set_boxed_take_ownership(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static FunctionDescriptor g_value_set_boxed_take_ownership$descriptor() {
        return g_value_set_boxed_take_ownership.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_set_boxed_take_ownership(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static MethodHandle g_value_set_boxed_take_ownership$handle() {
        return g_value_set_boxed_take_ownership.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_set_boxed_take_ownership(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static MemorySegment g_value_set_boxed_take_ownership$address() {
        return g_value_set_boxed_take_ownership.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_set_boxed_take_ownership(GValue *value, gconstpointer v_boxed)
     * }
     */
    public static void g_value_set_boxed_take_ownership(MemorySegment value, MemorySegment v_boxed) {
        var mh$ = g_value_set_boxed_take_ownership.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_set_boxed_take_ownership", value, v_boxed);
            }
            mh$.invokeExact(value, v_boxed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_get_boxed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_get_boxed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_value_get_boxed(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_get_boxed$descriptor() {
        return g_value_get_boxed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_value_get_boxed(const GValue *value)
     * }
     */
    public static MethodHandle g_value_get_boxed$handle() {
        return g_value_get_boxed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_value_get_boxed(const GValue *value)
     * }
     */
    public static MemorySegment g_value_get_boxed$address() {
        return g_value_get_boxed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_value_get_boxed(const GValue *value)
     * }
     */
    public static MemorySegment g_value_get_boxed(MemorySegment value) {
        var mh$ = g_value_get_boxed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_get_boxed", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_dup_boxed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_dup_boxed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_value_dup_boxed(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_dup_boxed$descriptor() {
        return g_value_dup_boxed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_value_dup_boxed(const GValue *value)
     * }
     */
    public static MethodHandle g_value_dup_boxed$handle() {
        return g_value_dup_boxed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_value_dup_boxed(const GValue *value)
     * }
     */
    public static MemorySegment g_value_dup_boxed$address() {
        return g_value_dup_boxed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_value_dup_boxed(const GValue *value)
     * }
     */
    public static MemorySegment g_value_dup_boxed(MemorySegment value) {
        var mh$ = g_value_dup_boxed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_dup_boxed", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_boxed_type_register_static {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_boxed_type_register_static");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_boxed_type_register_static(const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free)
     * }
     */
    public static FunctionDescriptor g_boxed_type_register_static$descriptor() {
        return g_boxed_type_register_static.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_boxed_type_register_static(const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free)
     * }
     */
    public static MethodHandle g_boxed_type_register_static$handle() {
        return g_boxed_type_register_static.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_boxed_type_register_static(const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free)
     * }
     */
    public static MemorySegment g_boxed_type_register_static$address() {
        return g_boxed_type_register_static.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_boxed_type_register_static(const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free)
     * }
     */
    public static long g_boxed_type_register_static(MemorySegment name, MemorySegment boxed_copy, MemorySegment boxed_free) {
        var mh$ = g_boxed_type_register_static.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_boxed_type_register_static", name, boxed_copy, boxed_free);
            }
            return (long)mh$.invokeExact(name, boxed_copy, boxed_free);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_closure_get_type()
     * }
     */
    public static FunctionDescriptor g_closure_get_type$descriptor() {
        return g_closure_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_closure_get_type()
     * }
     */
    public static MethodHandle g_closure_get_type$handle() {
        return g_closure_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_closure_get_type()
     * }
     */
    public static MemorySegment g_closure_get_type$address() {
        return g_closure_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_closure_get_type()
     * }
     */
    public static long g_closure_get_type() {
        var mh$ = g_closure_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_value_get_type()
     * }
     */
    public static FunctionDescriptor g_value_get_type$descriptor() {
        return g_value_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_value_get_type()
     * }
     */
    public static MethodHandle g_value_get_type$handle() {
        return g_value_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_value_get_type()
     * }
     */
    public static MemorySegment g_value_get_type$address() {
        return g_value_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_value_get_type()
     * }
     */
    public static long g_value_get_type() {
        var mh$ = g_value_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_initially_unowned_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_initially_unowned_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_initially_unowned_get_type()
     * }
     */
    public static FunctionDescriptor g_initially_unowned_get_type$descriptor() {
        return g_initially_unowned_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_initially_unowned_get_type()
     * }
     */
    public static MethodHandle g_initially_unowned_get_type$handle() {
        return g_initially_unowned_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_initially_unowned_get_type()
     * }
     */
    public static MemorySegment g_initially_unowned_get_type$address() {
        return g_initially_unowned_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_initially_unowned_get_type()
     * }
     */
    public static long g_initially_unowned_get_type() {
        var mh$ = g_initially_unowned_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_initially_unowned_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_class_install_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_class_install_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_class_install_property(GObjectClass *oclass, guint property_id, GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_object_class_install_property$descriptor() {
        return g_object_class_install_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_class_install_property(GObjectClass *oclass, guint property_id, GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_object_class_install_property$handle() {
        return g_object_class_install_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_class_install_property(GObjectClass *oclass, guint property_id, GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_object_class_install_property$address() {
        return g_object_class_install_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_class_install_property(GObjectClass *oclass, guint property_id, GParamSpec *pspec)
     * }
     */
    public static void g_object_class_install_property(MemorySegment oclass, int property_id, MemorySegment pspec) {
        var mh$ = g_object_class_install_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_class_install_property", oclass, property_id, pspec);
            }
            mh$.invokeExact(oclass, property_id, pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_class_find_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_class_find_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec *g_object_class_find_property(GObjectClass *oclass, const gchar *property_name)
     * }
     */
    public static FunctionDescriptor g_object_class_find_property$descriptor() {
        return g_object_class_find_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec *g_object_class_find_property(GObjectClass *oclass, const gchar *property_name)
     * }
     */
    public static MethodHandle g_object_class_find_property$handle() {
        return g_object_class_find_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec *g_object_class_find_property(GObjectClass *oclass, const gchar *property_name)
     * }
     */
    public static MemorySegment g_object_class_find_property$address() {
        return g_object_class_find_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec *g_object_class_find_property(GObjectClass *oclass, const gchar *property_name)
     * }
     */
    public static MemorySegment g_object_class_find_property(MemorySegment oclass, MemorySegment property_name) {
        var mh$ = g_object_class_find_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_class_find_property", oclass, property_name);
            }
            return (MemorySegment)mh$.invokeExact(oclass, property_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_class_list_properties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_class_list_properties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec **g_object_class_list_properties(GObjectClass *oclass, guint *n_properties)
     * }
     */
    public static FunctionDescriptor g_object_class_list_properties$descriptor() {
        return g_object_class_list_properties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec **g_object_class_list_properties(GObjectClass *oclass, guint *n_properties)
     * }
     */
    public static MethodHandle g_object_class_list_properties$handle() {
        return g_object_class_list_properties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec **g_object_class_list_properties(GObjectClass *oclass, guint *n_properties)
     * }
     */
    public static MemorySegment g_object_class_list_properties$address() {
        return g_object_class_list_properties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec **g_object_class_list_properties(GObjectClass *oclass, guint *n_properties)
     * }
     */
    public static MemorySegment g_object_class_list_properties(MemorySegment oclass, MemorySegment n_properties) {
        var mh$ = g_object_class_list_properties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_class_list_properties", oclass, n_properties);
            }
            return (MemorySegment)mh$.invokeExact(oclass, n_properties);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_class_override_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_class_override_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_class_override_property(GObjectClass *oclass, guint property_id, const gchar *name)
     * }
     */
    public static FunctionDescriptor g_object_class_override_property$descriptor() {
        return g_object_class_override_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_class_override_property(GObjectClass *oclass, guint property_id, const gchar *name)
     * }
     */
    public static MethodHandle g_object_class_override_property$handle() {
        return g_object_class_override_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_class_override_property(GObjectClass *oclass, guint property_id, const gchar *name)
     * }
     */
    public static MemorySegment g_object_class_override_property$address() {
        return g_object_class_override_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_class_override_property(GObjectClass *oclass, guint property_id, const gchar *name)
     * }
     */
    public static void g_object_class_override_property(MemorySegment oclass, int property_id, MemorySegment name) {
        var mh$ = g_object_class_override_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_class_override_property", oclass, property_id, name);
            }
            mh$.invokeExact(oclass, property_id, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_class_install_properties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_class_install_properties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_class_install_properties(GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs)
     * }
     */
    public static FunctionDescriptor g_object_class_install_properties$descriptor() {
        return g_object_class_install_properties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_class_install_properties(GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs)
     * }
     */
    public static MethodHandle g_object_class_install_properties$handle() {
        return g_object_class_install_properties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_class_install_properties(GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs)
     * }
     */
    public static MemorySegment g_object_class_install_properties$address() {
        return g_object_class_install_properties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_class_install_properties(GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs)
     * }
     */
    public static void g_object_class_install_properties(MemorySegment oclass, int n_pspecs, MemorySegment pspecs) {
        var mh$ = g_object_class_install_properties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_class_install_properties", oclass, n_pspecs, pspecs);
            }
            mh$.invokeExact(oclass, n_pspecs, pspecs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_interface_install_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_interface_install_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_interface_install_property(gpointer g_iface, GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_object_interface_install_property$descriptor() {
        return g_object_interface_install_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_interface_install_property(gpointer g_iface, GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_object_interface_install_property$handle() {
        return g_object_interface_install_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_interface_install_property(gpointer g_iface, GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_object_interface_install_property$address() {
        return g_object_interface_install_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_interface_install_property(gpointer g_iface, GParamSpec *pspec)
     * }
     */
    public static void g_object_interface_install_property(MemorySegment g_iface, MemorySegment pspec) {
        var mh$ = g_object_interface_install_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_interface_install_property", g_iface, pspec);
            }
            mh$.invokeExact(g_iface, pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_interface_find_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_interface_find_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec *g_object_interface_find_property(gpointer g_iface, const gchar *property_name)
     * }
     */
    public static FunctionDescriptor g_object_interface_find_property$descriptor() {
        return g_object_interface_find_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec *g_object_interface_find_property(gpointer g_iface, const gchar *property_name)
     * }
     */
    public static MethodHandle g_object_interface_find_property$handle() {
        return g_object_interface_find_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec *g_object_interface_find_property(gpointer g_iface, const gchar *property_name)
     * }
     */
    public static MemorySegment g_object_interface_find_property$address() {
        return g_object_interface_find_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec *g_object_interface_find_property(gpointer g_iface, const gchar *property_name)
     * }
     */
    public static MemorySegment g_object_interface_find_property(MemorySegment g_iface, MemorySegment property_name) {
        var mh$ = g_object_interface_find_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_interface_find_property", g_iface, property_name);
            }
            return (MemorySegment)mh$.invokeExact(g_iface, property_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_interface_list_properties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_interface_list_properties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GParamSpec **g_object_interface_list_properties(gpointer g_iface, guint *n_properties_p)
     * }
     */
    public static FunctionDescriptor g_object_interface_list_properties$descriptor() {
        return g_object_interface_list_properties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GParamSpec **g_object_interface_list_properties(gpointer g_iface, guint *n_properties_p)
     * }
     */
    public static MethodHandle g_object_interface_list_properties$handle() {
        return g_object_interface_list_properties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GParamSpec **g_object_interface_list_properties(gpointer g_iface, guint *n_properties_p)
     * }
     */
    public static MemorySegment g_object_interface_list_properties$address() {
        return g_object_interface_list_properties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GParamSpec **g_object_interface_list_properties(gpointer g_iface, guint *n_properties_p)
     * }
     */
    public static MemorySegment g_object_interface_list_properties(MemorySegment g_iface, MemorySegment n_properties_p) {
        var mh$ = g_object_interface_list_properties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_interface_list_properties", g_iface, n_properties_p);
            }
            return (MemorySegment)mh$.invokeExact(g_iface, n_properties_p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_object_get_type()
     * }
     */
    public static FunctionDescriptor g_object_get_type$descriptor() {
        return g_object_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_object_get_type()
     * }
     */
    public static MethodHandle g_object_get_type$handle() {
        return g_object_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_object_get_type()
     * }
     */
    public static MemorySegment g_object_get_type$address() {
        return g_object_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_object_get_type()
     * }
     */
    public static long g_object_get_type() {
        var mh$ = g_object_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gpointer g_object_new(GType object_type, const gchar *first_property_name, ...)
     * }
     */
    public static class g_object_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_LONG_LONG,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_object_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gpointer g_object_new(GType object_type, const gchar *first_property_name, ...)
         * }
         */
        public static g_object_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_object_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(long object_type, MemorySegment first_property_name, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_object_new", object_type, first_property_name, x2);
                }
                return (MemorySegment) spreader.invokeExact(object_type, first_property_name, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_object_new_with_properties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_new_with_properties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GObject *g_object_new_with_properties(GType object_type, guint n_properties, const char *names[], const GValue values[])
     * }
     */
    public static FunctionDescriptor g_object_new_with_properties$descriptor() {
        return g_object_new_with_properties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GObject *g_object_new_with_properties(GType object_type, guint n_properties, const char *names[], const GValue values[])
     * }
     */
    public static MethodHandle g_object_new_with_properties$handle() {
        return g_object_new_with_properties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GObject *g_object_new_with_properties(GType object_type, guint n_properties, const char *names[], const GValue values[])
     * }
     */
    public static MemorySegment g_object_new_with_properties$address() {
        return g_object_new_with_properties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GObject *g_object_new_with_properties(GType object_type, guint n_properties, const char *names[], const GValue values[])
     * }
     */
    public static MemorySegment g_object_new_with_properties(long object_type, int n_properties, MemorySegment names, MemorySegment values) {
        var mh$ = g_object_new_with_properties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_new_with_properties", object_type, n_properties, names, values);
            }
            return (MemorySegment)mh$.invokeExact(object_type, n_properties, names, values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_newv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_newv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_newv(GType object_type, guint n_parameters, GParameter *parameters)
     * }
     */
    public static FunctionDescriptor g_object_newv$descriptor() {
        return g_object_newv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_newv(GType object_type, guint n_parameters, GParameter *parameters)
     * }
     */
    public static MethodHandle g_object_newv$handle() {
        return g_object_newv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_newv(GType object_type, guint n_parameters, GParameter *parameters)
     * }
     */
    public static MemorySegment g_object_newv$address() {
        return g_object_newv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_newv(GType object_type, guint n_parameters, GParameter *parameters)
     * }
     */
    public static MemorySegment g_object_newv(long object_type, int n_parameters, MemorySegment parameters) {
        var mh$ = g_object_newv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_newv", object_type, n_parameters, parameters);
            }
            return (MemorySegment)mh$.invokeExact(object_type, n_parameters, parameters);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_new_valist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_new_valist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GObject *g_object_new_valist(GType object_type, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static FunctionDescriptor g_object_new_valist$descriptor() {
        return g_object_new_valist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GObject *g_object_new_valist(GType object_type, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static MethodHandle g_object_new_valist$handle() {
        return g_object_new_valist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GObject *g_object_new_valist(GType object_type, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static MemorySegment g_object_new_valist$address() {
        return g_object_new_valist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GObject *g_object_new_valist(GType object_type, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static MemorySegment g_object_new_valist(long object_type, MemorySegment first_property_name, MemorySegment var_args) {
        var mh$ = g_object_new_valist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_new_valist", object_type, first_property_name, var_args);
            }
            return (MemorySegment)mh$.invokeExact(object_type, first_property_name, var_args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_object_set(gpointer object, const gchar *first_property_name, ...)
     * }
     */
    public static class g_object_set {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_set");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_object_set(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_object_set(gpointer object, const gchar *first_property_name, ...)
         * }
         */
        public static g_object_set makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_object_set(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment object, MemorySegment first_property_name, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_object_set", object, first_property_name, x2);
                }
                 spreader.invokeExact(object, first_property_name, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_object_get(gpointer object, const gchar *first_property_name, ...)
     * }
     */
    public static class g_object_get {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_get");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_object_get(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_object_get(gpointer object, const gchar *first_property_name, ...)
         * }
         */
        public static g_object_get makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_object_get(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment object, MemorySegment first_property_name, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_object_get", object, first_property_name, x2);
                }
                 spreader.invokeExact(object, first_property_name, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gpointer g_object_connect(gpointer object, const gchar *signal_spec, ...)
     * }
     */
    public static class g_object_connect {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_connect");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_object_connect(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gpointer g_object_connect(gpointer object, const gchar *signal_spec, ...)
         * }
         */
        public static g_object_connect makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_object_connect(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment object, MemorySegment signal_spec, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_object_connect", object, signal_spec, x2);
                }
                return (MemorySegment) spreader.invokeExact(object, signal_spec, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_object_disconnect(gpointer object, const gchar *signal_spec, ...)
     * }
     */
    public static class g_object_disconnect {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_disconnect");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_object_disconnect(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_object_disconnect(gpointer object, const gchar *signal_spec, ...)
         * }
         */
        public static g_object_disconnect makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_object_disconnect(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment object, MemorySegment signal_spec, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_object_disconnect", object, signal_spec, x2);
                }
                 spreader.invokeExact(object, signal_spec, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_object_setv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_setv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_setv(GObject *object, guint n_properties, const gchar *names[], const GValue values[])
     * }
     */
    public static FunctionDescriptor g_object_setv$descriptor() {
        return g_object_setv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_setv(GObject *object, guint n_properties, const gchar *names[], const GValue values[])
     * }
     */
    public static MethodHandle g_object_setv$handle() {
        return g_object_setv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_setv(GObject *object, guint n_properties, const gchar *names[], const GValue values[])
     * }
     */
    public static MemorySegment g_object_setv$address() {
        return g_object_setv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_setv(GObject *object, guint n_properties, const gchar *names[], const GValue values[])
     * }
     */
    public static void g_object_setv(MemorySegment object, int n_properties, MemorySegment names, MemorySegment values) {
        var mh$ = g_object_setv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_setv", object, n_properties, names, values);
            }
            mh$.invokeExact(object, n_properties, names, values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_set_valist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_set_valist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_set_valist(GObject *object, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static FunctionDescriptor g_object_set_valist$descriptor() {
        return g_object_set_valist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_set_valist(GObject *object, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static MethodHandle g_object_set_valist$handle() {
        return g_object_set_valist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_set_valist(GObject *object, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static MemorySegment g_object_set_valist$address() {
        return g_object_set_valist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_set_valist(GObject *object, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static void g_object_set_valist(MemorySegment object, MemorySegment first_property_name, MemorySegment var_args) {
        var mh$ = g_object_set_valist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_set_valist", object, first_property_name, var_args);
            }
            mh$.invokeExact(object, first_property_name, var_args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_getv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_getv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_getv(GObject *object, guint n_properties, const gchar *names[], GValue values[])
     * }
     */
    public static FunctionDescriptor g_object_getv$descriptor() {
        return g_object_getv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_getv(GObject *object, guint n_properties, const gchar *names[], GValue values[])
     * }
     */
    public static MethodHandle g_object_getv$handle() {
        return g_object_getv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_getv(GObject *object, guint n_properties, const gchar *names[], GValue values[])
     * }
     */
    public static MemorySegment g_object_getv$address() {
        return g_object_getv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_getv(GObject *object, guint n_properties, const gchar *names[], GValue values[])
     * }
     */
    public static void g_object_getv(MemorySegment object, int n_properties, MemorySegment names, MemorySegment values) {
        var mh$ = g_object_getv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_getv", object, n_properties, names, values);
            }
            mh$.invokeExact(object, n_properties, names, values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_get_valist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_get_valist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_get_valist(GObject *object, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static FunctionDescriptor g_object_get_valist$descriptor() {
        return g_object_get_valist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_get_valist(GObject *object, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static MethodHandle g_object_get_valist$handle() {
        return g_object_get_valist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_get_valist(GObject *object, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static MemorySegment g_object_get_valist$address() {
        return g_object_get_valist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_get_valist(GObject *object, const gchar *first_property_name, va_list var_args)
     * }
     */
    public static void g_object_get_valist(MemorySegment object, MemorySegment first_property_name, MemorySegment var_args) {
        var mh$ = g_object_get_valist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_get_valist", object, first_property_name, var_args);
            }
            mh$.invokeExact(object, first_property_name, var_args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_set_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_set_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_set_property(GObject *object, const gchar *property_name, const GValue *value)
     * }
     */
    public static FunctionDescriptor g_object_set_property$descriptor() {
        return g_object_set_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_set_property(GObject *object, const gchar *property_name, const GValue *value)
     * }
     */
    public static MethodHandle g_object_set_property$handle() {
        return g_object_set_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_set_property(GObject *object, const gchar *property_name, const GValue *value)
     * }
     */
    public static MemorySegment g_object_set_property$address() {
        return g_object_set_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_set_property(GObject *object, const gchar *property_name, const GValue *value)
     * }
     */
    public static void g_object_set_property(MemorySegment object, MemorySegment property_name, MemorySegment value) {
        var mh$ = g_object_set_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_set_property", object, property_name, value);
            }
            mh$.invokeExact(object, property_name, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_get_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_get_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_get_property(GObject *object, const gchar *property_name, GValue *value)
     * }
     */
    public static FunctionDescriptor g_object_get_property$descriptor() {
        return g_object_get_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_get_property(GObject *object, const gchar *property_name, GValue *value)
     * }
     */
    public static MethodHandle g_object_get_property$handle() {
        return g_object_get_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_get_property(GObject *object, const gchar *property_name, GValue *value)
     * }
     */
    public static MemorySegment g_object_get_property$address() {
        return g_object_get_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_get_property(GObject *object, const gchar *property_name, GValue *value)
     * }
     */
    public static void g_object_get_property(MemorySegment object, MemorySegment property_name, MemorySegment value) {
        var mh$ = g_object_get_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_get_property", object, property_name, value);
            }
            mh$.invokeExact(object, property_name, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_freeze_notify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_freeze_notify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_freeze_notify(GObject *object)
     * }
     */
    public static FunctionDescriptor g_object_freeze_notify$descriptor() {
        return g_object_freeze_notify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_freeze_notify(GObject *object)
     * }
     */
    public static MethodHandle g_object_freeze_notify$handle() {
        return g_object_freeze_notify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_freeze_notify(GObject *object)
     * }
     */
    public static MemorySegment g_object_freeze_notify$address() {
        return g_object_freeze_notify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_freeze_notify(GObject *object)
     * }
     */
    public static void g_object_freeze_notify(MemorySegment object) {
        var mh$ = g_object_freeze_notify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_freeze_notify", object);
            }
            mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_notify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_notify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_notify(GObject *object, const gchar *property_name)
     * }
     */
    public static FunctionDescriptor g_object_notify$descriptor() {
        return g_object_notify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_notify(GObject *object, const gchar *property_name)
     * }
     */
    public static MethodHandle g_object_notify$handle() {
        return g_object_notify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_notify(GObject *object, const gchar *property_name)
     * }
     */
    public static MemorySegment g_object_notify$address() {
        return g_object_notify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_notify(GObject *object, const gchar *property_name)
     * }
     */
    public static void g_object_notify(MemorySegment object, MemorySegment property_name) {
        var mh$ = g_object_notify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_notify", object, property_name);
            }
            mh$.invokeExact(object, property_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_notify_by_pspec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_notify_by_pspec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_notify_by_pspec(GObject *object, GParamSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_object_notify_by_pspec$descriptor() {
        return g_object_notify_by_pspec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_notify_by_pspec(GObject *object, GParamSpec *pspec)
     * }
     */
    public static MethodHandle g_object_notify_by_pspec$handle() {
        return g_object_notify_by_pspec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_notify_by_pspec(GObject *object, GParamSpec *pspec)
     * }
     */
    public static MemorySegment g_object_notify_by_pspec$address() {
        return g_object_notify_by_pspec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_notify_by_pspec(GObject *object, GParamSpec *pspec)
     * }
     */
    public static void g_object_notify_by_pspec(MemorySegment object, MemorySegment pspec) {
        var mh$ = g_object_notify_by_pspec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_notify_by_pspec", object, pspec);
            }
            mh$.invokeExact(object, pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_thaw_notify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_thaw_notify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_thaw_notify(GObject *object)
     * }
     */
    public static FunctionDescriptor g_object_thaw_notify$descriptor() {
        return g_object_thaw_notify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_thaw_notify(GObject *object)
     * }
     */
    public static MethodHandle g_object_thaw_notify$handle() {
        return g_object_thaw_notify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_thaw_notify(GObject *object)
     * }
     */
    public static MemorySegment g_object_thaw_notify$address() {
        return g_object_thaw_notify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_thaw_notify(GObject *object)
     * }
     */
    public static void g_object_thaw_notify(MemorySegment object) {
        var mh$ = g_object_thaw_notify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_thaw_notify", object);
            }
            mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_is_floating {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_is_floating");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_object_is_floating(gpointer object)
     * }
     */
    public static FunctionDescriptor g_object_is_floating$descriptor() {
        return g_object_is_floating.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_object_is_floating(gpointer object)
     * }
     */
    public static MethodHandle g_object_is_floating$handle() {
        return g_object_is_floating.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_object_is_floating(gpointer object)
     * }
     */
    public static MemorySegment g_object_is_floating$address() {
        return g_object_is_floating.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_object_is_floating(gpointer object)
     * }
     */
    public static int g_object_is_floating(MemorySegment object) {
        var mh$ = g_object_is_floating.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_is_floating", object);
            }
            return (int)mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_ref_sink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_ref_sink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_ref_sink(gpointer object)
     * }
     */
    public static FunctionDescriptor g_object_ref_sink$descriptor() {
        return g_object_ref_sink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_ref_sink(gpointer object)
     * }
     */
    public static MethodHandle g_object_ref_sink$handle() {
        return g_object_ref_sink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_ref_sink(gpointer object)
     * }
     */
    public static MemorySegment g_object_ref_sink$address() {
        return g_object_ref_sink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_ref_sink(gpointer object)
     * }
     */
    public static MemorySegment g_object_ref_sink(MemorySegment object) {
        var mh$ = g_object_ref_sink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_ref_sink", object);
            }
            return (MemorySegment)mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_take_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_take_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_take_ref(gpointer object)
     * }
     */
    public static FunctionDescriptor g_object_take_ref$descriptor() {
        return g_object_take_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_take_ref(gpointer object)
     * }
     */
    public static MethodHandle g_object_take_ref$handle() {
        return g_object_take_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_take_ref(gpointer object)
     * }
     */
    public static MemorySegment g_object_take_ref$address() {
        return g_object_take_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_take_ref(gpointer object)
     * }
     */
    public static MemorySegment g_object_take_ref(MemorySegment object) {
        var mh$ = g_object_take_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_take_ref", object);
            }
            return (MemorySegment)mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_ref(gpointer object)
     * }
     */
    public static FunctionDescriptor g_object_ref$descriptor() {
        return g_object_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_ref(gpointer object)
     * }
     */
    public static MethodHandle g_object_ref$handle() {
        return g_object_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_ref(gpointer object)
     * }
     */
    public static MemorySegment g_object_ref$address() {
        return g_object_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_ref(gpointer object)
     * }
     */
    public static MemorySegment g_object_ref(MemorySegment object) {
        var mh$ = g_object_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_ref", object);
            }
            return (MemorySegment)mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_unref(gpointer object)
     * }
     */
    public static FunctionDescriptor g_object_unref$descriptor() {
        return g_object_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_unref(gpointer object)
     * }
     */
    public static MethodHandle g_object_unref$handle() {
        return g_object_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_unref(gpointer object)
     * }
     */
    public static MemorySegment g_object_unref$address() {
        return g_object_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_unref(gpointer object)
     * }
     */
    public static void g_object_unref(MemorySegment object) {
        var mh$ = g_object_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_unref", object);
            }
            mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_weak_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_weak_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_weak_ref(GObject *object, GWeakNotify notify, gpointer data)
     * }
     */
    public static FunctionDescriptor g_object_weak_ref$descriptor() {
        return g_object_weak_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_weak_ref(GObject *object, GWeakNotify notify, gpointer data)
     * }
     */
    public static MethodHandle g_object_weak_ref$handle() {
        return g_object_weak_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_weak_ref(GObject *object, GWeakNotify notify, gpointer data)
     * }
     */
    public static MemorySegment g_object_weak_ref$address() {
        return g_object_weak_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_weak_ref(GObject *object, GWeakNotify notify, gpointer data)
     * }
     */
    public static void g_object_weak_ref(MemorySegment object, MemorySegment notify, MemorySegment data) {
        var mh$ = g_object_weak_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_weak_ref", object, notify, data);
            }
            mh$.invokeExact(object, notify, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_weak_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_weak_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_weak_unref(GObject *object, GWeakNotify notify, gpointer data)
     * }
     */
    public static FunctionDescriptor g_object_weak_unref$descriptor() {
        return g_object_weak_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_weak_unref(GObject *object, GWeakNotify notify, gpointer data)
     * }
     */
    public static MethodHandle g_object_weak_unref$handle() {
        return g_object_weak_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_weak_unref(GObject *object, GWeakNotify notify, gpointer data)
     * }
     */
    public static MemorySegment g_object_weak_unref$address() {
        return g_object_weak_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_weak_unref(GObject *object, GWeakNotify notify, gpointer data)
     * }
     */
    public static void g_object_weak_unref(MemorySegment object, MemorySegment notify, MemorySegment data) {
        var mh$ = g_object_weak_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_weak_unref", object, notify, data);
            }
            mh$.invokeExact(object, notify, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_add_weak_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_add_weak_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_add_weak_pointer(GObject *object, gpointer *weak_pointer_location)
     * }
     */
    public static FunctionDescriptor g_object_add_weak_pointer$descriptor() {
        return g_object_add_weak_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_add_weak_pointer(GObject *object, gpointer *weak_pointer_location)
     * }
     */
    public static MethodHandle g_object_add_weak_pointer$handle() {
        return g_object_add_weak_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_add_weak_pointer(GObject *object, gpointer *weak_pointer_location)
     * }
     */
    public static MemorySegment g_object_add_weak_pointer$address() {
        return g_object_add_weak_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_add_weak_pointer(GObject *object, gpointer *weak_pointer_location)
     * }
     */
    public static void g_object_add_weak_pointer(MemorySegment object, MemorySegment weak_pointer_location) {
        var mh$ = g_object_add_weak_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_add_weak_pointer", object, weak_pointer_location);
            }
            mh$.invokeExact(object, weak_pointer_location);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_remove_weak_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_remove_weak_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_remove_weak_pointer(GObject *object, gpointer *weak_pointer_location)
     * }
     */
    public static FunctionDescriptor g_object_remove_weak_pointer$descriptor() {
        return g_object_remove_weak_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_remove_weak_pointer(GObject *object, gpointer *weak_pointer_location)
     * }
     */
    public static MethodHandle g_object_remove_weak_pointer$handle() {
        return g_object_remove_weak_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_remove_weak_pointer(GObject *object, gpointer *weak_pointer_location)
     * }
     */
    public static MemorySegment g_object_remove_weak_pointer$address() {
        return g_object_remove_weak_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_remove_weak_pointer(GObject *object, gpointer *weak_pointer_location)
     * }
     */
    public static void g_object_remove_weak_pointer(MemorySegment object, MemorySegment weak_pointer_location) {
        var mh$ = g_object_remove_weak_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_remove_weak_pointer", object, weak_pointer_location);
            }
            mh$.invokeExact(object, weak_pointer_location);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_add_toggle_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_add_toggle_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_add_toggle_ref(GObject *object, GToggleNotify notify, gpointer data)
     * }
     */
    public static FunctionDescriptor g_object_add_toggle_ref$descriptor() {
        return g_object_add_toggle_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_add_toggle_ref(GObject *object, GToggleNotify notify, gpointer data)
     * }
     */
    public static MethodHandle g_object_add_toggle_ref$handle() {
        return g_object_add_toggle_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_add_toggle_ref(GObject *object, GToggleNotify notify, gpointer data)
     * }
     */
    public static MemorySegment g_object_add_toggle_ref$address() {
        return g_object_add_toggle_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_add_toggle_ref(GObject *object, GToggleNotify notify, gpointer data)
     * }
     */
    public static void g_object_add_toggle_ref(MemorySegment object, MemorySegment notify, MemorySegment data) {
        var mh$ = g_object_add_toggle_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_add_toggle_ref", object, notify, data);
            }
            mh$.invokeExact(object, notify, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_remove_toggle_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_remove_toggle_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_remove_toggle_ref(GObject *object, GToggleNotify notify, gpointer data)
     * }
     */
    public static FunctionDescriptor g_object_remove_toggle_ref$descriptor() {
        return g_object_remove_toggle_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_remove_toggle_ref(GObject *object, GToggleNotify notify, gpointer data)
     * }
     */
    public static MethodHandle g_object_remove_toggle_ref$handle() {
        return g_object_remove_toggle_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_remove_toggle_ref(GObject *object, GToggleNotify notify, gpointer data)
     * }
     */
    public static MemorySegment g_object_remove_toggle_ref$address() {
        return g_object_remove_toggle_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_remove_toggle_ref(GObject *object, GToggleNotify notify, gpointer data)
     * }
     */
    public static void g_object_remove_toggle_ref(MemorySegment object, MemorySegment notify, MemorySegment data) {
        var mh$ = g_object_remove_toggle_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_remove_toggle_ref", object, notify, data);
            }
            mh$.invokeExact(object, notify, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_get_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_get_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_get_qdata(GObject *object, GQuark quark)
     * }
     */
    public static FunctionDescriptor g_object_get_qdata$descriptor() {
        return g_object_get_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_get_qdata(GObject *object, GQuark quark)
     * }
     */
    public static MethodHandle g_object_get_qdata$handle() {
        return g_object_get_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_get_qdata(GObject *object, GQuark quark)
     * }
     */
    public static MemorySegment g_object_get_qdata$address() {
        return g_object_get_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_get_qdata(GObject *object, GQuark quark)
     * }
     */
    public static MemorySegment g_object_get_qdata(MemorySegment object, int quark) {
        var mh$ = g_object_get_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_get_qdata", object, quark);
            }
            return (MemorySegment)mh$.invokeExact(object, quark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_set_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_set_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_set_qdata(GObject *object, GQuark quark, gpointer data)
     * }
     */
    public static FunctionDescriptor g_object_set_qdata$descriptor() {
        return g_object_set_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_set_qdata(GObject *object, GQuark quark, gpointer data)
     * }
     */
    public static MethodHandle g_object_set_qdata$handle() {
        return g_object_set_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_set_qdata(GObject *object, GQuark quark, gpointer data)
     * }
     */
    public static MemorySegment g_object_set_qdata$address() {
        return g_object_set_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_set_qdata(GObject *object, GQuark quark, gpointer data)
     * }
     */
    public static void g_object_set_qdata(MemorySegment object, int quark, MemorySegment data) {
        var mh$ = g_object_set_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_set_qdata", object, quark, data);
            }
            mh$.invokeExact(object, quark, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_set_qdata_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_set_qdata_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_set_qdata_full(GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static FunctionDescriptor g_object_set_qdata_full$descriptor() {
        return g_object_set_qdata_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_set_qdata_full(GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static MethodHandle g_object_set_qdata_full$handle() {
        return g_object_set_qdata_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_set_qdata_full(GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_object_set_qdata_full$address() {
        return g_object_set_qdata_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_set_qdata_full(GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static void g_object_set_qdata_full(MemorySegment object, int quark, MemorySegment data, MemorySegment destroy) {
        var mh$ = g_object_set_qdata_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_set_qdata_full", object, quark, data, destroy);
            }
            mh$.invokeExact(object, quark, data, destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_steal_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_steal_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_steal_qdata(GObject *object, GQuark quark)
     * }
     */
    public static FunctionDescriptor g_object_steal_qdata$descriptor() {
        return g_object_steal_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_steal_qdata(GObject *object, GQuark quark)
     * }
     */
    public static MethodHandle g_object_steal_qdata$handle() {
        return g_object_steal_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_steal_qdata(GObject *object, GQuark quark)
     * }
     */
    public static MemorySegment g_object_steal_qdata$address() {
        return g_object_steal_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_steal_qdata(GObject *object, GQuark quark)
     * }
     */
    public static MemorySegment g_object_steal_qdata(MemorySegment object, int quark) {
        var mh$ = g_object_steal_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_steal_qdata", object, quark);
            }
            return (MemorySegment)mh$.invokeExact(object, quark);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_dup_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_dup_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_dup_qdata(GObject *object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_object_dup_qdata$descriptor() {
        return g_object_dup_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_dup_qdata(GObject *object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_object_dup_qdata$handle() {
        return g_object_dup_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_dup_qdata(GObject *object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_object_dup_qdata$address() {
        return g_object_dup_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_dup_qdata(GObject *object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_object_dup_qdata(MemorySegment object, int quark, MemorySegment dup_func, MemorySegment user_data) {
        var mh$ = g_object_dup_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_dup_qdata", object, quark, dup_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(object, quark, dup_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_replace_qdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_replace_qdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_object_replace_qdata(GObject *object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static FunctionDescriptor g_object_replace_qdata$descriptor() {
        return g_object_replace_qdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_object_replace_qdata(GObject *object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static MethodHandle g_object_replace_qdata$handle() {
        return g_object_replace_qdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_object_replace_qdata(GObject *object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static MemorySegment g_object_replace_qdata$address() {
        return g_object_replace_qdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_object_replace_qdata(GObject *object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static int g_object_replace_qdata(MemorySegment object, int quark, MemorySegment oldval, MemorySegment newval, MemorySegment destroy, MemorySegment old_destroy) {
        var mh$ = g_object_replace_qdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_replace_qdata", object, quark, oldval, newval, destroy, old_destroy);
            }
            return (int)mh$.invokeExact(object, quark, oldval, newval, destroy, old_destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_get_data(GObject *object, const gchar *key)
     * }
     */
    public static FunctionDescriptor g_object_get_data$descriptor() {
        return g_object_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_get_data(GObject *object, const gchar *key)
     * }
     */
    public static MethodHandle g_object_get_data$handle() {
        return g_object_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_get_data(GObject *object, const gchar *key)
     * }
     */
    public static MemorySegment g_object_get_data$address() {
        return g_object_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_get_data(GObject *object, const gchar *key)
     * }
     */
    public static MemorySegment g_object_get_data(MemorySegment object, MemorySegment key) {
        var mh$ = g_object_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_get_data", object, key);
            }
            return (MemorySegment)mh$.invokeExact(object, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_set_data(GObject *object, const gchar *key, gpointer data)
     * }
     */
    public static FunctionDescriptor g_object_set_data$descriptor() {
        return g_object_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_set_data(GObject *object, const gchar *key, gpointer data)
     * }
     */
    public static MethodHandle g_object_set_data$handle() {
        return g_object_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_set_data(GObject *object, const gchar *key, gpointer data)
     * }
     */
    public static MemorySegment g_object_set_data$address() {
        return g_object_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_set_data(GObject *object, const gchar *key, gpointer data)
     * }
     */
    public static void g_object_set_data(MemorySegment object, MemorySegment key, MemorySegment data) {
        var mh$ = g_object_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_set_data", object, key, data);
            }
            mh$.invokeExact(object, key, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_set_data_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_set_data_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_set_data_full(GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static FunctionDescriptor g_object_set_data_full$descriptor() {
        return g_object_set_data_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_set_data_full(GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static MethodHandle g_object_set_data_full$handle() {
        return g_object_set_data_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_set_data_full(GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_object_set_data_full$address() {
        return g_object_set_data_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_set_data_full(GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy)
     * }
     */
    public static void g_object_set_data_full(MemorySegment object, MemorySegment key, MemorySegment data, MemorySegment destroy) {
        var mh$ = g_object_set_data_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_set_data_full", object, key, data, destroy);
            }
            mh$.invokeExact(object, key, data, destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_steal_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_steal_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_steal_data(GObject *object, const gchar *key)
     * }
     */
    public static FunctionDescriptor g_object_steal_data$descriptor() {
        return g_object_steal_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_steal_data(GObject *object, const gchar *key)
     * }
     */
    public static MethodHandle g_object_steal_data$handle() {
        return g_object_steal_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_steal_data(GObject *object, const gchar *key)
     * }
     */
    public static MemorySegment g_object_steal_data$address() {
        return g_object_steal_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_steal_data(GObject *object, const gchar *key)
     * }
     */
    public static MemorySegment g_object_steal_data(MemorySegment object, MemorySegment key) {
        var mh$ = g_object_steal_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_steal_data", object, key);
            }
            return (MemorySegment)mh$.invokeExact(object, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_dup_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_dup_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_object_dup_data(GObject *object, const gchar *key, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_object_dup_data$descriptor() {
        return g_object_dup_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_object_dup_data(GObject *object, const gchar *key, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_object_dup_data$handle() {
        return g_object_dup_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_object_dup_data(GObject *object, const gchar *key, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_object_dup_data$address() {
        return g_object_dup_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_object_dup_data(GObject *object, const gchar *key, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_object_dup_data(MemorySegment object, MemorySegment key, MemorySegment dup_func, MemorySegment user_data) {
        var mh$ = g_object_dup_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_dup_data", object, key, dup_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(object, key, dup_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_replace_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_replace_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_object_replace_data(GObject *object, const gchar *key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static FunctionDescriptor g_object_replace_data$descriptor() {
        return g_object_replace_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_object_replace_data(GObject *object, const gchar *key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static MethodHandle g_object_replace_data$handle() {
        return g_object_replace_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_object_replace_data(GObject *object, const gchar *key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static MemorySegment g_object_replace_data$address() {
        return g_object_replace_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_object_replace_data(GObject *object, const gchar *key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static int g_object_replace_data(MemorySegment object, MemorySegment key, MemorySegment oldval, MemorySegment newval, MemorySegment destroy, MemorySegment old_destroy) {
        var mh$ = g_object_replace_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_replace_data", object, key, oldval, newval, destroy, old_destroy);
            }
            return (int)mh$.invokeExact(object, key, oldval, newval, destroy, old_destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_watch_closure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_watch_closure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_watch_closure(GObject *object, GClosure *closure)
     * }
     */
    public static FunctionDescriptor g_object_watch_closure$descriptor() {
        return g_object_watch_closure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_watch_closure(GObject *object, GClosure *closure)
     * }
     */
    public static MethodHandle g_object_watch_closure$handle() {
        return g_object_watch_closure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_watch_closure(GObject *object, GClosure *closure)
     * }
     */
    public static MemorySegment g_object_watch_closure$address() {
        return g_object_watch_closure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_watch_closure(GObject *object, GClosure *closure)
     * }
     */
    public static void g_object_watch_closure(MemorySegment object, MemorySegment closure) {
        var mh$ = g_object_watch_closure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_watch_closure", object, closure);
            }
            mh$.invokeExact(object, closure);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_new_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_new_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_object(GCallback callback_func, GObject *object)
     * }
     */
    public static FunctionDescriptor g_cclosure_new_object$descriptor() {
        return g_cclosure_new_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_object(GCallback callback_func, GObject *object)
     * }
     */
    public static MethodHandle g_cclosure_new_object$handle() {
        return g_cclosure_new_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_object(GCallback callback_func, GObject *object)
     * }
     */
    public static MemorySegment g_cclosure_new_object$address() {
        return g_cclosure_new_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_object(GCallback callback_func, GObject *object)
     * }
     */
    public static MemorySegment g_cclosure_new_object(MemorySegment callback_func, MemorySegment object) {
        var mh$ = g_cclosure_new_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_new_object", callback_func, object);
            }
            return (MemorySegment)mh$.invokeExact(callback_func, object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_cclosure_new_object_swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_cclosure_new_object_swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_object_swap(GCallback callback_func, GObject *object)
     * }
     */
    public static FunctionDescriptor g_cclosure_new_object_swap$descriptor() {
        return g_cclosure_new_object_swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_object_swap(GCallback callback_func, GObject *object)
     * }
     */
    public static MethodHandle g_cclosure_new_object_swap$handle() {
        return g_cclosure_new_object_swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_object_swap(GCallback callback_func, GObject *object)
     * }
     */
    public static MemorySegment g_cclosure_new_object_swap$address() {
        return g_cclosure_new_object_swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GClosure *g_cclosure_new_object_swap(GCallback callback_func, GObject *object)
     * }
     */
    public static MemorySegment g_cclosure_new_object_swap(MemorySegment callback_func, MemorySegment object) {
        var mh$ = g_cclosure_new_object_swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_cclosure_new_object_swap", callback_func, object);
            }
            return (MemorySegment)mh$.invokeExact(callback_func, object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_closure_new_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_closure_new_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_new_object(guint sizeof_closure, GObject *object)
     * }
     */
    public static FunctionDescriptor g_closure_new_object$descriptor() {
        return g_closure_new_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_new_object(guint sizeof_closure, GObject *object)
     * }
     */
    public static MethodHandle g_closure_new_object$handle() {
        return g_closure_new_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GClosure *g_closure_new_object(guint sizeof_closure, GObject *object)
     * }
     */
    public static MemorySegment g_closure_new_object$address() {
        return g_closure_new_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GClosure *g_closure_new_object(guint sizeof_closure, GObject *object)
     * }
     */
    public static MemorySegment g_closure_new_object(int sizeof_closure, MemorySegment object) {
        var mh$ = g_closure_new_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_closure_new_object", sizeof_closure, object);
            }
            return (MemorySegment)mh$.invokeExact(sizeof_closure, object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_set_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_set_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_set_object(GValue *value, gpointer v_object)
     * }
     */
    public static FunctionDescriptor g_value_set_object$descriptor() {
        return g_value_set_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_set_object(GValue *value, gpointer v_object)
     * }
     */
    public static MethodHandle g_value_set_object$handle() {
        return g_value_set_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_set_object(GValue *value, gpointer v_object)
     * }
     */
    public static MemorySegment g_value_set_object$address() {
        return g_value_set_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_set_object(GValue *value, gpointer v_object)
     * }
     */
    public static void g_value_set_object(MemorySegment value, MemorySegment v_object) {
        var mh$ = g_value_set_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_set_object", value, v_object);
            }
            mh$.invokeExact(value, v_object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_get_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_get_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_value_get_object(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_get_object$descriptor() {
        return g_value_get_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_value_get_object(const GValue *value)
     * }
     */
    public static MethodHandle g_value_get_object$handle() {
        return g_value_get_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_value_get_object(const GValue *value)
     * }
     */
    public static MemorySegment g_value_get_object$address() {
        return g_value_get_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_value_get_object(const GValue *value)
     * }
     */
    public static MemorySegment g_value_get_object(MemorySegment value) {
        var mh$ = g_value_get_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_get_object", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_dup_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_dup_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_value_dup_object(const GValue *value)
     * }
     */
    public static FunctionDescriptor g_value_dup_object$descriptor() {
        return g_value_dup_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_value_dup_object(const GValue *value)
     * }
     */
    public static MethodHandle g_value_dup_object$handle() {
        return g_value_dup_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_value_dup_object(const GValue *value)
     * }
     */
    public static MemorySegment g_value_dup_object$address() {
        return g_value_dup_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_value_dup_object(const GValue *value)
     * }
     */
    public static MemorySegment g_value_dup_object(MemorySegment value) {
        var mh$ = g_value_dup_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_dup_object", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_signal_connect_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_signal_connect_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_object(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags)
     * }
     */
    public static FunctionDescriptor g_signal_connect_object$descriptor() {
        return g_signal_connect_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_object(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags)
     * }
     */
    public static MethodHandle g_signal_connect_object$handle() {
        return g_signal_connect_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gulong g_signal_connect_object(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags)
     * }
     */
    public static MemorySegment g_signal_connect_object$address() {
        return g_signal_connect_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gulong g_signal_connect_object(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags)
     * }
     */
    public static int g_signal_connect_object(MemorySegment instance, MemorySegment detailed_signal, MemorySegment c_handler, MemorySegment gobject, int connect_flags) {
        var mh$ = g_signal_connect_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_signal_connect_object", instance, detailed_signal, c_handler, gobject, connect_flags);
            }
            return (int)mh$.invokeExact(instance, detailed_signal, c_handler, gobject, connect_flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_force_floating {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_force_floating");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_force_floating(GObject *object)
     * }
     */
    public static FunctionDescriptor g_object_force_floating$descriptor() {
        return g_object_force_floating.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_force_floating(GObject *object)
     * }
     */
    public static MethodHandle g_object_force_floating$handle() {
        return g_object_force_floating.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_force_floating(GObject *object)
     * }
     */
    public static MemorySegment g_object_force_floating$address() {
        return g_object_force_floating.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_force_floating(GObject *object)
     * }
     */
    public static void g_object_force_floating(MemorySegment object) {
        var mh$ = g_object_force_floating.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_force_floating", object);
            }
            mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_run_dispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_run_dispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_object_run_dispose(GObject *object)
     * }
     */
    public static FunctionDescriptor g_object_run_dispose$descriptor() {
        return g_object_run_dispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_object_run_dispose(GObject *object)
     * }
     */
    public static MethodHandle g_object_run_dispose$handle() {
        return g_object_run_dispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_object_run_dispose(GObject *object)
     * }
     */
    public static MemorySegment g_object_run_dispose$address() {
        return g_object_run_dispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_object_run_dispose(GObject *object)
     * }
     */
    public static void g_object_run_dispose(MemorySegment object) {
        var mh$ = g_object_run_dispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_run_dispose", object);
            }
            mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_take_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_take_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_take_object(GValue *value, gpointer v_object)
     * }
     */
    public static FunctionDescriptor g_value_take_object$descriptor() {
        return g_value_take_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_take_object(GValue *value, gpointer v_object)
     * }
     */
    public static MethodHandle g_value_take_object$handle() {
        return g_value_take_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_take_object(GValue *value, gpointer v_object)
     * }
     */
    public static MemorySegment g_value_take_object$address() {
        return g_value_take_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_take_object(GValue *value, gpointer v_object)
     * }
     */
    public static void g_value_take_object(MemorySegment value, MemorySegment v_object) {
        var mh$ = g_value_take_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_take_object", value, v_object);
            }
            mh$.invokeExact(value, v_object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_value_set_object_take_ownership {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_value_set_object_take_ownership");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_value_set_object_take_ownership(GValue *value, gpointer v_object)
     * }
     */
    public static FunctionDescriptor g_value_set_object_take_ownership$descriptor() {
        return g_value_set_object_take_ownership.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_value_set_object_take_ownership(GValue *value, gpointer v_object)
     * }
     */
    public static MethodHandle g_value_set_object_take_ownership$handle() {
        return g_value_set_object_take_ownership.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_value_set_object_take_ownership(GValue *value, gpointer v_object)
     * }
     */
    public static MemorySegment g_value_set_object_take_ownership$address() {
        return g_value_set_object_take_ownership.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_value_set_object_take_ownership(GValue *value, gpointer v_object)
     * }
     */
    public static void g_value_set_object_take_ownership(MemorySegment value, MemorySegment v_object) {
        var mh$ = g_value_set_object_take_ownership.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_value_set_object_take_ownership", value, v_object);
            }
            mh$.invokeExact(value, v_object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_object_compat_control {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_object_compat_control");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_object_compat_control(gsize what, gpointer data)
     * }
     */
    public static FunctionDescriptor g_object_compat_control$descriptor() {
        return g_object_compat_control.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_object_compat_control(gsize what, gpointer data)
     * }
     */
    public static MethodHandle g_object_compat_control$handle() {
        return g_object_compat_control.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_object_compat_control(gsize what, gpointer data)
     * }
     */
    public static MemorySegment g_object_compat_control$address() {
        return g_object_compat_control.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_object_compat_control(gsize what, gpointer data)
     * }
     */
    public static long g_object_compat_control(long what, MemorySegment data) {
        var mh$ = g_object_compat_control.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_object_compat_control", what, data);
            }
            return (long)mh$.invokeExact(what, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_clear_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_clear_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_clear_object(GObject **object_ptr)
     * }
     */
    public static FunctionDescriptor g_clear_object$descriptor() {
        return g_clear_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_clear_object(GObject **object_ptr)
     * }
     */
    public static MethodHandle g_clear_object$handle() {
        return g_clear_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_clear_object(GObject **object_ptr)
     * }
     */
    public static MemorySegment g_clear_object$address() {
        return g_clear_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_clear_object(GObject **object_ptr)
     * }
     */
    public static void g_clear_object(MemorySegment object_ptr) {
        var mh$ = g_clear_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_clear_object", object_ptr);
            }
            mh$.invokeExact(object_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_weak_ref_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_weak_ref_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_weak_ref_init(GWeakRef *weak_ref, gpointer object)
     * }
     */
    public static FunctionDescriptor g_weak_ref_init$descriptor() {
        return g_weak_ref_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_weak_ref_init(GWeakRef *weak_ref, gpointer object)
     * }
     */
    public static MethodHandle g_weak_ref_init$handle() {
        return g_weak_ref_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_weak_ref_init(GWeakRef *weak_ref, gpointer object)
     * }
     */
    public static MemorySegment g_weak_ref_init$address() {
        return g_weak_ref_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_weak_ref_init(GWeakRef *weak_ref, gpointer object)
     * }
     */
    public static void g_weak_ref_init(MemorySegment weak_ref, MemorySegment object) {
        var mh$ = g_weak_ref_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_weak_ref_init", weak_ref, object);
            }
            mh$.invokeExact(weak_ref, object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_weak_ref_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_weak_ref_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_weak_ref_clear(GWeakRef *weak_ref)
     * }
     */
    public static FunctionDescriptor g_weak_ref_clear$descriptor() {
        return g_weak_ref_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_weak_ref_clear(GWeakRef *weak_ref)
     * }
     */
    public static MethodHandle g_weak_ref_clear$handle() {
        return g_weak_ref_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_weak_ref_clear(GWeakRef *weak_ref)
     * }
     */
    public static MemorySegment g_weak_ref_clear$address() {
        return g_weak_ref_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_weak_ref_clear(GWeakRef *weak_ref)
     * }
     */
    public static void g_weak_ref_clear(MemorySegment weak_ref) {
        var mh$ = g_weak_ref_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_weak_ref_clear", weak_ref);
            }
            mh$.invokeExact(weak_ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_weak_ref_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_weak_ref_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_weak_ref_get(GWeakRef *weak_ref)
     * }
     */
    public static FunctionDescriptor g_weak_ref_get$descriptor() {
        return g_weak_ref_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_weak_ref_get(GWeakRef *weak_ref)
     * }
     */
    public static MethodHandle g_weak_ref_get$handle() {
        return g_weak_ref_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_weak_ref_get(GWeakRef *weak_ref)
     * }
     */
    public static MemorySegment g_weak_ref_get$address() {
        return g_weak_ref_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_weak_ref_get(GWeakRef *weak_ref)
     * }
     */
    public static MemorySegment g_weak_ref_get(MemorySegment weak_ref) {
        var mh$ = g_weak_ref_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_weak_ref_get", weak_ref);
            }
            return (MemorySegment)mh$.invokeExact(weak_ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_weak_ref_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_weak_ref_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_weak_ref_set(GWeakRef *weak_ref, gpointer object)
     * }
     */
    public static FunctionDescriptor g_weak_ref_set$descriptor() {
        return g_weak_ref_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_weak_ref_set(GWeakRef *weak_ref, gpointer object)
     * }
     */
    public static MethodHandle g_weak_ref_set$handle() {
        return g_weak_ref_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_weak_ref_set(GWeakRef *weak_ref, gpointer object)
     * }
     */
    public static MemorySegment g_weak_ref_set$address() {
        return g_weak_ref_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_weak_ref_set(GWeakRef *weak_ref, gpointer object)
     * }
     */
    public static void g_weak_ref_set(MemorySegment weak_ref, MemorySegment object) {
        var mh$ = g_weak_ref_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_weak_ref_set", weak_ref, object);
            }
            mh$.invokeExact(weak_ref, object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_BINDING_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BINDING_DEFAULT = 0
     * }
     */
    public static int G_BINDING_DEFAULT() {
        return G_BINDING_DEFAULT;
    }
    private static final int G_BINDING_BIDIRECTIONAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BINDING_BIDIRECTIONAL = 1
     * }
     */
    public static int G_BINDING_BIDIRECTIONAL() {
        return G_BINDING_BIDIRECTIONAL;
    }
    private static final int G_BINDING_SYNC_CREATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BINDING_SYNC_CREATE = 2
     * }
     */
    public static int G_BINDING_SYNC_CREATE() {
        return G_BINDING_SYNC_CREATE;
    }
    private static final int G_BINDING_INVERT_BOOLEAN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_BINDING_INVERT_BOOLEAN = 4
     * }
     */
    public static int G_BINDING_INVERT_BOOLEAN() {
        return G_BINDING_INVERT_BOOLEAN;
    }

    private static class g_binding_flags_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_flags_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_binding_flags_get_type()
     * }
     */
    public static FunctionDescriptor g_binding_flags_get_type$descriptor() {
        return g_binding_flags_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_binding_flags_get_type()
     * }
     */
    public static MethodHandle g_binding_flags_get_type$handle() {
        return g_binding_flags_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_binding_flags_get_type()
     * }
     */
    public static MemorySegment g_binding_flags_get_type$address() {
        return g_binding_flags_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_binding_flags_get_type()
     * }
     */
    public static long g_binding_flags_get_type() {
        var mh$ = g_binding_flags_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_flags_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_binding_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GType g_binding_get_type()
     * }
     */
    public static FunctionDescriptor g_binding_get_type$descriptor() {
        return g_binding_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GType g_binding_get_type()
     * }
     */
    public static MethodHandle g_binding_get_type$handle() {
        return g_binding_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GType g_binding_get_type()
     * }
     */
    public static MemorySegment g_binding_get_type$address() {
        return g_binding_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GType g_binding_get_type()
     * }
     */
    public static long g_binding_get_type() {
        var mh$ = g_binding_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_get_type");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_binding_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBindingFlags g_binding_get_flags(GBinding *binding)
     * }
     */
    public static FunctionDescriptor g_binding_get_flags$descriptor() {
        return g_binding_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBindingFlags g_binding_get_flags(GBinding *binding)
     * }
     */
    public static MethodHandle g_binding_get_flags$handle() {
        return g_binding_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBindingFlags g_binding_get_flags(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_flags$address() {
        return g_binding_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBindingFlags g_binding_get_flags(GBinding *binding)
     * }
     */
    public static int g_binding_get_flags(MemorySegment binding) {
        var mh$ = g_binding_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_get_flags", binding);
            }
            return (int)mh$.invokeExact(binding);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_binding_get_source {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_get_source");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GObject *g_binding_get_source(GBinding *binding)
     * }
     */
    public static FunctionDescriptor g_binding_get_source$descriptor() {
        return g_binding_get_source.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GObject *g_binding_get_source(GBinding *binding)
     * }
     */
    public static MethodHandle g_binding_get_source$handle() {
        return g_binding_get_source.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GObject *g_binding_get_source(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_source$address() {
        return g_binding_get_source.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GObject *g_binding_get_source(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_source(MemorySegment binding) {
        var mh$ = g_binding_get_source.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_get_source", binding);
            }
            return (MemorySegment)mh$.invokeExact(binding);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_binding_dup_source {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_dup_source");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GObject *g_binding_dup_source(GBinding *binding)
     * }
     */
    public static FunctionDescriptor g_binding_dup_source$descriptor() {
        return g_binding_dup_source.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GObject *g_binding_dup_source(GBinding *binding)
     * }
     */
    public static MethodHandle g_binding_dup_source$handle() {
        return g_binding_dup_source.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GObject *g_binding_dup_source(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_dup_source$address() {
        return g_binding_dup_source.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GObject *g_binding_dup_source(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_dup_source(MemorySegment binding) {
        var mh$ = g_binding_dup_source.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_dup_source", binding);
            }
            return (MemorySegment)mh$.invokeExact(binding);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_binding_get_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_get_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GObject *g_binding_get_target(GBinding *binding)
     * }
     */
    public static FunctionDescriptor g_binding_get_target$descriptor() {
        return g_binding_get_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GObject *g_binding_get_target(GBinding *binding)
     * }
     */
    public static MethodHandle g_binding_get_target$handle() {
        return g_binding_get_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GObject *g_binding_get_target(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_target$address() {
        return g_binding_get_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GObject *g_binding_get_target(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_target(MemorySegment binding) {
        var mh$ = g_binding_get_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_get_target", binding);
            }
            return (MemorySegment)mh$.invokeExact(binding);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_binding_dup_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_dup_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GObject *g_binding_dup_target(GBinding *binding)
     * }
     */
    public static FunctionDescriptor g_binding_dup_target$descriptor() {
        return g_binding_dup_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GObject *g_binding_dup_target(GBinding *binding)
     * }
     */
    public static MethodHandle g_binding_dup_target$handle() {
        return g_binding_dup_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GObject *g_binding_dup_target(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_dup_target$address() {
        return g_binding_dup_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GObject *g_binding_dup_target(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_dup_target(MemorySegment binding) {
        var mh$ = g_binding_dup_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_dup_target", binding);
            }
            return (MemorySegment)mh$.invokeExact(binding);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_binding_get_source_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_get_source_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_binding_get_source_property(GBinding *binding)
     * }
     */
    public static FunctionDescriptor g_binding_get_source_property$descriptor() {
        return g_binding_get_source_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_binding_get_source_property(GBinding *binding)
     * }
     */
    public static MethodHandle g_binding_get_source_property$handle() {
        return g_binding_get_source_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_binding_get_source_property(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_source_property$address() {
        return g_binding_get_source_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_binding_get_source_property(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_source_property(MemorySegment binding) {
        var mh$ = g_binding_get_source_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_get_source_property", binding);
            }
            return (MemorySegment)mh$.invokeExact(binding);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_binding_get_target_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_binding_get_target_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_binding_get_target_property(GBinding *binding)
     * }
     */
    public static FunctionDescriptor g_binding_get_target_property$descriptor() {
        return g_binding_get_target_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_binding_get_target_property(GBinding *binding)
     * }
     */
    public static MethodHandle g_binding_get_target_property$handle() {
        return g_binding_get_target_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_binding_get_target_property(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_target_property$address() {
        return g_binding_get_target_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_binding_get_target_property(GBinding *binding)
     * }
     */
    public static MemorySegment g_binding_get_target_property(MemorySegment binding) {
        var mh$ = g_binding_get_target_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_binding_get_target_property", binding);
            }
            return (MemorySegment)mh$.invokeExact(binding);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

