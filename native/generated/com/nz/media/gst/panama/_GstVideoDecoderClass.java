// Generated by jextract

package com.nz.media.gst.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GstVideoDecoderClass {
 *     GstElementClass element_class;
 *     gboolean (*open)(GstVideoDecoder *);
 *     gboolean (*close)(GstVideoDecoder *);
 *     gboolean (*start)(GstVideoDecoder *);
 *     gboolean (*stop)(GstVideoDecoder *);
 *     GstFlowReturn (*parse)(GstVideoDecoder *, GstVideoCodecFrame *, GstAdapter *, gboolean);
 *     gboolean (*set_format)(GstVideoDecoder *, GstVideoCodecState *);
 *     gboolean (*reset)(GstVideoDecoder *, gboolean);
 *     GstFlowReturn (*finish)(GstVideoDecoder *);
 *     GstFlowReturn (*handle_frame)(GstVideoDecoder *, GstVideoCodecFrame *);
 *     gboolean (*sink_event)(GstVideoDecoder *, GstEvent *);
 *     gboolean (*src_event)(GstVideoDecoder *, GstEvent *);
 *     gboolean (*negotiate)(GstVideoDecoder *);
 *     gboolean (*decide_allocation)(GstVideoDecoder *, GstQuery *);
 *     gboolean (*propose_allocation)(GstVideoDecoder *, GstQuery *);
 *     gboolean (*flush)(GstVideoDecoder *);
 *     gboolean (*sink_query)(GstVideoDecoder *, GstQuery *);
 *     gboolean (*src_query)(GstVideoDecoder *, GstQuery *);
 *     GstCaps *(*getcaps)(GstVideoDecoder *, GstCaps *);
 *     GstFlowReturn (*drain)(GstVideoDecoder *);
 *     gboolean (*transform_meta)(GstVideoDecoder *, GstVideoCodecFrame *, GstMeta *);
 *     gboolean (*handle_missing_data)(GstVideoDecoder *, GstClockTime, GstClockTime);
 *     gpointer padding[13];
 * }
 * }
 */
public class _GstVideoDecoderClass {

    _GstVideoDecoderClass() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GstElementClass.layout().withName("element_class"),
        gst_min_h.C_POINTER.withName("open"),
        gst_min_h.C_POINTER.withName("close"),
        gst_min_h.C_POINTER.withName("start"),
        gst_min_h.C_POINTER.withName("stop"),
        gst_min_h.C_POINTER.withName("parse"),
        gst_min_h.C_POINTER.withName("set_format"),
        gst_min_h.C_POINTER.withName("reset"),
        gst_min_h.C_POINTER.withName("finish"),
        gst_min_h.C_POINTER.withName("handle_frame"),
        gst_min_h.C_POINTER.withName("sink_event"),
        gst_min_h.C_POINTER.withName("src_event"),
        gst_min_h.C_POINTER.withName("negotiate"),
        gst_min_h.C_POINTER.withName("decide_allocation"),
        gst_min_h.C_POINTER.withName("propose_allocation"),
        gst_min_h.C_POINTER.withName("flush"),
        gst_min_h.C_POINTER.withName("sink_query"),
        gst_min_h.C_POINTER.withName("src_query"),
        gst_min_h.C_POINTER.withName("getcaps"),
        gst_min_h.C_POINTER.withName("drain"),
        gst_min_h.C_POINTER.withName("transform_meta"),
        gst_min_h.C_POINTER.withName("handle_missing_data"),
        MemoryLayout.sequenceLayout(13, gst_min_h.C_POINTER).withName("padding")
    ).withName("_GstVideoDecoderClass");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout element_class$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("element_class"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstElementClass element_class
     * }
     */
    public static final GroupLayout element_class$layout() {
        return element_class$LAYOUT;
    }

    private static final long element_class$OFFSET = $LAYOUT.byteOffset(groupElement("element_class"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstElementClass element_class
     * }
     */
    public static final long element_class$offset() {
        return element_class$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstElementClass element_class
     * }
     */
    public static MemorySegment element_class(MemorySegment struct) {
        return struct.asSlice(element_class$OFFSET, element_class$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstElementClass element_class
     * }
     */
    public static void element_class(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, element_class$OFFSET, element_class$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * gboolean (*open)(GstVideoDecoder *)
     * }
     */
    public final static class open {

        private open() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(open.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(open.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*open)(GstVideoDecoder *)
     * }
     */
    public static final AddressLayout open$layout() {
        return open$LAYOUT;
    }

    private static final long open$OFFSET = $LAYOUT.byteOffset(groupElement("open"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*open)(GstVideoDecoder *)
     * }
     */
    public static final long open$offset() {
        return open$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*open)(GstVideoDecoder *)
     * }
     */
    public static MemorySegment open(MemorySegment struct) {
        return struct.get(open$LAYOUT, open$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*open)(GstVideoDecoder *)
     * }
     */
    public static void open(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open$LAYOUT, open$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*close)(GstVideoDecoder *)
     * }
     */
    public final static class close {

        private close() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(close.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(close.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout close$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("close"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*close)(GstVideoDecoder *)
     * }
     */
    public static final AddressLayout close$layout() {
        return close$LAYOUT;
    }

    private static final long close$OFFSET = $LAYOUT.byteOffset(groupElement("close"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*close)(GstVideoDecoder *)
     * }
     */
    public static final long close$offset() {
        return close$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*close)(GstVideoDecoder *)
     * }
     */
    public static MemorySegment close(MemorySegment struct) {
        return struct.get(close$LAYOUT, close$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*close)(GstVideoDecoder *)
     * }
     */
    public static void close(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(close$LAYOUT, close$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*start)(GstVideoDecoder *)
     * }
     */
    public final static class start {

        private start() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(start.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(start.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout start$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("start"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*start)(GstVideoDecoder *)
     * }
     */
    public static final AddressLayout start$layout() {
        return start$LAYOUT;
    }

    private static final long start$OFFSET = $LAYOUT.byteOffset(groupElement("start"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*start)(GstVideoDecoder *)
     * }
     */
    public static final long start$offset() {
        return start$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*start)(GstVideoDecoder *)
     * }
     */
    public static MemorySegment start(MemorySegment struct) {
        return struct.get(start$LAYOUT, start$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*start)(GstVideoDecoder *)
     * }
     */
    public static void start(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(start$LAYOUT, start$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*stop)(GstVideoDecoder *)
     * }
     */
    public final static class stop {

        private stop() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(stop.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(stop.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout stop$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("stop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*stop)(GstVideoDecoder *)
     * }
     */
    public static final AddressLayout stop$layout() {
        return stop$LAYOUT;
    }

    private static final long stop$OFFSET = $LAYOUT.byteOffset(groupElement("stop"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*stop)(GstVideoDecoder *)
     * }
     */
    public static final long stop$offset() {
        return stop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*stop)(GstVideoDecoder *)
     * }
     */
    public static MemorySegment stop(MemorySegment struct) {
        return struct.get(stop$LAYOUT, stop$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*stop)(GstVideoDecoder *)
     * }
     */
    public static void stop(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(stop$LAYOUT, stop$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*parse)(GstVideoDecoder *, GstVideoCodecFrame *, GstAdapter *, gboolean)
     * }
     */
    public final static class parse {

        private parse() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(parse.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(parse.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout parse$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("parse"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*parse)(GstVideoDecoder *, GstVideoCodecFrame *, GstAdapter *, gboolean)
     * }
     */
    public static final AddressLayout parse$layout() {
        return parse$LAYOUT;
    }

    private static final long parse$OFFSET = $LAYOUT.byteOffset(groupElement("parse"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*parse)(GstVideoDecoder *, GstVideoCodecFrame *, GstAdapter *, gboolean)
     * }
     */
    public static final long parse$offset() {
        return parse$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*parse)(GstVideoDecoder *, GstVideoCodecFrame *, GstAdapter *, gboolean)
     * }
     */
    public static MemorySegment parse(MemorySegment struct) {
        return struct.get(parse$LAYOUT, parse$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*parse)(GstVideoDecoder *, GstVideoCodecFrame *, GstAdapter *, gboolean)
     * }
     */
    public static void parse(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(parse$LAYOUT, parse$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_format)(GstVideoDecoder *, GstVideoCodecState *)
     * }
     */
    public final static class set_format {

        private set_format() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(set_format.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_format.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_format$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_format"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_format)(GstVideoDecoder *, GstVideoCodecState *)
     * }
     */
    public static final AddressLayout set_format$layout() {
        return set_format$LAYOUT;
    }

    private static final long set_format$OFFSET = $LAYOUT.byteOffset(groupElement("set_format"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_format)(GstVideoDecoder *, GstVideoCodecState *)
     * }
     */
    public static final long set_format$offset() {
        return set_format$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_format)(GstVideoDecoder *, GstVideoCodecState *)
     * }
     */
    public static MemorySegment set_format(MemorySegment struct) {
        return struct.get(set_format$LAYOUT, set_format$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_format)(GstVideoDecoder *, GstVideoCodecState *)
     * }
     */
    public static void set_format(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_format$LAYOUT, set_format$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*reset)(GstVideoDecoder *, gboolean)
     * }
     */
    public final static class reset {

        private reset() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(reset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(reset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout reset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*reset)(GstVideoDecoder *, gboolean)
     * }
     */
    public static final AddressLayout reset$layout() {
        return reset$LAYOUT;
    }

    private static final long reset$OFFSET = $LAYOUT.byteOffset(groupElement("reset"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*reset)(GstVideoDecoder *, gboolean)
     * }
     */
    public static final long reset$offset() {
        return reset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*reset)(GstVideoDecoder *, gboolean)
     * }
     */
    public static MemorySegment reset(MemorySegment struct) {
        return struct.get(reset$LAYOUT, reset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*reset)(GstVideoDecoder *, gboolean)
     * }
     */
    public static void reset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reset$LAYOUT, reset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*finish)(GstVideoDecoder *)
     * }
     */
    public final static class finish {

        private finish() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish)(GstVideoDecoder *)
     * }
     */
    public static final AddressLayout finish$layout() {
        return finish$LAYOUT;
    }

    private static final long finish$OFFSET = $LAYOUT.byteOffset(groupElement("finish"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish)(GstVideoDecoder *)
     * }
     */
    public static final long finish$offset() {
        return finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish)(GstVideoDecoder *)
     * }
     */
    public static MemorySegment finish(MemorySegment struct) {
        return struct.get(finish$LAYOUT, finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish)(GstVideoDecoder *)
     * }
     */
    public static void finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(finish$LAYOUT, finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*handle_frame)(GstVideoDecoder *, GstVideoCodecFrame *)
     * }
     */
    public final static class handle_frame {

        private handle_frame() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(handle_frame.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(handle_frame.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout handle_frame$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("handle_frame"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*handle_frame)(GstVideoDecoder *, GstVideoCodecFrame *)
     * }
     */
    public static final AddressLayout handle_frame$layout() {
        return handle_frame$LAYOUT;
    }

    private static final long handle_frame$OFFSET = $LAYOUT.byteOffset(groupElement("handle_frame"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*handle_frame)(GstVideoDecoder *, GstVideoCodecFrame *)
     * }
     */
    public static final long handle_frame$offset() {
        return handle_frame$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*handle_frame)(GstVideoDecoder *, GstVideoCodecFrame *)
     * }
     */
    public static MemorySegment handle_frame(MemorySegment struct) {
        return struct.get(handle_frame$LAYOUT, handle_frame$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*handle_frame)(GstVideoDecoder *, GstVideoCodecFrame *)
     * }
     */
    public static void handle_frame(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(handle_frame$LAYOUT, handle_frame$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public final static class sink_event {

        private sink_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(sink_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sink_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sink_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sink_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public static final AddressLayout sink_event$layout() {
        return sink_event$LAYOUT;
    }

    private static final long sink_event$OFFSET = $LAYOUT.byteOffset(groupElement("sink_event"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public static final long sink_event$offset() {
        return sink_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public static MemorySegment sink_event(MemorySegment struct) {
        return struct.get(sink_event$LAYOUT, sink_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public static void sink_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sink_event$LAYOUT, sink_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*src_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public final static class src_event {

        private src_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(src_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(src_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout src_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("src_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*src_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public static final AddressLayout src_event$layout() {
        return src_event$LAYOUT;
    }

    private static final long src_event$OFFSET = $LAYOUT.byteOffset(groupElement("src_event"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*src_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public static final long src_event$offset() {
        return src_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*src_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public static MemorySegment src_event(MemorySegment struct) {
        return struct.get(src_event$LAYOUT, src_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*src_event)(GstVideoDecoder *, GstEvent *)
     * }
     */
    public static void src_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(src_event$LAYOUT, src_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstVideoDecoder *)
     * }
     */
    public final static class negotiate {

        private negotiate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(negotiate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(negotiate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout negotiate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("negotiate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstVideoDecoder *)
     * }
     */
    public static final AddressLayout negotiate$layout() {
        return negotiate$LAYOUT;
    }

    private static final long negotiate$OFFSET = $LAYOUT.byteOffset(groupElement("negotiate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstVideoDecoder *)
     * }
     */
    public static final long negotiate$offset() {
        return negotiate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstVideoDecoder *)
     * }
     */
    public static MemorySegment negotiate(MemorySegment struct) {
        return struct.get(negotiate$LAYOUT, negotiate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstVideoDecoder *)
     * }
     */
    public static void negotiate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(negotiate$LAYOUT, negotiate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public final static class decide_allocation {

        private decide_allocation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(decide_allocation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(decide_allocation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout decide_allocation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("decide_allocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static final AddressLayout decide_allocation$layout() {
        return decide_allocation$LAYOUT;
    }

    private static final long decide_allocation$OFFSET = $LAYOUT.byteOffset(groupElement("decide_allocation"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static final long decide_allocation$offset() {
        return decide_allocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static MemorySegment decide_allocation(MemorySegment struct) {
        return struct.get(decide_allocation$LAYOUT, decide_allocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static void decide_allocation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(decide_allocation$LAYOUT, decide_allocation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public final static class propose_allocation {

        private propose_allocation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(propose_allocation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(propose_allocation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout propose_allocation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("propose_allocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static final AddressLayout propose_allocation$layout() {
        return propose_allocation$LAYOUT;
    }

    private static final long propose_allocation$OFFSET = $LAYOUT.byteOffset(groupElement("propose_allocation"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static final long propose_allocation$offset() {
        return propose_allocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static MemorySegment propose_allocation(MemorySegment struct) {
        return struct.get(propose_allocation$LAYOUT, propose_allocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static void propose_allocation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(propose_allocation$LAYOUT, propose_allocation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*flush)(GstVideoDecoder *)
     * }
     */
    public final static class flush {

        private flush() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(flush.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(flush.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout flush$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("flush"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*flush)(GstVideoDecoder *)
     * }
     */
    public static final AddressLayout flush$layout() {
        return flush$LAYOUT;
    }

    private static final long flush$OFFSET = $LAYOUT.byteOffset(groupElement("flush"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*flush)(GstVideoDecoder *)
     * }
     */
    public static final long flush$offset() {
        return flush$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*flush)(GstVideoDecoder *)
     * }
     */
    public static MemorySegment flush(MemorySegment struct) {
        return struct.get(flush$LAYOUT, flush$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*flush)(GstVideoDecoder *)
     * }
     */
    public static void flush(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(flush$LAYOUT, flush$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public final static class sink_query {

        private sink_query() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(sink_query.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sink_query.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sink_query$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sink_query"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static final AddressLayout sink_query$layout() {
        return sink_query$LAYOUT;
    }

    private static final long sink_query$OFFSET = $LAYOUT.byteOffset(groupElement("sink_query"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static final long sink_query$offset() {
        return sink_query$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static MemorySegment sink_query(MemorySegment struct) {
        return struct.get(sink_query$LAYOUT, sink_query$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static void sink_query(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sink_query$LAYOUT, sink_query$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*src_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public final static class src_query {

        private src_query() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(src_query.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(src_query.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout src_query$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("src_query"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*src_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static final AddressLayout src_query$layout() {
        return src_query$LAYOUT;
    }

    private static final long src_query$OFFSET = $LAYOUT.byteOffset(groupElement("src_query"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*src_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static final long src_query$offset() {
        return src_query$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*src_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static MemorySegment src_query(MemorySegment struct) {
        return struct.get(src_query$LAYOUT, src_query$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*src_query)(GstVideoDecoder *, GstQuery *)
     * }
     */
    public static void src_query(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(src_query$LAYOUT, src_query$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstCaps *(*getcaps)(GstVideoDecoder *, GstCaps *)
     * }
     */
    public final static class getcaps {

        private getcaps() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(getcaps.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getcaps.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getcaps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getcaps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstCaps *(*getcaps)(GstVideoDecoder *, GstCaps *)
     * }
     */
    public static final AddressLayout getcaps$layout() {
        return getcaps$LAYOUT;
    }

    private static final long getcaps$OFFSET = $LAYOUT.byteOffset(groupElement("getcaps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstCaps *(*getcaps)(GstVideoDecoder *, GstCaps *)
     * }
     */
    public static final long getcaps$offset() {
        return getcaps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstCaps *(*getcaps)(GstVideoDecoder *, GstCaps *)
     * }
     */
    public static MemorySegment getcaps(MemorySegment struct) {
        return struct.get(getcaps$LAYOUT, getcaps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstCaps *(*getcaps)(GstVideoDecoder *, GstCaps *)
     * }
     */
    public static void getcaps(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getcaps$LAYOUT, getcaps$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*drain)(GstVideoDecoder *)
     * }
     */
    public final static class drain {

        private drain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(drain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*drain)(GstVideoDecoder *)
     * }
     */
    public static final AddressLayout drain$layout() {
        return drain$LAYOUT;
    }

    private static final long drain$OFFSET = $LAYOUT.byteOffset(groupElement("drain"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*drain)(GstVideoDecoder *)
     * }
     */
    public static final long drain$offset() {
        return drain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*drain)(GstVideoDecoder *)
     * }
     */
    public static MemorySegment drain(MemorySegment struct) {
        return struct.get(drain$LAYOUT, drain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*drain)(GstVideoDecoder *)
     * }
     */
    public static void drain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drain$LAYOUT, drain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*transform_meta)(GstVideoDecoder *, GstVideoCodecFrame *, GstMeta *)
     * }
     */
    public final static class transform_meta {

        private transform_meta() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(transform_meta.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(transform_meta.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout transform_meta$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("transform_meta"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*transform_meta)(GstVideoDecoder *, GstVideoCodecFrame *, GstMeta *)
     * }
     */
    public static final AddressLayout transform_meta$layout() {
        return transform_meta$LAYOUT;
    }

    private static final long transform_meta$OFFSET = $LAYOUT.byteOffset(groupElement("transform_meta"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*transform_meta)(GstVideoDecoder *, GstVideoCodecFrame *, GstMeta *)
     * }
     */
    public static final long transform_meta$offset() {
        return transform_meta$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*transform_meta)(GstVideoDecoder *, GstVideoCodecFrame *, GstMeta *)
     * }
     */
    public static MemorySegment transform_meta(MemorySegment struct) {
        return struct.get(transform_meta$LAYOUT, transform_meta$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*transform_meta)(GstVideoDecoder *, GstVideoCodecFrame *, GstMeta *)
     * }
     */
    public static void transform_meta(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(transform_meta$LAYOUT, transform_meta$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*handle_missing_data)(GstVideoDecoder *, GstClockTime, GstClockTime)
     * }
     */
    public final static class handle_missing_data {

        private handle_missing_data() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(handle_missing_data.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(handle_missing_data.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout handle_missing_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("handle_missing_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*handle_missing_data)(GstVideoDecoder *, GstClockTime, GstClockTime)
     * }
     */
    public static final AddressLayout handle_missing_data$layout() {
        return handle_missing_data$LAYOUT;
    }

    private static final long handle_missing_data$OFFSET = $LAYOUT.byteOffset(groupElement("handle_missing_data"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*handle_missing_data)(GstVideoDecoder *, GstClockTime, GstClockTime)
     * }
     */
    public static final long handle_missing_data$offset() {
        return handle_missing_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*handle_missing_data)(GstVideoDecoder *, GstClockTime, GstClockTime)
     * }
     */
    public static MemorySegment handle_missing_data(MemorySegment struct) {
        return struct.get(handle_missing_data$LAYOUT, handle_missing_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*handle_missing_data)(GstVideoDecoder *, GstClockTime, GstClockTime)
     * }
     */
    public static void handle_missing_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(handle_missing_data$LAYOUT, handle_missing_data$OFFSET, fieldValue);
    }

    private static final SequenceLayout padding$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("padding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gpointer padding[13]
     * }
     */
    public static final SequenceLayout padding$layout() {
        return padding$LAYOUT;
    }

    private static final long padding$OFFSET = $LAYOUT.byteOffset(groupElement("padding"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gpointer padding[13]
     * }
     */
    public static final long padding$offset() {
        return padding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gpointer padding[13]
     * }
     */
    public static MemorySegment padding(MemorySegment struct) {
        return struct.asSlice(padding$OFFSET, padding$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gpointer padding[13]
     * }
     */
    public static void padding(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, padding$OFFSET, padding$LAYOUT.byteSize());
    }

    private static long[] padding$DIMS = { 13 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * gpointer padding[13]
     * }
     */
    public static long[] padding$dimensions() {
        return padding$DIMS;
    }
    private static final VarHandle padding$ELEM_HANDLE = padding$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * gpointer padding[13]
     * }
     */
    public static MemorySegment padding(MemorySegment struct, long index0) {
        return (MemorySegment)padding$ELEM_HANDLE.get(struct, padding$OFFSET, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * gpointer padding[13]
     * }
     */
    public static void padding(MemorySegment struct, long index0, MemorySegment fieldValue) {
        padding$ELEM_HANDLE.set(struct, padding$OFFSET, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

