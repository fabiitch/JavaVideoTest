// Generated by jextract

package com.nz.media.gst.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GstGLContextClass {
 *     GstObjectClass parent_class;
 *     guintptr (*get_current_context)(void);
 *     guintptr (*get_gl_context)(GstGLContext *);
 *     GstGLAPI (*get_gl_api)(GstGLContext *);
 *     GstGLPlatform (*get_gl_platform)(GstGLContext *);
 *     gpointer (*get_proc_address)(GstGLAPI, const gchar *);
 *     gboolean (*activate)(GstGLContext *, gboolean);
 *     gboolean (*choose_format)(GstGLContext *, GError **);
 *     gboolean (*create_context)(GstGLContext *, GstGLAPI, GstGLContext *, GError **);
 *     void (*destroy_context)(GstGLContext *);
 *     void (*swap_buffers)(GstGLContext *);
 *     gboolean (*check_feature)(GstGLContext *, const gchar *);
 *     void (*get_gl_platform_version)(GstGLContext *, gint *, gint *);
 *     GstStructure *(*get_config)(GstGLContext *);
 *     gboolean (*request_config)(GstGLContext *, GstStructure *);
 *     gpointer _reserved[2];
 * }
 * }
 */
public class _GstGLContextClass {

    _GstGLContextClass() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GstObjectClass.layout().withName("parent_class"),
        gst_min_h.C_POINTER.withName("get_current_context"),
        gst_min_h.C_POINTER.withName("get_gl_context"),
        gst_min_h.C_POINTER.withName("get_gl_api"),
        gst_min_h.C_POINTER.withName("get_gl_platform"),
        gst_min_h.C_POINTER.withName("get_proc_address"),
        gst_min_h.C_POINTER.withName("activate"),
        gst_min_h.C_POINTER.withName("choose_format"),
        gst_min_h.C_POINTER.withName("create_context"),
        gst_min_h.C_POINTER.withName("destroy_context"),
        gst_min_h.C_POINTER.withName("swap_buffers"),
        gst_min_h.C_POINTER.withName("check_feature"),
        gst_min_h.C_POINTER.withName("get_gl_platform_version"),
        gst_min_h.C_POINTER.withName("get_config"),
        gst_min_h.C_POINTER.withName("request_config"),
        MemoryLayout.sequenceLayout(2, gst_min_h.C_POINTER).withName("_reserved")
    ).withName("_GstGLContextClass");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout parent_class$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("parent_class"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstObjectClass parent_class
     * }
     */
    public static final GroupLayout parent_class$layout() {
        return parent_class$LAYOUT;
    }

    private static final long parent_class$OFFSET = $LAYOUT.byteOffset(groupElement("parent_class"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstObjectClass parent_class
     * }
     */
    public static final long parent_class$offset() {
        return parent_class$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstObjectClass parent_class
     * }
     */
    public static MemorySegment parent_class(MemorySegment struct) {
        return struct.asSlice(parent_class$OFFSET, parent_class$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstObjectClass parent_class
     * }
     */
    public static void parent_class(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, parent_class$OFFSET, parent_class$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * guintptr (*get_current_context)(void)
     * }
     */
    public final static class get_current_context {

        private get_current_context() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(get_current_context.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_current_context.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_current_context$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_current_context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * guintptr (*get_current_context)(void)
     * }
     */
    public static final AddressLayout get_current_context$layout() {
        return get_current_context$LAYOUT;
    }

    private static final long get_current_context$OFFSET = $LAYOUT.byteOffset(groupElement("get_current_context"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * guintptr (*get_current_context)(void)
     * }
     */
    public static final long get_current_context$offset() {
        return get_current_context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * guintptr (*get_current_context)(void)
     * }
     */
    public static MemorySegment get_current_context(MemorySegment struct) {
        return struct.get(get_current_context$LAYOUT, get_current_context$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * guintptr (*get_current_context)(void)
     * }
     */
    public static void get_current_context(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_current_context$LAYOUT, get_current_context$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * guintptr (*get_gl_context)(GstGLContext *)
     * }
     */
    public final static class get_gl_context {

        private get_gl_context() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(get_gl_context.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_gl_context.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_gl_context$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_gl_context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * guintptr (*get_gl_context)(GstGLContext *)
     * }
     */
    public static final AddressLayout get_gl_context$layout() {
        return get_gl_context$LAYOUT;
    }

    private static final long get_gl_context$OFFSET = $LAYOUT.byteOffset(groupElement("get_gl_context"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * guintptr (*get_gl_context)(GstGLContext *)
     * }
     */
    public static final long get_gl_context$offset() {
        return get_gl_context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * guintptr (*get_gl_context)(GstGLContext *)
     * }
     */
    public static MemorySegment get_gl_context(MemorySegment struct) {
        return struct.get(get_gl_context$LAYOUT, get_gl_context$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * guintptr (*get_gl_context)(GstGLContext *)
     * }
     */
    public static void get_gl_context(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_gl_context$LAYOUT, get_gl_context$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstGLAPI (*get_gl_api)(GstGLContext *)
     * }
     */
    public final static class get_gl_api {

        private get_gl_api() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(get_gl_api.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_gl_api.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_gl_api$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_gl_api"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstGLAPI (*get_gl_api)(GstGLContext *)
     * }
     */
    public static final AddressLayout get_gl_api$layout() {
        return get_gl_api$LAYOUT;
    }

    private static final long get_gl_api$OFFSET = $LAYOUT.byteOffset(groupElement("get_gl_api"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstGLAPI (*get_gl_api)(GstGLContext *)
     * }
     */
    public static final long get_gl_api$offset() {
        return get_gl_api$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstGLAPI (*get_gl_api)(GstGLContext *)
     * }
     */
    public static MemorySegment get_gl_api(MemorySegment struct) {
        return struct.get(get_gl_api$LAYOUT, get_gl_api$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstGLAPI (*get_gl_api)(GstGLContext *)
     * }
     */
    public static void get_gl_api(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_gl_api$LAYOUT, get_gl_api$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstGLPlatform (*get_gl_platform)(GstGLContext *)
     * }
     */
    public final static class get_gl_platform {

        private get_gl_platform() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(get_gl_platform.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_gl_platform.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_gl_platform$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_gl_platform"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstGLPlatform (*get_gl_platform)(GstGLContext *)
     * }
     */
    public static final AddressLayout get_gl_platform$layout() {
        return get_gl_platform$LAYOUT;
    }

    private static final long get_gl_platform$OFFSET = $LAYOUT.byteOffset(groupElement("get_gl_platform"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstGLPlatform (*get_gl_platform)(GstGLContext *)
     * }
     */
    public static final long get_gl_platform$offset() {
        return get_gl_platform$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstGLPlatform (*get_gl_platform)(GstGLContext *)
     * }
     */
    public static MemorySegment get_gl_platform(MemorySegment struct) {
        return struct.get(get_gl_platform$LAYOUT, get_gl_platform$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstGLPlatform (*get_gl_platform)(GstGLContext *)
     * }
     */
    public static void get_gl_platform(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_gl_platform$LAYOUT, get_gl_platform$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gpointer (*get_proc_address)(GstGLAPI, const gchar *)
     * }
     */
    public final static class get_proc_address {

        private get_proc_address() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(get_proc_address.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_proc_address.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_proc_address$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_proc_address"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gpointer (*get_proc_address)(GstGLAPI, const gchar *)
     * }
     */
    public static final AddressLayout get_proc_address$layout() {
        return get_proc_address$LAYOUT;
    }

    private static final long get_proc_address$OFFSET = $LAYOUT.byteOffset(groupElement("get_proc_address"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gpointer (*get_proc_address)(GstGLAPI, const gchar *)
     * }
     */
    public static final long get_proc_address$offset() {
        return get_proc_address$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gpointer (*get_proc_address)(GstGLAPI, const gchar *)
     * }
     */
    public static MemorySegment get_proc_address(MemorySegment struct) {
        return struct.get(get_proc_address$LAYOUT, get_proc_address$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gpointer (*get_proc_address)(GstGLAPI, const gchar *)
     * }
     */
    public static void get_proc_address(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_proc_address$LAYOUT, get_proc_address$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*activate)(GstGLContext *, gboolean)
     * }
     */
    public final static class activate {

        private activate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(activate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(activate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout activate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("activate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*activate)(GstGLContext *, gboolean)
     * }
     */
    public static final AddressLayout activate$layout() {
        return activate$LAYOUT;
    }

    private static final long activate$OFFSET = $LAYOUT.byteOffset(groupElement("activate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*activate)(GstGLContext *, gboolean)
     * }
     */
    public static final long activate$offset() {
        return activate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*activate)(GstGLContext *, gboolean)
     * }
     */
    public static MemorySegment activate(MemorySegment struct) {
        return struct.get(activate$LAYOUT, activate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*activate)(GstGLContext *, gboolean)
     * }
     */
    public static void activate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(activate$LAYOUT, activate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*choose_format)(GstGLContext *, GError **)
     * }
     */
    public final static class choose_format {

        private choose_format() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(choose_format.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(choose_format.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout choose_format$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("choose_format"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*choose_format)(GstGLContext *, GError **)
     * }
     */
    public static final AddressLayout choose_format$layout() {
        return choose_format$LAYOUT;
    }

    private static final long choose_format$OFFSET = $LAYOUT.byteOffset(groupElement("choose_format"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*choose_format)(GstGLContext *, GError **)
     * }
     */
    public static final long choose_format$offset() {
        return choose_format$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*choose_format)(GstGLContext *, GError **)
     * }
     */
    public static MemorySegment choose_format(MemorySegment struct) {
        return struct.get(choose_format$LAYOUT, choose_format$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*choose_format)(GstGLContext *, GError **)
     * }
     */
    public static void choose_format(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(choose_format$LAYOUT, choose_format$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*create_context)(GstGLContext *, GstGLAPI, GstGLContext *, GError **)
     * }
     */
    public final static class create_context {

        private create_context() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(create_context.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_context.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_context$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*create_context)(GstGLContext *, GstGLAPI, GstGLContext *, GError **)
     * }
     */
    public static final AddressLayout create_context$layout() {
        return create_context$LAYOUT;
    }

    private static final long create_context$OFFSET = $LAYOUT.byteOffset(groupElement("create_context"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*create_context)(GstGLContext *, GstGLAPI, GstGLContext *, GError **)
     * }
     */
    public static final long create_context$offset() {
        return create_context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*create_context)(GstGLContext *, GstGLAPI, GstGLContext *, GError **)
     * }
     */
    public static MemorySegment create_context(MemorySegment struct) {
        return struct.get(create_context$LAYOUT, create_context$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*create_context)(GstGLContext *, GstGLAPI, GstGLContext *, GError **)
     * }
     */
    public static void create_context(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_context$LAYOUT, create_context$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*destroy_context)(GstGLContext *)
     * }
     */
    public final static class destroy_context {

        private destroy_context() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(destroy_context.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(destroy_context.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout destroy_context$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destroy_context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*destroy_context)(GstGLContext *)
     * }
     */
    public static final AddressLayout destroy_context$layout() {
        return destroy_context$LAYOUT;
    }

    private static final long destroy_context$OFFSET = $LAYOUT.byteOffset(groupElement("destroy_context"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*destroy_context)(GstGLContext *)
     * }
     */
    public static final long destroy_context$offset() {
        return destroy_context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*destroy_context)(GstGLContext *)
     * }
     */
    public static MemorySegment destroy_context(MemorySegment struct) {
        return struct.get(destroy_context$LAYOUT, destroy_context$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*destroy_context)(GstGLContext *)
     * }
     */
    public static void destroy_context(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destroy_context$LAYOUT, destroy_context$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*swap_buffers)(GstGLContext *)
     * }
     */
    public final static class swap_buffers {

        private swap_buffers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(swap_buffers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(swap_buffers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout swap_buffers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("swap_buffers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*swap_buffers)(GstGLContext *)
     * }
     */
    public static final AddressLayout swap_buffers$layout() {
        return swap_buffers$LAYOUT;
    }

    private static final long swap_buffers$OFFSET = $LAYOUT.byteOffset(groupElement("swap_buffers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*swap_buffers)(GstGLContext *)
     * }
     */
    public static final long swap_buffers$offset() {
        return swap_buffers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*swap_buffers)(GstGLContext *)
     * }
     */
    public static MemorySegment swap_buffers(MemorySegment struct) {
        return struct.get(swap_buffers$LAYOUT, swap_buffers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*swap_buffers)(GstGLContext *)
     * }
     */
    public static void swap_buffers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(swap_buffers$LAYOUT, swap_buffers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*check_feature)(GstGLContext *, const gchar *)
     * }
     */
    public final static class check_feature {

        private check_feature() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(check_feature.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(check_feature.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout check_feature$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("check_feature"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*check_feature)(GstGLContext *, const gchar *)
     * }
     */
    public static final AddressLayout check_feature$layout() {
        return check_feature$LAYOUT;
    }

    private static final long check_feature$OFFSET = $LAYOUT.byteOffset(groupElement("check_feature"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*check_feature)(GstGLContext *, const gchar *)
     * }
     */
    public static final long check_feature$offset() {
        return check_feature$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*check_feature)(GstGLContext *, const gchar *)
     * }
     */
    public static MemorySegment check_feature(MemorySegment struct) {
        return struct.get(check_feature$LAYOUT, check_feature$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*check_feature)(GstGLContext *, const gchar *)
     * }
     */
    public static void check_feature(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(check_feature$LAYOUT, check_feature$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*get_gl_platform_version)(GstGLContext *, gint *, gint *)
     * }
     */
    public final static class get_gl_platform_version {

        private get_gl_platform_version() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(get_gl_platform_version.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_gl_platform_version.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_gl_platform_version$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_gl_platform_version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*get_gl_platform_version)(GstGLContext *, gint *, gint *)
     * }
     */
    public static final AddressLayout get_gl_platform_version$layout() {
        return get_gl_platform_version$LAYOUT;
    }

    private static final long get_gl_platform_version$OFFSET = $LAYOUT.byteOffset(groupElement("get_gl_platform_version"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*get_gl_platform_version)(GstGLContext *, gint *, gint *)
     * }
     */
    public static final long get_gl_platform_version$offset() {
        return get_gl_platform_version$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*get_gl_platform_version)(GstGLContext *, gint *, gint *)
     * }
     */
    public static MemorySegment get_gl_platform_version(MemorySegment struct) {
        return struct.get(get_gl_platform_version$LAYOUT, get_gl_platform_version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*get_gl_platform_version)(GstGLContext *, gint *, gint *)
     * }
     */
    public static void get_gl_platform_version(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_gl_platform_version$LAYOUT, get_gl_platform_version$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstStructure *(*get_config)(GstGLContext *)
     * }
     */
    public final static class get_config {

        private get_config() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(get_config.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_config.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_config$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_config"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstStructure *(*get_config)(GstGLContext *)
     * }
     */
    public static final AddressLayout get_config$layout() {
        return get_config$LAYOUT;
    }

    private static final long get_config$OFFSET = $LAYOUT.byteOffset(groupElement("get_config"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstStructure *(*get_config)(GstGLContext *)
     * }
     */
    public static final long get_config$offset() {
        return get_config$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstStructure *(*get_config)(GstGLContext *)
     * }
     */
    public static MemorySegment get_config(MemorySegment struct) {
        return struct.get(get_config$LAYOUT, get_config$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstStructure *(*get_config)(GstGLContext *)
     * }
     */
    public static void get_config(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_config$LAYOUT, get_config$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*request_config)(GstGLContext *, GstStructure *)
     * }
     */
    public final static class request_config {

        private request_config() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(request_config.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(request_config.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout request_config$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("request_config"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*request_config)(GstGLContext *, GstStructure *)
     * }
     */
    public static final AddressLayout request_config$layout() {
        return request_config$LAYOUT;
    }

    private static final long request_config$OFFSET = $LAYOUT.byteOffset(groupElement("request_config"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*request_config)(GstGLContext *, GstStructure *)
     * }
     */
    public static final long request_config$offset() {
        return request_config$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*request_config)(GstGLContext *, GstStructure *)
     * }
     */
    public static MemorySegment request_config(MemorySegment struct) {
        return struct.get(request_config$LAYOUT, request_config$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*request_config)(GstGLContext *, GstStructure *)
     * }
     */
    public static void request_config(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(request_config$LAYOUT, request_config$OFFSET, fieldValue);
    }

    private static final SequenceLayout _reserved$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("_reserved"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gpointer _reserved[2]
     * }
     */
    public static final SequenceLayout _reserved$layout() {
        return _reserved$LAYOUT;
    }

    private static final long _reserved$OFFSET = $LAYOUT.byteOffset(groupElement("_reserved"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gpointer _reserved[2]
     * }
     */
    public static final long _reserved$offset() {
        return _reserved$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gpointer _reserved[2]
     * }
     */
    public static MemorySegment _reserved(MemorySegment struct) {
        return struct.asSlice(_reserved$OFFSET, _reserved$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gpointer _reserved[2]
     * }
     */
    public static void _reserved(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, _reserved$OFFSET, _reserved$LAYOUT.byteSize());
    }

    private static long[] _reserved$DIMS = { 2 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * gpointer _reserved[2]
     * }
     */
    public static long[] _reserved$dimensions() {
        return _reserved$DIMS;
    }
    private static final VarHandle _reserved$ELEM_HANDLE = _reserved$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * gpointer _reserved[2]
     * }
     */
    public static MemorySegment _reserved(MemorySegment struct, long index0) {
        return (MemorySegment)_reserved$ELEM_HANDLE.get(struct, _reserved$OFFSET, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * gpointer _reserved[2]
     * }
     */
    public static void _reserved(MemorySegment struct, long index0, MemorySegment fieldValue) {
        _reserved$ELEM_HANDLE.set(struct, _reserved$OFFSET, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

