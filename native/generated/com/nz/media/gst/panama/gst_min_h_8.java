// Generated by jextract

package com.nz.media.gst.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class gst_min_h_8 extends gst_min_h_9 {

    gst_min_h_8() {
        // Should not be called directly
    }

    private static class g_bytes_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_bytes_get_size(GBytes *bytes)
     * }
     */
    public static FunctionDescriptor g_bytes_get_size$descriptor() {
        return g_bytes_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_bytes_get_size(GBytes *bytes)
     * }
     */
    public static MethodHandle g_bytes_get_size$handle() {
        return g_bytes_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_bytes_get_size(GBytes *bytes)
     * }
     */
    public static MemorySegment g_bytes_get_size$address() {
        return g_bytes_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_bytes_get_size(GBytes *bytes)
     * }
     */
    public static long g_bytes_get_size(MemorySegment bytes) {
        var mh$ = g_bytes_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_get_size", bytes);
            }
            return (long)mh$.invokeExact(bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_ref(GBytes *bytes)
     * }
     */
    public static FunctionDescriptor g_bytes_ref$descriptor() {
        return g_bytes_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_ref(GBytes *bytes)
     * }
     */
    public static MethodHandle g_bytes_ref$handle() {
        return g_bytes_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_bytes_ref(GBytes *bytes)
     * }
     */
    public static MemorySegment g_bytes_ref$address() {
        return g_bytes_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_bytes_ref(GBytes *bytes)
     * }
     */
    public static MemorySegment g_bytes_ref(MemorySegment bytes) {
        var mh$ = g_bytes_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_ref", bytes);
            }
            return (MemorySegment)mh$.invokeExact(bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_bytes_unref(GBytes *bytes)
     * }
     */
    public static FunctionDescriptor g_bytes_unref$descriptor() {
        return g_bytes_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_bytes_unref(GBytes *bytes)
     * }
     */
    public static MethodHandle g_bytes_unref$handle() {
        return g_bytes_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_bytes_unref(GBytes *bytes)
     * }
     */
    public static MemorySegment g_bytes_unref$address() {
        return g_bytes_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_bytes_unref(GBytes *bytes)
     * }
     */
    public static void g_bytes_unref(MemorySegment bytes) {
        var mh$ = g_bytes_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_unref", bytes);
            }
            mh$.invokeExact(bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_unref_to_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_unref_to_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_bytes_unref_to_data(GBytes *bytes, gsize *size)
     * }
     */
    public static FunctionDescriptor g_bytes_unref_to_data$descriptor() {
        return g_bytes_unref_to_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_bytes_unref_to_data(GBytes *bytes, gsize *size)
     * }
     */
    public static MethodHandle g_bytes_unref_to_data$handle() {
        return g_bytes_unref_to_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_bytes_unref_to_data(GBytes *bytes, gsize *size)
     * }
     */
    public static MemorySegment g_bytes_unref_to_data$address() {
        return g_bytes_unref_to_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_bytes_unref_to_data(GBytes *bytes, gsize *size)
     * }
     */
    public static MemorySegment g_bytes_unref_to_data(MemorySegment bytes, MemorySegment size) {
        var mh$ = g_bytes_unref_to_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_unref_to_data", bytes, size);
            }
            return (MemorySegment)mh$.invokeExact(bytes, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_unref_to_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_unref_to_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GByteArray *g_bytes_unref_to_array(GBytes *bytes)
     * }
     */
    public static FunctionDescriptor g_bytes_unref_to_array$descriptor() {
        return g_bytes_unref_to_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GByteArray *g_bytes_unref_to_array(GBytes *bytes)
     * }
     */
    public static MethodHandle g_bytes_unref_to_array$handle() {
        return g_bytes_unref_to_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GByteArray *g_bytes_unref_to_array(GBytes *bytes)
     * }
     */
    public static MemorySegment g_bytes_unref_to_array$address() {
        return g_bytes_unref_to_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GByteArray *g_bytes_unref_to_array(GBytes *bytes)
     * }
     */
    public static MemorySegment g_bytes_unref_to_array(MemorySegment bytes) {
        var mh$ = g_bytes_unref_to_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_unref_to_array", bytes);
            }
            return (MemorySegment)mh$.invokeExact(bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_bytes_hash(gconstpointer bytes)
     * }
     */
    public static FunctionDescriptor g_bytes_hash$descriptor() {
        return g_bytes_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_bytes_hash(gconstpointer bytes)
     * }
     */
    public static MethodHandle g_bytes_hash$handle() {
        return g_bytes_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_bytes_hash(gconstpointer bytes)
     * }
     */
    public static MemorySegment g_bytes_hash$address() {
        return g_bytes_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_bytes_hash(gconstpointer bytes)
     * }
     */
    public static int g_bytes_hash(MemorySegment bytes) {
        var mh$ = g_bytes_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_hash", bytes);
            }
            return (int)mh$.invokeExact(bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_bytes_equal(gconstpointer bytes1, gconstpointer bytes2)
     * }
     */
    public static FunctionDescriptor g_bytes_equal$descriptor() {
        return g_bytes_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_bytes_equal(gconstpointer bytes1, gconstpointer bytes2)
     * }
     */
    public static MethodHandle g_bytes_equal$handle() {
        return g_bytes_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_bytes_equal(gconstpointer bytes1, gconstpointer bytes2)
     * }
     */
    public static MemorySegment g_bytes_equal$address() {
        return g_bytes_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_bytes_equal(gconstpointer bytes1, gconstpointer bytes2)
     * }
     */
    public static int g_bytes_equal(MemorySegment bytes1, MemorySegment bytes2) {
        var mh$ = g_bytes_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_equal", bytes1, bytes2);
            }
            return (int)mh$.invokeExact(bytes1, bytes2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_bytes_compare(gconstpointer bytes1, gconstpointer bytes2)
     * }
     */
    public static FunctionDescriptor g_bytes_compare$descriptor() {
        return g_bytes_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_bytes_compare(gconstpointer bytes1, gconstpointer bytes2)
     * }
     */
    public static MethodHandle g_bytes_compare$handle() {
        return g_bytes_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_bytes_compare(gconstpointer bytes1, gconstpointer bytes2)
     * }
     */
    public static MemorySegment g_bytes_compare$address() {
        return g_bytes_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_bytes_compare(gconstpointer bytes1, gconstpointer bytes2)
     * }
     */
    public static int g_bytes_compare(MemorySegment bytes1, MemorySegment bytes2) {
        var mh$ = g_bytes_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_compare", bytes1, bytes2);
            }
            return (int)mh$.invokeExact(bytes1, bytes2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_bytes_get_region {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_bytes_get_region");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gconstpointer g_bytes_get_region(GBytes *bytes, gsize element_size, gsize offset, gsize n_elements)
     * }
     */
    public static FunctionDescriptor g_bytes_get_region$descriptor() {
        return g_bytes_get_region.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gconstpointer g_bytes_get_region(GBytes *bytes, gsize element_size, gsize offset, gsize n_elements)
     * }
     */
    public static MethodHandle g_bytes_get_region$handle() {
        return g_bytes_get_region.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gconstpointer g_bytes_get_region(GBytes *bytes, gsize element_size, gsize offset, gsize n_elements)
     * }
     */
    public static MemorySegment g_bytes_get_region$address() {
        return g_bytes_get_region.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gconstpointer g_bytes_get_region(GBytes *bytes, gsize element_size, gsize offset, gsize n_elements)
     * }
     */
    public static MemorySegment g_bytes_get_region(MemorySegment bytes, long element_size, long offset, long n_elements) {
        var mh$ = g_bytes_get_region.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_bytes_get_region", bytes, element_size, offset, n_elements);
            }
            return (MemorySegment)mh$.invokeExact(bytes, element_size, offset, n_elements);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_charset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_charset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_get_charset(const char **charset)
     * }
     */
    public static FunctionDescriptor g_get_charset$descriptor() {
        return g_get_charset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_get_charset(const char **charset)
     * }
     */
    public static MethodHandle g_get_charset$handle() {
        return g_get_charset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_get_charset(const char **charset)
     * }
     */
    public static MemorySegment g_get_charset$address() {
        return g_get_charset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_get_charset(const char **charset)
     * }
     */
    public static int g_get_charset(MemorySegment charset) {
        var mh$ = g_get_charset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_charset", charset);
            }
            return (int)mh$.invokeExact(charset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_codeset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_codeset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_get_codeset()
     * }
     */
    public static FunctionDescriptor g_get_codeset$descriptor() {
        return g_get_codeset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_get_codeset()
     * }
     */
    public static MethodHandle g_get_codeset$handle() {
        return g_get_codeset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_get_codeset()
     * }
     */
    public static MemorySegment g_get_codeset$address() {
        return g_get_codeset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_get_codeset()
     * }
     */
    public static MemorySegment g_get_codeset() {
        var mh$ = g_get_codeset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_codeset");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_console_charset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_console_charset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_get_console_charset(const char **charset)
     * }
     */
    public static FunctionDescriptor g_get_console_charset$descriptor() {
        return g_get_console_charset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_get_console_charset(const char **charset)
     * }
     */
    public static MethodHandle g_get_console_charset$handle() {
        return g_get_console_charset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_get_console_charset(const char **charset)
     * }
     */
    public static MemorySegment g_get_console_charset$address() {
        return g_get_console_charset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_get_console_charset(const char **charset)
     * }
     */
    public static int g_get_console_charset(MemorySegment charset) {
        var mh$ = g_get_console_charset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_console_charset", charset);
            }
            return (int)mh$.invokeExact(charset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_language_names {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_language_names");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_language_names()
     * }
     */
    public static FunctionDescriptor g_get_language_names$descriptor() {
        return g_get_language_names.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_language_names()
     * }
     */
    public static MethodHandle g_get_language_names$handle() {
        return g_get_language_names.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_language_names()
     * }
     */
    public static MemorySegment g_get_language_names$address() {
        return g_get_language_names.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *const *g_get_language_names()
     * }
     */
    public static MemorySegment g_get_language_names() {
        var mh$ = g_get_language_names.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_language_names");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_language_names_with_category {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_language_names_with_category");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_language_names_with_category(const gchar *category_name)
     * }
     */
    public static FunctionDescriptor g_get_language_names_with_category$descriptor() {
        return g_get_language_names_with_category.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_language_names_with_category(const gchar *category_name)
     * }
     */
    public static MethodHandle g_get_language_names_with_category$handle() {
        return g_get_language_names_with_category.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *const *g_get_language_names_with_category(const gchar *category_name)
     * }
     */
    public static MemorySegment g_get_language_names_with_category$address() {
        return g_get_language_names_with_category.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *const *g_get_language_names_with_category(const gchar *category_name)
     * }
     */
    public static MemorySegment g_get_language_names_with_category(MemorySegment category_name) {
        var mh$ = g_get_language_names_with_category.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_language_names_with_category", category_name);
            }
            return (MemorySegment)mh$.invokeExact(category_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_locale_variants {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_locale_variants");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_get_locale_variants(const gchar *locale)
     * }
     */
    public static FunctionDescriptor g_get_locale_variants$descriptor() {
        return g_get_locale_variants.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_get_locale_variants(const gchar *locale)
     * }
     */
    public static MethodHandle g_get_locale_variants$handle() {
        return g_get_locale_variants.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_get_locale_variants(const gchar *locale)
     * }
     */
    public static MemorySegment g_get_locale_variants$address() {
        return g_get_locale_variants.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_get_locale_variants(const gchar *locale)
     * }
     */
    public static MemorySegment g_get_locale_variants(MemorySegment locale) {
        var mh$ = g_get_locale_variants.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_locale_variants", locale);
            }
            return (MemorySegment)mh$.invokeExact(locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_CHECKSUM_MD5 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CHECKSUM_MD5 = 0
     * }
     */
    public static int G_CHECKSUM_MD5() {
        return G_CHECKSUM_MD5;
    }
    private static final int G_CHECKSUM_SHA1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CHECKSUM_SHA1 = 1
     * }
     */
    public static int G_CHECKSUM_SHA1() {
        return G_CHECKSUM_SHA1;
    }
    private static final int G_CHECKSUM_SHA256 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CHECKSUM_SHA256 = 2
     * }
     */
    public static int G_CHECKSUM_SHA256() {
        return G_CHECKSUM_SHA256;
    }
    private static final int G_CHECKSUM_SHA512 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CHECKSUM_SHA512 = 3
     * }
     */
    public static int G_CHECKSUM_SHA512() {
        return G_CHECKSUM_SHA512;
    }
    private static final int G_CHECKSUM_SHA384 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CHECKSUM_SHA384 = 4
     * }
     */
    public static int G_CHECKSUM_SHA384() {
        return G_CHECKSUM_SHA384;
    }

    private static class g_checksum_type_get_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_type_get_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gssize g_checksum_type_get_length(GChecksumType checksum_type)
     * }
     */
    public static FunctionDescriptor g_checksum_type_get_length$descriptor() {
        return g_checksum_type_get_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gssize g_checksum_type_get_length(GChecksumType checksum_type)
     * }
     */
    public static MethodHandle g_checksum_type_get_length$handle() {
        return g_checksum_type_get_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gssize g_checksum_type_get_length(GChecksumType checksum_type)
     * }
     */
    public static MemorySegment g_checksum_type_get_length$address() {
        return g_checksum_type_get_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gssize g_checksum_type_get_length(GChecksumType checksum_type)
     * }
     */
    public static long g_checksum_type_get_length(int checksum_type) {
        var mh$ = g_checksum_type_get_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_type_get_length", checksum_type);
            }
            return (long)mh$.invokeExact(checksum_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_checksum_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GChecksum *g_checksum_new(GChecksumType checksum_type)
     * }
     */
    public static FunctionDescriptor g_checksum_new$descriptor() {
        return g_checksum_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GChecksum *g_checksum_new(GChecksumType checksum_type)
     * }
     */
    public static MethodHandle g_checksum_new$handle() {
        return g_checksum_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GChecksum *g_checksum_new(GChecksumType checksum_type)
     * }
     */
    public static MemorySegment g_checksum_new$address() {
        return g_checksum_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GChecksum *g_checksum_new(GChecksumType checksum_type)
     * }
     */
    public static MemorySegment g_checksum_new(int checksum_type) {
        var mh$ = g_checksum_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_new", checksum_type);
            }
            return (MemorySegment)mh$.invokeExact(checksum_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_checksum_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_checksum_reset(GChecksum *checksum)
     * }
     */
    public static FunctionDescriptor g_checksum_reset$descriptor() {
        return g_checksum_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_checksum_reset(GChecksum *checksum)
     * }
     */
    public static MethodHandle g_checksum_reset$handle() {
        return g_checksum_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_checksum_reset(GChecksum *checksum)
     * }
     */
    public static MemorySegment g_checksum_reset$address() {
        return g_checksum_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_checksum_reset(GChecksum *checksum)
     * }
     */
    public static void g_checksum_reset(MemorySegment checksum) {
        var mh$ = g_checksum_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_reset", checksum);
            }
            mh$.invokeExact(checksum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_checksum_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GChecksum *g_checksum_copy(const GChecksum *checksum)
     * }
     */
    public static FunctionDescriptor g_checksum_copy$descriptor() {
        return g_checksum_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GChecksum *g_checksum_copy(const GChecksum *checksum)
     * }
     */
    public static MethodHandle g_checksum_copy$handle() {
        return g_checksum_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GChecksum *g_checksum_copy(const GChecksum *checksum)
     * }
     */
    public static MemorySegment g_checksum_copy$address() {
        return g_checksum_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GChecksum *g_checksum_copy(const GChecksum *checksum)
     * }
     */
    public static MemorySegment g_checksum_copy(MemorySegment checksum) {
        var mh$ = g_checksum_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_copy", checksum);
            }
            return (MemorySegment)mh$.invokeExact(checksum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_checksum_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_checksum_free(GChecksum *checksum)
     * }
     */
    public static FunctionDescriptor g_checksum_free$descriptor() {
        return g_checksum_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_checksum_free(GChecksum *checksum)
     * }
     */
    public static MethodHandle g_checksum_free$handle() {
        return g_checksum_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_checksum_free(GChecksum *checksum)
     * }
     */
    public static MemorySegment g_checksum_free$address() {
        return g_checksum_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_checksum_free(GChecksum *checksum)
     * }
     */
    public static void g_checksum_free(MemorySegment checksum) {
        var mh$ = g_checksum_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_free", checksum);
            }
            mh$.invokeExact(checksum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_checksum_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_checksum_update(GChecksum *checksum, const guchar *data, gssize length)
     * }
     */
    public static FunctionDescriptor g_checksum_update$descriptor() {
        return g_checksum_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_checksum_update(GChecksum *checksum, const guchar *data, gssize length)
     * }
     */
    public static MethodHandle g_checksum_update$handle() {
        return g_checksum_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_checksum_update(GChecksum *checksum, const guchar *data, gssize length)
     * }
     */
    public static MemorySegment g_checksum_update$address() {
        return g_checksum_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_checksum_update(GChecksum *checksum, const guchar *data, gssize length)
     * }
     */
    public static void g_checksum_update(MemorySegment checksum, MemorySegment data, long length) {
        var mh$ = g_checksum_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_update", checksum, data, length);
            }
            mh$.invokeExact(checksum, data, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_checksum_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_get_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_checksum_get_string(GChecksum *checksum)
     * }
     */
    public static FunctionDescriptor g_checksum_get_string$descriptor() {
        return g_checksum_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_checksum_get_string(GChecksum *checksum)
     * }
     */
    public static MethodHandle g_checksum_get_string$handle() {
        return g_checksum_get_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_checksum_get_string(GChecksum *checksum)
     * }
     */
    public static MemorySegment g_checksum_get_string$address() {
        return g_checksum_get_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_checksum_get_string(GChecksum *checksum)
     * }
     */
    public static MemorySegment g_checksum_get_string(MemorySegment checksum) {
        var mh$ = g_checksum_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_get_string", checksum);
            }
            return (MemorySegment)mh$.invokeExact(checksum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_checksum_get_digest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_checksum_get_digest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_checksum_get_digest(GChecksum *checksum, guint8 *buffer, gsize *digest_len)
     * }
     */
    public static FunctionDescriptor g_checksum_get_digest$descriptor() {
        return g_checksum_get_digest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_checksum_get_digest(GChecksum *checksum, guint8 *buffer, gsize *digest_len)
     * }
     */
    public static MethodHandle g_checksum_get_digest$handle() {
        return g_checksum_get_digest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_checksum_get_digest(GChecksum *checksum, guint8 *buffer, gsize *digest_len)
     * }
     */
    public static MemorySegment g_checksum_get_digest$address() {
        return g_checksum_get_digest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_checksum_get_digest(GChecksum *checksum, guint8 *buffer, gsize *digest_len)
     * }
     */
    public static void g_checksum_get_digest(MemorySegment checksum, MemorySegment buffer, MemorySegment digest_len) {
        var mh$ = g_checksum_get_digest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_checksum_get_digest", checksum, buffer, digest_len);
            }
            mh$.invokeExact(checksum, buffer, digest_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_compute_checksum_for_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_compute_checksum_for_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type, const guchar *data, gsize length)
     * }
     */
    public static FunctionDescriptor g_compute_checksum_for_data$descriptor() {
        return g_compute_checksum_for_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type, const guchar *data, gsize length)
     * }
     */
    public static MethodHandle g_compute_checksum_for_data$handle() {
        return g_compute_checksum_for_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type, const guchar *data, gsize length)
     * }
     */
    public static MemorySegment g_compute_checksum_for_data$address() {
        return g_compute_checksum_for_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type, const guchar *data, gsize length)
     * }
     */
    public static MemorySegment g_compute_checksum_for_data(int checksum_type, MemorySegment data, long length) {
        var mh$ = g_compute_checksum_for_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_compute_checksum_for_data", checksum_type, data, length);
            }
            return (MemorySegment)mh$.invokeExact(checksum_type, data, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_compute_checksum_for_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_compute_checksum_for_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type, const gchar *str, gssize length)
     * }
     */
    public static FunctionDescriptor g_compute_checksum_for_string$descriptor() {
        return g_compute_checksum_for_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type, const gchar *str, gssize length)
     * }
     */
    public static MethodHandle g_compute_checksum_for_string$handle() {
        return g_compute_checksum_for_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type, const gchar *str, gssize length)
     * }
     */
    public static MemorySegment g_compute_checksum_for_string$address() {
        return g_compute_checksum_for_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type, const gchar *str, gssize length)
     * }
     */
    public static MemorySegment g_compute_checksum_for_string(int checksum_type, MemorySegment str, long length) {
        var mh$ = g_compute_checksum_for_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_compute_checksum_for_string", checksum_type, str, length);
            }
            return (MemorySegment)mh$.invokeExact(checksum_type, str, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_compute_checksum_for_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_compute_checksum_for_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type, GBytes *data)
     * }
     */
    public static FunctionDescriptor g_compute_checksum_for_bytes$descriptor() {
        return g_compute_checksum_for_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type, GBytes *data)
     * }
     */
    public static MethodHandle g_compute_checksum_for_bytes$handle() {
        return g_compute_checksum_for_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type, GBytes *data)
     * }
     */
    public static MemorySegment g_compute_checksum_for_bytes$address() {
        return g_compute_checksum_for_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type, GBytes *data)
     * }
     */
    public static MemorySegment g_compute_checksum_for_bytes(int checksum_type, MemorySegment data) {
        var mh$ = g_compute_checksum_for_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_compute_checksum_for_bytes", checksum_type, data);
            }
            return (MemorySegment)mh$.invokeExact(checksum_type, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_CONVERT_ERROR_NO_CONVERSION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONVERT_ERROR_NO_CONVERSION = 0
     * }
     */
    public static int G_CONVERT_ERROR_NO_CONVERSION() {
        return G_CONVERT_ERROR_NO_CONVERSION;
    }
    private static final int G_CONVERT_ERROR_ILLEGAL_SEQUENCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1
     * }
     */
    public static int G_CONVERT_ERROR_ILLEGAL_SEQUENCE() {
        return G_CONVERT_ERROR_ILLEGAL_SEQUENCE;
    }
    private static final int G_CONVERT_ERROR_FAILED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONVERT_ERROR_FAILED = 2
     * }
     */
    public static int G_CONVERT_ERROR_FAILED() {
        return G_CONVERT_ERROR_FAILED;
    }
    private static final int G_CONVERT_ERROR_PARTIAL_INPUT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONVERT_ERROR_PARTIAL_INPUT = 3
     * }
     */
    public static int G_CONVERT_ERROR_PARTIAL_INPUT() {
        return G_CONVERT_ERROR_PARTIAL_INPUT;
    }
    private static final int G_CONVERT_ERROR_BAD_URI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONVERT_ERROR_BAD_URI = 4
     * }
     */
    public static int G_CONVERT_ERROR_BAD_URI() {
        return G_CONVERT_ERROR_BAD_URI;
    }
    private static final int G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5
     * }
     */
    public static int G_CONVERT_ERROR_NOT_ABSOLUTE_PATH() {
        return G_CONVERT_ERROR_NOT_ABSOLUTE_PATH;
    }
    private static final int G_CONVERT_ERROR_NO_MEMORY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONVERT_ERROR_NO_MEMORY = 6
     * }
     */
    public static int G_CONVERT_ERROR_NO_MEMORY() {
        return G_CONVERT_ERROR_NO_MEMORY;
    }
    private static final int G_CONVERT_ERROR_EMBEDDED_NUL = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_CONVERT_ERROR_EMBEDDED_NUL = 7
     * }
     */
    public static int G_CONVERT_ERROR_EMBEDDED_NUL() {
        return G_CONVERT_ERROR_EMBEDDED_NUL;
    }

    private static class g_convert_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_convert_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_convert_error_quark()
     * }
     */
    public static FunctionDescriptor g_convert_error_quark$descriptor() {
        return g_convert_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_convert_error_quark()
     * }
     */
    public static MethodHandle g_convert_error_quark$handle() {
        return g_convert_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_convert_error_quark()
     * }
     */
    public static MemorySegment g_convert_error_quark$address() {
        return g_convert_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_convert_error_quark()
     * }
     */
    public static int g_convert_error_quark() {
        var mh$ = g_convert_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_convert_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _GIConv *GIConv
     * }
     */
    public static final AddressLayout GIConv = gst_min_h.C_POINTER;

    private static class g_iconv_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_iconv_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIConv g_iconv_open(const gchar *to_codeset, const gchar *from_codeset)
     * }
     */
    public static FunctionDescriptor g_iconv_open$descriptor() {
        return g_iconv_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIConv g_iconv_open(const gchar *to_codeset, const gchar *from_codeset)
     * }
     */
    public static MethodHandle g_iconv_open$handle() {
        return g_iconv_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIConv g_iconv_open(const gchar *to_codeset, const gchar *from_codeset)
     * }
     */
    public static MemorySegment g_iconv_open$address() {
        return g_iconv_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIConv g_iconv_open(const gchar *to_codeset, const gchar *from_codeset)
     * }
     */
    public static MemorySegment g_iconv_open(MemorySegment to_codeset, MemorySegment from_codeset) {
        var mh$ = g_iconv_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_iconv_open", to_codeset, from_codeset);
            }
            return (MemorySegment)mh$.invokeExact(to_codeset, from_codeset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_iconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_iconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_iconv(GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left)
     * }
     */
    public static FunctionDescriptor g_iconv$descriptor() {
        return g_iconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_iconv(GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left)
     * }
     */
    public static MethodHandle g_iconv$handle() {
        return g_iconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_iconv(GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left)
     * }
     */
    public static MemorySegment g_iconv$address() {
        return g_iconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_iconv(GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left)
     * }
     */
    public static long g_iconv(MemorySegment converter, MemorySegment inbuf, MemorySegment inbytes_left, MemorySegment outbuf, MemorySegment outbytes_left) {
        var mh$ = g_iconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_iconv", converter, inbuf, inbytes_left, outbuf, outbytes_left);
            }
            return (long)mh$.invokeExact(converter, inbuf, inbytes_left, outbuf, outbytes_left);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_iconv_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_iconv_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_iconv_close(GIConv converter)
     * }
     */
    public static FunctionDescriptor g_iconv_close$descriptor() {
        return g_iconv_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_iconv_close(GIConv converter)
     * }
     */
    public static MethodHandle g_iconv_close$handle() {
        return g_iconv_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_iconv_close(GIConv converter)
     * }
     */
    public static MemorySegment g_iconv_close$address() {
        return g_iconv_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_iconv_close(GIConv converter)
     * }
     */
    public static int g_iconv_close(MemorySegment converter) {
        var mh$ = g_iconv_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_iconv_close", converter);
            }
            return (int)mh$.invokeExact(converter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_convert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_convert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_convert(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_convert$descriptor() {
        return g_convert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_convert(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MethodHandle g_convert$handle() {
        return g_convert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_convert(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_convert$address() {
        return g_convert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_convert(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_convert(MemorySegment str, long len, MemorySegment to_codeset, MemorySegment from_codeset, MemorySegment bytes_read, MemorySegment bytes_written, MemorySegment error) {
        var mh$ = g_convert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_convert", str, len, to_codeset, from_codeset, bytes_read, bytes_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, to_codeset, from_codeset, bytes_read, bytes_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_convert_with_iconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_convert_with_iconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_convert_with_iconv(const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_convert_with_iconv$descriptor() {
        return g_convert_with_iconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_convert_with_iconv(const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MethodHandle g_convert_with_iconv$handle() {
        return g_convert_with_iconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_convert_with_iconv(const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_convert_with_iconv$address() {
        return g_convert_with_iconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_convert_with_iconv(const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_convert_with_iconv(MemorySegment str, long len, MemorySegment converter, MemorySegment bytes_read, MemorySegment bytes_written, MemorySegment error) {
        var mh$ = g_convert_with_iconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_convert_with_iconv", str, len, converter, bytes_read, bytes_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, converter, bytes_read, bytes_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_convert_with_fallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_convert_with_fallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_convert_with_fallback(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_convert_with_fallback$descriptor() {
        return g_convert_with_fallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_convert_with_fallback(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MethodHandle g_convert_with_fallback$handle() {
        return g_convert_with_fallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_convert_with_fallback(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_convert_with_fallback$address() {
        return g_convert_with_fallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_convert_with_fallback(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_convert_with_fallback(MemorySegment str, long len, MemorySegment to_codeset, MemorySegment from_codeset, MemorySegment fallback, MemorySegment bytes_read, MemorySegment bytes_written, MemorySegment error) {
        var mh$ = g_convert_with_fallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_convert_with_fallback", str, len, to_codeset, from_codeset, fallback, bytes_read, bytes_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, to_codeset, from_codeset, fallback, bytes_read, bytes_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_locale_to_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_locale_to_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_locale_to_utf8$descriptor() {
        return g_locale_to_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MethodHandle g_locale_to_utf8$handle() {
        return g_locale_to_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_locale_to_utf8$address() {
        return g_locale_to_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_locale_to_utf8(MemorySegment opsysstring, long len, MemorySegment bytes_read, MemorySegment bytes_written, MemorySegment error) {
        var mh$ = g_locale_to_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_locale_to_utf8", opsysstring, len, bytes_read, bytes_written, error);
            }
            return (MemorySegment)mh$.invokeExact(opsysstring, len, bytes_read, bytes_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_locale_from_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_locale_from_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_locale_from_utf8$descriptor() {
        return g_locale_from_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MethodHandle g_locale_from_utf8$handle() {
        return g_locale_from_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_locale_from_utf8$address() {
        return g_locale_from_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_locale_from_utf8(MemorySegment utf8string, long len, MemorySegment bytes_read, MemorySegment bytes_written, MemorySegment error) {
        var mh$ = g_locale_from_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_locale_from_utf8", utf8string, len, bytes_read, bytes_written, error);
            }
            return (MemorySegment)mh$.invokeExact(utf8string, len, bytes_read, bytes_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_filename_to_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_filename_to_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_filename_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_filename_to_utf8$descriptor() {
        return g_filename_to_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_filename_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MethodHandle g_filename_to_utf8$handle() {
        return g_filename_to_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_filename_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_filename_to_utf8$address() {
        return g_filename_to_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_filename_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_filename_to_utf8(MemorySegment opsysstring, long len, MemorySegment bytes_read, MemorySegment bytes_written, MemorySegment error) {
        var mh$ = g_filename_to_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_filename_to_utf8", opsysstring, len, bytes_read, bytes_written, error);
            }
            return (MemorySegment)mh$.invokeExact(opsysstring, len, bytes_read, bytes_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_filename_from_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_filename_from_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_filename_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_filename_from_utf8$descriptor() {
        return g_filename_from_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_filename_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MethodHandle g_filename_from_utf8$handle() {
        return g_filename_from_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_filename_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_filename_from_utf8$address() {
        return g_filename_from_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_filename_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_filename_from_utf8(MemorySegment utf8string, long len, MemorySegment bytes_read, MemorySegment bytes_written, MemorySegment error) {
        var mh$ = g_filename_from_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_filename_from_utf8", utf8string, len, bytes_read, bytes_written, error);
            }
            return (MemorySegment)mh$.invokeExact(utf8string, len, bytes_read, bytes_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_filename_from_uri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_filename_from_uri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_filename_from_uri(const gchar *uri, gchar **hostname, GError **error)
     * }
     */
    public static FunctionDescriptor g_filename_from_uri$descriptor() {
        return g_filename_from_uri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_filename_from_uri(const gchar *uri, gchar **hostname, GError **error)
     * }
     */
    public static MethodHandle g_filename_from_uri$handle() {
        return g_filename_from_uri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_filename_from_uri(const gchar *uri, gchar **hostname, GError **error)
     * }
     */
    public static MemorySegment g_filename_from_uri$address() {
        return g_filename_from_uri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_filename_from_uri(const gchar *uri, gchar **hostname, GError **error)
     * }
     */
    public static MemorySegment g_filename_from_uri(MemorySegment uri, MemorySegment hostname, MemorySegment error) {
        var mh$ = g_filename_from_uri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_filename_from_uri", uri, hostname, error);
            }
            return (MemorySegment)mh$.invokeExact(uri, hostname, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_filename_to_uri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_filename_to_uri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_filename_to_uri(const gchar *filename, const gchar *hostname, GError **error)
     * }
     */
    public static FunctionDescriptor g_filename_to_uri$descriptor() {
        return g_filename_to_uri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_filename_to_uri(const gchar *filename, const gchar *hostname, GError **error)
     * }
     */
    public static MethodHandle g_filename_to_uri$handle() {
        return g_filename_to_uri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_filename_to_uri(const gchar *filename, const gchar *hostname, GError **error)
     * }
     */
    public static MemorySegment g_filename_to_uri$address() {
        return g_filename_to_uri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_filename_to_uri(const gchar *filename, const gchar *hostname, GError **error)
     * }
     */
    public static MemorySegment g_filename_to_uri(MemorySegment filename, MemorySegment hostname, MemorySegment error) {
        var mh$ = g_filename_to_uri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_filename_to_uri", filename, hostname, error);
            }
            return (MemorySegment)mh$.invokeExact(filename, hostname, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_filename_display_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_filename_display_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_filename_display_name(const gchar *filename)
     * }
     */
    public static FunctionDescriptor g_filename_display_name$descriptor() {
        return g_filename_display_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_filename_display_name(const gchar *filename)
     * }
     */
    public static MethodHandle g_filename_display_name$handle() {
        return g_filename_display_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_filename_display_name(const gchar *filename)
     * }
     */
    public static MemorySegment g_filename_display_name$address() {
        return g_filename_display_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_filename_display_name(const gchar *filename)
     * }
     */
    public static MemorySegment g_filename_display_name(MemorySegment filename) {
        var mh$ = g_filename_display_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_filename_display_name", filename);
            }
            return (MemorySegment)mh$.invokeExact(filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_filename_charsets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_filename_charsets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_get_filename_charsets(const gchar ***filename_charsets)
     * }
     */
    public static FunctionDescriptor g_get_filename_charsets$descriptor() {
        return g_get_filename_charsets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_get_filename_charsets(const gchar ***filename_charsets)
     * }
     */
    public static MethodHandle g_get_filename_charsets$handle() {
        return g_get_filename_charsets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_get_filename_charsets(const gchar ***filename_charsets)
     * }
     */
    public static MemorySegment g_get_filename_charsets$address() {
        return g_get_filename_charsets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_get_filename_charsets(const gchar ***filename_charsets)
     * }
     */
    public static int g_get_filename_charsets(MemorySegment filename_charsets) {
        var mh$ = g_get_filename_charsets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_filename_charsets", filename_charsets);
            }
            return (int)mh$.invokeExact(filename_charsets);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_filename_display_basename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_filename_display_basename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_filename_display_basename(const gchar *filename)
     * }
     */
    public static FunctionDescriptor g_filename_display_basename$descriptor() {
        return g_filename_display_basename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_filename_display_basename(const gchar *filename)
     * }
     */
    public static MethodHandle g_filename_display_basename$handle() {
        return g_filename_display_basename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_filename_display_basename(const gchar *filename)
     * }
     */
    public static MemorySegment g_filename_display_basename$address() {
        return g_filename_display_basename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_filename_display_basename(const gchar *filename)
     * }
     */
    public static MemorySegment g_filename_display_basename(MemorySegment filename) {
        var mh$ = g_filename_display_basename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_filename_display_basename", filename);
            }
            return (MemorySegment)mh$.invokeExact(filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_uri_list_extract_uris {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_uri_list_extract_uris");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_uri_list_extract_uris(const gchar *uri_list)
     * }
     */
    public static FunctionDescriptor g_uri_list_extract_uris$descriptor() {
        return g_uri_list_extract_uris.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_uri_list_extract_uris(const gchar *uri_list)
     * }
     */
    public static MethodHandle g_uri_list_extract_uris$handle() {
        return g_uri_list_extract_uris.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_uri_list_extract_uris(const gchar *uri_list)
     * }
     */
    public static MemorySegment g_uri_list_extract_uris$address() {
        return g_uri_list_extract_uris.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_uri_list_extract_uris(const gchar *uri_list)
     * }
     */
    public static MemorySegment g_uri_list_extract_uris(MemorySegment uri_list) {
        var mh$ = g_uri_list_extract_uris.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_uri_list_extract_uris", uri_list);
            }
            return (MemorySegment)mh$.invokeExact(uri_list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_datalist_init(GData **datalist)
     * }
     */
    public static FunctionDescriptor g_datalist_init$descriptor() {
        return g_datalist_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_datalist_init(GData **datalist)
     * }
     */
    public static MethodHandle g_datalist_init$handle() {
        return g_datalist_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_datalist_init(GData **datalist)
     * }
     */
    public static MemorySegment g_datalist_init$address() {
        return g_datalist_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_datalist_init(GData **datalist)
     * }
     */
    public static void g_datalist_init(MemorySegment datalist) {
        var mh$ = g_datalist_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_init", datalist);
            }
            mh$.invokeExact(datalist);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_datalist_clear(GData **datalist)
     * }
     */
    public static FunctionDescriptor g_datalist_clear$descriptor() {
        return g_datalist_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_datalist_clear(GData **datalist)
     * }
     */
    public static MethodHandle g_datalist_clear$handle() {
        return g_datalist_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_datalist_clear(GData **datalist)
     * }
     */
    public static MemorySegment g_datalist_clear$address() {
        return g_datalist_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_datalist_clear(GData **datalist)
     * }
     */
    public static void g_datalist_clear(MemorySegment datalist) {
        var mh$ = g_datalist_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_clear", datalist);
            }
            mh$.invokeExact(datalist);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_id_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_id_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_get_data(GData **datalist, GQuark key_id)
     * }
     */
    public static FunctionDescriptor g_datalist_id_get_data$descriptor() {
        return g_datalist_id_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_get_data(GData **datalist, GQuark key_id)
     * }
     */
    public static MethodHandle g_datalist_id_get_data$handle() {
        return g_datalist_id_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_get_data(GData **datalist, GQuark key_id)
     * }
     */
    public static MemorySegment g_datalist_id_get_data$address() {
        return g_datalist_id_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_get_data(GData **datalist, GQuark key_id)
     * }
     */
    public static MemorySegment g_datalist_id_get_data(MemorySegment datalist, int key_id) {
        var mh$ = g_datalist_id_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_id_get_data", datalist, key_id);
            }
            return (MemorySegment)mh$.invokeExact(datalist, key_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_id_set_data_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_id_set_data_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_datalist_id_set_data_full(GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func)
     * }
     */
    public static FunctionDescriptor g_datalist_id_set_data_full$descriptor() {
        return g_datalist_id_set_data_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_datalist_id_set_data_full(GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func)
     * }
     */
    public static MethodHandle g_datalist_id_set_data_full$handle() {
        return g_datalist_id_set_data_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_datalist_id_set_data_full(GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func)
     * }
     */
    public static MemorySegment g_datalist_id_set_data_full$address() {
        return g_datalist_id_set_data_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_datalist_id_set_data_full(GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func)
     * }
     */
    public static void g_datalist_id_set_data_full(MemorySegment datalist, int key_id, MemorySegment data, MemorySegment destroy_func) {
        var mh$ = g_datalist_id_set_data_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_id_set_data_full", datalist, key_id, data, destroy_func);
            }
            mh$.invokeExact(datalist, key_id, data, destroy_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_id_remove_multiple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_id_remove_multiple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_datalist_id_remove_multiple(GData **datalist, GQuark *keys, gsize n_keys)
     * }
     */
    public static FunctionDescriptor g_datalist_id_remove_multiple$descriptor() {
        return g_datalist_id_remove_multiple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_datalist_id_remove_multiple(GData **datalist, GQuark *keys, gsize n_keys)
     * }
     */
    public static MethodHandle g_datalist_id_remove_multiple$handle() {
        return g_datalist_id_remove_multiple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_datalist_id_remove_multiple(GData **datalist, GQuark *keys, gsize n_keys)
     * }
     */
    public static MemorySegment g_datalist_id_remove_multiple$address() {
        return g_datalist_id_remove_multiple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_datalist_id_remove_multiple(GData **datalist, GQuark *keys, gsize n_keys)
     * }
     */
    public static void g_datalist_id_remove_multiple(MemorySegment datalist, MemorySegment keys, long n_keys) {
        var mh$ = g_datalist_id_remove_multiple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_id_remove_multiple", datalist, keys, n_keys);
            }
            mh$.invokeExact(datalist, keys, n_keys);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_id_dup_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_id_dup_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_dup_data(GData **datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_datalist_id_dup_data$descriptor() {
        return g_datalist_id_dup_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_dup_data(GData **datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_datalist_id_dup_data$handle() {
        return g_datalist_id_dup_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_dup_data(GData **datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_datalist_id_dup_data$address() {
        return g_datalist_id_dup_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_dup_data(GData **datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_datalist_id_dup_data(MemorySegment datalist, int key_id, MemorySegment dup_func, MemorySegment user_data) {
        var mh$ = g_datalist_id_dup_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_id_dup_data", datalist, key_id, dup_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(datalist, key_id, dup_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_id_replace_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_id_replace_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_datalist_id_replace_data(GData **datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static FunctionDescriptor g_datalist_id_replace_data$descriptor() {
        return g_datalist_id_replace_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_datalist_id_replace_data(GData **datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static MethodHandle g_datalist_id_replace_data$handle() {
        return g_datalist_id_replace_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_datalist_id_replace_data(GData **datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static MemorySegment g_datalist_id_replace_data$address() {
        return g_datalist_id_replace_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_datalist_id_replace_data(GData **datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy)
     * }
     */
    public static int g_datalist_id_replace_data(MemorySegment datalist, int key_id, MemorySegment oldval, MemorySegment newval, MemorySegment destroy, MemorySegment old_destroy) {
        var mh$ = g_datalist_id_replace_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_id_replace_data", datalist, key_id, oldval, newval, destroy, old_destroy);
            }
            return (int)mh$.invokeExact(datalist, key_id, oldval, newval, destroy, old_destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_id_remove_no_notify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_id_remove_no_notify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_remove_no_notify(GData **datalist, GQuark key_id)
     * }
     */
    public static FunctionDescriptor g_datalist_id_remove_no_notify$descriptor() {
        return g_datalist_id_remove_no_notify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_remove_no_notify(GData **datalist, GQuark key_id)
     * }
     */
    public static MethodHandle g_datalist_id_remove_no_notify$handle() {
        return g_datalist_id_remove_no_notify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_remove_no_notify(GData **datalist, GQuark key_id)
     * }
     */
    public static MemorySegment g_datalist_id_remove_no_notify$address() {
        return g_datalist_id_remove_no_notify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_datalist_id_remove_no_notify(GData **datalist, GQuark key_id)
     * }
     */
    public static MemorySegment g_datalist_id_remove_no_notify(MemorySegment datalist, int key_id) {
        var mh$ = g_datalist_id_remove_no_notify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_id_remove_no_notify", datalist, key_id);
            }
            return (MemorySegment)mh$.invokeExact(datalist, key_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_datalist_foreach(GData **datalist, GDataForeachFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_datalist_foreach$descriptor() {
        return g_datalist_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_datalist_foreach(GData **datalist, GDataForeachFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_datalist_foreach$handle() {
        return g_datalist_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_datalist_foreach(GData **datalist, GDataForeachFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_datalist_foreach$address() {
        return g_datalist_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_datalist_foreach(GData **datalist, GDataForeachFunc func, gpointer user_data)
     * }
     */
    public static void g_datalist_foreach(MemorySegment datalist, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_datalist_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_foreach", datalist, func, user_data);
            }
            mh$.invokeExact(datalist, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_set_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_set_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_datalist_set_flags(GData **datalist, guint flags)
     * }
     */
    public static FunctionDescriptor g_datalist_set_flags$descriptor() {
        return g_datalist_set_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_datalist_set_flags(GData **datalist, guint flags)
     * }
     */
    public static MethodHandle g_datalist_set_flags$handle() {
        return g_datalist_set_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_datalist_set_flags(GData **datalist, guint flags)
     * }
     */
    public static MemorySegment g_datalist_set_flags$address() {
        return g_datalist_set_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_datalist_set_flags(GData **datalist, guint flags)
     * }
     */
    public static void g_datalist_set_flags(MemorySegment datalist, int flags) {
        var mh$ = g_datalist_set_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_set_flags", datalist, flags);
            }
            mh$.invokeExact(datalist, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_unset_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_unset_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_datalist_unset_flags(GData **datalist, guint flags)
     * }
     */
    public static FunctionDescriptor g_datalist_unset_flags$descriptor() {
        return g_datalist_unset_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_datalist_unset_flags(GData **datalist, guint flags)
     * }
     */
    public static MethodHandle g_datalist_unset_flags$handle() {
        return g_datalist_unset_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_datalist_unset_flags(GData **datalist, guint flags)
     * }
     */
    public static MemorySegment g_datalist_unset_flags$address() {
        return g_datalist_unset_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_datalist_unset_flags(GData **datalist, guint flags)
     * }
     */
    public static void g_datalist_unset_flags(MemorySegment datalist, int flags) {
        var mh$ = g_datalist_unset_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_unset_flags", datalist, flags);
            }
            mh$.invokeExact(datalist, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_datalist_get_flags(GData **datalist)
     * }
     */
    public static FunctionDescriptor g_datalist_get_flags$descriptor() {
        return g_datalist_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_datalist_get_flags(GData **datalist)
     * }
     */
    public static MethodHandle g_datalist_get_flags$handle() {
        return g_datalist_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_datalist_get_flags(GData **datalist)
     * }
     */
    public static MemorySegment g_datalist_get_flags$address() {
        return g_datalist_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_datalist_get_flags(GData **datalist)
     * }
     */
    public static int g_datalist_get_flags(MemorySegment datalist) {
        var mh$ = g_datalist_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_get_flags", datalist);
            }
            return (int)mh$.invokeExact(datalist);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dataset_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dataset_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_dataset_destroy(gconstpointer dataset_location)
     * }
     */
    public static FunctionDescriptor g_dataset_destroy$descriptor() {
        return g_dataset_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_dataset_destroy(gconstpointer dataset_location)
     * }
     */
    public static MethodHandle g_dataset_destroy$handle() {
        return g_dataset_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_dataset_destroy(gconstpointer dataset_location)
     * }
     */
    public static MemorySegment g_dataset_destroy$address() {
        return g_dataset_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_dataset_destroy(gconstpointer dataset_location)
     * }
     */
    public static void g_dataset_destroy(MemorySegment dataset_location) {
        var mh$ = g_dataset_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dataset_destroy", dataset_location);
            }
            mh$.invokeExact(dataset_location);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dataset_id_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dataset_id_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_dataset_id_get_data(gconstpointer dataset_location, GQuark key_id)
     * }
     */
    public static FunctionDescriptor g_dataset_id_get_data$descriptor() {
        return g_dataset_id_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_dataset_id_get_data(gconstpointer dataset_location, GQuark key_id)
     * }
     */
    public static MethodHandle g_dataset_id_get_data$handle() {
        return g_dataset_id_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_dataset_id_get_data(gconstpointer dataset_location, GQuark key_id)
     * }
     */
    public static MemorySegment g_dataset_id_get_data$address() {
        return g_dataset_id_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_dataset_id_get_data(gconstpointer dataset_location, GQuark key_id)
     * }
     */
    public static MemorySegment g_dataset_id_get_data(MemorySegment dataset_location, int key_id) {
        var mh$ = g_dataset_id_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dataset_id_get_data", dataset_location, key_id);
            }
            return (MemorySegment)mh$.invokeExact(dataset_location, key_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_datalist_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_datalist_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_get_data(GData **datalist, const gchar *key)
     * }
     */
    public static FunctionDescriptor g_datalist_get_data$descriptor() {
        return g_datalist_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_get_data(GData **datalist, const gchar *key)
     * }
     */
    public static MethodHandle g_datalist_get_data$handle() {
        return g_datalist_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_datalist_get_data(GData **datalist, const gchar *key)
     * }
     */
    public static MemorySegment g_datalist_get_data$address() {
        return g_datalist_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_datalist_get_data(GData **datalist, const gchar *key)
     * }
     */
    public static MemorySegment g_datalist_get_data(MemorySegment datalist, MemorySegment key) {
        var mh$ = g_datalist_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_datalist_get_data", datalist, key);
            }
            return (MemorySegment)mh$.invokeExact(datalist, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dataset_id_set_data_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dataset_id_set_data_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_dataset_id_set_data_full(gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func)
     * }
     */
    public static FunctionDescriptor g_dataset_id_set_data_full$descriptor() {
        return g_dataset_id_set_data_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_dataset_id_set_data_full(gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func)
     * }
     */
    public static MethodHandle g_dataset_id_set_data_full$handle() {
        return g_dataset_id_set_data_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_dataset_id_set_data_full(gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func)
     * }
     */
    public static MemorySegment g_dataset_id_set_data_full$address() {
        return g_dataset_id_set_data_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_dataset_id_set_data_full(gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func)
     * }
     */
    public static void g_dataset_id_set_data_full(MemorySegment dataset_location, int key_id, MemorySegment data, MemorySegment destroy_func) {
        var mh$ = g_dataset_id_set_data_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dataset_id_set_data_full", dataset_location, key_id, data, destroy_func);
            }
            mh$.invokeExact(dataset_location, key_id, data, destroy_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dataset_id_remove_no_notify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dataset_id_remove_no_notify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location, GQuark key_id)
     * }
     */
    public static FunctionDescriptor g_dataset_id_remove_no_notify$descriptor() {
        return g_dataset_id_remove_no_notify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location, GQuark key_id)
     * }
     */
    public static MethodHandle g_dataset_id_remove_no_notify$handle() {
        return g_dataset_id_remove_no_notify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location, GQuark key_id)
     * }
     */
    public static MemorySegment g_dataset_id_remove_no_notify$address() {
        return g_dataset_id_remove_no_notify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location, GQuark key_id)
     * }
     */
    public static MemorySegment g_dataset_id_remove_no_notify(MemorySegment dataset_location, int key_id) {
        var mh$ = g_dataset_id_remove_no_notify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dataset_id_remove_no_notify", dataset_location, key_id);
            }
            return (MemorySegment)mh$.invokeExact(dataset_location, key_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dataset_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dataset_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_dataset_foreach(gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_dataset_foreach$descriptor() {
        return g_dataset_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_dataset_foreach(gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_dataset_foreach$handle() {
        return g_dataset_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_dataset_foreach(gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_dataset_foreach$address() {
        return g_dataset_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_dataset_foreach(gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data)
     * }
     */
    public static void g_dataset_foreach(MemorySegment dataset_location, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_dataset_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dataset_foreach", dataset_location, func, user_data);
            }
            mh$.invokeExact(dataset_location, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef gint32 GTime
     * }
     */
    public static final OfInt GTime = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef guint16 GDateYear
     * }
     */
    public static final OfShort GDateYear = gst_min_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef guint8 GDateDay
     * }
     */
    public static final OfByte GDateDay = gst_min_h.C_CHAR;
    private static final int G_DATE_DAY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_DAY = 0
     * }
     */
    public static int G_DATE_DAY() {
        return G_DATE_DAY;
    }
    private static final int G_DATE_MONTH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_MONTH = 1
     * }
     */
    public static int G_DATE_MONTH() {
        return G_DATE_MONTH;
    }
    private static final int G_DATE_YEAR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_YEAR = 2
     * }
     */
    public static int G_DATE_YEAR() {
        return G_DATE_YEAR;
    }
    private static final int G_DATE_BAD_WEEKDAY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_BAD_WEEKDAY = 0
     * }
     */
    public static int G_DATE_BAD_WEEKDAY() {
        return G_DATE_BAD_WEEKDAY;
    }
    private static final int G_DATE_MONDAY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_MONDAY = 1
     * }
     */
    public static int G_DATE_MONDAY() {
        return G_DATE_MONDAY;
    }
    private static final int G_DATE_TUESDAY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_TUESDAY = 2
     * }
     */
    public static int G_DATE_TUESDAY() {
        return G_DATE_TUESDAY;
    }
    private static final int G_DATE_WEDNESDAY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_WEDNESDAY = 3
     * }
     */
    public static int G_DATE_WEDNESDAY() {
        return G_DATE_WEDNESDAY;
    }
    private static final int G_DATE_THURSDAY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_THURSDAY = 4
     * }
     */
    public static int G_DATE_THURSDAY() {
        return G_DATE_THURSDAY;
    }
    private static final int G_DATE_FRIDAY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_FRIDAY = 5
     * }
     */
    public static int G_DATE_FRIDAY() {
        return G_DATE_FRIDAY;
    }
    private static final int G_DATE_SATURDAY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_SATURDAY = 6
     * }
     */
    public static int G_DATE_SATURDAY() {
        return G_DATE_SATURDAY;
    }
    private static final int G_DATE_SUNDAY = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_SUNDAY = 7
     * }
     */
    public static int G_DATE_SUNDAY() {
        return G_DATE_SUNDAY;
    }
    private static final int G_DATE_BAD_MONTH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_BAD_MONTH = 0
     * }
     */
    public static int G_DATE_BAD_MONTH() {
        return G_DATE_BAD_MONTH;
    }
    private static final int G_DATE_JANUARY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_JANUARY = 1
     * }
     */
    public static int G_DATE_JANUARY() {
        return G_DATE_JANUARY;
    }
    private static final int G_DATE_FEBRUARY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_FEBRUARY = 2
     * }
     */
    public static int G_DATE_FEBRUARY() {
        return G_DATE_FEBRUARY;
    }
    private static final int G_DATE_MARCH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_MARCH = 3
     * }
     */
    public static int G_DATE_MARCH() {
        return G_DATE_MARCH;
    }
    private static final int G_DATE_APRIL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_APRIL = 4
     * }
     */
    public static int G_DATE_APRIL() {
        return G_DATE_APRIL;
    }
    private static final int G_DATE_MAY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_MAY = 5
     * }
     */
    public static int G_DATE_MAY() {
        return G_DATE_MAY;
    }
    private static final int G_DATE_JUNE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_JUNE = 6
     * }
     */
    public static int G_DATE_JUNE() {
        return G_DATE_JUNE;
    }
    private static final int G_DATE_JULY = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_JULY = 7
     * }
     */
    public static int G_DATE_JULY() {
        return G_DATE_JULY;
    }
    private static final int G_DATE_AUGUST = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_AUGUST = 8
     * }
     */
    public static int G_DATE_AUGUST() {
        return G_DATE_AUGUST;
    }
    private static final int G_DATE_SEPTEMBER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_SEPTEMBER = 9
     * }
     */
    public static int G_DATE_SEPTEMBER() {
        return G_DATE_SEPTEMBER;
    }
    private static final int G_DATE_OCTOBER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_OCTOBER = 10
     * }
     */
    public static int G_DATE_OCTOBER() {
        return G_DATE_OCTOBER;
    }
    private static final int G_DATE_NOVEMBER = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_NOVEMBER = 11
     * }
     */
    public static int G_DATE_NOVEMBER() {
        return G_DATE_NOVEMBER;
    }
    private static final int G_DATE_DECEMBER = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_DATE_DECEMBER = 12
     * }
     */
    public static int G_DATE_DECEMBER() {
        return G_DATE_DECEMBER;
    }

    private static class g_date_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDate *g_date_new()
     * }
     */
    public static FunctionDescriptor g_date_new$descriptor() {
        return g_date_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDate *g_date_new()
     * }
     */
    public static MethodHandle g_date_new$handle() {
        return g_date_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDate *g_date_new()
     * }
     */
    public static MemorySegment g_date_new$address() {
        return g_date_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDate *g_date_new()
     * }
     */
    public static MemorySegment g_date_new() {
        var mh$ = g_date_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_new_dmy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR,
            gst_min_h.C_INT,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_new_dmy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDate *g_date_new_dmy(GDateDay day, GDateMonth month, GDateYear year)
     * }
     */
    public static FunctionDescriptor g_date_new_dmy$descriptor() {
        return g_date_new_dmy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDate *g_date_new_dmy(GDateDay day, GDateMonth month, GDateYear year)
     * }
     */
    public static MethodHandle g_date_new_dmy$handle() {
        return g_date_new_dmy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDate *g_date_new_dmy(GDateDay day, GDateMonth month, GDateYear year)
     * }
     */
    public static MemorySegment g_date_new_dmy$address() {
        return g_date_new_dmy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDate *g_date_new_dmy(GDateDay day, GDateMonth month, GDateYear year)
     * }
     */
    public static MemorySegment g_date_new_dmy(byte day, int month, short year) {
        var mh$ = g_date_new_dmy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_new_dmy", day, month, year);
            }
            return (MemorySegment)mh$.invokeExact(day, month, year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_new_julian {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_new_julian");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDate *g_date_new_julian(guint32 julian_day)
     * }
     */
    public static FunctionDescriptor g_date_new_julian$descriptor() {
        return g_date_new_julian.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDate *g_date_new_julian(guint32 julian_day)
     * }
     */
    public static MethodHandle g_date_new_julian$handle() {
        return g_date_new_julian.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDate *g_date_new_julian(guint32 julian_day)
     * }
     */
    public static MemorySegment g_date_new_julian$address() {
        return g_date_new_julian.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDate *g_date_new_julian(guint32 julian_day)
     * }
     */
    public static MemorySegment g_date_new_julian(int julian_day) {
        var mh$ = g_date_new_julian.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_new_julian", julian_day);
            }
            return (MemorySegment)mh$.invokeExact(julian_day);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_free(GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_free$descriptor() {
        return g_date_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_free(GDate *date)
     * }
     */
    public static MethodHandle g_date_free$handle() {
        return g_date_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_free(GDate *date)
     * }
     */
    public static MemorySegment g_date_free$address() {
        return g_date_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_free(GDate *date)
     * }
     */
    public static void g_date_free(MemorySegment date) {
        var mh$ = g_date_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_free", date);
            }
            mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDate *g_date_copy(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_copy$descriptor() {
        return g_date_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDate *g_date_copy(const GDate *date)
     * }
     */
    public static MethodHandle g_date_copy$handle() {
        return g_date_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDate *g_date_copy(const GDate *date)
     * }
     */
    public static MemorySegment g_date_copy$address() {
        return g_date_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDate *g_date_copy(const GDate *date)
     * }
     */
    public static MemorySegment g_date_copy(MemorySegment date) {
        var mh$ = g_date_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_copy", date);
            }
            return (MemorySegment)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_valid$descriptor() {
        return g_date_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid(const GDate *date)
     * }
     */
    public static MethodHandle g_date_valid$handle() {
        return g_date_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid(const GDate *date)
     * }
     */
    public static MemorySegment g_date_valid$address() {
        return g_date_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_valid(const GDate *date)
     * }
     */
    public static int g_date_valid(MemorySegment date) {
        var mh$ = g_date_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_valid", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_valid_day {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_valid_day");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_day(GDateDay day)
     * }
     */
    public static FunctionDescriptor g_date_valid_day$descriptor() {
        return g_date_valid_day.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_day(GDateDay day)
     * }
     */
    public static MethodHandle g_date_valid_day$handle() {
        return g_date_valid_day.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_day(GDateDay day)
     * }
     */
    public static MemorySegment g_date_valid_day$address() {
        return g_date_valid_day.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_valid_day(GDateDay day)
     * }
     */
    public static int g_date_valid_day(byte day) {
        var mh$ = g_date_valid_day.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_valid_day", day);
            }
            return (int)mh$.invokeExact(day);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_valid_month {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_valid_month");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_month(GDateMonth month)
     * }
     */
    public static FunctionDescriptor g_date_valid_month$descriptor() {
        return g_date_valid_month.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_month(GDateMonth month)
     * }
     */
    public static MethodHandle g_date_valid_month$handle() {
        return g_date_valid_month.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_month(GDateMonth month)
     * }
     */
    public static MemorySegment g_date_valid_month$address() {
        return g_date_valid_month.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_valid_month(GDateMonth month)
     * }
     */
    public static int g_date_valid_month(int month) {
        var mh$ = g_date_valid_month.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_valid_month", month);
            }
            return (int)mh$.invokeExact(month);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_valid_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_valid_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_year(GDateYear year)
     * }
     */
    public static FunctionDescriptor g_date_valid_year$descriptor() {
        return g_date_valid_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_year(GDateYear year)
     * }
     */
    public static MethodHandle g_date_valid_year$handle() {
        return g_date_valid_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_year(GDateYear year)
     * }
     */
    public static MemorySegment g_date_valid_year$address() {
        return g_date_valid_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_valid_year(GDateYear year)
     * }
     */
    public static int g_date_valid_year(short year) {
        var mh$ = g_date_valid_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_valid_year", year);
            }
            return (int)mh$.invokeExact(year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_valid_weekday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_valid_weekday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_weekday(GDateWeekday weekday)
     * }
     */
    public static FunctionDescriptor g_date_valid_weekday$descriptor() {
        return g_date_valid_weekday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_weekday(GDateWeekday weekday)
     * }
     */
    public static MethodHandle g_date_valid_weekday$handle() {
        return g_date_valid_weekday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_weekday(GDateWeekday weekday)
     * }
     */
    public static MemorySegment g_date_valid_weekday$address() {
        return g_date_valid_weekday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_valid_weekday(GDateWeekday weekday)
     * }
     */
    public static int g_date_valid_weekday(int weekday) {
        var mh$ = g_date_valid_weekday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_valid_weekday", weekday);
            }
            return (int)mh$.invokeExact(weekday);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_valid_julian {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_valid_julian");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_julian(guint32 julian_date)
     * }
     */
    public static FunctionDescriptor g_date_valid_julian$descriptor() {
        return g_date_valid_julian.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_julian(guint32 julian_date)
     * }
     */
    public static MethodHandle g_date_valid_julian$handle() {
        return g_date_valid_julian.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_julian(guint32 julian_date)
     * }
     */
    public static MemorySegment g_date_valid_julian$address() {
        return g_date_valid_julian.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_valid_julian(guint32 julian_date)
     * }
     */
    public static int g_date_valid_julian(int julian_date) {
        var mh$ = g_date_valid_julian.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_valid_julian", julian_date);
            }
            return (int)mh$.invokeExact(julian_date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_valid_dmy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_CHAR,
            gst_min_h.C_INT,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_valid_dmy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_dmy(GDateDay day, GDateMonth month, GDateYear year)
     * }
     */
    public static FunctionDescriptor g_date_valid_dmy$descriptor() {
        return g_date_valid_dmy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_dmy(GDateDay day, GDateMonth month, GDateYear year)
     * }
     */
    public static MethodHandle g_date_valid_dmy$handle() {
        return g_date_valid_dmy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_valid_dmy(GDateDay day, GDateMonth month, GDateYear year)
     * }
     */
    public static MemorySegment g_date_valid_dmy$address() {
        return g_date_valid_dmy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_valid_dmy(GDateDay day, GDateMonth month, GDateYear year)
     * }
     */
    public static int g_date_valid_dmy(byte day, int month, short year) {
        var mh$ = g_date_valid_dmy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_valid_dmy", day, month, year);
            }
            return (int)mh$.invokeExact(day, month, year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_weekday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_weekday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateWeekday g_date_get_weekday(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_weekday$descriptor() {
        return g_date_get_weekday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateWeekday g_date_get_weekday(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_weekday$handle() {
        return g_date_get_weekday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateWeekday g_date_get_weekday(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_weekday$address() {
        return g_date_get_weekday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateWeekday g_date_get_weekday(const GDate *date)
     * }
     */
    public static int g_date_get_weekday(MemorySegment date) {
        var mh$ = g_date_get_weekday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_weekday", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_month {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_month");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateMonth g_date_get_month(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_month$descriptor() {
        return g_date_get_month.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateMonth g_date_get_month(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_month$handle() {
        return g_date_get_month.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateMonth g_date_get_month(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_month$address() {
        return g_date_get_month.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateMonth g_date_get_month(const GDate *date)
     * }
     */
    public static int g_date_get_month(MemorySegment date) {
        var mh$ = g_date_get_month.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_month", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_SHORT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateYear g_date_get_year(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_year$descriptor() {
        return g_date_get_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateYear g_date_get_year(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_year$handle() {
        return g_date_get_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateYear g_date_get_year(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_year$address() {
        return g_date_get_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateYear g_date_get_year(const GDate *date)
     * }
     */
    public static short g_date_get_year(MemorySegment date) {
        var mh$ = g_date_get_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_year", date);
            }
            return (short)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_day {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_CHAR,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_day");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDateDay g_date_get_day(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_day$descriptor() {
        return g_date_get_day.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDateDay g_date_get_day(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_day$handle() {
        return g_date_get_day.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDateDay g_date_get_day(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_day$address() {
        return g_date_get_day.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDateDay g_date_get_day(const GDate *date)
     * }
     */
    public static byte g_date_get_day(MemorySegment date) {
        var mh$ = g_date_get_day.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_day", date);
            }
            return (byte)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_julian {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_julian");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint32 g_date_get_julian(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_julian$descriptor() {
        return g_date_get_julian.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint32 g_date_get_julian(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_julian$handle() {
        return g_date_get_julian.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint32 g_date_get_julian(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_julian$address() {
        return g_date_get_julian.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint32 g_date_get_julian(const GDate *date)
     * }
     */
    public static int g_date_get_julian(MemorySegment date) {
        var mh$ = g_date_get_julian.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_julian", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_day_of_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_day_of_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_date_get_day_of_year(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_day_of_year$descriptor() {
        return g_date_get_day_of_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_date_get_day_of_year(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_day_of_year$handle() {
        return g_date_get_day_of_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_date_get_day_of_year(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_day_of_year$address() {
        return g_date_get_day_of_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_date_get_day_of_year(const GDate *date)
     * }
     */
    public static int g_date_get_day_of_year(MemorySegment date) {
        var mh$ = g_date_get_day_of_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_day_of_year", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_monday_week_of_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_monday_week_of_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_date_get_monday_week_of_year(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_monday_week_of_year$descriptor() {
        return g_date_get_monday_week_of_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_date_get_monday_week_of_year(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_monday_week_of_year$handle() {
        return g_date_get_monday_week_of_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_date_get_monday_week_of_year(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_monday_week_of_year$address() {
        return g_date_get_monday_week_of_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_date_get_monday_week_of_year(const GDate *date)
     * }
     */
    public static int g_date_get_monday_week_of_year(MemorySegment date) {
        var mh$ = g_date_get_monday_week_of_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_monday_week_of_year", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_sunday_week_of_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_sunday_week_of_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_date_get_sunday_week_of_year(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_sunday_week_of_year$descriptor() {
        return g_date_get_sunday_week_of_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_date_get_sunday_week_of_year(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_sunday_week_of_year$handle() {
        return g_date_get_sunday_week_of_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_date_get_sunday_week_of_year(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_sunday_week_of_year$address() {
        return g_date_get_sunday_week_of_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_date_get_sunday_week_of_year(const GDate *date)
     * }
     */
    public static int g_date_get_sunday_week_of_year(MemorySegment date) {
        var mh$ = g_date_get_sunday_week_of_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_sunday_week_of_year", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_iso8601_week_of_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_iso8601_week_of_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_date_get_iso8601_week_of_year(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_get_iso8601_week_of_year$descriptor() {
        return g_date_get_iso8601_week_of_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_date_get_iso8601_week_of_year(const GDate *date)
     * }
     */
    public static MethodHandle g_date_get_iso8601_week_of_year$handle() {
        return g_date_get_iso8601_week_of_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_date_get_iso8601_week_of_year(const GDate *date)
     * }
     */
    public static MemorySegment g_date_get_iso8601_week_of_year$address() {
        return g_date_get_iso8601_week_of_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_date_get_iso8601_week_of_year(const GDate *date)
     * }
     */
    public static int g_date_get_iso8601_week_of_year(MemorySegment date) {
        var mh$ = g_date_get_iso8601_week_of_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_iso8601_week_of_year", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_clear(GDate *date, guint n_dates)
     * }
     */
    public static FunctionDescriptor g_date_clear$descriptor() {
        return g_date_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_clear(GDate *date, guint n_dates)
     * }
     */
    public static MethodHandle g_date_clear$handle() {
        return g_date_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_clear(GDate *date, guint n_dates)
     * }
     */
    public static MemorySegment g_date_clear$address() {
        return g_date_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_clear(GDate *date, guint n_dates)
     * }
     */
    public static void g_date_clear(MemorySegment date, int n_dates) {
        var mh$ = g_date_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_clear", date, n_dates);
            }
            mh$.invokeExact(date, n_dates);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_parse(GDate *date, const gchar *str)
     * }
     */
    public static FunctionDescriptor g_date_set_parse$descriptor() {
        return g_date_set_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_parse(GDate *date, const gchar *str)
     * }
     */
    public static MethodHandle g_date_set_parse$handle() {
        return g_date_set_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_parse(GDate *date, const gchar *str)
     * }
     */
    public static MemorySegment g_date_set_parse$address() {
        return g_date_set_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_parse(GDate *date, const gchar *str)
     * }
     */
    public static void g_date_set_parse(MemorySegment date, MemorySegment str) {
        var mh$ = g_date_set_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_parse", date, str);
            }
            mh$.invokeExact(date, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_time_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_time_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_time_t(GDate *date, time_t timet)
     * }
     */
    public static FunctionDescriptor g_date_set_time_t$descriptor() {
        return g_date_set_time_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_time_t(GDate *date, time_t timet)
     * }
     */
    public static MethodHandle g_date_set_time_t$handle() {
        return g_date_set_time_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_time_t(GDate *date, time_t timet)
     * }
     */
    public static MemorySegment g_date_set_time_t$address() {
        return g_date_set_time_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_time_t(GDate *date, time_t timet)
     * }
     */
    public static void g_date_set_time_t(MemorySegment date, long timet) {
        var mh$ = g_date_set_time_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_time_t", date, timet);
            }
            mh$.invokeExact(date, timet);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_time_val {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_time_val");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_time_val(GDate *date, GTimeVal *timeval)
     * }
     */
    public static FunctionDescriptor g_date_set_time_val$descriptor() {
        return g_date_set_time_val.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_time_val(GDate *date, GTimeVal *timeval)
     * }
     */
    public static MethodHandle g_date_set_time_val$handle() {
        return g_date_set_time_val.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_time_val(GDate *date, GTimeVal *timeval)
     * }
     */
    public static MemorySegment g_date_set_time_val$address() {
        return g_date_set_time_val.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_time_val(GDate *date, GTimeVal *timeval)
     * }
     */
    public static void g_date_set_time_val(MemorySegment date, MemorySegment timeval) {
        var mh$ = g_date_set_time_val.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_time_val", date, timeval);
            }
            mh$.invokeExact(date, timeval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_time(GDate *date, GTime time_)
     * }
     */
    public static FunctionDescriptor g_date_set_time$descriptor() {
        return g_date_set_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_time(GDate *date, GTime time_)
     * }
     */
    public static MethodHandle g_date_set_time$handle() {
        return g_date_set_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_time(GDate *date, GTime time_)
     * }
     */
    public static MemorySegment g_date_set_time$address() {
        return g_date_set_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_time(GDate *date, GTime time_)
     * }
     */
    public static void g_date_set_time(MemorySegment date, int time_) {
        var mh$ = g_date_set_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_time", date, time_);
            }
            mh$.invokeExact(date, time_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_month {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_month");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_month(GDate *date, GDateMonth month)
     * }
     */
    public static FunctionDescriptor g_date_set_month$descriptor() {
        return g_date_set_month.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_month(GDate *date, GDateMonth month)
     * }
     */
    public static MethodHandle g_date_set_month$handle() {
        return g_date_set_month.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_month(GDate *date, GDateMonth month)
     * }
     */
    public static MemorySegment g_date_set_month$address() {
        return g_date_set_month.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_month(GDate *date, GDateMonth month)
     * }
     */
    public static void g_date_set_month(MemorySegment date, int month) {
        var mh$ = g_date_set_month.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_month", date, month);
            }
            mh$.invokeExact(date, month);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_day {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_day");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_day(GDate *date, GDateDay day)
     * }
     */
    public static FunctionDescriptor g_date_set_day$descriptor() {
        return g_date_set_day.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_day(GDate *date, GDateDay day)
     * }
     */
    public static MethodHandle g_date_set_day$handle() {
        return g_date_set_day.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_day(GDate *date, GDateDay day)
     * }
     */
    public static MemorySegment g_date_set_day$address() {
        return g_date_set_day.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_day(GDate *date, GDateDay day)
     * }
     */
    public static void g_date_set_day(MemorySegment date, byte day) {
        var mh$ = g_date_set_day.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_day", date, day);
            }
            mh$.invokeExact(date, day);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_year(GDate *date, GDateYear year)
     * }
     */
    public static FunctionDescriptor g_date_set_year$descriptor() {
        return g_date_set_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_year(GDate *date, GDateYear year)
     * }
     */
    public static MethodHandle g_date_set_year$handle() {
        return g_date_set_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_year(GDate *date, GDateYear year)
     * }
     */
    public static MemorySegment g_date_set_year$address() {
        return g_date_set_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_year(GDate *date, GDateYear year)
     * }
     */
    public static void g_date_set_year(MemorySegment date, short year) {
        var mh$ = g_date_set_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_year", date, year);
            }
            mh$.invokeExact(date, year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_dmy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR,
            gst_min_h.C_INT,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_dmy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_dmy(GDate *date, GDateDay day, GDateMonth month, GDateYear y)
     * }
     */
    public static FunctionDescriptor g_date_set_dmy$descriptor() {
        return g_date_set_dmy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_dmy(GDate *date, GDateDay day, GDateMonth month, GDateYear y)
     * }
     */
    public static MethodHandle g_date_set_dmy$handle() {
        return g_date_set_dmy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_dmy(GDate *date, GDateDay day, GDateMonth month, GDateYear y)
     * }
     */
    public static MemorySegment g_date_set_dmy$address() {
        return g_date_set_dmy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_dmy(GDate *date, GDateDay day, GDateMonth month, GDateYear y)
     * }
     */
    public static void g_date_set_dmy(MemorySegment date, byte day, int month, short y) {
        var mh$ = g_date_set_dmy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_dmy", date, day, month, y);
            }
            mh$.invokeExact(date, day, month, y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_set_julian {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_set_julian");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_set_julian(GDate *date, guint32 julian_date)
     * }
     */
    public static FunctionDescriptor g_date_set_julian$descriptor() {
        return g_date_set_julian.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_set_julian(GDate *date, guint32 julian_date)
     * }
     */
    public static MethodHandle g_date_set_julian$handle() {
        return g_date_set_julian.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_set_julian(GDate *date, guint32 julian_date)
     * }
     */
    public static MemorySegment g_date_set_julian$address() {
        return g_date_set_julian.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_set_julian(GDate *date, guint32 julian_date)
     * }
     */
    public static void g_date_set_julian(MemorySegment date, int julian_date) {
        var mh$ = g_date_set_julian.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_set_julian", date, julian_date);
            }
            mh$.invokeExact(date, julian_date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_is_first_of_month {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_is_first_of_month");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_first_of_month(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_is_first_of_month$descriptor() {
        return g_date_is_first_of_month.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_first_of_month(const GDate *date)
     * }
     */
    public static MethodHandle g_date_is_first_of_month$handle() {
        return g_date_is_first_of_month.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_first_of_month(const GDate *date)
     * }
     */
    public static MemorySegment g_date_is_first_of_month$address() {
        return g_date_is_first_of_month.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_is_first_of_month(const GDate *date)
     * }
     */
    public static int g_date_is_first_of_month(MemorySegment date) {
        var mh$ = g_date_is_first_of_month.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_is_first_of_month", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_is_last_of_month {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_is_last_of_month");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_last_of_month(const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_is_last_of_month$descriptor() {
        return g_date_is_last_of_month.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_last_of_month(const GDate *date)
     * }
     */
    public static MethodHandle g_date_is_last_of_month$handle() {
        return g_date_is_last_of_month.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_last_of_month(const GDate *date)
     * }
     */
    public static MemorySegment g_date_is_last_of_month$address() {
        return g_date_is_last_of_month.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_is_last_of_month(const GDate *date)
     * }
     */
    public static int g_date_is_last_of_month(MemorySegment date) {
        var mh$ = g_date_is_last_of_month.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_is_last_of_month", date);
            }
            return (int)mh$.invokeExact(date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_add_days {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_add_days");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_add_days(GDate *date, guint n_days)
     * }
     */
    public static FunctionDescriptor g_date_add_days$descriptor() {
        return g_date_add_days.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_add_days(GDate *date, guint n_days)
     * }
     */
    public static MethodHandle g_date_add_days$handle() {
        return g_date_add_days.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_add_days(GDate *date, guint n_days)
     * }
     */
    public static MemorySegment g_date_add_days$address() {
        return g_date_add_days.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_add_days(GDate *date, guint n_days)
     * }
     */
    public static void g_date_add_days(MemorySegment date, int n_days) {
        var mh$ = g_date_add_days.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_add_days", date, n_days);
            }
            mh$.invokeExact(date, n_days);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_subtract_days {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_subtract_days");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_subtract_days(GDate *date, guint n_days)
     * }
     */
    public static FunctionDescriptor g_date_subtract_days$descriptor() {
        return g_date_subtract_days.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_subtract_days(GDate *date, guint n_days)
     * }
     */
    public static MethodHandle g_date_subtract_days$handle() {
        return g_date_subtract_days.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_subtract_days(GDate *date, guint n_days)
     * }
     */
    public static MemorySegment g_date_subtract_days$address() {
        return g_date_subtract_days.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_subtract_days(GDate *date, guint n_days)
     * }
     */
    public static void g_date_subtract_days(MemorySegment date, int n_days) {
        var mh$ = g_date_subtract_days.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_subtract_days", date, n_days);
            }
            mh$.invokeExact(date, n_days);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_add_months {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_add_months");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_add_months(GDate *date, guint n_months)
     * }
     */
    public static FunctionDescriptor g_date_add_months$descriptor() {
        return g_date_add_months.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_add_months(GDate *date, guint n_months)
     * }
     */
    public static MethodHandle g_date_add_months$handle() {
        return g_date_add_months.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_add_months(GDate *date, guint n_months)
     * }
     */
    public static MemorySegment g_date_add_months$address() {
        return g_date_add_months.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_add_months(GDate *date, guint n_months)
     * }
     */
    public static void g_date_add_months(MemorySegment date, int n_months) {
        var mh$ = g_date_add_months.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_add_months", date, n_months);
            }
            mh$.invokeExact(date, n_months);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_subtract_months {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_subtract_months");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_subtract_months(GDate *date, guint n_months)
     * }
     */
    public static FunctionDescriptor g_date_subtract_months$descriptor() {
        return g_date_subtract_months.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_subtract_months(GDate *date, guint n_months)
     * }
     */
    public static MethodHandle g_date_subtract_months$handle() {
        return g_date_subtract_months.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_subtract_months(GDate *date, guint n_months)
     * }
     */
    public static MemorySegment g_date_subtract_months$address() {
        return g_date_subtract_months.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_subtract_months(GDate *date, guint n_months)
     * }
     */
    public static void g_date_subtract_months(MemorySegment date, int n_months) {
        var mh$ = g_date_subtract_months.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_subtract_months", date, n_months);
            }
            mh$.invokeExact(date, n_months);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_add_years {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_add_years");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_add_years(GDate *date, guint n_years)
     * }
     */
    public static FunctionDescriptor g_date_add_years$descriptor() {
        return g_date_add_years.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_add_years(GDate *date, guint n_years)
     * }
     */
    public static MethodHandle g_date_add_years$handle() {
        return g_date_add_years.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_add_years(GDate *date, guint n_years)
     * }
     */
    public static MemorySegment g_date_add_years$address() {
        return g_date_add_years.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_add_years(GDate *date, guint n_years)
     * }
     */
    public static void g_date_add_years(MemorySegment date, int n_years) {
        var mh$ = g_date_add_years.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_add_years", date, n_years);
            }
            mh$.invokeExact(date, n_years);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_subtract_years {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_subtract_years");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_subtract_years(GDate *date, guint n_years)
     * }
     */
    public static FunctionDescriptor g_date_subtract_years$descriptor() {
        return g_date_subtract_years.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_subtract_years(GDate *date, guint n_years)
     * }
     */
    public static MethodHandle g_date_subtract_years$handle() {
        return g_date_subtract_years.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_subtract_years(GDate *date, guint n_years)
     * }
     */
    public static MemorySegment g_date_subtract_years$address() {
        return g_date_subtract_years.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_subtract_years(GDate *date, guint n_years)
     * }
     */
    public static void g_date_subtract_years(MemorySegment date, int n_years) {
        var mh$ = g_date_subtract_years.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_subtract_years", date, n_years);
            }
            mh$.invokeExact(date, n_years);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_is_leap_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_is_leap_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_leap_year(GDateYear year)
     * }
     */
    public static FunctionDescriptor g_date_is_leap_year$descriptor() {
        return g_date_is_leap_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_leap_year(GDateYear year)
     * }
     */
    public static MethodHandle g_date_is_leap_year$handle() {
        return g_date_is_leap_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_date_is_leap_year(GDateYear year)
     * }
     */
    public static MemorySegment g_date_is_leap_year$address() {
        return g_date_is_leap_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_date_is_leap_year(GDateYear year)
     * }
     */
    public static int g_date_is_leap_year(short year) {
        var mh$ = g_date_is_leap_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_is_leap_year", year);
            }
            return (int)mh$.invokeExact(year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_days_in_month {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_CHAR,
            gst_min_h.C_INT,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_days_in_month");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_days_in_month(GDateMonth month, GDateYear year)
     * }
     */
    public static FunctionDescriptor g_date_get_days_in_month$descriptor() {
        return g_date_get_days_in_month.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_days_in_month(GDateMonth month, GDateYear year)
     * }
     */
    public static MethodHandle g_date_get_days_in_month$handle() {
        return g_date_get_days_in_month.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_days_in_month(GDateMonth month, GDateYear year)
     * }
     */
    public static MemorySegment g_date_get_days_in_month$address() {
        return g_date_get_days_in_month.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint8 g_date_get_days_in_month(GDateMonth month, GDateYear year)
     * }
     */
    public static byte g_date_get_days_in_month(int month, short year) {
        var mh$ = g_date_get_days_in_month.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_days_in_month", month, year);
            }
            return (byte)mh$.invokeExact(month, year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_monday_weeks_in_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_CHAR,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_monday_weeks_in_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_monday_weeks_in_year(GDateYear year)
     * }
     */
    public static FunctionDescriptor g_date_get_monday_weeks_in_year$descriptor() {
        return g_date_get_monday_weeks_in_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_monday_weeks_in_year(GDateYear year)
     * }
     */
    public static MethodHandle g_date_get_monday_weeks_in_year$handle() {
        return g_date_get_monday_weeks_in_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_monday_weeks_in_year(GDateYear year)
     * }
     */
    public static MemorySegment g_date_get_monday_weeks_in_year$address() {
        return g_date_get_monday_weeks_in_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint8 g_date_get_monday_weeks_in_year(GDateYear year)
     * }
     */
    public static byte g_date_get_monday_weeks_in_year(short year) {
        var mh$ = g_date_get_monday_weeks_in_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_monday_weeks_in_year", year);
            }
            return (byte)mh$.invokeExact(year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_get_sunday_weeks_in_year {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_CHAR,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_get_sunday_weeks_in_year");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year)
     * }
     */
    public static FunctionDescriptor g_date_get_sunday_weeks_in_year$descriptor() {
        return g_date_get_sunday_weeks_in_year.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year)
     * }
     */
    public static MethodHandle g_date_get_sunday_weeks_in_year$handle() {
        return g_date_get_sunday_weeks_in_year.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year)
     * }
     */
    public static MemorySegment g_date_get_sunday_weeks_in_year$address() {
        return g_date_get_sunday_weeks_in_year.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year)
     * }
     */
    public static byte g_date_get_sunday_weeks_in_year(short year) {
        var mh$ = g_date_get_sunday_weeks_in_year.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_get_sunday_weeks_in_year", year);
            }
            return (byte)mh$.invokeExact(year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_days_between {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_days_between");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_days_between(const GDate *date1, const GDate *date2)
     * }
     */
    public static FunctionDescriptor g_date_days_between$descriptor() {
        return g_date_days_between.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_days_between(const GDate *date1, const GDate *date2)
     * }
     */
    public static MethodHandle g_date_days_between$handle() {
        return g_date_days_between.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_days_between(const GDate *date1, const GDate *date2)
     * }
     */
    public static MemorySegment g_date_days_between$address() {
        return g_date_days_between.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_days_between(const GDate *date1, const GDate *date2)
     * }
     */
    public static int g_date_days_between(MemorySegment date1, MemorySegment date2) {
        var mh$ = g_date_days_between.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_days_between", date1, date2);
            }
            return (int)mh$.invokeExact(date1, date2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_date_compare(const GDate *lhs, const GDate *rhs)
     * }
     */
    public static FunctionDescriptor g_date_compare$descriptor() {
        return g_date_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_date_compare(const GDate *lhs, const GDate *rhs)
     * }
     */
    public static MethodHandle g_date_compare$handle() {
        return g_date_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_date_compare(const GDate *lhs, const GDate *rhs)
     * }
     */
    public static MemorySegment g_date_compare$address() {
        return g_date_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_date_compare(const GDate *lhs, const GDate *rhs)
     * }
     */
    public static int g_date_compare(MemorySegment lhs, MemorySegment rhs) {
        var mh$ = g_date_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_compare", lhs, rhs);
            }
            return (int)mh$.invokeExact(lhs, rhs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_to_struct_tm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_to_struct_tm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_to_struct_tm(const GDate *date, struct tm *tm)
     * }
     */
    public static FunctionDescriptor g_date_to_struct_tm$descriptor() {
        return g_date_to_struct_tm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_to_struct_tm(const GDate *date, struct tm *tm)
     * }
     */
    public static MethodHandle g_date_to_struct_tm$handle() {
        return g_date_to_struct_tm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_to_struct_tm(const GDate *date, struct tm *tm)
     * }
     */
    public static MemorySegment g_date_to_struct_tm$address() {
        return g_date_to_struct_tm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_to_struct_tm(const GDate *date, struct tm *tm)
     * }
     */
    public static void g_date_to_struct_tm(MemorySegment date, MemorySegment tm) {
        var mh$ = g_date_to_struct_tm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_to_struct_tm", date, tm);
            }
            mh$.invokeExact(date, tm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_clamp(GDate *date, const GDate *min_date, const GDate *max_date)
     * }
     */
    public static FunctionDescriptor g_date_clamp$descriptor() {
        return g_date_clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_clamp(GDate *date, const GDate *min_date, const GDate *max_date)
     * }
     */
    public static MethodHandle g_date_clamp$handle() {
        return g_date_clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_clamp(GDate *date, const GDate *min_date, const GDate *max_date)
     * }
     */
    public static MemorySegment g_date_clamp$address() {
        return g_date_clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_clamp(GDate *date, const GDate *min_date, const GDate *max_date)
     * }
     */
    public static void g_date_clamp(MemorySegment date, MemorySegment min_date, MemorySegment max_date) {
        var mh$ = g_date_clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_clamp", date, min_date, max_date);
            }
            mh$.invokeExact(date, min_date, max_date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_order {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_order");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_date_order(GDate *date1, GDate *date2)
     * }
     */
    public static FunctionDescriptor g_date_order$descriptor() {
        return g_date_order.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_date_order(GDate *date1, GDate *date2)
     * }
     */
    public static MethodHandle g_date_order$handle() {
        return g_date_order.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_date_order(GDate *date1, GDate *date2)
     * }
     */
    public static MemorySegment g_date_order$address() {
        return g_date_order.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_date_order(GDate *date1, GDate *date2)
     * }
     */
    public static void g_date_order(MemorySegment date1, MemorySegment date2) {
        var mh$ = g_date_order.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_order", date1, date2);
            }
            mh$.invokeExact(date1, date2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_date_strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_date_strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_date_strftime(gchar *s, gsize slen, const gchar *format, const GDate *date)
     * }
     */
    public static FunctionDescriptor g_date_strftime$descriptor() {
        return g_date_strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_date_strftime(gchar *s, gsize slen, const gchar *format, const GDate *date)
     * }
     */
    public static MethodHandle g_date_strftime$handle() {
        return g_date_strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_date_strftime(gchar *s, gsize slen, const gchar *format, const GDate *date)
     * }
     */
    public static MemorySegment g_date_strftime$address() {
        return g_date_strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_date_strftime(gchar *s, gsize slen, const gchar *format, const GDate *date)
     * }
     */
    public static long g_date_strftime(MemorySegment s, long slen, MemorySegment format, MemorySegment date) {
        var mh$ = g_date_strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_date_strftime", s, slen, format, date);
            }
            return (long)mh$.invokeExact(s, slen, format, date);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dir_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dir_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDir *g_dir_open(const gchar *path, guint flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_dir_open$descriptor() {
        return g_dir_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDir *g_dir_open(const gchar *path, guint flags, GError **error)
     * }
     */
    public static MethodHandle g_dir_open$handle() {
        return g_dir_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDir *g_dir_open(const gchar *path, guint flags, GError **error)
     * }
     */
    public static MemorySegment g_dir_open$address() {
        return g_dir_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDir *g_dir_open(const gchar *path, guint flags, GError **error)
     * }
     */
    public static MemorySegment g_dir_open(MemorySegment path, int flags, MemorySegment error) {
        var mh$ = g_dir_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dir_open", path, flags, error);
            }
            return (MemorySegment)mh$.invokeExact(path, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dir_read_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dir_read_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_dir_read_name(GDir *dir)
     * }
     */
    public static FunctionDescriptor g_dir_read_name$descriptor() {
        return g_dir_read_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_dir_read_name(GDir *dir)
     * }
     */
    public static MethodHandle g_dir_read_name$handle() {
        return g_dir_read_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_dir_read_name(GDir *dir)
     * }
     */
    public static MemorySegment g_dir_read_name$address() {
        return g_dir_read_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_dir_read_name(GDir *dir)
     * }
     */
    public static MemorySegment g_dir_read_name(MemorySegment dir) {
        var mh$ = g_dir_read_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dir_read_name", dir);
            }
            return (MemorySegment)mh$.invokeExact(dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dir_rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dir_rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_dir_rewind(GDir *dir)
     * }
     */
    public static FunctionDescriptor g_dir_rewind$descriptor() {
        return g_dir_rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_dir_rewind(GDir *dir)
     * }
     */
    public static MethodHandle g_dir_rewind$handle() {
        return g_dir_rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_dir_rewind(GDir *dir)
     * }
     */
    public static MemorySegment g_dir_rewind$address() {
        return g_dir_rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_dir_rewind(GDir *dir)
     * }
     */
    public static void g_dir_rewind(MemorySegment dir) {
        var mh$ = g_dir_rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dir_rewind", dir);
            }
            mh$.invokeExact(dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dir_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dir_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_dir_close(GDir *dir)
     * }
     */
    public static FunctionDescriptor g_dir_close$descriptor() {
        return g_dir_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_dir_close(GDir *dir)
     * }
     */
    public static MethodHandle g_dir_close$handle() {
        return g_dir_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_dir_close(GDir *dir)
     * }
     */
    public static MemorySegment g_dir_close$address() {
        return g_dir_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_dir_close(GDir *dir)
     * }
     */
    public static void g_dir_close(MemorySegment dir) {
        var mh$ = g_dir_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dir_close", dir);
            }
            mh$.invokeExact(dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dir_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dir_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GDir *g_dir_ref(GDir *dir)
     * }
     */
    public static FunctionDescriptor g_dir_ref$descriptor() {
        return g_dir_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GDir *g_dir_ref(GDir *dir)
     * }
     */
    public static MethodHandle g_dir_ref$handle() {
        return g_dir_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GDir *g_dir_ref(GDir *dir)
     * }
     */
    public static MemorySegment g_dir_ref$address() {
        return g_dir_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GDir *g_dir_ref(GDir *dir)
     * }
     */
    public static MemorySegment g_dir_ref(MemorySegment dir) {
        var mh$ = g_dir_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dir_ref", dir);
            }
            return (MemorySegment)mh$.invokeExact(dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dir_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dir_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_dir_unref(GDir *dir)
     * }
     */
    public static FunctionDescriptor g_dir_unref$descriptor() {
        return g_dir_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_dir_unref(GDir *dir)
     * }
     */
    public static MethodHandle g_dir_unref$handle() {
        return g_dir_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_dir_unref(GDir *dir)
     * }
     */
    public static MemorySegment g_dir_unref$address() {
        return g_dir_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_dir_unref(GDir *dir)
     * }
     */
    public static void g_dir_unref(MemorySegment dir) {
        var mh$ = g_dir_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dir_unref", dir);
            }
            mh$.invokeExact(dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_getenv(const gchar *variable)
     * }
     */
    public static FunctionDescriptor g_getenv$descriptor() {
        return g_getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_getenv(const gchar *variable)
     * }
     */
    public static MethodHandle g_getenv$handle() {
        return g_getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_getenv(const gchar *variable)
     * }
     */
    public static MemorySegment g_getenv$address() {
        return g_getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_getenv(const gchar *variable)
     * }
     */
    public static MemorySegment g_getenv(MemorySegment variable) {
        var mh$ = g_getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_getenv", variable);
            }
            return (MemorySegment)mh$.invokeExact(variable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_setenv(const gchar *variable, const gchar *value, gboolean overwrite)
     * }
     */
    public static FunctionDescriptor g_setenv$descriptor() {
        return g_setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_setenv(const gchar *variable, const gchar *value, gboolean overwrite)
     * }
     */
    public static MethodHandle g_setenv$handle() {
        return g_setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_setenv(const gchar *variable, const gchar *value, gboolean overwrite)
     * }
     */
    public static MemorySegment g_setenv$address() {
        return g_setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_setenv(const gchar *variable, const gchar *value, gboolean overwrite)
     * }
     */
    public static int g_setenv(MemorySegment variable, MemorySegment value, int overwrite) {
        var mh$ = g_setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_setenv", variable, value, overwrite);
            }
            return (int)mh$.invokeExact(variable, value, overwrite);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_unsetenv(const gchar *variable)
     * }
     */
    public static FunctionDescriptor g_unsetenv$descriptor() {
        return g_unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_unsetenv(const gchar *variable)
     * }
     */
    public static MethodHandle g_unsetenv$handle() {
        return g_unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_unsetenv(const gchar *variable)
     * }
     */
    public static MemorySegment g_unsetenv$address() {
        return g_unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_unsetenv(const gchar *variable)
     * }
     */
    public static void g_unsetenv(MemorySegment variable) {
        var mh$ = g_unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unsetenv", variable);
            }
            mh$.invokeExact(variable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_listenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_listenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_listenv()
     * }
     */
    public static FunctionDescriptor g_listenv$descriptor() {
        return g_listenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_listenv()
     * }
     */
    public static MethodHandle g_listenv$handle() {
        return g_listenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_listenv()
     * }
     */
    public static MemorySegment g_listenv$address() {
        return g_listenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_listenv()
     * }
     */
    public static MemorySegment g_listenv() {
        var mh$ = g_listenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_listenv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_environ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_environ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_get_environ()
     * }
     */
    public static FunctionDescriptor g_get_environ$descriptor() {
        return g_get_environ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_get_environ()
     * }
     */
    public static MethodHandle g_get_environ$handle() {
        return g_get_environ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_get_environ()
     * }
     */
    public static MemorySegment g_get_environ$address() {
        return g_get_environ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_get_environ()
     * }
     */
    public static MemorySegment g_get_environ() {
        var mh$ = g_get_environ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_environ");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_environ_getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_environ_getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_environ_getenv(gchar **envp, const gchar *variable)
     * }
     */
    public static FunctionDescriptor g_environ_getenv$descriptor() {
        return g_environ_getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_environ_getenv(gchar **envp, const gchar *variable)
     * }
     */
    public static MethodHandle g_environ_getenv$handle() {
        return g_environ_getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_environ_getenv(gchar **envp, const gchar *variable)
     * }
     */
    public static MemorySegment g_environ_getenv$address() {
        return g_environ_getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_environ_getenv(gchar **envp, const gchar *variable)
     * }
     */
    public static MemorySegment g_environ_getenv(MemorySegment envp, MemorySegment variable) {
        var mh$ = g_environ_getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_environ_getenv", envp, variable);
            }
            return (MemorySegment)mh$.invokeExact(envp, variable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_environ_setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_environ_setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_environ_setenv(gchar **envp, const gchar *variable, const gchar *value, gboolean overwrite)
     * }
     */
    public static FunctionDescriptor g_environ_setenv$descriptor() {
        return g_environ_setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_environ_setenv(gchar **envp, const gchar *variable, const gchar *value, gboolean overwrite)
     * }
     */
    public static MethodHandle g_environ_setenv$handle() {
        return g_environ_setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_environ_setenv(gchar **envp, const gchar *variable, const gchar *value, gboolean overwrite)
     * }
     */
    public static MemorySegment g_environ_setenv$address() {
        return g_environ_setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_environ_setenv(gchar **envp, const gchar *variable, const gchar *value, gboolean overwrite)
     * }
     */
    public static MemorySegment g_environ_setenv(MemorySegment envp, MemorySegment variable, MemorySegment value, int overwrite) {
        var mh$ = g_environ_setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_environ_setenv", envp, variable, value, overwrite);
            }
            return (MemorySegment)mh$.invokeExact(envp, variable, value, overwrite);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_environ_unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_environ_unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_environ_unsetenv(gchar **envp, const gchar *variable)
     * }
     */
    public static FunctionDescriptor g_environ_unsetenv$descriptor() {
        return g_environ_unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_environ_unsetenv(gchar **envp, const gchar *variable)
     * }
     */
    public static MethodHandle g_environ_unsetenv$handle() {
        return g_environ_unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_environ_unsetenv(gchar **envp, const gchar *variable)
     * }
     */
    public static MemorySegment g_environ_unsetenv$address() {
        return g_environ_unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_environ_unsetenv(gchar **envp, const gchar *variable)
     * }
     */
    public static MemorySegment g_environ_unsetenv(MemorySegment envp, MemorySegment variable) {
        var mh$ = g_environ_unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_environ_unsetenv", envp, variable);
            }
            return (MemorySegment)mh$.invokeExact(envp, variable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_FILE_ERROR_EXIST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_EXIST = 0
     * }
     */
    public static int G_FILE_ERROR_EXIST() {
        return G_FILE_ERROR_EXIST;
    }
    private static final int G_FILE_ERROR_ISDIR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_ISDIR = 1
     * }
     */
    public static int G_FILE_ERROR_ISDIR() {
        return G_FILE_ERROR_ISDIR;
    }
    private static final int G_FILE_ERROR_ACCES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_ACCES = 2
     * }
     */
    public static int G_FILE_ERROR_ACCES() {
        return G_FILE_ERROR_ACCES;
    }
    private static final int G_FILE_ERROR_NAMETOOLONG = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NAMETOOLONG = 3
     * }
     */
    public static int G_FILE_ERROR_NAMETOOLONG() {
        return G_FILE_ERROR_NAMETOOLONG;
    }
    private static final int G_FILE_ERROR_NOENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NOENT = 4
     * }
     */
    public static int G_FILE_ERROR_NOENT() {
        return G_FILE_ERROR_NOENT;
    }
    private static final int G_FILE_ERROR_NOTDIR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NOTDIR = 5
     * }
     */
    public static int G_FILE_ERROR_NOTDIR() {
        return G_FILE_ERROR_NOTDIR;
    }
    private static final int G_FILE_ERROR_NXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NXIO = 6
     * }
     */
    public static int G_FILE_ERROR_NXIO() {
        return G_FILE_ERROR_NXIO;
    }
    private static final int G_FILE_ERROR_NODEV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NODEV = 7
     * }
     */
    public static int G_FILE_ERROR_NODEV() {
        return G_FILE_ERROR_NODEV;
    }
    private static final int G_FILE_ERROR_ROFS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_ROFS = 8
     * }
     */
    public static int G_FILE_ERROR_ROFS() {
        return G_FILE_ERROR_ROFS;
    }
    private static final int G_FILE_ERROR_TXTBSY = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_TXTBSY = 9
     * }
     */
    public static int G_FILE_ERROR_TXTBSY() {
        return G_FILE_ERROR_TXTBSY;
    }
    private static final int G_FILE_ERROR_FAULT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_FAULT = 10
     * }
     */
    public static int G_FILE_ERROR_FAULT() {
        return G_FILE_ERROR_FAULT;
    }
    private static final int G_FILE_ERROR_LOOP = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_LOOP = 11
     * }
     */
    public static int G_FILE_ERROR_LOOP() {
        return G_FILE_ERROR_LOOP;
    }
    private static final int G_FILE_ERROR_NOSPC = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NOSPC = 12
     * }
     */
    public static int G_FILE_ERROR_NOSPC() {
        return G_FILE_ERROR_NOSPC;
    }
    private static final int G_FILE_ERROR_NOMEM = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NOMEM = 13
     * }
     */
    public static int G_FILE_ERROR_NOMEM() {
        return G_FILE_ERROR_NOMEM;
    }
    private static final int G_FILE_ERROR_MFILE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_MFILE = 14
     * }
     */
    public static int G_FILE_ERROR_MFILE() {
        return G_FILE_ERROR_MFILE;
    }
    private static final int G_FILE_ERROR_NFILE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NFILE = 15
     * }
     */
    public static int G_FILE_ERROR_NFILE() {
        return G_FILE_ERROR_NFILE;
    }
    private static final int G_FILE_ERROR_BADF = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_BADF = 16
     * }
     */
    public static int G_FILE_ERROR_BADF() {
        return G_FILE_ERROR_BADF;
    }
    private static final int G_FILE_ERROR_INVAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_INVAL = 17
     * }
     */
    public static int G_FILE_ERROR_INVAL() {
        return G_FILE_ERROR_INVAL;
    }
    private static final int G_FILE_ERROR_PIPE = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_PIPE = 18
     * }
     */
    public static int G_FILE_ERROR_PIPE() {
        return G_FILE_ERROR_PIPE;
    }
    private static final int G_FILE_ERROR_AGAIN = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_AGAIN = 19
     * }
     */
    public static int G_FILE_ERROR_AGAIN() {
        return G_FILE_ERROR_AGAIN;
    }
    private static final int G_FILE_ERROR_INTR = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_INTR = 20
     * }
     */
    public static int G_FILE_ERROR_INTR() {
        return G_FILE_ERROR_INTR;
    }
    private static final int G_FILE_ERROR_IO = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_IO = 21
     * }
     */
    public static int G_FILE_ERROR_IO() {
        return G_FILE_ERROR_IO;
    }
    private static final int G_FILE_ERROR_PERM = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_PERM = 22
     * }
     */
    public static int G_FILE_ERROR_PERM() {
        return G_FILE_ERROR_PERM;
    }
    private static final int G_FILE_ERROR_NOSYS = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_NOSYS = 23
     * }
     */
    public static int G_FILE_ERROR_NOSYS() {
        return G_FILE_ERROR_NOSYS;
    }
    private static final int G_FILE_ERROR_FAILED = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_ERROR_FAILED = 24
     * }
     */
    public static int G_FILE_ERROR_FAILED() {
        return G_FILE_ERROR_FAILED;
    }
    private static final int G_FILE_TEST_IS_REGULAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_TEST_IS_REGULAR = 1
     * }
     */
    public static int G_FILE_TEST_IS_REGULAR() {
        return G_FILE_TEST_IS_REGULAR;
    }
    private static final int G_FILE_TEST_IS_SYMLINK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_TEST_IS_SYMLINK = 2
     * }
     */
    public static int G_FILE_TEST_IS_SYMLINK() {
        return G_FILE_TEST_IS_SYMLINK;
    }
    private static final int G_FILE_TEST_IS_DIR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_TEST_IS_DIR = 4
     * }
     */
    public static int G_FILE_TEST_IS_DIR() {
        return G_FILE_TEST_IS_DIR;
    }
    private static final int G_FILE_TEST_IS_EXECUTABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_TEST_IS_EXECUTABLE = 8
     * }
     */
    public static int G_FILE_TEST_IS_EXECUTABLE() {
        return G_FILE_TEST_IS_EXECUTABLE;
    }
    private static final int G_FILE_TEST_EXISTS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_TEST_EXISTS = 16
     * }
     */
    public static int G_FILE_TEST_EXISTS() {
        return G_FILE_TEST_EXISTS;
    }
    private static final int G_FILE_SET_CONTENTS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_SET_CONTENTS_NONE = 0
     * }
     */
    public static int G_FILE_SET_CONTENTS_NONE() {
        return G_FILE_SET_CONTENTS_NONE;
    }
    private static final int G_FILE_SET_CONTENTS_CONSISTENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_SET_CONTENTS_CONSISTENT = 1
     * }
     */
    public static int G_FILE_SET_CONTENTS_CONSISTENT() {
        return G_FILE_SET_CONTENTS_CONSISTENT;
    }
    private static final int G_FILE_SET_CONTENTS_DURABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_SET_CONTENTS_DURABLE = 2
     * }
     */
    public static int G_FILE_SET_CONTENTS_DURABLE() {
        return G_FILE_SET_CONTENTS_DURABLE;
    }
    private static final int G_FILE_SET_CONTENTS_ONLY_EXISTING = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_FILE_SET_CONTENTS_ONLY_EXISTING = 4
     * }
     */
    public static int G_FILE_SET_CONTENTS_ONLY_EXISTING() {
        return G_FILE_SET_CONTENTS_ONLY_EXISTING;
    }

    private static class g_file_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_file_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_file_error_quark()
     * }
     */
    public static FunctionDescriptor g_file_error_quark$descriptor() {
        return g_file_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_file_error_quark()
     * }
     */
    public static MethodHandle g_file_error_quark$handle() {
        return g_file_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_file_error_quark()
     * }
     */
    public static MemorySegment g_file_error_quark$address() {
        return g_file_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_file_error_quark()
     * }
     */
    public static int g_file_error_quark() {
        var mh$ = g_file_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_file_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_file_error_from_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_file_error_from_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GFileError g_file_error_from_errno(gint err_no)
     * }
     */
    public static FunctionDescriptor g_file_error_from_errno$descriptor() {
        return g_file_error_from_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GFileError g_file_error_from_errno(gint err_no)
     * }
     */
    public static MethodHandle g_file_error_from_errno$handle() {
        return g_file_error_from_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GFileError g_file_error_from_errno(gint err_no)
     * }
     */
    public static MemorySegment g_file_error_from_errno$address() {
        return g_file_error_from_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GFileError g_file_error_from_errno(gint err_no)
     * }
     */
    public static int g_file_error_from_errno(int err_no) {
        var mh$ = g_file_error_from_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_file_error_from_errno", err_no);
            }
            return (int)mh$.invokeExact(err_no);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_file_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_file_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_file_test(const gchar *filename, GFileTest test)
     * }
     */
    public static FunctionDescriptor g_file_test$descriptor() {
        return g_file_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_file_test(const gchar *filename, GFileTest test)
     * }
     */
    public static MethodHandle g_file_test$handle() {
        return g_file_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_file_test(const gchar *filename, GFileTest test)
     * }
     */
    public static MemorySegment g_file_test$address() {
        return g_file_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_file_test(const gchar *filename, GFileTest test)
     * }
     */
    public static int g_file_test(MemorySegment filename, int test) {
        var mh$ = g_file_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_file_test", filename, test);
            }
            return (int)mh$.invokeExact(filename, test);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_file_get_contents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_file_get_contents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_file_get_contents(const gchar *filename, gchar **contents, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_file_get_contents$descriptor() {
        return g_file_get_contents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_file_get_contents(const gchar *filename, gchar **contents, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_file_get_contents$handle() {
        return g_file_get_contents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_file_get_contents(const gchar *filename, gchar **contents, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_file_get_contents$address() {
        return g_file_get_contents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_file_get_contents(const gchar *filename, gchar **contents, gsize *length, GError **error)
     * }
     */
    public static int g_file_get_contents(MemorySegment filename, MemorySegment contents, MemorySegment length, MemorySegment error) {
        var mh$ = g_file_get_contents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_file_get_contents", filename, contents, length, error);
            }
            return (int)mh$.invokeExact(filename, contents, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_file_set_contents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_file_set_contents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_file_set_contents(const gchar *filename, const gchar *contents, gssize length, GError **error)
     * }
     */
    public static FunctionDescriptor g_file_set_contents$descriptor() {
        return g_file_set_contents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_file_set_contents(const gchar *filename, const gchar *contents, gssize length, GError **error)
     * }
     */
    public static MethodHandle g_file_set_contents$handle() {
        return g_file_set_contents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_file_set_contents(const gchar *filename, const gchar *contents, gssize length, GError **error)
     * }
     */
    public static MemorySegment g_file_set_contents$address() {
        return g_file_set_contents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_file_set_contents(const gchar *filename, const gchar *contents, gssize length, GError **error)
     * }
     */
    public static int g_file_set_contents(MemorySegment filename, MemorySegment contents, long length, MemorySegment error) {
        var mh$ = g_file_set_contents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_file_set_contents", filename, contents, length, error);
            }
            return (int)mh$.invokeExact(filename, contents, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_file_set_contents_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_file_set_contents_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_file_set_contents_full(const gchar *filename, const gchar *contents, gssize length, GFileSetContentsFlags flags, int mode, GError **error)
     * }
     */
    public static FunctionDescriptor g_file_set_contents_full$descriptor() {
        return g_file_set_contents_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_file_set_contents_full(const gchar *filename, const gchar *contents, gssize length, GFileSetContentsFlags flags, int mode, GError **error)
     * }
     */
    public static MethodHandle g_file_set_contents_full$handle() {
        return g_file_set_contents_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_file_set_contents_full(const gchar *filename, const gchar *contents, gssize length, GFileSetContentsFlags flags, int mode, GError **error)
     * }
     */
    public static MemorySegment g_file_set_contents_full$address() {
        return g_file_set_contents_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_file_set_contents_full(const gchar *filename, const gchar *contents, gssize length, GFileSetContentsFlags flags, int mode, GError **error)
     * }
     */
    public static int g_file_set_contents_full(MemorySegment filename, MemorySegment contents, long length, int flags, int mode, MemorySegment error) {
        var mh$ = g_file_set_contents_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_file_set_contents_full", filename, contents, length, flags, mode, error);
            }
            return (int)mh$.invokeExact(filename, contents, length, flags, mode, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_file_read_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_file_read_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_file_read_link(const gchar *filename, GError **error)
     * }
     */
    public static FunctionDescriptor g_file_read_link$descriptor() {
        return g_file_read_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_file_read_link(const gchar *filename, GError **error)
     * }
     */
    public static MethodHandle g_file_read_link$handle() {
        return g_file_read_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_file_read_link(const gchar *filename, GError **error)
     * }
     */
    public static MemorySegment g_file_read_link$address() {
        return g_file_read_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_file_read_link(const gchar *filename, GError **error)
     * }
     */
    public static MemorySegment g_file_read_link(MemorySegment filename, MemorySegment error) {
        var mh$ = g_file_read_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_file_read_link", filename, error);
            }
            return (MemorySegment)mh$.invokeExact(filename, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_mkdtemp(gchar *tmpl)
     * }
     */
    public static FunctionDescriptor g_mkdtemp$descriptor() {
        return g_mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_mkdtemp(gchar *tmpl)
     * }
     */
    public static MethodHandle g_mkdtemp$handle() {
        return g_mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_mkdtemp(gchar *tmpl)
     * }
     */
    public static MemorySegment g_mkdtemp$address() {
        return g_mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_mkdtemp(gchar *tmpl)
     * }
     */
    public static MemorySegment g_mkdtemp(MemorySegment tmpl) {
        var mh$ = g_mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mkdtemp", tmpl);
            }
            return (MemorySegment)mh$.invokeExact(tmpl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mkdtemp_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mkdtemp_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_mkdtemp_full(gchar *tmpl, gint mode)
     * }
     */
    public static FunctionDescriptor g_mkdtemp_full$descriptor() {
        return g_mkdtemp_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_mkdtemp_full(gchar *tmpl, gint mode)
     * }
     */
    public static MethodHandle g_mkdtemp_full$handle() {
        return g_mkdtemp_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_mkdtemp_full(gchar *tmpl, gint mode)
     * }
     */
    public static MemorySegment g_mkdtemp_full$address() {
        return g_mkdtemp_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_mkdtemp_full(gchar *tmpl, gint mode)
     * }
     */
    public static MemorySegment g_mkdtemp_full(MemorySegment tmpl, int mode) {
        var mh$ = g_mkdtemp_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mkdtemp_full", tmpl, mode);
            }
            return (MemorySegment)mh$.invokeExact(tmpl, mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_mkstemp(gchar *tmpl)
     * }
     */
    public static FunctionDescriptor g_mkstemp$descriptor() {
        return g_mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_mkstemp(gchar *tmpl)
     * }
     */
    public static MethodHandle g_mkstemp$handle() {
        return g_mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_mkstemp(gchar *tmpl)
     * }
     */
    public static MemorySegment g_mkstemp$address() {
        return g_mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_mkstemp(gchar *tmpl)
     * }
     */
    public static int g_mkstemp(MemorySegment tmpl) {
        var mh$ = g_mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mkstemp", tmpl);
            }
            return (int)mh$.invokeExact(tmpl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mkstemp_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mkstemp_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_mkstemp_full(gchar *tmpl, gint flags, gint mode)
     * }
     */
    public static FunctionDescriptor g_mkstemp_full$descriptor() {
        return g_mkstemp_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_mkstemp_full(gchar *tmpl, gint flags, gint mode)
     * }
     */
    public static MethodHandle g_mkstemp_full$handle() {
        return g_mkstemp_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_mkstemp_full(gchar *tmpl, gint flags, gint mode)
     * }
     */
    public static MemorySegment g_mkstemp_full$address() {
        return g_mkstemp_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_mkstemp_full(gchar *tmpl, gint flags, gint mode)
     * }
     */
    public static int g_mkstemp_full(MemorySegment tmpl, int flags, int mode) {
        var mh$ = g_mkstemp_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mkstemp_full", tmpl, flags, mode);
            }
            return (int)mh$.invokeExact(tmpl, flags, mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_file_open_tmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_file_open_tmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_file_open_tmp(const gchar *tmpl, gchar **name_used, GError **error)
     * }
     */
    public static FunctionDescriptor g_file_open_tmp$descriptor() {
        return g_file_open_tmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_file_open_tmp(const gchar *tmpl, gchar **name_used, GError **error)
     * }
     */
    public static MethodHandle g_file_open_tmp$handle() {
        return g_file_open_tmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_file_open_tmp(const gchar *tmpl, gchar **name_used, GError **error)
     * }
     */
    public static MemorySegment g_file_open_tmp$address() {
        return g_file_open_tmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_file_open_tmp(const gchar *tmpl, gchar **name_used, GError **error)
     * }
     */
    public static int g_file_open_tmp(MemorySegment tmpl, MemorySegment name_used, MemorySegment error) {
        var mh$ = g_file_open_tmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_file_open_tmp", tmpl, name_used, error);
            }
            return (int)mh$.invokeExact(tmpl, name_used, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dir_make_tmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dir_make_tmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_dir_make_tmp(const gchar *tmpl, GError **error)
     * }
     */
    public static FunctionDescriptor g_dir_make_tmp$descriptor() {
        return g_dir_make_tmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_dir_make_tmp(const gchar *tmpl, GError **error)
     * }
     */
    public static MethodHandle g_dir_make_tmp$handle() {
        return g_dir_make_tmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_dir_make_tmp(const gchar *tmpl, GError **error)
     * }
     */
    public static MemorySegment g_dir_make_tmp$address() {
        return g_dir_make_tmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_dir_make_tmp(const gchar *tmpl, GError **error)
     * }
     */
    public static MemorySegment g_dir_make_tmp(MemorySegment tmpl, MemorySegment error) {
        var mh$ = g_dir_make_tmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dir_make_tmp", tmpl, error);
            }
            return (MemorySegment)mh$.invokeExact(tmpl, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gchar *g_build_path(const gchar *separator, const gchar *first_element, ...)
     * }
     */
    public static class g_build_path {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_build_path");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_build_path(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gchar *g_build_path(const gchar *separator, const gchar *first_element, ...)
         * }
         */
        public static g_build_path makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_build_path(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment separator, MemorySegment first_element, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_build_path", separator, first_element, x2);
                }
                return (MemorySegment) spreader.invokeExact(separator, first_element, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_build_pathv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_build_pathv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_build_pathv(const gchar *separator, gchar **args)
     * }
     */
    public static FunctionDescriptor g_build_pathv$descriptor() {
        return g_build_pathv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_build_pathv(const gchar *separator, gchar **args)
     * }
     */
    public static MethodHandle g_build_pathv$handle() {
        return g_build_pathv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_build_pathv(const gchar *separator, gchar **args)
     * }
     */
    public static MemorySegment g_build_pathv$address() {
        return g_build_pathv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_build_pathv(const gchar *separator, gchar **args)
     * }
     */
    public static MemorySegment g_build_pathv(MemorySegment separator, MemorySegment args) {
        var mh$ = g_build_pathv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_build_pathv", separator, args);
            }
            return (MemorySegment)mh$.invokeExact(separator, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gchar *g_build_filename(const gchar *first_element, ...)
     * }
     */
    public static class g_build_filename {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_build_filename");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_build_filename(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gchar *g_build_filename(const gchar *first_element, ...)
         * }
         */
        public static g_build_filename makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_build_filename(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment first_element, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_build_filename", first_element, x1);
                }
                return (MemorySegment) spreader.invokeExact(first_element, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_build_filenamev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_build_filenamev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_build_filenamev(gchar **args)
     * }
     */
    public static FunctionDescriptor g_build_filenamev$descriptor() {
        return g_build_filenamev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_build_filenamev(gchar **args)
     * }
     */
    public static MethodHandle g_build_filenamev$handle() {
        return g_build_filenamev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_build_filenamev(gchar **args)
     * }
     */
    public static MemorySegment g_build_filenamev$address() {
        return g_build_filenamev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_build_filenamev(gchar **args)
     * }
     */
    public static MemorySegment g_build_filenamev(MemorySegment args) {
        var mh$ = g_build_filenamev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_build_filenamev", args);
            }
            return (MemorySegment)mh$.invokeExact(args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_build_filename_valist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_build_filename_valist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_build_filename_valist(const gchar *first_element, va_list *args)
     * }
     */
    public static FunctionDescriptor g_build_filename_valist$descriptor() {
        return g_build_filename_valist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_build_filename_valist(const gchar *first_element, va_list *args)
     * }
     */
    public static MethodHandle g_build_filename_valist$handle() {
        return g_build_filename_valist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_build_filename_valist(const gchar *first_element, va_list *args)
     * }
     */
    public static MemorySegment g_build_filename_valist$address() {
        return g_build_filename_valist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_build_filename_valist(const gchar *first_element, va_list *args)
     * }
     */
    public static MemorySegment g_build_filename_valist(MemorySegment first_element, MemorySegment args) {
        var mh$ = g_build_filename_valist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_build_filename_valist", first_element, args);
            }
            return (MemorySegment)mh$.invokeExact(first_element, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mkdir_with_parents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mkdir_with_parents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_mkdir_with_parents(const gchar *pathname, gint mode)
     * }
     */
    public static FunctionDescriptor g_mkdir_with_parents$descriptor() {
        return g_mkdir_with_parents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_mkdir_with_parents(const gchar *pathname, gint mode)
     * }
     */
    public static MethodHandle g_mkdir_with_parents$handle() {
        return g_mkdir_with_parents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_mkdir_with_parents(const gchar *pathname, gint mode)
     * }
     */
    public static MemorySegment g_mkdir_with_parents$address() {
        return g_mkdir_with_parents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_mkdir_with_parents(const gchar *pathname, gint mode)
     * }
     */
    public static int g_mkdir_with_parents(MemorySegment pathname, int mode) {
        var mh$ = g_mkdir_with_parents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mkdir_with_parents", pathname, mode);
            }
            return (int)mh$.invokeExact(pathname, mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_is_absolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_is_absolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_path_is_absolute(const gchar *file_name)
     * }
     */
    public static FunctionDescriptor g_path_is_absolute$descriptor() {
        return g_path_is_absolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_path_is_absolute(const gchar *file_name)
     * }
     */
    public static MethodHandle g_path_is_absolute$handle() {
        return g_path_is_absolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_path_is_absolute(const gchar *file_name)
     * }
     */
    public static MemorySegment g_path_is_absolute$address() {
        return g_path_is_absolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_path_is_absolute(const gchar *file_name)
     * }
     */
    public static int g_path_is_absolute(MemorySegment file_name) {
        var mh$ = g_path_is_absolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_is_absolute", file_name);
            }
            return (int)mh$.invokeExact(file_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_skip_root {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_skip_root");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_path_skip_root(const gchar *file_name)
     * }
     */
    public static FunctionDescriptor g_path_skip_root$descriptor() {
        return g_path_skip_root.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_path_skip_root(const gchar *file_name)
     * }
     */
    public static MethodHandle g_path_skip_root$handle() {
        return g_path_skip_root.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_path_skip_root(const gchar *file_name)
     * }
     */
    public static MemorySegment g_path_skip_root$address() {
        return g_path_skip_root.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_path_skip_root(const gchar *file_name)
     * }
     */
    public static MemorySegment g_path_skip_root(MemorySegment file_name) {
        var mh$ = g_path_skip_root.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_skip_root", file_name);
            }
            return (MemorySegment)mh$.invokeExact(file_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_basename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_basename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_basename(const gchar *file_name)
     * }
     */
    public static FunctionDescriptor g_basename$descriptor() {
        return g_basename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_basename(const gchar *file_name)
     * }
     */
    public static MethodHandle g_basename$handle() {
        return g_basename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_basename(const gchar *file_name)
     * }
     */
    public static MemorySegment g_basename$address() {
        return g_basename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_basename(const gchar *file_name)
     * }
     */
    public static MemorySegment g_basename(MemorySegment file_name) {
        var mh$ = g_basename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_basename", file_name);
            }
            return (MemorySegment)mh$.invokeExact(file_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_current_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_current_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_get_current_dir()
     * }
     */
    public static FunctionDescriptor g_get_current_dir$descriptor() {
        return g_get_current_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_get_current_dir()
     * }
     */
    public static MethodHandle g_get_current_dir$handle() {
        return g_get_current_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_get_current_dir()
     * }
     */
    public static MemorySegment g_get_current_dir$address() {
        return g_get_current_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_get_current_dir()
     * }
     */
    public static MemorySegment g_get_current_dir() {
        var mh$ = g_get_current_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_current_dir");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_get_basename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_get_basename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_path_get_basename(const gchar *file_name)
     * }
     */
    public static FunctionDescriptor g_path_get_basename$descriptor() {
        return g_path_get_basename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_path_get_basename(const gchar *file_name)
     * }
     */
    public static MethodHandle g_path_get_basename$handle() {
        return g_path_get_basename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_path_get_basename(const gchar *file_name)
     * }
     */
    public static MemorySegment g_path_get_basename$address() {
        return g_path_get_basename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_path_get_basename(const gchar *file_name)
     * }
     */
    public static MemorySegment g_path_get_basename(MemorySegment file_name) {
        var mh$ = g_path_get_basename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_get_basename", file_name);
            }
            return (MemorySegment)mh$.invokeExact(file_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_get_dirname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_get_dirname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_path_get_dirname(const gchar *file_name)
     * }
     */
    public static FunctionDescriptor g_path_get_dirname$descriptor() {
        return g_path_get_dirname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_path_get_dirname(const gchar *file_name)
     * }
     */
    public static MethodHandle g_path_get_dirname$handle() {
        return g_path_get_dirname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_path_get_dirname(const gchar *file_name)
     * }
     */
    public static MemorySegment g_path_get_dirname$address() {
        return g_path_get_dirname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_path_get_dirname(const gchar *file_name)
     * }
     */
    public static MemorySegment g_path_get_dirname(MemorySegment file_name) {
        var mh$ = g_path_get_dirname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_get_dirname", file_name);
            }
            return (MemorySegment)mh$.invokeExact(file_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_canonicalize_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_canonicalize_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_canonicalize_filename(const gchar *filename, const gchar *relative_to)
     * }
     */
    public static FunctionDescriptor g_canonicalize_filename$descriptor() {
        return g_canonicalize_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_canonicalize_filename(const gchar *filename, const gchar *relative_to)
     * }
     */
    public static MethodHandle g_canonicalize_filename$handle() {
        return g_canonicalize_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_canonicalize_filename(const gchar *filename, const gchar *relative_to)
     * }
     */
    public static MemorySegment g_canonicalize_filename$address() {
        return g_canonicalize_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_canonicalize_filename(const gchar *filename, const gchar *relative_to)
     * }
     */
    public static MemorySegment g_canonicalize_filename(MemorySegment filename, MemorySegment relative_to) {
        var mh$ = g_canonicalize_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_canonicalize_filename", filename, relative_to);
            }
            return (MemorySegment)mh$.invokeExact(filename, relative_to);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strip_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strip_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_strip_context(const gchar *msgid, const gchar *msgval)
     * }
     */
    public static FunctionDescriptor g_strip_context$descriptor() {
        return g_strip_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_strip_context(const gchar *msgid, const gchar *msgval)
     * }
     */
    public static MethodHandle g_strip_context$handle() {
        return g_strip_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_strip_context(const gchar *msgid, const gchar *msgval)
     * }
     */
    public static MemorySegment g_strip_context$address() {
        return g_strip_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_strip_context(const gchar *msgid, const gchar *msgval)
     * }
     */
    public static MemorySegment g_strip_context(MemorySegment msgid, MemorySegment msgval) {
        var mh$ = g_strip_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strip_context", msgid, msgval);
            }
            return (MemorySegment)mh$.invokeExact(msgid, msgval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dgettext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dgettext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_dgettext(const gchar *domain, const gchar *msgid)
     * }
     */
    public static FunctionDescriptor g_dgettext$descriptor() {
        return g_dgettext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_dgettext(const gchar *domain, const gchar *msgid)
     * }
     */
    public static MethodHandle g_dgettext$handle() {
        return g_dgettext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_dgettext(const gchar *domain, const gchar *msgid)
     * }
     */
    public static MemorySegment g_dgettext$address() {
        return g_dgettext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_dgettext(const gchar *domain, const gchar *msgid)
     * }
     */
    public static MemorySegment g_dgettext(MemorySegment domain, MemorySegment msgid) {
        var mh$ = g_dgettext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dgettext", domain, msgid);
            }
            return (MemorySegment)mh$.invokeExact(domain, msgid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dcgettext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dcgettext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_dcgettext(const gchar *domain, const gchar *msgid, gint category)
     * }
     */
    public static FunctionDescriptor g_dcgettext$descriptor() {
        return g_dcgettext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_dcgettext(const gchar *domain, const gchar *msgid, gint category)
     * }
     */
    public static MethodHandle g_dcgettext$handle() {
        return g_dcgettext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_dcgettext(const gchar *domain, const gchar *msgid, gint category)
     * }
     */
    public static MemorySegment g_dcgettext$address() {
        return g_dcgettext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_dcgettext(const gchar *domain, const gchar *msgid, gint category)
     * }
     */
    public static MemorySegment g_dcgettext(MemorySegment domain, MemorySegment msgid, int category) {
        var mh$ = g_dcgettext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dcgettext", domain, msgid, category);
            }
            return (MemorySegment)mh$.invokeExact(domain, msgid, category);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dngettext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dngettext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_dngettext(const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n)
     * }
     */
    public static FunctionDescriptor g_dngettext$descriptor() {
        return g_dngettext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_dngettext(const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n)
     * }
     */
    public static MethodHandle g_dngettext$handle() {
        return g_dngettext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_dngettext(const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n)
     * }
     */
    public static MemorySegment g_dngettext$address() {
        return g_dngettext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_dngettext(const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n)
     * }
     */
    public static MemorySegment g_dngettext(MemorySegment domain, MemorySegment msgid, MemorySegment msgid_plural, int n) {
        var mh$ = g_dngettext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dngettext", domain, msgid, msgid_plural, n);
            }
            return (MemorySegment)mh$.invokeExact(domain, msgid, msgid_plural, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dpgettext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dpgettext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_dpgettext(const gchar *domain, const gchar *msgctxtid, gsize msgidoffset)
     * }
     */
    public static FunctionDescriptor g_dpgettext$descriptor() {
        return g_dpgettext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_dpgettext(const gchar *domain, const gchar *msgctxtid, gsize msgidoffset)
     * }
     */
    public static MethodHandle g_dpgettext$handle() {
        return g_dpgettext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_dpgettext(const gchar *domain, const gchar *msgctxtid, gsize msgidoffset)
     * }
     */
    public static MemorySegment g_dpgettext$address() {
        return g_dpgettext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_dpgettext(const gchar *domain, const gchar *msgctxtid, gsize msgidoffset)
     * }
     */
    public static MemorySegment g_dpgettext(MemorySegment domain, MemorySegment msgctxtid, long msgidoffset) {
        var mh$ = g_dpgettext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dpgettext", domain, msgctxtid, msgidoffset);
            }
            return (MemorySegment)mh$.invokeExact(domain, msgctxtid, msgidoffset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_dpgettext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_dpgettext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_dpgettext2(const gchar *domain, const gchar *context, const gchar *msgid)
     * }
     */
    public static FunctionDescriptor g_dpgettext2$descriptor() {
        return g_dpgettext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_dpgettext2(const gchar *domain, const gchar *context, const gchar *msgid)
     * }
     */
    public static MethodHandle g_dpgettext2$handle() {
        return g_dpgettext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_dpgettext2(const gchar *domain, const gchar *context, const gchar *msgid)
     * }
     */
    public static MemorySegment g_dpgettext2$address() {
        return g_dpgettext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_dpgettext2(const gchar *domain, const gchar *context, const gchar *msgid)
     * }
     */
    public static MemorySegment g_dpgettext2(MemorySegment domain, MemorySegment context, MemorySegment msgid) {
        var mh$ = g_dpgettext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_dpgettext2", domain, context, msgid);
            }
            return (MemorySegment)mh$.invokeExact(domain, context, msgid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (g_free)(gpointer mem)
     * }
     */
    public static FunctionDescriptor g_free$descriptor() {
        return g_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (g_free)(gpointer mem)
     * }
     */
    public static MethodHandle g_free$handle() {
        return g_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void (g_free)(gpointer mem)
     * }
     */
    public static MemorySegment g_free$address() {
        return g_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void (g_free)(gpointer mem)
     * }
     */
    public static void g_free(MemorySegment mem) {
        var mh$ = g_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_free", mem);
            }
            mh$.invokeExact(mem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_free_sized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_free_sized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_free_sized(gpointer mem, size_t size)
     * }
     */
    public static FunctionDescriptor g_free_sized$descriptor() {
        return g_free_sized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_free_sized(gpointer mem, size_t size)
     * }
     */
    public static MethodHandle g_free_sized$handle() {
        return g_free_sized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_free_sized(gpointer mem, size_t size)
     * }
     */
    public static MemorySegment g_free_sized$address() {
        return g_free_sized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_free_sized(gpointer mem, size_t size)
     * }
     */
    public static void g_free_sized(MemorySegment mem, long size) {
        var mh$ = g_free_sized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_free_sized", mem, size);
            }
            mh$.invokeExact(mem, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_clear_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_clear_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_clear_pointer(gpointer *pp, GDestroyNotify destroy)
     * }
     */
    public static FunctionDescriptor g_clear_pointer$descriptor() {
        return g_clear_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_clear_pointer(gpointer *pp, GDestroyNotify destroy)
     * }
     */
    public static MethodHandle g_clear_pointer$handle() {
        return g_clear_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_clear_pointer(gpointer *pp, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_clear_pointer$address() {
        return g_clear_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_clear_pointer(gpointer *pp, GDestroyNotify destroy)
     * }
     */
    public static void g_clear_pointer(MemorySegment pp, MemorySegment destroy) {
        var mh$ = g_clear_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_clear_pointer", pp, destroy);
            }
            mh$.invokeExact(pp, destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_malloc(gsize n_bytes)
     * }
     */
    public static FunctionDescriptor g_malloc$descriptor() {
        return g_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_malloc(gsize n_bytes)
     * }
     */
    public static MethodHandle g_malloc$handle() {
        return g_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_malloc(gsize n_bytes)
     * }
     */
    public static MemorySegment g_malloc$address() {
        return g_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_malloc(gsize n_bytes)
     * }
     */
    public static MemorySegment g_malloc(long n_bytes) {
        var mh$ = g_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_malloc", n_bytes);
            }
            return (MemorySegment)mh$.invokeExact(n_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_malloc0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_malloc0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_malloc0(gsize n_bytes)
     * }
     */
    public static FunctionDescriptor g_malloc0$descriptor() {
        return g_malloc0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_malloc0(gsize n_bytes)
     * }
     */
    public static MethodHandle g_malloc0$handle() {
        return g_malloc0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_malloc0(gsize n_bytes)
     * }
     */
    public static MemorySegment g_malloc0$address() {
        return g_malloc0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_malloc0(gsize n_bytes)
     * }
     */
    public static MemorySegment g_malloc0(long n_bytes) {
        var mh$ = g_malloc0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_malloc0", n_bytes);
            }
            return (MemorySegment)mh$.invokeExact(n_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_realloc(gpointer mem, gsize n_bytes)
     * }
     */
    public static FunctionDescriptor g_realloc$descriptor() {
        return g_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_realloc(gpointer mem, gsize n_bytes)
     * }
     */
    public static MethodHandle g_realloc$handle() {
        return g_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_realloc(gpointer mem, gsize n_bytes)
     * }
     */
    public static MemorySegment g_realloc$address() {
        return g_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_realloc(gpointer mem, gsize n_bytes)
     * }
     */
    public static MemorySegment g_realloc(MemorySegment mem, long n_bytes) {
        var mh$ = g_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_realloc", mem, n_bytes);
            }
            return (MemorySegment)mh$.invokeExact(mem, n_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_try_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_try_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc(gsize n_bytes)
     * }
     */
    public static FunctionDescriptor g_try_malloc$descriptor() {
        return g_try_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc(gsize n_bytes)
     * }
     */
    public static MethodHandle g_try_malloc$handle() {
        return g_try_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc(gsize n_bytes)
     * }
     */
    public static MemorySegment g_try_malloc$address() {
        return g_try_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_try_malloc(gsize n_bytes)
     * }
     */
    public static MemorySegment g_try_malloc(long n_bytes) {
        var mh$ = g_try_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_try_malloc", n_bytes);
            }
            return (MemorySegment)mh$.invokeExact(n_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_try_malloc0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_try_malloc0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc0(gsize n_bytes)
     * }
     */
    public static FunctionDescriptor g_try_malloc0$descriptor() {
        return g_try_malloc0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc0(gsize n_bytes)
     * }
     */
    public static MethodHandle g_try_malloc0$handle() {
        return g_try_malloc0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc0(gsize n_bytes)
     * }
     */
    public static MemorySegment g_try_malloc0$address() {
        return g_try_malloc0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_try_malloc0(gsize n_bytes)
     * }
     */
    public static MemorySegment g_try_malloc0(long n_bytes) {
        var mh$ = g_try_malloc0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_try_malloc0", n_bytes);
            }
            return (MemorySegment)mh$.invokeExact(n_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_try_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_try_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_try_realloc(gpointer mem, gsize n_bytes)
     * }
     */
    public static FunctionDescriptor g_try_realloc$descriptor() {
        return g_try_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_try_realloc(gpointer mem, gsize n_bytes)
     * }
     */
    public static MethodHandle g_try_realloc$handle() {
        return g_try_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_try_realloc(gpointer mem, gsize n_bytes)
     * }
     */
    public static MemorySegment g_try_realloc$address() {
        return g_try_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_try_realloc(gpointer mem, gsize n_bytes)
     * }
     */
    public static MemorySegment g_try_realloc(MemorySegment mem, long n_bytes) {
        var mh$ = g_try_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_try_realloc", mem, n_bytes);
            }
            return (MemorySegment)mh$.invokeExact(mem, n_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_malloc_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_malloc_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_malloc_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static FunctionDescriptor g_malloc_n$descriptor() {
        return g_malloc_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_malloc_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MethodHandle g_malloc_n$handle() {
        return g_malloc_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_malloc_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_malloc_n$address() {
        return g_malloc_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_malloc_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_malloc_n(long n_blocks, long n_block_bytes) {
        var mh$ = g_malloc_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_malloc_n", n_blocks, n_block_bytes);
            }
            return (MemorySegment)mh$.invokeExact(n_blocks, n_block_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_malloc0_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_malloc0_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_malloc0_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static FunctionDescriptor g_malloc0_n$descriptor() {
        return g_malloc0_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_malloc0_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MethodHandle g_malloc0_n$handle() {
        return g_malloc0_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_malloc0_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_malloc0_n$address() {
        return g_malloc0_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_malloc0_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_malloc0_n(long n_blocks, long n_block_bytes) {
        var mh$ = g_malloc0_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_malloc0_n", n_blocks, n_block_bytes);
            }
            return (MemorySegment)mh$.invokeExact(n_blocks, n_block_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_realloc_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_realloc_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_realloc_n(gpointer mem, gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static FunctionDescriptor g_realloc_n$descriptor() {
        return g_realloc_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_realloc_n(gpointer mem, gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MethodHandle g_realloc_n$handle() {
        return g_realloc_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_realloc_n(gpointer mem, gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_realloc_n$address() {
        return g_realloc_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_realloc_n(gpointer mem, gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_realloc_n(MemorySegment mem, long n_blocks, long n_block_bytes) {
        var mh$ = g_realloc_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_realloc_n", mem, n_blocks, n_block_bytes);
            }
            return (MemorySegment)mh$.invokeExact(mem, n_blocks, n_block_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_try_malloc_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_try_malloc_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static FunctionDescriptor g_try_malloc_n$descriptor() {
        return g_try_malloc_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MethodHandle g_try_malloc_n$handle() {
        return g_try_malloc_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_try_malloc_n$address() {
        return g_try_malloc_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_try_malloc_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_try_malloc_n(long n_blocks, long n_block_bytes) {
        var mh$ = g_try_malloc_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_try_malloc_n", n_blocks, n_block_bytes);
            }
            return (MemorySegment)mh$.invokeExact(n_blocks, n_block_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_try_malloc0_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_try_malloc0_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc0_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static FunctionDescriptor g_try_malloc0_n$descriptor() {
        return g_try_malloc0_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc0_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MethodHandle g_try_malloc0_n$handle() {
        return g_try_malloc0_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_try_malloc0_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_try_malloc0_n$address() {
        return g_try_malloc0_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_try_malloc0_n(gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_try_malloc0_n(long n_blocks, long n_block_bytes) {
        var mh$ = g_try_malloc0_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_try_malloc0_n", n_blocks, n_block_bytes);
            }
            return (MemorySegment)mh$.invokeExact(n_blocks, n_block_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_try_realloc_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_try_realloc_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_try_realloc_n(gpointer mem, gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static FunctionDescriptor g_try_realloc_n$descriptor() {
        return g_try_realloc_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_try_realloc_n(gpointer mem, gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MethodHandle g_try_realloc_n$handle() {
        return g_try_realloc_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_try_realloc_n(gpointer mem, gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_try_realloc_n$address() {
        return g_try_realloc_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_try_realloc_n(gpointer mem, gsize n_blocks, gsize n_block_bytes)
     * }
     */
    public static MemorySegment g_try_realloc_n(MemorySegment mem, long n_blocks, long n_block_bytes) {
        var mh$ = g_try_realloc_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_try_realloc_n", mem, n_blocks, n_block_bytes);
            }
            return (MemorySegment)mh$.invokeExact(mem, n_blocks, n_block_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_aligned_alloc(gsize n_blocks, gsize n_block_bytes, gsize alignment)
     * }
     */
    public static FunctionDescriptor g_aligned_alloc$descriptor() {
        return g_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_aligned_alloc(gsize n_blocks, gsize n_block_bytes, gsize alignment)
     * }
     */
    public static MethodHandle g_aligned_alloc$handle() {
        return g_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_aligned_alloc(gsize n_blocks, gsize n_block_bytes, gsize alignment)
     * }
     */
    public static MemorySegment g_aligned_alloc$address() {
        return g_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_aligned_alloc(gsize n_blocks, gsize n_block_bytes, gsize alignment)
     * }
     */
    public static MemorySegment g_aligned_alloc(long n_blocks, long n_block_bytes, long alignment) {
        var mh$ = g_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_aligned_alloc", n_blocks, n_block_bytes, alignment);
            }
            return (MemorySegment)mh$.invokeExact(n_blocks, n_block_bytes, alignment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_aligned_alloc0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_aligned_alloc0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_aligned_alloc0(gsize n_blocks, gsize n_block_bytes, gsize alignment)
     * }
     */
    public static FunctionDescriptor g_aligned_alloc0$descriptor() {
        return g_aligned_alloc0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_aligned_alloc0(gsize n_blocks, gsize n_block_bytes, gsize alignment)
     * }
     */
    public static MethodHandle g_aligned_alloc0$handle() {
        return g_aligned_alloc0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_aligned_alloc0(gsize n_blocks, gsize n_block_bytes, gsize alignment)
     * }
     */
    public static MemorySegment g_aligned_alloc0$address() {
        return g_aligned_alloc0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_aligned_alloc0(gsize n_blocks, gsize n_block_bytes, gsize alignment)
     * }
     */
    public static MemorySegment g_aligned_alloc0(long n_blocks, long n_block_bytes, long alignment) {
        var mh$ = g_aligned_alloc0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_aligned_alloc0", n_blocks, n_block_bytes, alignment);
            }
            return (MemorySegment)mh$.invokeExact(n_blocks, n_block_bytes, alignment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_aligned_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_aligned_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_aligned_free(gpointer mem)
     * }
     */
    public static FunctionDescriptor g_aligned_free$descriptor() {
        return g_aligned_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_aligned_free(gpointer mem)
     * }
     */
    public static MethodHandle g_aligned_free$handle() {
        return g_aligned_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_aligned_free(gpointer mem)
     * }
     */
    public static MemorySegment g_aligned_free$address() {
        return g_aligned_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_aligned_free(gpointer mem)
     * }
     */
    public static void g_aligned_free(MemorySegment mem) {
        var mh$ = g_aligned_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_aligned_free", mem);
            }
            mh$.invokeExact(mem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_aligned_free_sized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_aligned_free_sized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_aligned_free_sized(gpointer mem, size_t alignment, size_t size)
     * }
     */
    public static FunctionDescriptor g_aligned_free_sized$descriptor() {
        return g_aligned_free_sized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_aligned_free_sized(gpointer mem, size_t alignment, size_t size)
     * }
     */
    public static MethodHandle g_aligned_free_sized$handle() {
        return g_aligned_free_sized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_aligned_free_sized(gpointer mem, size_t alignment, size_t size)
     * }
     */
    public static MemorySegment g_aligned_free_sized$address() {
        return g_aligned_free_sized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_aligned_free_sized(gpointer mem, size_t alignment, size_t size)
     * }
     */
    public static void g_aligned_free_sized(MemorySegment mem, long alignment, long size) {
        var mh$ = g_aligned_free_sized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_aligned_free_sized", mem, alignment, size);
            }
            mh$.invokeExact(mem, alignment, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_set_vtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_set_vtable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mem_set_vtable(GMemVTable *vtable)
     * }
     */
    public static FunctionDescriptor g_mem_set_vtable$descriptor() {
        return g_mem_set_vtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mem_set_vtable(GMemVTable *vtable)
     * }
     */
    public static MethodHandle g_mem_set_vtable$handle() {
        return g_mem_set_vtable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mem_set_vtable(GMemVTable *vtable)
     * }
     */
    public static MemorySegment g_mem_set_vtable$address() {
        return g_mem_set_vtable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mem_set_vtable(GMemVTable *vtable)
     * }
     */
    public static void g_mem_set_vtable(MemorySegment vtable) {
        var mh$ = g_mem_set_vtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_set_vtable", vtable);
            }
            mh$.invokeExact(vtable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_is_system_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_is_system_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_mem_is_system_malloc()
     * }
     */
    public static FunctionDescriptor g_mem_is_system_malloc$descriptor() {
        return g_mem_is_system_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_mem_is_system_malloc()
     * }
     */
    public static MethodHandle g_mem_is_system_malloc$handle() {
        return g_mem_is_system_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_mem_is_system_malloc()
     * }
     */
    public static MemorySegment g_mem_is_system_malloc$address() {
        return g_mem_is_system_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_mem_is_system_malloc()
     * }
     */
    public static int g_mem_is_system_malloc() {
        var mh$ = g_mem_is_system_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_is_system_malloc");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mem_gc_friendly$constants {
        public static final OfInt LAYOUT = gst_min_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_mem_gc_friendly").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern gboolean g_mem_gc_friendly
     * }
     */
    public static OfInt g_mem_gc_friendly$layout() {
        return g_mem_gc_friendly$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern gboolean g_mem_gc_friendly
     * }
     */
    public static MemorySegment g_mem_gc_friendly$segment() {
        return g_mem_gc_friendly$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern gboolean g_mem_gc_friendly
     * }
     */
    public static int g_mem_gc_friendly() {
        return g_mem_gc_friendly$constants.SEGMENT.get(g_mem_gc_friendly$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern gboolean g_mem_gc_friendly
     * }
     */
    public static void g_mem_gc_friendly(int varValue) {
        g_mem_gc_friendly$constants.SEGMENT.set(g_mem_gc_friendly$constants.LAYOUT, 0L, varValue);
    }

    private static class glib_mem_profiler_table$constants {
        public static final AddressLayout LAYOUT = gst_min_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("glib_mem_profiler_table").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern GMemVTable *glib_mem_profiler_table
     * }
     */
    public static AddressLayout glib_mem_profiler_table$layout() {
        return glib_mem_profiler_table$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern GMemVTable *glib_mem_profiler_table
     * }
     */
    public static MemorySegment glib_mem_profiler_table$segment() {
        return glib_mem_profiler_table$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern GMemVTable *glib_mem_profiler_table
     * }
     */
    public static MemorySegment glib_mem_profiler_table() {
        return glib_mem_profiler_table$constants.SEGMENT.get(glib_mem_profiler_table$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern GMemVTable *glib_mem_profiler_table
     * }
     */
    public static void glib_mem_profiler_table(MemorySegment varValue) {
        glib_mem_profiler_table$constants.SEGMENT.set(glib_mem_profiler_table$constants.LAYOUT, 0L, varValue);
    }

    private static class g_mem_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mem_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mem_profile()
     * }
     */
    public static FunctionDescriptor g_mem_profile$descriptor() {
        return g_mem_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mem_profile()
     * }
     */
    public static MethodHandle g_mem_profile$handle() {
        return g_mem_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mem_profile()
     * }
     */
    public static MemorySegment g_mem_profile$address() {
        return g_mem_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mem_profile()
     * }
     */
    public static void g_mem_profile() {
        var mh$ = g_mem_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mem_profile");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_TRAVERSE_LEAVES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TRAVERSE_LEAVES = 1
     * }
     */
    public static int G_TRAVERSE_LEAVES() {
        return G_TRAVERSE_LEAVES;
    }
    private static final int G_TRAVERSE_NON_LEAVES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TRAVERSE_NON_LEAVES = 2
     * }
     */
    public static int G_TRAVERSE_NON_LEAVES() {
        return G_TRAVERSE_NON_LEAVES;
    }
    private static final int G_TRAVERSE_ALL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TRAVERSE_ALL = 3
     * }
     */
    public static int G_TRAVERSE_ALL() {
        return G_TRAVERSE_ALL;
    }
    private static final int G_TRAVERSE_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TRAVERSE_MASK = 3
     * }
     */
    public static int G_TRAVERSE_MASK() {
        return G_TRAVERSE_MASK;
    }
    private static final int G_TRAVERSE_LEAFS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TRAVERSE_LEAFS = 1
     * }
     */
    public static int G_TRAVERSE_LEAFS() {
        return G_TRAVERSE_LEAFS;
    }
    private static final int G_TRAVERSE_NON_LEAFS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TRAVERSE_NON_LEAFS = 2
     * }
     */
    public static int G_TRAVERSE_NON_LEAFS() {
        return G_TRAVERSE_NON_LEAFS;
    }
    private static final int G_IN_ORDER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IN_ORDER = 0
     * }
     */
    public static int G_IN_ORDER() {
        return G_IN_ORDER;
    }
    private static final int G_PRE_ORDER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_PRE_ORDER = 1
     * }
     */
    public static int G_PRE_ORDER() {
        return G_PRE_ORDER;
    }
    private static final int G_POST_ORDER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_POST_ORDER = 2
     * }
     */
    public static int G_POST_ORDER() {
        return G_POST_ORDER;
    }
    private static final int G_LEVEL_ORDER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LEVEL_ORDER = 3
     * }
     */
    public static int G_LEVEL_ORDER() {
        return G_LEVEL_ORDER;
    }

    private static class g_node_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_new(gpointer data)
     * }
     */
    public static FunctionDescriptor g_node_new$descriptor() {
        return g_node_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_new(gpointer data)
     * }
     */
    public static MethodHandle g_node_new$handle() {
        return g_node_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_new(gpointer data)
     * }
     */
    public static MemorySegment g_node_new$address() {
        return g_node_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_new(gpointer data)
     * }
     */
    public static MemorySegment g_node_new(MemorySegment data) {
        var mh$ = g_node_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_new", data);
            }
            return (MemorySegment)mh$.invokeExact(data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_node_destroy(GNode *root)
     * }
     */
    public static FunctionDescriptor g_node_destroy$descriptor() {
        return g_node_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_node_destroy(GNode *root)
     * }
     */
    public static MethodHandle g_node_destroy$handle() {
        return g_node_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_node_destroy(GNode *root)
     * }
     */
    public static MemorySegment g_node_destroy$address() {
        return g_node_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_node_destroy(GNode *root)
     * }
     */
    public static void g_node_destroy(MemorySegment root) {
        var mh$ = g_node_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_destroy", root);
            }
            mh$.invokeExact(root);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_node_unlink(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_unlink$descriptor() {
        return g_node_unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_node_unlink(GNode *node)
     * }
     */
    public static MethodHandle g_node_unlink$handle() {
        return g_node_unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_node_unlink(GNode *node)
     * }
     */
    public static MemorySegment g_node_unlink$address() {
        return g_node_unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_node_unlink(GNode *node)
     * }
     */
    public static void g_node_unlink(MemorySegment node) {
        var mh$ = g_node_unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_unlink", node);
            }
            mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_copy_deep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_copy_deep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_copy_deep(GNode *node, GCopyFunc copy_func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_node_copy_deep$descriptor() {
        return g_node_copy_deep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_copy_deep(GNode *node, GCopyFunc copy_func, gpointer data)
     * }
     */
    public static MethodHandle g_node_copy_deep$handle() {
        return g_node_copy_deep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_copy_deep(GNode *node, GCopyFunc copy_func, gpointer data)
     * }
     */
    public static MemorySegment g_node_copy_deep$address() {
        return g_node_copy_deep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_copy_deep(GNode *node, GCopyFunc copy_func, gpointer data)
     * }
     */
    public static MemorySegment g_node_copy_deep(MemorySegment node, MemorySegment copy_func, MemorySegment data) {
        var mh$ = g_node_copy_deep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_copy_deep", node, copy_func, data);
            }
            return (MemorySegment)mh$.invokeExact(node, copy_func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_copy(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_copy$descriptor() {
        return g_node_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_copy(GNode *node)
     * }
     */
    public static MethodHandle g_node_copy$handle() {
        return g_node_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_copy(GNode *node)
     * }
     */
    public static MemorySegment g_node_copy$address() {
        return g_node_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_copy(GNode *node)
     * }
     */
    public static MemorySegment g_node_copy(MemorySegment node) {
        var mh$ = g_node_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_copy", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert(GNode *parent, gint position, GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_insert$descriptor() {
        return g_node_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert(GNode *parent, gint position, GNode *node)
     * }
     */
    public static MethodHandle g_node_insert$handle() {
        return g_node_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert(GNode *parent, gint position, GNode *node)
     * }
     */
    public static MemorySegment g_node_insert$address() {
        return g_node_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_insert(GNode *parent, gint position, GNode *node)
     * }
     */
    public static MemorySegment g_node_insert(MemorySegment parent, int position, MemorySegment node) {
        var mh$ = g_node_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_insert", parent, position, node);
            }
            return (MemorySegment)mh$.invokeExact(parent, position, node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_insert_before {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_insert_before");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert_before(GNode *parent, GNode *sibling, GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_insert_before$descriptor() {
        return g_node_insert_before.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert_before(GNode *parent, GNode *sibling, GNode *node)
     * }
     */
    public static MethodHandle g_node_insert_before$handle() {
        return g_node_insert_before.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert_before(GNode *parent, GNode *sibling, GNode *node)
     * }
     */
    public static MemorySegment g_node_insert_before$address() {
        return g_node_insert_before.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_insert_before(GNode *parent, GNode *sibling, GNode *node)
     * }
     */
    public static MemorySegment g_node_insert_before(MemorySegment parent, MemorySegment sibling, MemorySegment node) {
        var mh$ = g_node_insert_before.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_insert_before", parent, sibling, node);
            }
            return (MemorySegment)mh$.invokeExact(parent, sibling, node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_insert_after {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_insert_after");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert_after(GNode *parent, GNode *sibling, GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_insert_after$descriptor() {
        return g_node_insert_after.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert_after(GNode *parent, GNode *sibling, GNode *node)
     * }
     */
    public static MethodHandle g_node_insert_after$handle() {
        return g_node_insert_after.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_insert_after(GNode *parent, GNode *sibling, GNode *node)
     * }
     */
    public static MemorySegment g_node_insert_after$address() {
        return g_node_insert_after.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_insert_after(GNode *parent, GNode *sibling, GNode *node)
     * }
     */
    public static MemorySegment g_node_insert_after(MemorySegment parent, MemorySegment sibling, MemorySegment node) {
        var mh$ = g_node_insert_after.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_insert_after", parent, sibling, node);
            }
            return (MemorySegment)mh$.invokeExact(parent, sibling, node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_prepend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_prepend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_prepend(GNode *parent, GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_prepend$descriptor() {
        return g_node_prepend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_prepend(GNode *parent, GNode *node)
     * }
     */
    public static MethodHandle g_node_prepend$handle() {
        return g_node_prepend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_prepend(GNode *parent, GNode *node)
     * }
     */
    public static MemorySegment g_node_prepend$address() {
        return g_node_prepend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_prepend(GNode *parent, GNode *node)
     * }
     */
    public static MemorySegment g_node_prepend(MemorySegment parent, MemorySegment node) {
        var mh$ = g_node_prepend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_prepend", parent, node);
            }
            return (MemorySegment)mh$.invokeExact(parent, node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_n_nodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_n_nodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_node_n_nodes(GNode *root, GTraverseFlags flags)
     * }
     */
    public static FunctionDescriptor g_node_n_nodes$descriptor() {
        return g_node_n_nodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_node_n_nodes(GNode *root, GTraverseFlags flags)
     * }
     */
    public static MethodHandle g_node_n_nodes$handle() {
        return g_node_n_nodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_node_n_nodes(GNode *root, GTraverseFlags flags)
     * }
     */
    public static MemorySegment g_node_n_nodes$address() {
        return g_node_n_nodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_node_n_nodes(GNode *root, GTraverseFlags flags)
     * }
     */
    public static int g_node_n_nodes(MemorySegment root, int flags) {
        var mh$ = g_node_n_nodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_n_nodes", root, flags);
            }
            return (int)mh$.invokeExact(root, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_get_root {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_get_root");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_get_root(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_get_root$descriptor() {
        return g_node_get_root.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_get_root(GNode *node)
     * }
     */
    public static MethodHandle g_node_get_root$handle() {
        return g_node_get_root.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_get_root(GNode *node)
     * }
     */
    public static MemorySegment g_node_get_root$address() {
        return g_node_get_root.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_get_root(GNode *node)
     * }
     */
    public static MemorySegment g_node_get_root(MemorySegment node) {
        var mh$ = g_node_get_root.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_get_root", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_is_ancestor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_is_ancestor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_node_is_ancestor(GNode *node, GNode *descendant)
     * }
     */
    public static FunctionDescriptor g_node_is_ancestor$descriptor() {
        return g_node_is_ancestor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_node_is_ancestor(GNode *node, GNode *descendant)
     * }
     */
    public static MethodHandle g_node_is_ancestor$handle() {
        return g_node_is_ancestor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_node_is_ancestor(GNode *node, GNode *descendant)
     * }
     */
    public static MemorySegment g_node_is_ancestor$address() {
        return g_node_is_ancestor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_node_is_ancestor(GNode *node, GNode *descendant)
     * }
     */
    public static int g_node_is_ancestor(MemorySegment node, MemorySegment descendant) {
        var mh$ = g_node_is_ancestor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_is_ancestor", node, descendant);
            }
            return (int)mh$.invokeExact(node, descendant);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_node_depth(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_depth$descriptor() {
        return g_node_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_node_depth(GNode *node)
     * }
     */
    public static MethodHandle g_node_depth$handle() {
        return g_node_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_node_depth(GNode *node)
     * }
     */
    public static MemorySegment g_node_depth$address() {
        return g_node_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_node_depth(GNode *node)
     * }
     */
    public static int g_node_depth(MemorySegment node) {
        var mh$ = g_node_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_depth", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_find(GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data)
     * }
     */
    public static FunctionDescriptor g_node_find$descriptor() {
        return g_node_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_find(GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data)
     * }
     */
    public static MethodHandle g_node_find$handle() {
        return g_node_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_find(GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data)
     * }
     */
    public static MemorySegment g_node_find$address() {
        return g_node_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_find(GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data)
     * }
     */
    public static MemorySegment g_node_find(MemorySegment root, int order, int flags, MemorySegment data) {
        var mh$ = g_node_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_find", root, order, flags, data);
            }
            return (MemorySegment)mh$.invokeExact(root, order, flags, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_traverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_traverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_node_traverse(GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_node_traverse$descriptor() {
        return g_node_traverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_node_traverse(GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data)
     * }
     */
    public static MethodHandle g_node_traverse$handle() {
        return g_node_traverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_node_traverse(GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data)
     * }
     */
    public static MemorySegment g_node_traverse$address() {
        return g_node_traverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_node_traverse(GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data)
     * }
     */
    public static void g_node_traverse(MemorySegment root, int order, int flags, int max_depth, MemorySegment func, MemorySegment data) {
        var mh$ = g_node_traverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_traverse", root, order, flags, max_depth, func, data);
            }
            mh$.invokeExact(root, order, flags, max_depth, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_max_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_max_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_node_max_height(GNode *root)
     * }
     */
    public static FunctionDescriptor g_node_max_height$descriptor() {
        return g_node_max_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_node_max_height(GNode *root)
     * }
     */
    public static MethodHandle g_node_max_height$handle() {
        return g_node_max_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_node_max_height(GNode *root)
     * }
     */
    public static MemorySegment g_node_max_height$address() {
        return g_node_max_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_node_max_height(GNode *root)
     * }
     */
    public static int g_node_max_height(MemorySegment root) {
        var mh$ = g_node_max_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_max_height", root);
            }
            return (int)mh$.invokeExact(root);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_children_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_children_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_node_children_foreach(GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_node_children_foreach$descriptor() {
        return g_node_children_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_node_children_foreach(GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data)
     * }
     */
    public static MethodHandle g_node_children_foreach$handle() {
        return g_node_children_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_node_children_foreach(GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data)
     * }
     */
    public static MemorySegment g_node_children_foreach$address() {
        return g_node_children_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_node_children_foreach(GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data)
     * }
     */
    public static void g_node_children_foreach(MemorySegment node, int flags, MemorySegment func, MemorySegment data) {
        var mh$ = g_node_children_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_children_foreach", node, flags, func, data);
            }
            mh$.invokeExact(node, flags, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_reverse_children {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_reverse_children");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_node_reverse_children(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_reverse_children$descriptor() {
        return g_node_reverse_children.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_node_reverse_children(GNode *node)
     * }
     */
    public static MethodHandle g_node_reverse_children$handle() {
        return g_node_reverse_children.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_node_reverse_children(GNode *node)
     * }
     */
    public static MemorySegment g_node_reverse_children$address() {
        return g_node_reverse_children.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_node_reverse_children(GNode *node)
     * }
     */
    public static void g_node_reverse_children(MemorySegment node) {
        var mh$ = g_node_reverse_children.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_reverse_children", node);
            }
            mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_n_children {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_n_children");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_node_n_children(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_n_children$descriptor() {
        return g_node_n_children.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_node_n_children(GNode *node)
     * }
     */
    public static MethodHandle g_node_n_children$handle() {
        return g_node_n_children.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_node_n_children(GNode *node)
     * }
     */
    public static MemorySegment g_node_n_children$address() {
        return g_node_n_children.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_node_n_children(GNode *node)
     * }
     */
    public static int g_node_n_children(MemorySegment node) {
        var mh$ = g_node_n_children.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_n_children", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_nth_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_nth_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_nth_child(GNode *node, guint n)
     * }
     */
    public static FunctionDescriptor g_node_nth_child$descriptor() {
        return g_node_nth_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_nth_child(GNode *node, guint n)
     * }
     */
    public static MethodHandle g_node_nth_child$handle() {
        return g_node_nth_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_nth_child(GNode *node, guint n)
     * }
     */
    public static MemorySegment g_node_nth_child$address() {
        return g_node_nth_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_nth_child(GNode *node, guint n)
     * }
     */
    public static MemorySegment g_node_nth_child(MemorySegment node, int n) {
        var mh$ = g_node_nth_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_nth_child", node, n);
            }
            return (MemorySegment)mh$.invokeExact(node, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_last_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_last_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_last_child(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_last_child$descriptor() {
        return g_node_last_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_last_child(GNode *node)
     * }
     */
    public static MethodHandle g_node_last_child$handle() {
        return g_node_last_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_last_child(GNode *node)
     * }
     */
    public static MemorySegment g_node_last_child$address() {
        return g_node_last_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_last_child(GNode *node)
     * }
     */
    public static MemorySegment g_node_last_child(MemorySegment node) {
        var mh$ = g_node_last_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_last_child", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_find_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_find_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_find_child(GNode *node, GTraverseFlags flags, gpointer data)
     * }
     */
    public static FunctionDescriptor g_node_find_child$descriptor() {
        return g_node_find_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_find_child(GNode *node, GTraverseFlags flags, gpointer data)
     * }
     */
    public static MethodHandle g_node_find_child$handle() {
        return g_node_find_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_find_child(GNode *node, GTraverseFlags flags, gpointer data)
     * }
     */
    public static MemorySegment g_node_find_child$address() {
        return g_node_find_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_find_child(GNode *node, GTraverseFlags flags, gpointer data)
     * }
     */
    public static MemorySegment g_node_find_child(MemorySegment node, int flags, MemorySegment data) {
        var mh$ = g_node_find_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_find_child", node, flags, data);
            }
            return (MemorySegment)mh$.invokeExact(node, flags, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_child_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_child_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_node_child_position(GNode *node, GNode *child)
     * }
     */
    public static FunctionDescriptor g_node_child_position$descriptor() {
        return g_node_child_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_node_child_position(GNode *node, GNode *child)
     * }
     */
    public static MethodHandle g_node_child_position$handle() {
        return g_node_child_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_node_child_position(GNode *node, GNode *child)
     * }
     */
    public static MemorySegment g_node_child_position$address() {
        return g_node_child_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_node_child_position(GNode *node, GNode *child)
     * }
     */
    public static int g_node_child_position(MemorySegment node, MemorySegment child) {
        var mh$ = g_node_child_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_child_position", node, child);
            }
            return (int)mh$.invokeExact(node, child);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_child_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_child_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_node_child_index(GNode *node, gpointer data)
     * }
     */
    public static FunctionDescriptor g_node_child_index$descriptor() {
        return g_node_child_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_node_child_index(GNode *node, gpointer data)
     * }
     */
    public static MethodHandle g_node_child_index$handle() {
        return g_node_child_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_node_child_index(GNode *node, gpointer data)
     * }
     */
    public static MemorySegment g_node_child_index$address() {
        return g_node_child_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_node_child_index(GNode *node, gpointer data)
     * }
     */
    public static int g_node_child_index(MemorySegment node, MemorySegment data) {
        var mh$ = g_node_child_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_child_index", node, data);
            }
            return (int)mh$.invokeExact(node, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_first_sibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_first_sibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_first_sibling(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_first_sibling$descriptor() {
        return g_node_first_sibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_first_sibling(GNode *node)
     * }
     */
    public static MethodHandle g_node_first_sibling$handle() {
        return g_node_first_sibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_first_sibling(GNode *node)
     * }
     */
    public static MemorySegment g_node_first_sibling$address() {
        return g_node_first_sibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_first_sibling(GNode *node)
     * }
     */
    public static MemorySegment g_node_first_sibling(MemorySegment node) {
        var mh$ = g_node_first_sibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_first_sibling", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_node_last_sibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_node_last_sibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GNode *g_node_last_sibling(GNode *node)
     * }
     */
    public static FunctionDescriptor g_node_last_sibling$descriptor() {
        return g_node_last_sibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GNode *g_node_last_sibling(GNode *node)
     * }
     */
    public static MethodHandle g_node_last_sibling$handle() {
        return g_node_last_sibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GNode *g_node_last_sibling(GNode *node)
     * }
     */
    public static MemorySegment g_node_last_sibling$address() {
        return g_node_last_sibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GNode *g_node_last_sibling(GNode *node)
     * }
     */
    public static MemorySegment g_node_last_sibling(MemorySegment node) {
        var mh$ = g_node_last_sibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_node_last_sibling", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_alloc()
     * }
     */
    public static FunctionDescriptor g_list_alloc$descriptor() {
        return g_list_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_alloc()
     * }
     */
    public static MethodHandle g_list_alloc$handle() {
        return g_list_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_alloc()
     * }
     */
    public static MemorySegment g_list_alloc$address() {
        return g_list_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_alloc()
     * }
     */
    public static MemorySegment g_list_alloc() {
        var mh$ = g_list_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_list_free(GList *list)
     * }
     */
    public static FunctionDescriptor g_list_free$descriptor() {
        return g_list_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_list_free(GList *list)
     * }
     */
    public static MethodHandle g_list_free$handle() {
        return g_list_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_list_free(GList *list)
     * }
     */
    public static MemorySegment g_list_free$address() {
        return g_list_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_list_free(GList *list)
     * }
     */
    public static void g_list_free(MemorySegment list) {
        var mh$ = g_list_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_free", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_free_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_free_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_list_free_1(GList *list)
     * }
     */
    public static FunctionDescriptor g_list_free_1$descriptor() {
        return g_list_free_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_list_free_1(GList *list)
     * }
     */
    public static MethodHandle g_list_free_1$handle() {
        return g_list_free_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_list_free_1(GList *list)
     * }
     */
    public static MemorySegment g_list_free_1$address() {
        return g_list_free_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_list_free_1(GList *list)
     * }
     */
    public static void g_list_free_1(MemorySegment list) {
        var mh$ = g_list_free_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_free_1", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_free_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_free_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_list_free_full(GList *list, GDestroyNotify free_func)
     * }
     */
    public static FunctionDescriptor g_list_free_full$descriptor() {
        return g_list_free_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_list_free_full(GList *list, GDestroyNotify free_func)
     * }
     */
    public static MethodHandle g_list_free_full$handle() {
        return g_list_free_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_list_free_full(GList *list, GDestroyNotify free_func)
     * }
     */
    public static MemorySegment g_list_free_full$address() {
        return g_list_free_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_list_free_full(GList *list, GDestroyNotify free_func)
     * }
     */
    public static void g_list_free_full(MemorySegment list, MemorySegment free_func) {
        var mh$ = g_list_free_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_free_full", list, free_func);
            }
            mh$.invokeExact(list, free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_append(GList *list, gpointer data)
     * }
     */
    public static FunctionDescriptor g_list_append$descriptor() {
        return g_list_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_append(GList *list, gpointer data)
     * }
     */
    public static MethodHandle g_list_append$handle() {
        return g_list_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_append(GList *list, gpointer data)
     * }
     */
    public static MemorySegment g_list_append$address() {
        return g_list_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_append(GList *list, gpointer data)
     * }
     */
    public static MemorySegment g_list_append(MemorySegment list, MemorySegment data) {
        var mh$ = g_list_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_append", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_prepend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_prepend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_prepend(GList *list, gpointer data)
     * }
     */
    public static FunctionDescriptor g_list_prepend$descriptor() {
        return g_list_prepend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_prepend(GList *list, gpointer data)
     * }
     */
    public static MethodHandle g_list_prepend$handle() {
        return g_list_prepend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_prepend(GList *list, gpointer data)
     * }
     */
    public static MemorySegment g_list_prepend$address() {
        return g_list_prepend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_prepend(GList *list, gpointer data)
     * }
     */
    public static MemorySegment g_list_prepend(MemorySegment list, MemorySegment data) {
        var mh$ = g_list_prepend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_prepend", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_insert(GList *list, gpointer data, gint position)
     * }
     */
    public static FunctionDescriptor g_list_insert$descriptor() {
        return g_list_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_insert(GList *list, gpointer data, gint position)
     * }
     */
    public static MethodHandle g_list_insert$handle() {
        return g_list_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_insert(GList *list, gpointer data, gint position)
     * }
     */
    public static MemorySegment g_list_insert$address() {
        return g_list_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_insert(GList *list, gpointer data, gint position)
     * }
     */
    public static MemorySegment g_list_insert(MemorySegment list, MemorySegment data, int position) {
        var mh$ = g_list_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_insert", list, data, position);
            }
            return (MemorySegment)mh$.invokeExact(list, data, position);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_insert_sorted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_insert_sorted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_sorted(GList *list, gpointer data, GCompareFunc func)
     * }
     */
    public static FunctionDescriptor g_list_insert_sorted$descriptor() {
        return g_list_insert_sorted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_sorted(GList *list, gpointer data, GCompareFunc func)
     * }
     */
    public static MethodHandle g_list_insert_sorted$handle() {
        return g_list_insert_sorted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_sorted(GList *list, gpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_list_insert_sorted$address() {
        return g_list_insert_sorted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_insert_sorted(GList *list, gpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_list_insert_sorted(MemorySegment list, MemorySegment data, MemorySegment func) {
        var mh$ = g_list_insert_sorted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_insert_sorted", list, data, func);
            }
            return (MemorySegment)mh$.invokeExact(list, data, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_insert_sorted_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_insert_sorted_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_sorted_with_data(GList *list, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_list_insert_sorted_with_data$descriptor() {
        return g_list_insert_sorted_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_sorted_with_data(GList *list, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_list_insert_sorted_with_data$handle() {
        return g_list_insert_sorted_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_sorted_with_data(GList *list, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_list_insert_sorted_with_data$address() {
        return g_list_insert_sorted_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_insert_sorted_with_data(GList *list, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_list_insert_sorted_with_data(MemorySegment list, MemorySegment data, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_list_insert_sorted_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_insert_sorted_with_data", list, data, func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(list, data, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_insert_before {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_insert_before");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_before(GList *list, GList *sibling, gpointer data)
     * }
     */
    public static FunctionDescriptor g_list_insert_before$descriptor() {
        return g_list_insert_before.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_before(GList *list, GList *sibling, gpointer data)
     * }
     */
    public static MethodHandle g_list_insert_before$handle() {
        return g_list_insert_before.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_before(GList *list, GList *sibling, gpointer data)
     * }
     */
    public static MemorySegment g_list_insert_before$address() {
        return g_list_insert_before.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_insert_before(GList *list, GList *sibling, gpointer data)
     * }
     */
    public static MemorySegment g_list_insert_before(MemorySegment list, MemorySegment sibling, MemorySegment data) {
        var mh$ = g_list_insert_before.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_insert_before", list, sibling, data);
            }
            return (MemorySegment)mh$.invokeExact(list, sibling, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_insert_before_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_insert_before_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_before_link(GList *list, GList *sibling, GList *link_)
     * }
     */
    public static FunctionDescriptor g_list_insert_before_link$descriptor() {
        return g_list_insert_before_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_before_link(GList *list, GList *sibling, GList *link_)
     * }
     */
    public static MethodHandle g_list_insert_before_link$handle() {
        return g_list_insert_before_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_insert_before_link(GList *list, GList *sibling, GList *link_)
     * }
     */
    public static MemorySegment g_list_insert_before_link$address() {
        return g_list_insert_before_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_insert_before_link(GList *list, GList *sibling, GList *link_)
     * }
     */
    public static MemorySegment g_list_insert_before_link(MemorySegment list, MemorySegment sibling, MemorySegment link_) {
        var mh$ = g_list_insert_before_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_insert_before_link", list, sibling, link_);
            }
            return (MemorySegment)mh$.invokeExact(list, sibling, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_concat(GList *list1, GList *list2)
     * }
     */
    public static FunctionDescriptor g_list_concat$descriptor() {
        return g_list_concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_concat(GList *list1, GList *list2)
     * }
     */
    public static MethodHandle g_list_concat$handle() {
        return g_list_concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_concat(GList *list1, GList *list2)
     * }
     */
    public static MemorySegment g_list_concat$address() {
        return g_list_concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_concat(GList *list1, GList *list2)
     * }
     */
    public static MemorySegment g_list_concat(MemorySegment list1, MemorySegment list2) {
        var mh$ = g_list_concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_concat", list1, list2);
            }
            return (MemorySegment)mh$.invokeExact(list1, list2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_remove(GList *list, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_list_remove$descriptor() {
        return g_list_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_remove(GList *list, gconstpointer data)
     * }
     */
    public static MethodHandle g_list_remove$handle() {
        return g_list_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_remove(GList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_list_remove$address() {
        return g_list_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_remove(GList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_list_remove(MemorySegment list, MemorySegment data) {
        var mh$ = g_list_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_remove", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_remove_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_remove_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_remove_all(GList *list, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_list_remove_all$descriptor() {
        return g_list_remove_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_remove_all(GList *list, gconstpointer data)
     * }
     */
    public static MethodHandle g_list_remove_all$handle() {
        return g_list_remove_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_remove_all(GList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_list_remove_all$address() {
        return g_list_remove_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_remove_all(GList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_list_remove_all(MemorySegment list, MemorySegment data) {
        var mh$ = g_list_remove_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_remove_all", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_remove_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_remove_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_remove_link(GList *list, GList *llink)
     * }
     */
    public static FunctionDescriptor g_list_remove_link$descriptor() {
        return g_list_remove_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_remove_link(GList *list, GList *llink)
     * }
     */
    public static MethodHandle g_list_remove_link$handle() {
        return g_list_remove_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_remove_link(GList *list, GList *llink)
     * }
     */
    public static MemorySegment g_list_remove_link$address() {
        return g_list_remove_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_remove_link(GList *list, GList *llink)
     * }
     */
    public static MemorySegment g_list_remove_link(MemorySegment list, MemorySegment llink) {
        var mh$ = g_list_remove_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_remove_link", list, llink);
            }
            return (MemorySegment)mh$.invokeExact(list, llink);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_delete_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_delete_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_delete_link(GList *list, GList *link_)
     * }
     */
    public static FunctionDescriptor g_list_delete_link$descriptor() {
        return g_list_delete_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_delete_link(GList *list, GList *link_)
     * }
     */
    public static MethodHandle g_list_delete_link$handle() {
        return g_list_delete_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_delete_link(GList *list, GList *link_)
     * }
     */
    public static MemorySegment g_list_delete_link$address() {
        return g_list_delete_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_delete_link(GList *list, GList *link_)
     * }
     */
    public static MemorySegment g_list_delete_link(MemorySegment list, MemorySegment link_) {
        var mh$ = g_list_delete_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_delete_link", list, link_);
            }
            return (MemorySegment)mh$.invokeExact(list, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_reverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_reverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_reverse(GList *list)
     * }
     */
    public static FunctionDescriptor g_list_reverse$descriptor() {
        return g_list_reverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_reverse(GList *list)
     * }
     */
    public static MethodHandle g_list_reverse$handle() {
        return g_list_reverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_reverse(GList *list)
     * }
     */
    public static MemorySegment g_list_reverse$address() {
        return g_list_reverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_reverse(GList *list)
     * }
     */
    public static MemorySegment g_list_reverse(MemorySegment list) {
        var mh$ = g_list_reverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_reverse", list);
            }
            return (MemorySegment)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_copy(GList *list)
     * }
     */
    public static FunctionDescriptor g_list_copy$descriptor() {
        return g_list_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_copy(GList *list)
     * }
     */
    public static MethodHandle g_list_copy$handle() {
        return g_list_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_copy(GList *list)
     * }
     */
    public static MemorySegment g_list_copy$address() {
        return g_list_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_copy(GList *list)
     * }
     */
    public static MemorySegment g_list_copy(MemorySegment list) {
        var mh$ = g_list_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_copy", list);
            }
            return (MemorySegment)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_copy_deep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_copy_deep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_copy_deep(GList *list, GCopyFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_list_copy_deep$descriptor() {
        return g_list_copy_deep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_copy_deep(GList *list, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_list_copy_deep$handle() {
        return g_list_copy_deep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_copy_deep(GList *list, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_list_copy_deep$address() {
        return g_list_copy_deep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_copy_deep(GList *list, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_list_copy_deep(MemorySegment list, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_list_copy_deep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_copy_deep", list, func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(list, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_nth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_nth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_nth(GList *list, guint n)
     * }
     */
    public static FunctionDescriptor g_list_nth$descriptor() {
        return g_list_nth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_nth(GList *list, guint n)
     * }
     */
    public static MethodHandle g_list_nth$handle() {
        return g_list_nth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_nth(GList *list, guint n)
     * }
     */
    public static MemorySegment g_list_nth$address() {
        return g_list_nth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_nth(GList *list, guint n)
     * }
     */
    public static MemorySegment g_list_nth(MemorySegment list, int n) {
        var mh$ = g_list_nth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_nth", list, n);
            }
            return (MemorySegment)mh$.invokeExact(list, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_nth_prev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_nth_prev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_nth_prev(GList *list, guint n)
     * }
     */
    public static FunctionDescriptor g_list_nth_prev$descriptor() {
        return g_list_nth_prev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_nth_prev(GList *list, guint n)
     * }
     */
    public static MethodHandle g_list_nth_prev$handle() {
        return g_list_nth_prev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_nth_prev(GList *list, guint n)
     * }
     */
    public static MemorySegment g_list_nth_prev$address() {
        return g_list_nth_prev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_nth_prev(GList *list, guint n)
     * }
     */
    public static MemorySegment g_list_nth_prev(MemorySegment list, int n) {
        var mh$ = g_list_nth_prev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_nth_prev", list, n);
            }
            return (MemorySegment)mh$.invokeExact(list, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_find(GList *list, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_list_find$descriptor() {
        return g_list_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_find(GList *list, gconstpointer data)
     * }
     */
    public static MethodHandle g_list_find$handle() {
        return g_list_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_find(GList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_list_find$address() {
        return g_list_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_find(GList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_list_find(MemorySegment list, MemorySegment data) {
        var mh$ = g_list_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_find", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_find_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_find_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_find_custom(GList *list, gconstpointer data, GCompareFunc func)
     * }
     */
    public static FunctionDescriptor g_list_find_custom$descriptor() {
        return g_list_find_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_find_custom(GList *list, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MethodHandle g_list_find_custom$handle() {
        return g_list_find_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_find_custom(GList *list, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_list_find_custom$address() {
        return g_list_find_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_find_custom(GList *list, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_list_find_custom(MemorySegment list, MemorySegment data, MemorySegment func) {
        var mh$ = g_list_find_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_find_custom", list, data, func);
            }
            return (MemorySegment)mh$.invokeExact(list, data, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_list_position(GList *list, GList *llink)
     * }
     */
    public static FunctionDescriptor g_list_position$descriptor() {
        return g_list_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_list_position(GList *list, GList *llink)
     * }
     */
    public static MethodHandle g_list_position$handle() {
        return g_list_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_list_position(GList *list, GList *llink)
     * }
     */
    public static MemorySegment g_list_position$address() {
        return g_list_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_list_position(GList *list, GList *llink)
     * }
     */
    public static int g_list_position(MemorySegment list, MemorySegment llink) {
        var mh$ = g_list_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_position", list, llink);
            }
            return (int)mh$.invokeExact(list, llink);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_list_index(GList *list, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_list_index$descriptor() {
        return g_list_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_list_index(GList *list, gconstpointer data)
     * }
     */
    public static MethodHandle g_list_index$handle() {
        return g_list_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_list_index(GList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_list_index$address() {
        return g_list_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_list_index(GList *list, gconstpointer data)
     * }
     */
    public static int g_list_index(MemorySegment list, MemorySegment data) {
        var mh$ = g_list_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_index", list, data);
            }
            return (int)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_last(GList *list)
     * }
     */
    public static FunctionDescriptor g_list_last$descriptor() {
        return g_list_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_last(GList *list)
     * }
     */
    public static MethodHandle g_list_last$handle() {
        return g_list_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_last(GList *list)
     * }
     */
    public static MemorySegment g_list_last$address() {
        return g_list_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_last(GList *list)
     * }
     */
    public static MemorySegment g_list_last(MemorySegment list) {
        var mh$ = g_list_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_last", list);
            }
            return (MemorySegment)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_first(GList *list)
     * }
     */
    public static FunctionDescriptor g_list_first$descriptor() {
        return g_list_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_first(GList *list)
     * }
     */
    public static MethodHandle g_list_first$handle() {
        return g_list_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_first(GList *list)
     * }
     */
    public static MemorySegment g_list_first$address() {
        return g_list_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_first(GList *list)
     * }
     */
    public static MemorySegment g_list_first(MemorySegment list) {
        var mh$ = g_list_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_first", list);
            }
            return (MemorySegment)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_list_length(GList *list)
     * }
     */
    public static FunctionDescriptor g_list_length$descriptor() {
        return g_list_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_list_length(GList *list)
     * }
     */
    public static MethodHandle g_list_length$handle() {
        return g_list_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_list_length(GList *list)
     * }
     */
    public static MemorySegment g_list_length$address() {
        return g_list_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_list_length(GList *list)
     * }
     */
    public static int g_list_length(MemorySegment list) {
        var mh$ = g_list_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_length", list);
            }
            return (int)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_list_foreach(GList *list, GFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_list_foreach$descriptor() {
        return g_list_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_list_foreach(GList *list, GFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_list_foreach$handle() {
        return g_list_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_list_foreach(GList *list, GFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_list_foreach$address() {
        return g_list_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_list_foreach(GList *list, GFunc func, gpointer user_data)
     * }
     */
    public static void g_list_foreach(MemorySegment list, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_list_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_foreach", list, func, user_data);
            }
            mh$.invokeExact(list, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_sort(GList *list, GCompareFunc compare_func)
     * }
     */
    public static FunctionDescriptor g_list_sort$descriptor() {
        return g_list_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_sort(GList *list, GCompareFunc compare_func)
     * }
     */
    public static MethodHandle g_list_sort$handle() {
        return g_list_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_sort(GList *list, GCompareFunc compare_func)
     * }
     */
    public static MemorySegment g_list_sort$address() {
        return g_list_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_sort(GList *list, GCompareFunc compare_func)
     * }
     */
    public static MemorySegment g_list_sort(MemorySegment list, MemorySegment compare_func) {
        var mh$ = g_list_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_sort", list, compare_func);
            }
            return (MemorySegment)mh$.invokeExact(list, compare_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_sort_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_sort_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_list_sort_with_data(GList *list, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_list_sort_with_data$descriptor() {
        return g_list_sort_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_list_sort_with_data(GList *list, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_list_sort_with_data$handle() {
        return g_list_sort_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_list_sort_with_data(GList *list, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_list_sort_with_data$address() {
        return g_list_sort_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_list_sort_with_data(GList *list, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_list_sort_with_data(MemorySegment list, MemorySegment compare_func, MemorySegment user_data) {
        var mh$ = g_list_sort_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_sort_with_data", list, compare_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(list, compare_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_list_nth_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_list_nth_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_list_nth_data(GList *list, guint n)
     * }
     */
    public static FunctionDescriptor g_list_nth_data$descriptor() {
        return g_list_nth_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_list_nth_data(GList *list, guint n)
     * }
     */
    public static MethodHandle g_list_nth_data$handle() {
        return g_list_nth_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_list_nth_data(GList *list, guint n)
     * }
     */
    public static MemorySegment g_list_nth_data$address() {
        return g_list_nth_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_list_nth_data(GList *list, guint n)
     * }
     */
    public static MemorySegment g_list_nth_data(MemorySegment list, int n) {
        var mh$ = g_list_nth_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_list_nth_data", list, n);
            }
            return (MemorySegment)mh$.invokeExact(list, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_clear_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_clear_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_clear_list(GList **list_ptr, GDestroyNotify destroy)
     * }
     */
    public static FunctionDescriptor g_clear_list$descriptor() {
        return g_clear_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_clear_list(GList **list_ptr, GDestroyNotify destroy)
     * }
     */
    public static MethodHandle g_clear_list$handle() {
        return g_clear_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_clear_list(GList **list_ptr, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_clear_list$address() {
        return g_clear_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_clear_list(GList **list_ptr, GDestroyNotify destroy)
     * }
     */
    public static void g_clear_list(MemorySegment list_ptr, MemorySegment destroy) {
        var mh$ = g_clear_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_clear_list", list_ptr, destroy);
            }
            mh$.invokeExact(list_ptr, destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new(GHashFunc hash_func, GEqualFunc key_equal_func)
     * }
     */
    public static FunctionDescriptor g_hash_table_new$descriptor() {
        return g_hash_table_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new(GHashFunc hash_func, GEqualFunc key_equal_func)
     * }
     */
    public static MethodHandle g_hash_table_new$handle() {
        return g_hash_table_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new(GHashFunc hash_func, GEqualFunc key_equal_func)
     * }
     */
    public static MemorySegment g_hash_table_new$address() {
        return g_hash_table_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new(GHashFunc hash_func, GEqualFunc key_equal_func)
     * }
     */
    public static MemorySegment g_hash_table_new(MemorySegment hash_func, MemorySegment key_equal_func) {
        var mh$ = g_hash_table_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_new", hash_func, key_equal_func);
            }
            return (MemorySegment)mh$.invokeExact(hash_func, key_equal_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_new_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_new_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new_full(GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func)
     * }
     */
    public static FunctionDescriptor g_hash_table_new_full$descriptor() {
        return g_hash_table_new_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new_full(GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func)
     * }
     */
    public static MethodHandle g_hash_table_new_full$handle() {
        return g_hash_table_new_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new_full(GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func)
     * }
     */
    public static MemorySegment g_hash_table_new_full$address() {
        return g_hash_table_new_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new_full(GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func)
     * }
     */
    public static MemorySegment g_hash_table_new_full(MemorySegment hash_func, MemorySegment key_equal_func, MemorySegment key_destroy_func, MemorySegment value_destroy_func) {
        var mh$ = g_hash_table_new_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_new_full", hash_func, key_equal_func, key_destroy_func, value_destroy_func);
            }
            return (MemorySegment)mh$.invokeExact(hash_func, key_equal_func, key_destroy_func, value_destroy_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_new_similar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_new_similar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new_similar(GHashTable *other_hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_new_similar$descriptor() {
        return g_hash_table_new_similar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new_similar(GHashTable *other_hash_table)
     * }
     */
    public static MethodHandle g_hash_table_new_similar$handle() {
        return g_hash_table_new_similar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new_similar(GHashTable *other_hash_table)
     * }
     */
    public static MemorySegment g_hash_table_new_similar$address() {
        return g_hash_table_new_similar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_new_similar(GHashTable *other_hash_table)
     * }
     */
    public static MemorySegment g_hash_table_new_similar(MemorySegment other_hash_table) {
        var mh$ = g_hash_table_new_similar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_new_similar", other_hash_table);
            }
            return (MemorySegment)mh$.invokeExact(other_hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_destroy(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_destroy$descriptor() {
        return g_hash_table_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_destroy(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_destroy$handle() {
        return g_hash_table_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_destroy(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_destroy$address() {
        return g_hash_table_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_destroy(GHashTable *hash_table)
     * }
     */
    public static void g_hash_table_destroy(MemorySegment hash_table) {
        var mh$ = g_hash_table_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_destroy", hash_table);
            }
            mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_insert(GHashTable *hash_table, gpointer key, gpointer value)
     * }
     */
    public static FunctionDescriptor g_hash_table_insert$descriptor() {
        return g_hash_table_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_insert(GHashTable *hash_table, gpointer key, gpointer value)
     * }
     */
    public static MethodHandle g_hash_table_insert$handle() {
        return g_hash_table_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_insert(GHashTable *hash_table, gpointer key, gpointer value)
     * }
     */
    public static MemorySegment g_hash_table_insert$address() {
        return g_hash_table_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_insert(GHashTable *hash_table, gpointer key, gpointer value)
     * }
     */
    public static int g_hash_table_insert(MemorySegment hash_table, MemorySegment key, MemorySegment value) {
        var mh$ = g_hash_table_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_insert", hash_table, key, value);
            }
            return (int)mh$.invokeExact(hash_table, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_replace(GHashTable *hash_table, gpointer key, gpointer value)
     * }
     */
    public static FunctionDescriptor g_hash_table_replace$descriptor() {
        return g_hash_table_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_replace(GHashTable *hash_table, gpointer key, gpointer value)
     * }
     */
    public static MethodHandle g_hash_table_replace$handle() {
        return g_hash_table_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_replace(GHashTable *hash_table, gpointer key, gpointer value)
     * }
     */
    public static MemorySegment g_hash_table_replace$address() {
        return g_hash_table_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_replace(GHashTable *hash_table, gpointer key, gpointer value)
     * }
     */
    public static int g_hash_table_replace(MemorySegment hash_table, MemorySegment key, MemorySegment value) {
        var mh$ = g_hash_table_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_replace", hash_table, key, value);
            }
            return (int)mh$.invokeExact(hash_table, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_add(GHashTable *hash_table, gpointer key)
     * }
     */
    public static FunctionDescriptor g_hash_table_add$descriptor() {
        return g_hash_table_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_add(GHashTable *hash_table, gpointer key)
     * }
     */
    public static MethodHandle g_hash_table_add$handle() {
        return g_hash_table_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_add(GHashTable *hash_table, gpointer key)
     * }
     */
    public static MemorySegment g_hash_table_add$address() {
        return g_hash_table_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_add(GHashTable *hash_table, gpointer key)
     * }
     */
    public static int g_hash_table_add(MemorySegment hash_table, MemorySegment key) {
        var mh$ = g_hash_table_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_add", hash_table, key);
            }
            return (int)mh$.invokeExact(hash_table, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_remove(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_hash_table_remove$descriptor() {
        return g_hash_table_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_remove(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MethodHandle g_hash_table_remove$handle() {
        return g_hash_table_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_remove(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MemorySegment g_hash_table_remove$address() {
        return g_hash_table_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_remove(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static int g_hash_table_remove(MemorySegment hash_table, MemorySegment key) {
        var mh$ = g_hash_table_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_remove", hash_table, key);
            }
            return (int)mh$.invokeExact(hash_table, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_remove_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_remove_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_remove_all(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_remove_all$descriptor() {
        return g_hash_table_remove_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_remove_all(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_remove_all$handle() {
        return g_hash_table_remove_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_remove_all(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_remove_all$address() {
        return g_hash_table_remove_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_remove_all(GHashTable *hash_table)
     * }
     */
    public static void g_hash_table_remove_all(MemorySegment hash_table) {
        var mh$ = g_hash_table_remove_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_remove_all", hash_table);
            }
            mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_steal(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_hash_table_steal$descriptor() {
        return g_hash_table_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_steal(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MethodHandle g_hash_table_steal$handle() {
        return g_hash_table_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_steal(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MemorySegment g_hash_table_steal$address() {
        return g_hash_table_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_steal(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static int g_hash_table_steal(MemorySegment hash_table, MemorySegment key) {
        var mh$ = g_hash_table_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_steal", hash_table, key);
            }
            return (int)mh$.invokeExact(hash_table, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_steal_extended {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_steal_extended");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_steal_extended(GHashTable *hash_table, gconstpointer lookup_key, gpointer *stolen_key, gpointer *stolen_value)
     * }
     */
    public static FunctionDescriptor g_hash_table_steal_extended$descriptor() {
        return g_hash_table_steal_extended.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_steal_extended(GHashTable *hash_table, gconstpointer lookup_key, gpointer *stolen_key, gpointer *stolen_value)
     * }
     */
    public static MethodHandle g_hash_table_steal_extended$handle() {
        return g_hash_table_steal_extended.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_steal_extended(GHashTable *hash_table, gconstpointer lookup_key, gpointer *stolen_key, gpointer *stolen_value)
     * }
     */
    public static MemorySegment g_hash_table_steal_extended$address() {
        return g_hash_table_steal_extended.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_steal_extended(GHashTable *hash_table, gconstpointer lookup_key, gpointer *stolen_key, gpointer *stolen_value)
     * }
     */
    public static int g_hash_table_steal_extended(MemorySegment hash_table, MemorySegment lookup_key, MemorySegment stolen_key, MemorySegment stolen_value) {
        var mh$ = g_hash_table_steal_extended.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_steal_extended", hash_table, lookup_key, stolen_key, stolen_value);
            }
            return (int)mh$.invokeExact(hash_table, lookup_key, stolen_key, stolen_value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_steal_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_steal_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_steal_all(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_steal_all$descriptor() {
        return g_hash_table_steal_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_steal_all(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_steal_all$handle() {
        return g_hash_table_steal_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_steal_all(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_steal_all$address() {
        return g_hash_table_steal_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_steal_all(GHashTable *hash_table)
     * }
     */
    public static void g_hash_table_steal_all(MemorySegment hash_table) {
        var mh$ = g_hash_table_steal_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_steal_all", hash_table);
            }
            mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_steal_all_keys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_steal_all_keys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_steal_all_keys(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_steal_all_keys$descriptor() {
        return g_hash_table_steal_all_keys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_steal_all_keys(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_steal_all_keys$handle() {
        return g_hash_table_steal_all_keys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_steal_all_keys(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_steal_all_keys$address() {
        return g_hash_table_steal_all_keys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_steal_all_keys(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_steal_all_keys(MemorySegment hash_table) {
        var mh$ = g_hash_table_steal_all_keys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_steal_all_keys", hash_table);
            }
            return (MemorySegment)mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_steal_all_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_steal_all_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_steal_all_values(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_steal_all_values$descriptor() {
        return g_hash_table_steal_all_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_steal_all_values(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_steal_all_values$handle() {
        return g_hash_table_steal_all_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_steal_all_values(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_steal_all_values$address() {
        return g_hash_table_steal_all_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_steal_all_values(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_steal_all_values(MemorySegment hash_table) {
        var mh$ = g_hash_table_steal_all_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_steal_all_values", hash_table);
            }
            return (MemorySegment)mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_hash_table_lookup(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_hash_table_lookup$descriptor() {
        return g_hash_table_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_hash_table_lookup(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MethodHandle g_hash_table_lookup$handle() {
        return g_hash_table_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_hash_table_lookup(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MemorySegment g_hash_table_lookup$address() {
        return g_hash_table_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_hash_table_lookup(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MemorySegment g_hash_table_lookup(MemorySegment hash_table, MemorySegment key) {
        var mh$ = g_hash_table_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_lookup", hash_table, key);
            }
            return (MemorySegment)mh$.invokeExact(hash_table, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_contains(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static FunctionDescriptor g_hash_table_contains$descriptor() {
        return g_hash_table_contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_contains(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MethodHandle g_hash_table_contains$handle() {
        return g_hash_table_contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_contains(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static MemorySegment g_hash_table_contains$address() {
        return g_hash_table_contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_contains(GHashTable *hash_table, gconstpointer key)
     * }
     */
    public static int g_hash_table_contains(MemorySegment hash_table, MemorySegment key) {
        var mh$ = g_hash_table_contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_contains", hash_table, key);
            }
            return (int)mh$.invokeExact(hash_table, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_lookup_extended {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_lookup_extended");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value)
     * }
     */
    public static FunctionDescriptor g_hash_table_lookup_extended$descriptor() {
        return g_hash_table_lookup_extended.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value)
     * }
     */
    public static MethodHandle g_hash_table_lookup_extended$handle() {
        return g_hash_table_lookup_extended.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value)
     * }
     */
    public static MemorySegment g_hash_table_lookup_extended$address() {
        return g_hash_table_lookup_extended.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value)
     * }
     */
    public static int g_hash_table_lookup_extended(MemorySegment hash_table, MemorySegment lookup_key, MemorySegment orig_key, MemorySegment value) {
        var mh$ = g_hash_table_lookup_extended.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_lookup_extended", hash_table, lookup_key, orig_key, value);
            }
            return (int)mh$.invokeExact(hash_table, lookup_key, orig_key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_foreach(GHashTable *hash_table, GHFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_hash_table_foreach$descriptor() {
        return g_hash_table_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_foreach(GHashTable *hash_table, GHFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_hash_table_foreach$handle() {
        return g_hash_table_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_foreach(GHashTable *hash_table, GHFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_hash_table_foreach$address() {
        return g_hash_table_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_foreach(GHashTable *hash_table, GHFunc func, gpointer user_data)
     * }
     */
    public static void g_hash_table_foreach(MemorySegment hash_table, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_hash_table_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_foreach", hash_table, func, user_data);
            }
            mh$.invokeExact(hash_table, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_hash_table_find(GHashTable *hash_table, GHRFunc predicate, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_hash_table_find$descriptor() {
        return g_hash_table_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_hash_table_find(GHashTable *hash_table, GHRFunc predicate, gpointer user_data)
     * }
     */
    public static MethodHandle g_hash_table_find$handle() {
        return g_hash_table_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_hash_table_find(GHashTable *hash_table, GHRFunc predicate, gpointer user_data)
     * }
     */
    public static MemorySegment g_hash_table_find$address() {
        return g_hash_table_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_hash_table_find(GHashTable *hash_table, GHRFunc predicate, gpointer user_data)
     * }
     */
    public static MemorySegment g_hash_table_find(MemorySegment hash_table, MemorySegment predicate, MemorySegment user_data) {
        var mh$ = g_hash_table_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_find", hash_table, predicate, user_data);
            }
            return (MemorySegment)mh$.invokeExact(hash_table, predicate, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_foreach_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_foreach_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_hash_table_foreach_remove(GHashTable *hash_table, GHRFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_hash_table_foreach_remove$descriptor() {
        return g_hash_table_foreach_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_hash_table_foreach_remove(GHashTable *hash_table, GHRFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_hash_table_foreach_remove$handle() {
        return g_hash_table_foreach_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_hash_table_foreach_remove(GHashTable *hash_table, GHRFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_hash_table_foreach_remove$address() {
        return g_hash_table_foreach_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_hash_table_foreach_remove(GHashTable *hash_table, GHRFunc func, gpointer user_data)
     * }
     */
    public static int g_hash_table_foreach_remove(MemorySegment hash_table, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_hash_table_foreach_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_foreach_remove", hash_table, func, user_data);
            }
            return (int)mh$.invokeExact(hash_table, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_foreach_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_foreach_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_hash_table_foreach_steal(GHashTable *hash_table, GHRFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_hash_table_foreach_steal$descriptor() {
        return g_hash_table_foreach_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_hash_table_foreach_steal(GHashTable *hash_table, GHRFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_hash_table_foreach_steal$handle() {
        return g_hash_table_foreach_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_hash_table_foreach_steal(GHashTable *hash_table, GHRFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_hash_table_foreach_steal$address() {
        return g_hash_table_foreach_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_hash_table_foreach_steal(GHashTable *hash_table, GHRFunc func, gpointer user_data)
     * }
     */
    public static int g_hash_table_foreach_steal(MemorySegment hash_table, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_hash_table_foreach_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_foreach_steal", hash_table, func, user_data);
            }
            return (int)mh$.invokeExact(hash_table, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_hash_table_size(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_size$descriptor() {
        return g_hash_table_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_hash_table_size(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_size$handle() {
        return g_hash_table_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_hash_table_size(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_size$address() {
        return g_hash_table_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_hash_table_size(GHashTable *hash_table)
     * }
     */
    public static int g_hash_table_size(MemorySegment hash_table) {
        var mh$ = g_hash_table_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_size", hash_table);
            }
            return (int)mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_get_keys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_get_keys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_hash_table_get_keys(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_get_keys$descriptor() {
        return g_hash_table_get_keys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_hash_table_get_keys(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_get_keys$handle() {
        return g_hash_table_get_keys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_hash_table_get_keys(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_get_keys$address() {
        return g_hash_table_get_keys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_hash_table_get_keys(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_get_keys(MemorySegment hash_table) {
        var mh$ = g_hash_table_get_keys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_get_keys", hash_table);
            }
            return (MemorySegment)mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_get_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_get_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_hash_table_get_values(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_get_values$descriptor() {
        return g_hash_table_get_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_hash_table_get_values(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_get_values$handle() {
        return g_hash_table_get_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_hash_table_get_values(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_get_values$address() {
        return g_hash_table_get_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_hash_table_get_values(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_get_values(MemorySegment hash_table) {
        var mh$ = g_hash_table_get_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_get_values", hash_table);
            }
            return (MemorySegment)mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_get_keys_as_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_get_keys_as_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table, guint *length)
     * }
     */
    public static FunctionDescriptor g_hash_table_get_keys_as_array$descriptor() {
        return g_hash_table_get_keys_as_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table, guint *length)
     * }
     */
    public static MethodHandle g_hash_table_get_keys_as_array$handle() {
        return g_hash_table_get_keys_as_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table, guint *length)
     * }
     */
    public static MemorySegment g_hash_table_get_keys_as_array$address() {
        return g_hash_table_get_keys_as_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table, guint *length)
     * }
     */
    public static MemorySegment g_hash_table_get_keys_as_array(MemorySegment hash_table, MemorySegment length) {
        var mh$ = g_hash_table_get_keys_as_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_get_keys_as_array", hash_table, length);
            }
            return (MemorySegment)mh$.invokeExact(hash_table, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_get_keys_as_ptr_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_get_keys_as_ptr_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_get_keys_as_ptr_array(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_get_keys_as_ptr_array$descriptor() {
        return g_hash_table_get_keys_as_ptr_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_get_keys_as_ptr_array(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_get_keys_as_ptr_array$handle() {
        return g_hash_table_get_keys_as_ptr_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_get_keys_as_ptr_array(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_get_keys_as_ptr_array$address() {
        return g_hash_table_get_keys_as_ptr_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_get_keys_as_ptr_array(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_get_keys_as_ptr_array(MemorySegment hash_table) {
        var mh$ = g_hash_table_get_keys_as_ptr_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_get_keys_as_ptr_array", hash_table);
            }
            return (MemorySegment)mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_get_values_as_ptr_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_get_values_as_ptr_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_get_values_as_ptr_array(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_get_values_as_ptr_array$descriptor() {
        return g_hash_table_get_values_as_ptr_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_get_values_as_ptr_array(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_get_values_as_ptr_array$handle() {
        return g_hash_table_get_values_as_ptr_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_get_values_as_ptr_array(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_get_values_as_ptr_array$address() {
        return g_hash_table_get_values_as_ptr_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPtrArray *g_hash_table_get_values_as_ptr_array(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_get_values_as_ptr_array(MemorySegment hash_table) {
        var mh$ = g_hash_table_get_values_as_ptr_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_get_values_as_ptr_array", hash_table);
            }
            return (MemorySegment)mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_iter_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_iter_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_init(GHashTableIter *iter, GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_iter_init$descriptor() {
        return g_hash_table_iter_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_init(GHashTableIter *iter, GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_iter_init$handle() {
        return g_hash_table_iter_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_init(GHashTableIter *iter, GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_iter_init$address() {
        return g_hash_table_iter_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_iter_init(GHashTableIter *iter, GHashTable *hash_table)
     * }
     */
    public static void g_hash_table_iter_init(MemorySegment iter, MemorySegment hash_table) {
        var mh$ = g_hash_table_iter_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_iter_init", iter, hash_table);
            }
            mh$.invokeExact(iter, hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_iter_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_iter_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_iter_next(GHashTableIter *iter, gpointer *key, gpointer *value)
     * }
     */
    public static FunctionDescriptor g_hash_table_iter_next$descriptor() {
        return g_hash_table_iter_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_iter_next(GHashTableIter *iter, gpointer *key, gpointer *value)
     * }
     */
    public static MethodHandle g_hash_table_iter_next$handle() {
        return g_hash_table_iter_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hash_table_iter_next(GHashTableIter *iter, gpointer *key, gpointer *value)
     * }
     */
    public static MemorySegment g_hash_table_iter_next$address() {
        return g_hash_table_iter_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hash_table_iter_next(GHashTableIter *iter, gpointer *key, gpointer *value)
     * }
     */
    public static int g_hash_table_iter_next(MemorySegment iter, MemorySegment key, MemorySegment value) {
        var mh$ = g_hash_table_iter_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_iter_next", iter, key, value);
            }
            return (int)mh$.invokeExact(iter, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_iter_get_hash_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_iter_get_hash_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter)
     * }
     */
    public static FunctionDescriptor g_hash_table_iter_get_hash_table$descriptor() {
        return g_hash_table_iter_get_hash_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter)
     * }
     */
    public static MethodHandle g_hash_table_iter_get_hash_table$handle() {
        return g_hash_table_iter_get_hash_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter)
     * }
     */
    public static MemorySegment g_hash_table_iter_get_hash_table$address() {
        return g_hash_table_iter_get_hash_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter)
     * }
     */
    public static MemorySegment g_hash_table_iter_get_hash_table(MemorySegment iter) {
        var mh$ = g_hash_table_iter_get_hash_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_iter_get_hash_table", iter);
            }
            return (MemorySegment)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_iter_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_iter_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_remove(GHashTableIter *iter)
     * }
     */
    public static FunctionDescriptor g_hash_table_iter_remove$descriptor() {
        return g_hash_table_iter_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_remove(GHashTableIter *iter)
     * }
     */
    public static MethodHandle g_hash_table_iter_remove$handle() {
        return g_hash_table_iter_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_remove(GHashTableIter *iter)
     * }
     */
    public static MemorySegment g_hash_table_iter_remove$address() {
        return g_hash_table_iter_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_iter_remove(GHashTableIter *iter)
     * }
     */
    public static void g_hash_table_iter_remove(MemorySegment iter) {
        var mh$ = g_hash_table_iter_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_iter_remove", iter);
            }
            mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_iter_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_iter_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_replace(GHashTableIter *iter, gpointer value)
     * }
     */
    public static FunctionDescriptor g_hash_table_iter_replace$descriptor() {
        return g_hash_table_iter_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_replace(GHashTableIter *iter, gpointer value)
     * }
     */
    public static MethodHandle g_hash_table_iter_replace$handle() {
        return g_hash_table_iter_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_replace(GHashTableIter *iter, gpointer value)
     * }
     */
    public static MemorySegment g_hash_table_iter_replace$address() {
        return g_hash_table_iter_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_iter_replace(GHashTableIter *iter, gpointer value)
     * }
     */
    public static void g_hash_table_iter_replace(MemorySegment iter, MemorySegment value) {
        var mh$ = g_hash_table_iter_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_iter_replace", iter, value);
            }
            mh$.invokeExact(iter, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_iter_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_iter_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_steal(GHashTableIter *iter)
     * }
     */
    public static FunctionDescriptor g_hash_table_iter_steal$descriptor() {
        return g_hash_table_iter_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_steal(GHashTableIter *iter)
     * }
     */
    public static MethodHandle g_hash_table_iter_steal$handle() {
        return g_hash_table_iter_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_iter_steal(GHashTableIter *iter)
     * }
     */
    public static MemorySegment g_hash_table_iter_steal$address() {
        return g_hash_table_iter_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_iter_steal(GHashTableIter *iter)
     * }
     */
    public static void g_hash_table_iter_steal(MemorySegment iter) {
        var mh$ = g_hash_table_iter_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_iter_steal", iter);
            }
            mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_ref(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_ref$descriptor() {
        return g_hash_table_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_ref(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_ref$handle() {
        return g_hash_table_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_ref(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_ref$address() {
        return g_hash_table_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHashTable *g_hash_table_ref(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_ref(MemorySegment hash_table) {
        var mh$ = g_hash_table_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_ref", hash_table);
            }
            return (MemorySegment)mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hash_table_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hash_table_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hash_table_unref(GHashTable *hash_table)
     * }
     */
    public static FunctionDescriptor g_hash_table_unref$descriptor() {
        return g_hash_table_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hash_table_unref(GHashTable *hash_table)
     * }
     */
    public static MethodHandle g_hash_table_unref$handle() {
        return g_hash_table_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hash_table_unref(GHashTable *hash_table)
     * }
     */
    public static MemorySegment g_hash_table_unref$address() {
        return g_hash_table_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hash_table_unref(GHashTable *hash_table)
     * }
     */
    public static void g_hash_table_unref(MemorySegment hash_table) {
        var mh$ = g_hash_table_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hash_table_unref", hash_table);
            }
            mh$.invokeExact(hash_table);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_str_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_str_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_str_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static FunctionDescriptor g_str_equal$descriptor() {
        return g_str_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_str_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MethodHandle g_str_equal$handle() {
        return g_str_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_str_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MemorySegment g_str_equal$address() {
        return g_str_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_str_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static int g_str_equal(MemorySegment v1, MemorySegment v2) {
        var mh$ = g_str_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_str_equal", v1, v2);
            }
            return (int)mh$.invokeExact(v1, v2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_str_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_str_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_str_hash(gconstpointer v)
     * }
     */
    public static FunctionDescriptor g_str_hash$descriptor() {
        return g_str_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_str_hash(gconstpointer v)
     * }
     */
    public static MethodHandle g_str_hash$handle() {
        return g_str_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_str_hash(gconstpointer v)
     * }
     */
    public static MemorySegment g_str_hash$address() {
        return g_str_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_str_hash(gconstpointer v)
     * }
     */
    public static int g_str_hash(MemorySegment v) {
        var mh$ = g_str_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_str_hash", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_int_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_int_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_int_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static FunctionDescriptor g_int_equal$descriptor() {
        return g_int_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_int_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MethodHandle g_int_equal$handle() {
        return g_int_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_int_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MemorySegment g_int_equal$address() {
        return g_int_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_int_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static int g_int_equal(MemorySegment v1, MemorySegment v2) {
        var mh$ = g_int_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_int_equal", v1, v2);
            }
            return (int)mh$.invokeExact(v1, v2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_int_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_int_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_int_hash(gconstpointer v)
     * }
     */
    public static FunctionDescriptor g_int_hash$descriptor() {
        return g_int_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_int_hash(gconstpointer v)
     * }
     */
    public static MethodHandle g_int_hash$handle() {
        return g_int_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_int_hash(gconstpointer v)
     * }
     */
    public static MemorySegment g_int_hash$address() {
        return g_int_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_int_hash(gconstpointer v)
     * }
     */
    public static int g_int_hash(MemorySegment v) {
        var mh$ = g_int_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_int_hash", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_int64_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_int64_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_int64_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static FunctionDescriptor g_int64_equal$descriptor() {
        return g_int64_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_int64_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MethodHandle g_int64_equal$handle() {
        return g_int64_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_int64_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MemorySegment g_int64_equal$address() {
        return g_int64_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_int64_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static int g_int64_equal(MemorySegment v1, MemorySegment v2) {
        var mh$ = g_int64_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_int64_equal", v1, v2);
            }
            return (int)mh$.invokeExact(v1, v2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_int64_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_int64_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_int64_hash(gconstpointer v)
     * }
     */
    public static FunctionDescriptor g_int64_hash$descriptor() {
        return g_int64_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_int64_hash(gconstpointer v)
     * }
     */
    public static MethodHandle g_int64_hash$handle() {
        return g_int64_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_int64_hash(gconstpointer v)
     * }
     */
    public static MemorySegment g_int64_hash$address() {
        return g_int64_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_int64_hash(gconstpointer v)
     * }
     */
    public static int g_int64_hash(MemorySegment v) {
        var mh$ = g_int64_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_int64_hash", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_double_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_double_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_double_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static FunctionDescriptor g_double_equal$descriptor() {
        return g_double_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_double_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MethodHandle g_double_equal$handle() {
        return g_double_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_double_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MemorySegment g_double_equal$address() {
        return g_double_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_double_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static int g_double_equal(MemorySegment v1, MemorySegment v2) {
        var mh$ = g_double_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_double_equal", v1, v2);
            }
            return (int)mh$.invokeExact(v1, v2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_double_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_double_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_double_hash(gconstpointer v)
     * }
     */
    public static FunctionDescriptor g_double_hash$descriptor() {
        return g_double_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_double_hash(gconstpointer v)
     * }
     */
    public static MethodHandle g_double_hash$handle() {
        return g_double_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_double_hash(gconstpointer v)
     * }
     */
    public static MemorySegment g_double_hash$address() {
        return g_double_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_double_hash(gconstpointer v)
     * }
     */
    public static int g_double_hash(MemorySegment v) {
        var mh$ = g_double_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_double_hash", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_direct_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_direct_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_direct_hash(gconstpointer v)
     * }
     */
    public static FunctionDescriptor g_direct_hash$descriptor() {
        return g_direct_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_direct_hash(gconstpointer v)
     * }
     */
    public static MethodHandle g_direct_hash$handle() {
        return g_direct_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_direct_hash(gconstpointer v)
     * }
     */
    public static MemorySegment g_direct_hash$address() {
        return g_direct_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_direct_hash(gconstpointer v)
     * }
     */
    public static int g_direct_hash(MemorySegment v) {
        var mh$ = g_direct_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_direct_hash", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_direct_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_direct_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_direct_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static FunctionDescriptor g_direct_equal$descriptor() {
        return g_direct_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_direct_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MethodHandle g_direct_equal$handle() {
        return g_direct_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_direct_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MemorySegment g_direct_equal$address() {
        return g_direct_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_direct_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static int g_direct_equal(MemorySegment v1, MemorySegment v2) {
        var mh$ = g_direct_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_direct_equal", v1, v2);
            }
            return (int)mh$.invokeExact(v1, v2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hmac_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hmac_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_new(GChecksumType digest_type, const guchar *key, gsize key_len)
     * }
     */
    public static FunctionDescriptor g_hmac_new$descriptor() {
        return g_hmac_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_new(GChecksumType digest_type, const guchar *key, gsize key_len)
     * }
     */
    public static MethodHandle g_hmac_new$handle() {
        return g_hmac_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_new(GChecksumType digest_type, const guchar *key, gsize key_len)
     * }
     */
    public static MemorySegment g_hmac_new$address() {
        return g_hmac_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHmac *g_hmac_new(GChecksumType digest_type, const guchar *key, gsize key_len)
     * }
     */
    public static MemorySegment g_hmac_new(int digest_type, MemorySegment key, long key_len) {
        var mh$ = g_hmac_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hmac_new", digest_type, key, key_len);
            }
            return (MemorySegment)mh$.invokeExact(digest_type, key, key_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hmac_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hmac_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_copy(const GHmac *hmac)
     * }
     */
    public static FunctionDescriptor g_hmac_copy$descriptor() {
        return g_hmac_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_copy(const GHmac *hmac)
     * }
     */
    public static MethodHandle g_hmac_copy$handle() {
        return g_hmac_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_copy(const GHmac *hmac)
     * }
     */
    public static MemorySegment g_hmac_copy$address() {
        return g_hmac_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHmac *g_hmac_copy(const GHmac *hmac)
     * }
     */
    public static MemorySegment g_hmac_copy(MemorySegment hmac) {
        var mh$ = g_hmac_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hmac_copy", hmac);
            }
            return (MemorySegment)mh$.invokeExact(hmac);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hmac_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hmac_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_ref(GHmac *hmac)
     * }
     */
    public static FunctionDescriptor g_hmac_ref$descriptor() {
        return g_hmac_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_ref(GHmac *hmac)
     * }
     */
    public static MethodHandle g_hmac_ref$handle() {
        return g_hmac_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHmac *g_hmac_ref(GHmac *hmac)
     * }
     */
    public static MemorySegment g_hmac_ref$address() {
        return g_hmac_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHmac *g_hmac_ref(GHmac *hmac)
     * }
     */
    public static MemorySegment g_hmac_ref(MemorySegment hmac) {
        var mh$ = g_hmac_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hmac_ref", hmac);
            }
            return (MemorySegment)mh$.invokeExact(hmac);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hmac_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hmac_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hmac_unref(GHmac *hmac)
     * }
     */
    public static FunctionDescriptor g_hmac_unref$descriptor() {
        return g_hmac_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hmac_unref(GHmac *hmac)
     * }
     */
    public static MethodHandle g_hmac_unref$handle() {
        return g_hmac_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hmac_unref(GHmac *hmac)
     * }
     */
    public static MemorySegment g_hmac_unref$address() {
        return g_hmac_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hmac_unref(GHmac *hmac)
     * }
     */
    public static void g_hmac_unref(MemorySegment hmac) {
        var mh$ = g_hmac_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hmac_unref", hmac);
            }
            mh$.invokeExact(hmac);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hmac_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hmac_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hmac_update(GHmac *hmac, const guchar *data, gssize length)
     * }
     */
    public static FunctionDescriptor g_hmac_update$descriptor() {
        return g_hmac_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hmac_update(GHmac *hmac, const guchar *data, gssize length)
     * }
     */
    public static MethodHandle g_hmac_update$handle() {
        return g_hmac_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hmac_update(GHmac *hmac, const guchar *data, gssize length)
     * }
     */
    public static MemorySegment g_hmac_update$address() {
        return g_hmac_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hmac_update(GHmac *hmac, const guchar *data, gssize length)
     * }
     */
    public static void g_hmac_update(MemorySegment hmac, MemorySegment data, long length) {
        var mh$ = g_hmac_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hmac_update", hmac, data, length);
            }
            mh$.invokeExact(hmac, data, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hmac_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hmac_get_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_hmac_get_string(GHmac *hmac)
     * }
     */
    public static FunctionDescriptor g_hmac_get_string$descriptor() {
        return g_hmac_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_hmac_get_string(GHmac *hmac)
     * }
     */
    public static MethodHandle g_hmac_get_string$handle() {
        return g_hmac_get_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_hmac_get_string(GHmac *hmac)
     * }
     */
    public static MemorySegment g_hmac_get_string$address() {
        return g_hmac_get_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_hmac_get_string(GHmac *hmac)
     * }
     */
    public static MemorySegment g_hmac_get_string(MemorySegment hmac) {
        var mh$ = g_hmac_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hmac_get_string", hmac);
            }
            return (MemorySegment)mh$.invokeExact(hmac);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hmac_get_digest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hmac_get_digest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hmac_get_digest(GHmac *hmac, guint8 *buffer, gsize *digest_len)
     * }
     */
    public static FunctionDescriptor g_hmac_get_digest$descriptor() {
        return g_hmac_get_digest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hmac_get_digest(GHmac *hmac, guint8 *buffer, gsize *digest_len)
     * }
     */
    public static MethodHandle g_hmac_get_digest$handle() {
        return g_hmac_get_digest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hmac_get_digest(GHmac *hmac, guint8 *buffer, gsize *digest_len)
     * }
     */
    public static MemorySegment g_hmac_get_digest$address() {
        return g_hmac_get_digest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hmac_get_digest(GHmac *hmac, guint8 *buffer, gsize *digest_len)
     * }
     */
    public static void g_hmac_get_digest(MemorySegment hmac, MemorySegment buffer, MemorySegment digest_len) {
        var mh$ = g_hmac_get_digest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hmac_get_digest", hmac, buffer, digest_len);
            }
            mh$.invokeExact(hmac, buffer, digest_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_compute_hmac_for_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_compute_hmac_for_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_data(GChecksumType digest_type, const guchar *key, gsize key_len, const guchar *data, gsize length)
     * }
     */
    public static FunctionDescriptor g_compute_hmac_for_data$descriptor() {
        return g_compute_hmac_for_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_data(GChecksumType digest_type, const guchar *key, gsize key_len, const guchar *data, gsize length)
     * }
     */
    public static MethodHandle g_compute_hmac_for_data$handle() {
        return g_compute_hmac_for_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_data(GChecksumType digest_type, const guchar *key, gsize key_len, const guchar *data, gsize length)
     * }
     */
    public static MemorySegment g_compute_hmac_for_data$address() {
        return g_compute_hmac_for_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_data(GChecksumType digest_type, const guchar *key, gsize key_len, const guchar *data, gsize length)
     * }
     */
    public static MemorySegment g_compute_hmac_for_data(int digest_type, MemorySegment key, long key_len, MemorySegment data, long length) {
        var mh$ = g_compute_hmac_for_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_compute_hmac_for_data", digest_type, key, key_len, data, length);
            }
            return (MemorySegment)mh$.invokeExact(digest_type, key, key_len, data, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_compute_hmac_for_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_compute_hmac_for_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_string(GChecksumType digest_type, const guchar *key, gsize key_len, const gchar *str, gssize length)
     * }
     */
    public static FunctionDescriptor g_compute_hmac_for_string$descriptor() {
        return g_compute_hmac_for_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_string(GChecksumType digest_type, const guchar *key, gsize key_len, const gchar *str, gssize length)
     * }
     */
    public static MethodHandle g_compute_hmac_for_string$handle() {
        return g_compute_hmac_for_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_string(GChecksumType digest_type, const guchar *key, gsize key_len, const gchar *str, gssize length)
     * }
     */
    public static MemorySegment g_compute_hmac_for_string$address() {
        return g_compute_hmac_for_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_string(GChecksumType digest_type, const guchar *key, gsize key_len, const gchar *str, gssize length)
     * }
     */
    public static MemorySegment g_compute_hmac_for_string(int digest_type, MemorySegment key, long key_len, MemorySegment str, long length) {
        var mh$ = g_compute_hmac_for_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_compute_hmac_for_string", digest_type, key, key_len, str, length);
            }
            return (MemorySegment)mh$.invokeExact(digest_type, key, key_len, str, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_compute_hmac_for_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_compute_hmac_for_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type, GBytes *key, GBytes *data)
     * }
     */
    public static FunctionDescriptor g_compute_hmac_for_bytes$descriptor() {
        return g_compute_hmac_for_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type, GBytes *key, GBytes *data)
     * }
     */
    public static MethodHandle g_compute_hmac_for_bytes$handle() {
        return g_compute_hmac_for_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type, GBytes *key, GBytes *data)
     * }
     */
    public static MemorySegment g_compute_hmac_for_bytes$address() {
        return g_compute_hmac_for_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type, GBytes *key, GBytes *data)
     * }
     */
    public static MemorySegment g_compute_hmac_for_bytes(int digest_type, MemorySegment key, MemorySegment data) {
        var mh$ = g_compute_hmac_for_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_compute_hmac_for_bytes", digest_type, key, data);
            }
            return (MemorySegment)mh$.invokeExact(digest_type, key, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_HOOK_FLAG_ACTIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_HOOK_FLAG_ACTIVE = 1
     * }
     */
    public static int G_HOOK_FLAG_ACTIVE() {
        return G_HOOK_FLAG_ACTIVE;
    }
    private static final int G_HOOK_FLAG_IN_CALL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_HOOK_FLAG_IN_CALL = 2
     * }
     */
    public static int G_HOOK_FLAG_IN_CALL() {
        return G_HOOK_FLAG_IN_CALL;
    }
    private static final int G_HOOK_FLAG_MASK = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_HOOK_FLAG_MASK = 15
     * }
     */
    public static int G_HOOK_FLAG_MASK() {
        return G_HOOK_FLAG_MASK;
    }

    private static class g_hook_list_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_list_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_list_init(GHookList *hook_list, guint hook_size)
     * }
     */
    public static FunctionDescriptor g_hook_list_init$descriptor() {
        return g_hook_list_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_list_init(GHookList *hook_list, guint hook_size)
     * }
     */
    public static MethodHandle g_hook_list_init$handle() {
        return g_hook_list_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_list_init(GHookList *hook_list, guint hook_size)
     * }
     */
    public static MemorySegment g_hook_list_init$address() {
        return g_hook_list_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_list_init(GHookList *hook_list, guint hook_size)
     * }
     */
    public static void g_hook_list_init(MemorySegment hook_list, int hook_size) {
        var mh$ = g_hook_list_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_list_init", hook_list, hook_size);
            }
            mh$.invokeExact(hook_list, hook_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_list_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_list_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_list_clear(GHookList *hook_list)
     * }
     */
    public static FunctionDescriptor g_hook_list_clear$descriptor() {
        return g_hook_list_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_list_clear(GHookList *hook_list)
     * }
     */
    public static MethodHandle g_hook_list_clear$handle() {
        return g_hook_list_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_list_clear(GHookList *hook_list)
     * }
     */
    public static MemorySegment g_hook_list_clear$address() {
        return g_hook_list_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_list_clear(GHookList *hook_list)
     * }
     */
    public static void g_hook_list_clear(MemorySegment hook_list) {
        var mh$ = g_hook_list_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_list_clear", hook_list);
            }
            mh$.invokeExact(hook_list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_alloc(GHookList *hook_list)
     * }
     */
    public static FunctionDescriptor g_hook_alloc$descriptor() {
        return g_hook_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_alloc(GHookList *hook_list)
     * }
     */
    public static MethodHandle g_hook_alloc$handle() {
        return g_hook_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_alloc(GHookList *hook_list)
     * }
     */
    public static MemorySegment g_hook_alloc$address() {
        return g_hook_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_alloc(GHookList *hook_list)
     * }
     */
    public static MemorySegment g_hook_alloc(MemorySegment hook_list) {
        var mh$ = g_hook_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_alloc", hook_list);
            }
            return (MemorySegment)mh$.invokeExact(hook_list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_free(GHookList *hook_list, GHook *hook)
     * }
     */
    public static FunctionDescriptor g_hook_free$descriptor() {
        return g_hook_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_free(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MethodHandle g_hook_free$handle() {
        return g_hook_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_free(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MemorySegment g_hook_free$address() {
        return g_hook_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_free(GHookList *hook_list, GHook *hook)
     * }
     */
    public static void g_hook_free(MemorySegment hook_list, MemorySegment hook) {
        var mh$ = g_hook_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_free", hook_list, hook);
            }
            mh$.invokeExact(hook_list, hook);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_ref(GHookList *hook_list, GHook *hook)
     * }
     */
    public static FunctionDescriptor g_hook_ref$descriptor() {
        return g_hook_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_ref(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MethodHandle g_hook_ref$handle() {
        return g_hook_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_ref(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MemorySegment g_hook_ref$address() {
        return g_hook_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_ref(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MemorySegment g_hook_ref(MemorySegment hook_list, MemorySegment hook) {
        var mh$ = g_hook_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_ref", hook_list, hook);
            }
            return (MemorySegment)mh$.invokeExact(hook_list, hook);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_unref(GHookList *hook_list, GHook *hook)
     * }
     */
    public static FunctionDescriptor g_hook_unref$descriptor() {
        return g_hook_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_unref(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MethodHandle g_hook_unref$handle() {
        return g_hook_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_unref(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MemorySegment g_hook_unref$address() {
        return g_hook_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_unref(GHookList *hook_list, GHook *hook)
     * }
     */
    public static void g_hook_unref(MemorySegment hook_list, MemorySegment hook) {
        var mh$ = g_hook_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_unref", hook_list, hook);
            }
            mh$.invokeExact(hook_list, hook);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hook_destroy(GHookList *hook_list, gulong hook_id)
     * }
     */
    public static FunctionDescriptor g_hook_destroy$descriptor() {
        return g_hook_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hook_destroy(GHookList *hook_list, gulong hook_id)
     * }
     */
    public static MethodHandle g_hook_destroy$handle() {
        return g_hook_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hook_destroy(GHookList *hook_list, gulong hook_id)
     * }
     */
    public static MemorySegment g_hook_destroy$address() {
        return g_hook_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hook_destroy(GHookList *hook_list, gulong hook_id)
     * }
     */
    public static int g_hook_destroy(MemorySegment hook_list, int hook_id) {
        var mh$ = g_hook_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_destroy", hook_list, hook_id);
            }
            return (int)mh$.invokeExact(hook_list, hook_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_destroy_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_destroy_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_destroy_link(GHookList *hook_list, GHook *hook)
     * }
     */
    public static FunctionDescriptor g_hook_destroy_link$descriptor() {
        return g_hook_destroy_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_destroy_link(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MethodHandle g_hook_destroy_link$handle() {
        return g_hook_destroy_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_destroy_link(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MemorySegment g_hook_destroy_link$address() {
        return g_hook_destroy_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_destroy_link(GHookList *hook_list, GHook *hook)
     * }
     */
    public static void g_hook_destroy_link(MemorySegment hook_list, MemorySegment hook) {
        var mh$ = g_hook_destroy_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_destroy_link", hook_list, hook);
            }
            mh$.invokeExact(hook_list, hook);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_prepend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_prepend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_prepend(GHookList *hook_list, GHook *hook)
     * }
     */
    public static FunctionDescriptor g_hook_prepend$descriptor() {
        return g_hook_prepend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_prepend(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MethodHandle g_hook_prepend$handle() {
        return g_hook_prepend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_prepend(GHookList *hook_list, GHook *hook)
     * }
     */
    public static MemorySegment g_hook_prepend$address() {
        return g_hook_prepend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_prepend(GHookList *hook_list, GHook *hook)
     * }
     */
    public static void g_hook_prepend(MemorySegment hook_list, MemorySegment hook) {
        var mh$ = g_hook_prepend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_prepend", hook_list, hook);
            }
            mh$.invokeExact(hook_list, hook);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_insert_before {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_insert_before");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_insert_before(GHookList *hook_list, GHook *sibling, GHook *hook)
     * }
     */
    public static FunctionDescriptor g_hook_insert_before$descriptor() {
        return g_hook_insert_before.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_insert_before(GHookList *hook_list, GHook *sibling, GHook *hook)
     * }
     */
    public static MethodHandle g_hook_insert_before$handle() {
        return g_hook_insert_before.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_insert_before(GHookList *hook_list, GHook *sibling, GHook *hook)
     * }
     */
    public static MemorySegment g_hook_insert_before$address() {
        return g_hook_insert_before.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_insert_before(GHookList *hook_list, GHook *sibling, GHook *hook)
     * }
     */
    public static void g_hook_insert_before(MemorySegment hook_list, MemorySegment sibling, MemorySegment hook) {
        var mh$ = g_hook_insert_before.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_insert_before", hook_list, sibling, hook);
            }
            mh$.invokeExact(hook_list, sibling, hook);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_insert_sorted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_insert_sorted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_insert_sorted(GHookList *hook_list, GHook *hook, GHookCompareFunc func)
     * }
     */
    public static FunctionDescriptor g_hook_insert_sorted$descriptor() {
        return g_hook_insert_sorted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_insert_sorted(GHookList *hook_list, GHook *hook, GHookCompareFunc func)
     * }
     */
    public static MethodHandle g_hook_insert_sorted$handle() {
        return g_hook_insert_sorted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_insert_sorted(GHookList *hook_list, GHook *hook, GHookCompareFunc func)
     * }
     */
    public static MemorySegment g_hook_insert_sorted$address() {
        return g_hook_insert_sorted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_insert_sorted(GHookList *hook_list, GHook *hook, GHookCompareFunc func)
     * }
     */
    public static void g_hook_insert_sorted(MemorySegment hook_list, MemorySegment hook, MemorySegment func) {
        var mh$ = g_hook_insert_sorted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_insert_sorted", hook_list, hook, func);
            }
            mh$.invokeExact(hook_list, hook, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_get(GHookList *hook_list, gulong hook_id)
     * }
     */
    public static FunctionDescriptor g_hook_get$descriptor() {
        return g_hook_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_get(GHookList *hook_list, gulong hook_id)
     * }
     */
    public static MethodHandle g_hook_get$handle() {
        return g_hook_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_get(GHookList *hook_list, gulong hook_id)
     * }
     */
    public static MemorySegment g_hook_get$address() {
        return g_hook_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_get(GHookList *hook_list, gulong hook_id)
     * }
     */
    public static MemorySegment g_hook_get(MemorySegment hook_list, int hook_id) {
        var mh$ = g_hook_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_get", hook_list, hook_id);
            }
            return (MemorySegment)mh$.invokeExact(hook_list, hook_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find(GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_hook_find$descriptor() {
        return g_hook_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find(GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data)
     * }
     */
    public static MethodHandle g_hook_find$handle() {
        return g_hook_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find(GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data)
     * }
     */
    public static MemorySegment g_hook_find$address() {
        return g_hook_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_find(GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data)
     * }
     */
    public static MemorySegment g_hook_find(MemorySegment hook_list, int need_valids, MemorySegment func, MemorySegment data) {
        var mh$ = g_hook_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_find", hook_list, need_valids, func, data);
            }
            return (MemorySegment)mh$.invokeExact(hook_list, need_valids, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_find_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_find_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_data(GHookList *hook_list, gboolean need_valids, gpointer data)
     * }
     */
    public static FunctionDescriptor g_hook_find_data$descriptor() {
        return g_hook_find_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_data(GHookList *hook_list, gboolean need_valids, gpointer data)
     * }
     */
    public static MethodHandle g_hook_find_data$handle() {
        return g_hook_find_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_data(GHookList *hook_list, gboolean need_valids, gpointer data)
     * }
     */
    public static MemorySegment g_hook_find_data$address() {
        return g_hook_find_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_find_data(GHookList *hook_list, gboolean need_valids, gpointer data)
     * }
     */
    public static MemorySegment g_hook_find_data(MemorySegment hook_list, int need_valids, MemorySegment data) {
        var mh$ = g_hook_find_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_find_data", hook_list, need_valids, data);
            }
            return (MemorySegment)mh$.invokeExact(hook_list, need_valids, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_find_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_find_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_func(GHookList *hook_list, gboolean need_valids, gpointer func)
     * }
     */
    public static FunctionDescriptor g_hook_find_func$descriptor() {
        return g_hook_find_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_func(GHookList *hook_list, gboolean need_valids, gpointer func)
     * }
     */
    public static MethodHandle g_hook_find_func$handle() {
        return g_hook_find_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_func(GHookList *hook_list, gboolean need_valids, gpointer func)
     * }
     */
    public static MemorySegment g_hook_find_func$address() {
        return g_hook_find_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_find_func(GHookList *hook_list, gboolean need_valids, gpointer func)
     * }
     */
    public static MemorySegment g_hook_find_func(MemorySegment hook_list, int need_valids, MemorySegment func) {
        var mh$ = g_hook_find_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_find_func", hook_list, need_valids, func);
            }
            return (MemorySegment)mh$.invokeExact(hook_list, need_valids, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_find_func_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_find_func_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_func_data(GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data)
     * }
     */
    public static FunctionDescriptor g_hook_find_func_data$descriptor() {
        return g_hook_find_func_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_func_data(GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data)
     * }
     */
    public static MethodHandle g_hook_find_func_data$handle() {
        return g_hook_find_func_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_find_func_data(GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data)
     * }
     */
    public static MemorySegment g_hook_find_func_data$address() {
        return g_hook_find_func_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_find_func_data(GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data)
     * }
     */
    public static MemorySegment g_hook_find_func_data(MemorySegment hook_list, int need_valids, MemorySegment func, MemorySegment data) {
        var mh$ = g_hook_find_func_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_find_func_data", hook_list, need_valids, func, data);
            }
            return (MemorySegment)mh$.invokeExact(hook_list, need_valids, func, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_first_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_first_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_first_valid(GHookList *hook_list, gboolean may_be_in_call)
     * }
     */
    public static FunctionDescriptor g_hook_first_valid$descriptor() {
        return g_hook_first_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_first_valid(GHookList *hook_list, gboolean may_be_in_call)
     * }
     */
    public static MethodHandle g_hook_first_valid$handle() {
        return g_hook_first_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_first_valid(GHookList *hook_list, gboolean may_be_in_call)
     * }
     */
    public static MemorySegment g_hook_first_valid$address() {
        return g_hook_first_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_first_valid(GHookList *hook_list, gboolean may_be_in_call)
     * }
     */
    public static MemorySegment g_hook_first_valid(MemorySegment hook_list, int may_be_in_call) {
        var mh$ = g_hook_first_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_first_valid", hook_list, may_be_in_call);
            }
            return (MemorySegment)mh$.invokeExact(hook_list, may_be_in_call);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_next_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_next_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GHook *g_hook_next_valid(GHookList *hook_list, GHook *hook, gboolean may_be_in_call)
     * }
     */
    public static FunctionDescriptor g_hook_next_valid$descriptor() {
        return g_hook_next_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GHook *g_hook_next_valid(GHookList *hook_list, GHook *hook, gboolean may_be_in_call)
     * }
     */
    public static MethodHandle g_hook_next_valid$handle() {
        return g_hook_next_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GHook *g_hook_next_valid(GHookList *hook_list, GHook *hook, gboolean may_be_in_call)
     * }
     */
    public static MemorySegment g_hook_next_valid$address() {
        return g_hook_next_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GHook *g_hook_next_valid(GHookList *hook_list, GHook *hook, gboolean may_be_in_call)
     * }
     */
    public static MemorySegment g_hook_next_valid(MemorySegment hook_list, MemorySegment hook, int may_be_in_call) {
        var mh$ = g_hook_next_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_next_valid", hook_list, hook, may_be_in_call);
            }
            return (MemorySegment)mh$.invokeExact(hook_list, hook, may_be_in_call);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_compare_ids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_compare_ids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_hook_compare_ids(GHook *new_hook, GHook *sibling)
     * }
     */
    public static FunctionDescriptor g_hook_compare_ids$descriptor() {
        return g_hook_compare_ids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_hook_compare_ids(GHook *new_hook, GHook *sibling)
     * }
     */
    public static MethodHandle g_hook_compare_ids$handle() {
        return g_hook_compare_ids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_hook_compare_ids(GHook *new_hook, GHook *sibling)
     * }
     */
    public static MemorySegment g_hook_compare_ids$address() {
        return g_hook_compare_ids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_hook_compare_ids(GHook *new_hook, GHook *sibling)
     * }
     */
    public static int g_hook_compare_ids(MemorySegment new_hook, MemorySegment sibling) {
        var mh$ = g_hook_compare_ids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_compare_ids", new_hook, sibling);
            }
            return (int)mh$.invokeExact(new_hook, sibling);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_list_invoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_list_invoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_list_invoke(GHookList *hook_list, gboolean may_recurse)
     * }
     */
    public static FunctionDescriptor g_hook_list_invoke$descriptor() {
        return g_hook_list_invoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_list_invoke(GHookList *hook_list, gboolean may_recurse)
     * }
     */
    public static MethodHandle g_hook_list_invoke$handle() {
        return g_hook_list_invoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_list_invoke(GHookList *hook_list, gboolean may_recurse)
     * }
     */
    public static MemorySegment g_hook_list_invoke$address() {
        return g_hook_list_invoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_list_invoke(GHookList *hook_list, gboolean may_recurse)
     * }
     */
    public static void g_hook_list_invoke(MemorySegment hook_list, int may_recurse) {
        var mh$ = g_hook_list_invoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_list_invoke", hook_list, may_recurse);
            }
            mh$.invokeExact(hook_list, may_recurse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_list_invoke_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_list_invoke_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_list_invoke_check(GHookList *hook_list, gboolean may_recurse)
     * }
     */
    public static FunctionDescriptor g_hook_list_invoke_check$descriptor() {
        return g_hook_list_invoke_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_list_invoke_check(GHookList *hook_list, gboolean may_recurse)
     * }
     */
    public static MethodHandle g_hook_list_invoke_check$handle() {
        return g_hook_list_invoke_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_list_invoke_check(GHookList *hook_list, gboolean may_recurse)
     * }
     */
    public static MemorySegment g_hook_list_invoke_check$address() {
        return g_hook_list_invoke_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_list_invoke_check(GHookList *hook_list, gboolean may_recurse)
     * }
     */
    public static void g_hook_list_invoke_check(MemorySegment hook_list, int may_recurse) {
        var mh$ = g_hook_list_invoke_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_list_invoke_check", hook_list, may_recurse);
            }
            mh$.invokeExact(hook_list, may_recurse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_list_marshal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_list_marshal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_list_marshal(GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_hook_list_marshal$descriptor() {
        return g_hook_list_marshal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_list_marshal(GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_hook_list_marshal$handle() {
        return g_hook_list_marshal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_list_marshal(GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_hook_list_marshal$address() {
        return g_hook_list_marshal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_list_marshal(GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data)
     * }
     */
    public static void g_hook_list_marshal(MemorySegment hook_list, int may_recurse, MemorySegment marshaller, MemorySegment marshal_data) {
        var mh$ = g_hook_list_marshal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_list_marshal", hook_list, may_recurse, marshaller, marshal_data);
            }
            mh$.invokeExact(hook_list, may_recurse, marshaller, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hook_list_marshal_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hook_list_marshal_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_hook_list_marshal_check(GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data)
     * }
     */
    public static FunctionDescriptor g_hook_list_marshal_check$descriptor() {
        return g_hook_list_marshal_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_hook_list_marshal_check(GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data)
     * }
     */
    public static MethodHandle g_hook_list_marshal_check$handle() {
        return g_hook_list_marshal_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_hook_list_marshal_check(GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data)
     * }
     */
    public static MemorySegment g_hook_list_marshal_check$address() {
        return g_hook_list_marshal_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_hook_list_marshal_check(GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data)
     * }
     */
    public static void g_hook_list_marshal_check(MemorySegment hook_list, int may_recurse, MemorySegment marshaller, MemorySegment marshal_data) {
        var mh$ = g_hook_list_marshal_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hook_list_marshal_check", hook_list, may_recurse, marshaller, marshal_data);
            }
            mh$.invokeExact(hook_list, may_recurse, marshaller, marshal_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hostname_is_non_ascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hostname_is_non_ascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_non_ascii(const gchar *hostname)
     * }
     */
    public static FunctionDescriptor g_hostname_is_non_ascii$descriptor() {
        return g_hostname_is_non_ascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_non_ascii(const gchar *hostname)
     * }
     */
    public static MethodHandle g_hostname_is_non_ascii$handle() {
        return g_hostname_is_non_ascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_non_ascii(const gchar *hostname)
     * }
     */
    public static MemorySegment g_hostname_is_non_ascii$address() {
        return g_hostname_is_non_ascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_non_ascii(const gchar *hostname)
     * }
     */
    public static int g_hostname_is_non_ascii(MemorySegment hostname) {
        var mh$ = g_hostname_is_non_ascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hostname_is_non_ascii", hostname);
            }
            return (int)mh$.invokeExact(hostname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hostname_is_ascii_encoded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hostname_is_ascii_encoded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_ascii_encoded(const gchar *hostname)
     * }
     */
    public static FunctionDescriptor g_hostname_is_ascii_encoded$descriptor() {
        return g_hostname_is_ascii_encoded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_ascii_encoded(const gchar *hostname)
     * }
     */
    public static MethodHandle g_hostname_is_ascii_encoded$handle() {
        return g_hostname_is_ascii_encoded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_ascii_encoded(const gchar *hostname)
     * }
     */
    public static MemorySegment g_hostname_is_ascii_encoded$address() {
        return g_hostname_is_ascii_encoded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_ascii_encoded(const gchar *hostname)
     * }
     */
    public static int g_hostname_is_ascii_encoded(MemorySegment hostname) {
        var mh$ = g_hostname_is_ascii_encoded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hostname_is_ascii_encoded", hostname);
            }
            return (int)mh$.invokeExact(hostname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hostname_is_ip_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hostname_is_ip_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_ip_address(const gchar *hostname)
     * }
     */
    public static FunctionDescriptor g_hostname_is_ip_address$descriptor() {
        return g_hostname_is_ip_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_ip_address(const gchar *hostname)
     * }
     */
    public static MethodHandle g_hostname_is_ip_address$handle() {
        return g_hostname_is_ip_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_ip_address(const gchar *hostname)
     * }
     */
    public static MemorySegment g_hostname_is_ip_address$address() {
        return g_hostname_is_ip_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_hostname_is_ip_address(const gchar *hostname)
     * }
     */
    public static int g_hostname_is_ip_address(MemorySegment hostname) {
        var mh$ = g_hostname_is_ip_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hostname_is_ip_address", hostname);
            }
            return (int)mh$.invokeExact(hostname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hostname_to_ascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hostname_to_ascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_hostname_to_ascii(const gchar *hostname)
     * }
     */
    public static FunctionDescriptor g_hostname_to_ascii$descriptor() {
        return g_hostname_to_ascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_hostname_to_ascii(const gchar *hostname)
     * }
     */
    public static MethodHandle g_hostname_to_ascii$handle() {
        return g_hostname_to_ascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_hostname_to_ascii(const gchar *hostname)
     * }
     */
    public static MemorySegment g_hostname_to_ascii$address() {
        return g_hostname_to_ascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_hostname_to_ascii(const gchar *hostname)
     * }
     */
    public static MemorySegment g_hostname_to_ascii(MemorySegment hostname) {
        var mh$ = g_hostname_to_ascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hostname_to_ascii", hostname);
            }
            return (MemorySegment)mh$.invokeExact(hostname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_hostname_to_unicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_hostname_to_unicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_hostname_to_unicode(const gchar *hostname)
     * }
     */
    public static FunctionDescriptor g_hostname_to_unicode$descriptor() {
        return g_hostname_to_unicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_hostname_to_unicode(const gchar *hostname)
     * }
     */
    public static MethodHandle g_hostname_to_unicode$handle() {
        return g_hostname_to_unicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_hostname_to_unicode(const gchar *hostname)
     * }
     */
    public static MemorySegment g_hostname_to_unicode$address() {
        return g_hostname_to_unicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_hostname_to_unicode(const gchar *hostname)
     * }
     */
    public static MemorySegment g_hostname_to_unicode(MemorySegment hostname) {
        var mh$ = g_hostname_to_unicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_hostname_to_unicode", hostname);
            }
            return (MemorySegment)mh$.invokeExact(hostname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_poll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_poll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_poll(GPollFD *fds, guint nfds, gint timeout)
     * }
     */
    public static FunctionDescriptor g_poll$descriptor() {
        return g_poll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_poll(GPollFD *fds, guint nfds, gint timeout)
     * }
     */
    public static MethodHandle g_poll$handle() {
        return g_poll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_poll(GPollFD *fds, guint nfds, gint timeout)
     * }
     */
    public static MemorySegment g_poll$address() {
        return g_poll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_poll(GPollFD *fds, guint nfds, gint timeout)
     * }
     */
    public static int g_poll(MemorySegment fds, int nfds, int timeout) {
        var mh$ = g_poll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_poll", fds, nfds, timeout);
            }
            return (int)mh$.invokeExact(fds, nfds, timeout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_alloc()
     * }
     */
    public static FunctionDescriptor g_slist_alloc$descriptor() {
        return g_slist_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_alloc()
     * }
     */
    public static MethodHandle g_slist_alloc$handle() {
        return g_slist_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_alloc()
     * }
     */
    public static MemorySegment g_slist_alloc$address() {
        return g_slist_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_alloc()
     * }
     */
    public static MemorySegment g_slist_alloc() {
        var mh$ = g_slist_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slist_free(GSList *list)
     * }
     */
    public static FunctionDescriptor g_slist_free$descriptor() {
        return g_slist_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slist_free(GSList *list)
     * }
     */
    public static MethodHandle g_slist_free$handle() {
        return g_slist_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slist_free(GSList *list)
     * }
     */
    public static MemorySegment g_slist_free$address() {
        return g_slist_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slist_free(GSList *list)
     * }
     */
    public static void g_slist_free(MemorySegment list) {
        var mh$ = g_slist_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_free", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_free_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_free_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slist_free_1(GSList *list)
     * }
     */
    public static FunctionDescriptor g_slist_free_1$descriptor() {
        return g_slist_free_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slist_free_1(GSList *list)
     * }
     */
    public static MethodHandle g_slist_free_1$handle() {
        return g_slist_free_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slist_free_1(GSList *list)
     * }
     */
    public static MemorySegment g_slist_free_1$address() {
        return g_slist_free_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slist_free_1(GSList *list)
     * }
     */
    public static void g_slist_free_1(MemorySegment list) {
        var mh$ = g_slist_free_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_free_1", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_free_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_free_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slist_free_full(GSList *list, GDestroyNotify free_func)
     * }
     */
    public static FunctionDescriptor g_slist_free_full$descriptor() {
        return g_slist_free_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slist_free_full(GSList *list, GDestroyNotify free_func)
     * }
     */
    public static MethodHandle g_slist_free_full$handle() {
        return g_slist_free_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slist_free_full(GSList *list, GDestroyNotify free_func)
     * }
     */
    public static MemorySegment g_slist_free_full$address() {
        return g_slist_free_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slist_free_full(GSList *list, GDestroyNotify free_func)
     * }
     */
    public static void g_slist_free_full(MemorySegment list, MemorySegment free_func) {
        var mh$ = g_slist_free_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_free_full", list, free_func);
            }
            mh$.invokeExact(list, free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_append(GSList *list, gpointer data)
     * }
     */
    public static FunctionDescriptor g_slist_append$descriptor() {
        return g_slist_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_append(GSList *list, gpointer data)
     * }
     */
    public static MethodHandle g_slist_append$handle() {
        return g_slist_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_append(GSList *list, gpointer data)
     * }
     */
    public static MemorySegment g_slist_append$address() {
        return g_slist_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_append(GSList *list, gpointer data)
     * }
     */
    public static MemorySegment g_slist_append(MemorySegment list, MemorySegment data) {
        var mh$ = g_slist_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_append", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_prepend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_prepend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_prepend(GSList *list, gpointer data)
     * }
     */
    public static FunctionDescriptor g_slist_prepend$descriptor() {
        return g_slist_prepend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_prepend(GSList *list, gpointer data)
     * }
     */
    public static MethodHandle g_slist_prepend$handle() {
        return g_slist_prepend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_prepend(GSList *list, gpointer data)
     * }
     */
    public static MemorySegment g_slist_prepend$address() {
        return g_slist_prepend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_prepend(GSList *list, gpointer data)
     * }
     */
    public static MemorySegment g_slist_prepend(MemorySegment list, MemorySegment data) {
        var mh$ = g_slist_prepend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_prepend", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert(GSList *list, gpointer data, gint position)
     * }
     */
    public static FunctionDescriptor g_slist_insert$descriptor() {
        return g_slist_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert(GSList *list, gpointer data, gint position)
     * }
     */
    public static MethodHandle g_slist_insert$handle() {
        return g_slist_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert(GSList *list, gpointer data, gint position)
     * }
     */
    public static MemorySegment g_slist_insert$address() {
        return g_slist_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_insert(GSList *list, gpointer data, gint position)
     * }
     */
    public static MemorySegment g_slist_insert(MemorySegment list, MemorySegment data, int position) {
        var mh$ = g_slist_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_insert", list, data, position);
            }
            return (MemorySegment)mh$.invokeExact(list, data, position);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_insert_sorted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_insert_sorted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_sorted(GSList *list, gpointer data, GCompareFunc func)
     * }
     */
    public static FunctionDescriptor g_slist_insert_sorted$descriptor() {
        return g_slist_insert_sorted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_sorted(GSList *list, gpointer data, GCompareFunc func)
     * }
     */
    public static MethodHandle g_slist_insert_sorted$handle() {
        return g_slist_insert_sorted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_sorted(GSList *list, gpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_slist_insert_sorted$address() {
        return g_slist_insert_sorted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_sorted(GSList *list, gpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_slist_insert_sorted(MemorySegment list, MemorySegment data, MemorySegment func) {
        var mh$ = g_slist_insert_sorted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_insert_sorted", list, data, func);
            }
            return (MemorySegment)mh$.invokeExact(list, data, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_insert_sorted_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_insert_sorted_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_sorted_with_data(GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_slist_insert_sorted_with_data$descriptor() {
        return g_slist_insert_sorted_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_sorted_with_data(GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_slist_insert_sorted_with_data$handle() {
        return g_slist_insert_sorted_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_sorted_with_data(GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_slist_insert_sorted_with_data$address() {
        return g_slist_insert_sorted_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_sorted_with_data(GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_slist_insert_sorted_with_data(MemorySegment list, MemorySegment data, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_slist_insert_sorted_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_insert_sorted_with_data", list, data, func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(list, data, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_insert_before {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_insert_before");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_before(GSList *slist, GSList *sibling, gpointer data)
     * }
     */
    public static FunctionDescriptor g_slist_insert_before$descriptor() {
        return g_slist_insert_before.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_before(GSList *slist, GSList *sibling, gpointer data)
     * }
     */
    public static MethodHandle g_slist_insert_before$handle() {
        return g_slist_insert_before.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_before(GSList *slist, GSList *sibling, gpointer data)
     * }
     */
    public static MemorySegment g_slist_insert_before$address() {
        return g_slist_insert_before.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_insert_before(GSList *slist, GSList *sibling, gpointer data)
     * }
     */
    public static MemorySegment g_slist_insert_before(MemorySegment slist, MemorySegment sibling, MemorySegment data) {
        var mh$ = g_slist_insert_before.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_insert_before", slist, sibling, data);
            }
            return (MemorySegment)mh$.invokeExact(slist, sibling, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_concat(GSList *list1, GSList *list2)
     * }
     */
    public static FunctionDescriptor g_slist_concat$descriptor() {
        return g_slist_concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_concat(GSList *list1, GSList *list2)
     * }
     */
    public static MethodHandle g_slist_concat$handle() {
        return g_slist_concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_concat(GSList *list1, GSList *list2)
     * }
     */
    public static MemorySegment g_slist_concat$address() {
        return g_slist_concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_concat(GSList *list1, GSList *list2)
     * }
     */
    public static MemorySegment g_slist_concat(MemorySegment list1, MemorySegment list2) {
        var mh$ = g_slist_concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_concat", list1, list2);
            }
            return (MemorySegment)mh$.invokeExact(list1, list2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove(GSList *list, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_slist_remove$descriptor() {
        return g_slist_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove(GSList *list, gconstpointer data)
     * }
     */
    public static MethodHandle g_slist_remove$handle() {
        return g_slist_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove(GSList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_slist_remove$address() {
        return g_slist_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_remove(GSList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_slist_remove(MemorySegment list, MemorySegment data) {
        var mh$ = g_slist_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_remove", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_remove_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_remove_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove_all(GSList *list, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_slist_remove_all$descriptor() {
        return g_slist_remove_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove_all(GSList *list, gconstpointer data)
     * }
     */
    public static MethodHandle g_slist_remove_all$handle() {
        return g_slist_remove_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove_all(GSList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_slist_remove_all$address() {
        return g_slist_remove_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_remove_all(GSList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_slist_remove_all(MemorySegment list, MemorySegment data) {
        var mh$ = g_slist_remove_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_remove_all", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_remove_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_remove_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove_link(GSList *list, GSList *link_)
     * }
     */
    public static FunctionDescriptor g_slist_remove_link$descriptor() {
        return g_slist_remove_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove_link(GSList *list, GSList *link_)
     * }
     */
    public static MethodHandle g_slist_remove_link$handle() {
        return g_slist_remove_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_remove_link(GSList *list, GSList *link_)
     * }
     */
    public static MemorySegment g_slist_remove_link$address() {
        return g_slist_remove_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_remove_link(GSList *list, GSList *link_)
     * }
     */
    public static MemorySegment g_slist_remove_link(MemorySegment list, MemorySegment link_) {
        var mh$ = g_slist_remove_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_remove_link", list, link_);
            }
            return (MemorySegment)mh$.invokeExact(list, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_delete_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_delete_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_delete_link(GSList *list, GSList *link_)
     * }
     */
    public static FunctionDescriptor g_slist_delete_link$descriptor() {
        return g_slist_delete_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_delete_link(GSList *list, GSList *link_)
     * }
     */
    public static MethodHandle g_slist_delete_link$handle() {
        return g_slist_delete_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_delete_link(GSList *list, GSList *link_)
     * }
     */
    public static MemorySegment g_slist_delete_link$address() {
        return g_slist_delete_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_delete_link(GSList *list, GSList *link_)
     * }
     */
    public static MemorySegment g_slist_delete_link(MemorySegment list, MemorySegment link_) {
        var mh$ = g_slist_delete_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_delete_link", list, link_);
            }
            return (MemorySegment)mh$.invokeExact(list, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_reverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_reverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_reverse(GSList *list)
     * }
     */
    public static FunctionDescriptor g_slist_reverse$descriptor() {
        return g_slist_reverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_reverse(GSList *list)
     * }
     */
    public static MethodHandle g_slist_reverse$handle() {
        return g_slist_reverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_reverse(GSList *list)
     * }
     */
    public static MemorySegment g_slist_reverse$address() {
        return g_slist_reverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_reverse(GSList *list)
     * }
     */
    public static MemorySegment g_slist_reverse(MemorySegment list) {
        var mh$ = g_slist_reverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_reverse", list);
            }
            return (MemorySegment)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_copy(GSList *list)
     * }
     */
    public static FunctionDescriptor g_slist_copy$descriptor() {
        return g_slist_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_copy(GSList *list)
     * }
     */
    public static MethodHandle g_slist_copy$handle() {
        return g_slist_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_copy(GSList *list)
     * }
     */
    public static MemorySegment g_slist_copy$address() {
        return g_slist_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_copy(GSList *list)
     * }
     */
    public static MemorySegment g_slist_copy(MemorySegment list) {
        var mh$ = g_slist_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_copy", list);
            }
            return (MemorySegment)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_copy_deep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_copy_deep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_copy_deep(GSList *list, GCopyFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_slist_copy_deep$descriptor() {
        return g_slist_copy_deep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_copy_deep(GSList *list, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_slist_copy_deep$handle() {
        return g_slist_copy_deep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_copy_deep(GSList *list, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_slist_copy_deep$address() {
        return g_slist_copy_deep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_copy_deep(GSList *list, GCopyFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_slist_copy_deep(MemorySegment list, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_slist_copy_deep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_copy_deep", list, func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(list, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_nth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_nth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_nth(GSList *list, guint n)
     * }
     */
    public static FunctionDescriptor g_slist_nth$descriptor() {
        return g_slist_nth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_nth(GSList *list, guint n)
     * }
     */
    public static MethodHandle g_slist_nth$handle() {
        return g_slist_nth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_nth(GSList *list, guint n)
     * }
     */
    public static MemorySegment g_slist_nth$address() {
        return g_slist_nth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_nth(GSList *list, guint n)
     * }
     */
    public static MemorySegment g_slist_nth(MemorySegment list, int n) {
        var mh$ = g_slist_nth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_nth", list, n);
            }
            return (MemorySegment)mh$.invokeExact(list, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_find(GSList *list, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_slist_find$descriptor() {
        return g_slist_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_find(GSList *list, gconstpointer data)
     * }
     */
    public static MethodHandle g_slist_find$handle() {
        return g_slist_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_find(GSList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_slist_find$address() {
        return g_slist_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_find(GSList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_slist_find(MemorySegment list, MemorySegment data) {
        var mh$ = g_slist_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_find", list, data);
            }
            return (MemorySegment)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_find_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_find_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_find_custom(GSList *list, gconstpointer data, GCompareFunc func)
     * }
     */
    public static FunctionDescriptor g_slist_find_custom$descriptor() {
        return g_slist_find_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_find_custom(GSList *list, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MethodHandle g_slist_find_custom$handle() {
        return g_slist_find_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_find_custom(GSList *list, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_slist_find_custom$address() {
        return g_slist_find_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_find_custom(GSList *list, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_slist_find_custom(MemorySegment list, MemorySegment data, MemorySegment func) {
        var mh$ = g_slist_find_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_find_custom", list, data, func);
            }
            return (MemorySegment)mh$.invokeExact(list, data, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_slist_position(GSList *list, GSList *llink)
     * }
     */
    public static FunctionDescriptor g_slist_position$descriptor() {
        return g_slist_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_slist_position(GSList *list, GSList *llink)
     * }
     */
    public static MethodHandle g_slist_position$handle() {
        return g_slist_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_slist_position(GSList *list, GSList *llink)
     * }
     */
    public static MemorySegment g_slist_position$address() {
        return g_slist_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_slist_position(GSList *list, GSList *llink)
     * }
     */
    public static int g_slist_position(MemorySegment list, MemorySegment llink) {
        var mh$ = g_slist_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_position", list, llink);
            }
            return (int)mh$.invokeExact(list, llink);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_slist_index(GSList *list, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_slist_index$descriptor() {
        return g_slist_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_slist_index(GSList *list, gconstpointer data)
     * }
     */
    public static MethodHandle g_slist_index$handle() {
        return g_slist_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_slist_index(GSList *list, gconstpointer data)
     * }
     */
    public static MemorySegment g_slist_index$address() {
        return g_slist_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_slist_index(GSList *list, gconstpointer data)
     * }
     */
    public static int g_slist_index(MemorySegment list, MemorySegment data) {
        var mh$ = g_slist_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_index", list, data);
            }
            return (int)mh$.invokeExact(list, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_last(GSList *list)
     * }
     */
    public static FunctionDescriptor g_slist_last$descriptor() {
        return g_slist_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_last(GSList *list)
     * }
     */
    public static MethodHandle g_slist_last$handle() {
        return g_slist_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_last(GSList *list)
     * }
     */
    public static MemorySegment g_slist_last$address() {
        return g_slist_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_last(GSList *list)
     * }
     */
    public static MemorySegment g_slist_last(MemorySegment list) {
        var mh$ = g_slist_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_last", list);
            }
            return (MemorySegment)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_slist_length(GSList *list)
     * }
     */
    public static FunctionDescriptor g_slist_length$descriptor() {
        return g_slist_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_slist_length(GSList *list)
     * }
     */
    public static MethodHandle g_slist_length$handle() {
        return g_slist_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_slist_length(GSList *list)
     * }
     */
    public static MemorySegment g_slist_length$address() {
        return g_slist_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_slist_length(GSList *list)
     * }
     */
    public static int g_slist_length(MemorySegment list) {
        var mh$ = g_slist_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_length", list);
            }
            return (int)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slist_foreach(GSList *list, GFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_slist_foreach$descriptor() {
        return g_slist_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slist_foreach(GSList *list, GFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_slist_foreach$handle() {
        return g_slist_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slist_foreach(GSList *list, GFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_slist_foreach$address() {
        return g_slist_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slist_foreach(GSList *list, GFunc func, gpointer user_data)
     * }
     */
    public static void g_slist_foreach(MemorySegment list, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_slist_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_foreach", list, func, user_data);
            }
            mh$.invokeExact(list, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_sort(GSList *list, GCompareFunc compare_func)
     * }
     */
    public static FunctionDescriptor g_slist_sort$descriptor() {
        return g_slist_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_sort(GSList *list, GCompareFunc compare_func)
     * }
     */
    public static MethodHandle g_slist_sort$handle() {
        return g_slist_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_sort(GSList *list, GCompareFunc compare_func)
     * }
     */
    public static MemorySegment g_slist_sort$address() {
        return g_slist_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_sort(GSList *list, GCompareFunc compare_func)
     * }
     */
    public static MemorySegment g_slist_sort(MemorySegment list, MemorySegment compare_func) {
        var mh$ = g_slist_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_sort", list, compare_func);
            }
            return (MemorySegment)mh$.invokeExact(list, compare_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_sort_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_sort_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSList *g_slist_sort_with_data(GSList *list, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_slist_sort_with_data$descriptor() {
        return g_slist_sort_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSList *g_slist_sort_with_data(GSList *list, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_slist_sort_with_data$handle() {
        return g_slist_sort_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSList *g_slist_sort_with_data(GSList *list, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_slist_sort_with_data$address() {
        return g_slist_sort_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSList *g_slist_sort_with_data(GSList *list, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_slist_sort_with_data(MemorySegment list, MemorySegment compare_func, MemorySegment user_data) {
        var mh$ = g_slist_sort_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_sort_with_data", list, compare_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(list, compare_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slist_nth_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slist_nth_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_slist_nth_data(GSList *list, guint n)
     * }
     */
    public static FunctionDescriptor g_slist_nth_data$descriptor() {
        return g_slist_nth_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_slist_nth_data(GSList *list, guint n)
     * }
     */
    public static MethodHandle g_slist_nth_data$handle() {
        return g_slist_nth_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_slist_nth_data(GSList *list, guint n)
     * }
     */
    public static MemorySegment g_slist_nth_data$address() {
        return g_slist_nth_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_slist_nth_data(GSList *list, guint n)
     * }
     */
    public static MemorySegment g_slist_nth_data(MemorySegment list, int n) {
        var mh$ = g_slist_nth_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slist_nth_data", list, n);
            }
            return (MemorySegment)mh$.invokeExact(list, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_clear_slist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_clear_slist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_clear_slist(GSList **slist_ptr, GDestroyNotify destroy)
     * }
     */
    public static FunctionDescriptor g_clear_slist$descriptor() {
        return g_clear_slist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_clear_slist(GSList **slist_ptr, GDestroyNotify destroy)
     * }
     */
    public static MethodHandle g_clear_slist$handle() {
        return g_clear_slist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_clear_slist(GSList **slist_ptr, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_clear_slist$address() {
        return g_clear_slist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_clear_slist(GSList **slist_ptr, GDestroyNotify destroy)
     * }
     */
    public static void g_clear_slist(MemorySegment slist_ptr, MemorySegment destroy) {
        var mh$ = g_clear_slist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_clear_slist", slist_ptr, destroy);
            }
            mh$.invokeExact(slist_ptr, destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_IO_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_IN = 1
     * }
     */
    public static int G_IO_IN() {
        return G_IO_IN;
    }
    private static final int G_IO_OUT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_OUT = 4
     * }
     */
    public static int G_IO_OUT() {
        return G_IO_OUT;
    }
    private static final int G_IO_PRI = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_PRI = 2
     * }
     */
    public static int G_IO_PRI() {
        return G_IO_PRI;
    }
    private static final int G_IO_ERR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_ERR = 8
     * }
     */
    public static int G_IO_ERR() {
        return G_IO_ERR;
    }
    private static final int G_IO_HUP = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_HUP = 16
     * }
     */
    public static int G_IO_HUP() {
        return G_IO_HUP;
    }
    private static final int G_IO_NVAL = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_NVAL = 32
     * }
     */
    public static int G_IO_NVAL() {
        return G_IO_NVAL;
    }
    private static final int G_MAIN_CONTEXT_FLAGS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MAIN_CONTEXT_FLAGS_NONE = 0
     * }
     */
    public static int G_MAIN_CONTEXT_FLAGS_NONE() {
        return G_MAIN_CONTEXT_FLAGS_NONE;
    }
    private static final int G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING = 1
     * }
     */
    public static int G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING() {
        return G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING;
    }

    private static class g_main_context_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_new()
     * }
     */
    public static FunctionDescriptor g_main_context_new$descriptor() {
        return g_main_context_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_new()
     * }
     */
    public static MethodHandle g_main_context_new$handle() {
        return g_main_context_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_new()
     * }
     */
    public static MemorySegment g_main_context_new$address() {
        return g_main_context_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_new()
     * }
     */
    public static MemorySegment g_main_context_new() {
        var mh$ = g_main_context_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_new_with_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_new_with_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_new_with_flags(GMainContextFlags flags)
     * }
     */
    public static FunctionDescriptor g_main_context_new_with_flags$descriptor() {
        return g_main_context_new_with_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_new_with_flags(GMainContextFlags flags)
     * }
     */
    public static MethodHandle g_main_context_new_with_flags$handle() {
        return g_main_context_new_with_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_new_with_flags(GMainContextFlags flags)
     * }
     */
    public static MemorySegment g_main_context_new_with_flags$address() {
        return g_main_context_new_with_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_new_with_flags(GMainContextFlags flags)
     * }
     */
    public static MemorySegment g_main_context_new_with_flags(int flags) {
        var mh$ = g_main_context_new_with_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_new_with_flags", flags);
            }
            return (MemorySegment)mh$.invokeExact(flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_ref(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_ref$descriptor() {
        return g_main_context_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_ref(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_ref$handle() {
        return g_main_context_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_ref(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_ref$address() {
        return g_main_context_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_ref(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_ref(MemorySegment context) {
        var mh$ = g_main_context_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_ref", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_unref(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_unref$descriptor() {
        return g_main_context_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_unref(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_unref$handle() {
        return g_main_context_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_unref(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_unref$address() {
        return g_main_context_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_unref(GMainContext *context)
     * }
     */
    public static void g_main_context_unref(MemorySegment context) {
        var mh$ = g_main_context_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_unref", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_default()
     * }
     */
    public static FunctionDescriptor g_main_context_default$descriptor() {
        return g_main_context_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_default()
     * }
     */
    public static MethodHandle g_main_context_default$handle() {
        return g_main_context_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_default()
     * }
     */
    public static MemorySegment g_main_context_default$address() {
        return g_main_context_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_default()
     * }
     */
    public static MemorySegment g_main_context_default() {
        var mh$ = g_main_context_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_default");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_iteration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_iteration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_iteration(GMainContext *context, gboolean may_block)
     * }
     */
    public static FunctionDescriptor g_main_context_iteration$descriptor() {
        return g_main_context_iteration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_iteration(GMainContext *context, gboolean may_block)
     * }
     */
    public static MethodHandle g_main_context_iteration$handle() {
        return g_main_context_iteration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_iteration(GMainContext *context, gboolean may_block)
     * }
     */
    public static MemorySegment g_main_context_iteration$address() {
        return g_main_context_iteration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_main_context_iteration(GMainContext *context, gboolean may_block)
     * }
     */
    public static int g_main_context_iteration(MemorySegment context, int may_block) {
        var mh$ = g_main_context_iteration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_iteration", context, may_block);
            }
            return (int)mh$.invokeExact(context, may_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_pending {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_pending");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_pending(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_pending$descriptor() {
        return g_main_context_pending.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_pending(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_pending$handle() {
        return g_main_context_pending.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_pending(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_pending$address() {
        return g_main_context_pending.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_main_context_pending(GMainContext *context)
     * }
     */
    public static int g_main_context_pending(MemorySegment context) {
        var mh$ = g_main_context_pending.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_pending", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_find_source_by_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_find_source_by_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_id(GMainContext *context, guint source_id)
     * }
     */
    public static FunctionDescriptor g_main_context_find_source_by_id$descriptor() {
        return g_main_context_find_source_by_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_id(GMainContext *context, guint source_id)
     * }
     */
    public static MethodHandle g_main_context_find_source_by_id$handle() {
        return g_main_context_find_source_by_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_id(GMainContext *context, guint source_id)
     * }
     */
    public static MemorySegment g_main_context_find_source_by_id$address() {
        return g_main_context_find_source_by_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_id(GMainContext *context, guint source_id)
     * }
     */
    public static MemorySegment g_main_context_find_source_by_id(MemorySegment context, int source_id) {
        var mh$ = g_main_context_find_source_by_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_find_source_by_id", context, source_id);
            }
            return (MemorySegment)mh$.invokeExact(context, source_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_find_source_by_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_find_source_by_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_user_data(GMainContext *context, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_main_context_find_source_by_user_data$descriptor() {
        return g_main_context_find_source_by_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_user_data(GMainContext *context, gpointer user_data)
     * }
     */
    public static MethodHandle g_main_context_find_source_by_user_data$handle() {
        return g_main_context_find_source_by_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_user_data(GMainContext *context, gpointer user_data)
     * }
     */
    public static MemorySegment g_main_context_find_source_by_user_data$address() {
        return g_main_context_find_source_by_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_user_data(GMainContext *context, gpointer user_data)
     * }
     */
    public static MemorySegment g_main_context_find_source_by_user_data(MemorySegment context, MemorySegment user_data) {
        var mh$ = g_main_context_find_source_by_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_find_source_by_user_data", context, user_data);
            }
            return (MemorySegment)mh$.invokeExact(context, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_find_source_by_funcs_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_find_source_by_funcs_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *context, GSourceFuncs *funcs, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_main_context_find_source_by_funcs_user_data$descriptor() {
        return g_main_context_find_source_by_funcs_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *context, GSourceFuncs *funcs, gpointer user_data)
     * }
     */
    public static MethodHandle g_main_context_find_source_by_funcs_user_data$handle() {
        return g_main_context_find_source_by_funcs_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *context, GSourceFuncs *funcs, gpointer user_data)
     * }
     */
    public static MemorySegment g_main_context_find_source_by_funcs_user_data$address() {
        return g_main_context_find_source_by_funcs_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *context, GSourceFuncs *funcs, gpointer user_data)
     * }
     */
    public static MemorySegment g_main_context_find_source_by_funcs_user_data(MemorySegment context, MemorySegment funcs, MemorySegment user_data) {
        var mh$ = g_main_context_find_source_by_funcs_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_find_source_by_funcs_user_data", context, funcs, user_data);
            }
            return (MemorySegment)mh$.invokeExact(context, funcs, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_wakeup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_wakeup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_wakeup(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_wakeup$descriptor() {
        return g_main_context_wakeup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_wakeup(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_wakeup$handle() {
        return g_main_context_wakeup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_wakeup(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_wakeup$address() {
        return g_main_context_wakeup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_wakeup(GMainContext *context)
     * }
     */
    public static void g_main_context_wakeup(MemorySegment context) {
        var mh$ = g_main_context_wakeup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_wakeup", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_acquire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_acquire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_acquire(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_acquire$descriptor() {
        return g_main_context_acquire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_acquire(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_acquire$handle() {
        return g_main_context_acquire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_acquire(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_acquire$address() {
        return g_main_context_acquire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_main_context_acquire(GMainContext *context)
     * }
     */
    public static int g_main_context_acquire(MemorySegment context) {
        var mh$ = g_main_context_acquire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_acquire", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_release(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_release$descriptor() {
        return g_main_context_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_release(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_release$handle() {
        return g_main_context_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_release(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_release$address() {
        return g_main_context_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_release(GMainContext *context)
     * }
     */
    public static void g_main_context_release(MemorySegment context) {
        var mh$ = g_main_context_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_release", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_is_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_is_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_is_owner(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_is_owner$descriptor() {
        return g_main_context_is_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_is_owner(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_is_owner$handle() {
        return g_main_context_is_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_is_owner(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_is_owner$address() {
        return g_main_context_is_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_main_context_is_owner(GMainContext *context)
     * }
     */
    public static int g_main_context_is_owner(MemorySegment context) {
        var mh$ = g_main_context_is_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_is_owner", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_wait(GMainContext *context, GCond *cond, GMutex *mutex)
     * }
     */
    public static FunctionDescriptor g_main_context_wait$descriptor() {
        return g_main_context_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_wait(GMainContext *context, GCond *cond, GMutex *mutex)
     * }
     */
    public static MethodHandle g_main_context_wait$handle() {
        return g_main_context_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_wait(GMainContext *context, GCond *cond, GMutex *mutex)
     * }
     */
    public static MemorySegment g_main_context_wait$address() {
        return g_main_context_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_main_context_wait(GMainContext *context, GCond *cond, GMutex *mutex)
     * }
     */
    public static int g_main_context_wait(MemorySegment context, MemorySegment cond, MemorySegment mutex) {
        var mh$ = g_main_context_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_wait", context, cond, mutex);
            }
            return (int)mh$.invokeExact(context, cond, mutex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_prepare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_prepare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_prepare(GMainContext *context, gint *priority)
     * }
     */
    public static FunctionDescriptor g_main_context_prepare$descriptor() {
        return g_main_context_prepare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_prepare(GMainContext *context, gint *priority)
     * }
     */
    public static MethodHandle g_main_context_prepare$handle() {
        return g_main_context_prepare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_prepare(GMainContext *context, gint *priority)
     * }
     */
    public static MemorySegment g_main_context_prepare$address() {
        return g_main_context_prepare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_main_context_prepare(GMainContext *context, gint *priority)
     * }
     */
    public static int g_main_context_prepare(MemorySegment context, MemorySegment priority) {
        var mh$ = g_main_context_prepare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_prepare", context, priority);
            }
            return (int)mh$.invokeExact(context, priority);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_main_context_query(GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds)
     * }
     */
    public static FunctionDescriptor g_main_context_query$descriptor() {
        return g_main_context_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_main_context_query(GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds)
     * }
     */
    public static MethodHandle g_main_context_query$handle() {
        return g_main_context_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_main_context_query(GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds)
     * }
     */
    public static MemorySegment g_main_context_query$address() {
        return g_main_context_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_main_context_query(GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds)
     * }
     */
    public static int g_main_context_query(MemorySegment context, int max_priority, MemorySegment timeout_, MemorySegment fds, int n_fds) {
        var mh$ = g_main_context_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_query", context, max_priority, timeout_, fds, n_fds);
            }
            return (int)mh$.invokeExact(context, max_priority, timeout_, fds, n_fds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_check(GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds)
     * }
     */
    public static FunctionDescriptor g_main_context_check$descriptor() {
        return g_main_context_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_check(GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds)
     * }
     */
    public static MethodHandle g_main_context_check$handle() {
        return g_main_context_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_main_context_check(GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds)
     * }
     */
    public static MemorySegment g_main_context_check$address() {
        return g_main_context_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_main_context_check(GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds)
     * }
     */
    public static int g_main_context_check(MemorySegment context, int max_priority, MemorySegment fds, int n_fds) {
        var mh$ = g_main_context_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_check", context, max_priority, fds, n_fds);
            }
            return (int)mh$.invokeExact(context, max_priority, fds, n_fds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_dispatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_dispatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_dispatch(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_dispatch$descriptor() {
        return g_main_context_dispatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_dispatch(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_dispatch$handle() {
        return g_main_context_dispatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_dispatch(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_dispatch$address() {
        return g_main_context_dispatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_dispatch(GMainContext *context)
     * }
     */
    public static void g_main_context_dispatch(MemorySegment context) {
        var mh$ = g_main_context_dispatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_dispatch", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_set_poll_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_set_poll_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_set_poll_func(GMainContext *context, GPollFunc func)
     * }
     */
    public static FunctionDescriptor g_main_context_set_poll_func$descriptor() {
        return g_main_context_set_poll_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_set_poll_func(GMainContext *context, GPollFunc func)
     * }
     */
    public static MethodHandle g_main_context_set_poll_func$handle() {
        return g_main_context_set_poll_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_set_poll_func(GMainContext *context, GPollFunc func)
     * }
     */
    public static MemorySegment g_main_context_set_poll_func$address() {
        return g_main_context_set_poll_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_set_poll_func(GMainContext *context, GPollFunc func)
     * }
     */
    public static void g_main_context_set_poll_func(MemorySegment context, MemorySegment func) {
        var mh$ = g_main_context_set_poll_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_set_poll_func", context, func);
            }
            mh$.invokeExact(context, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_get_poll_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_get_poll_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPollFunc g_main_context_get_poll_func(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_get_poll_func$descriptor() {
        return g_main_context_get_poll_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPollFunc g_main_context_get_poll_func(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_get_poll_func$handle() {
        return g_main_context_get_poll_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPollFunc g_main_context_get_poll_func(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_get_poll_func$address() {
        return g_main_context_get_poll_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPollFunc g_main_context_get_poll_func(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_get_poll_func(MemorySegment context) {
        var mh$ = g_main_context_get_poll_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_get_poll_func", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_add_poll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_add_poll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_add_poll(GMainContext *context, GPollFD *fd, gint priority)
     * }
     */
    public static FunctionDescriptor g_main_context_add_poll$descriptor() {
        return g_main_context_add_poll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_add_poll(GMainContext *context, GPollFD *fd, gint priority)
     * }
     */
    public static MethodHandle g_main_context_add_poll$handle() {
        return g_main_context_add_poll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_add_poll(GMainContext *context, GPollFD *fd, gint priority)
     * }
     */
    public static MemorySegment g_main_context_add_poll$address() {
        return g_main_context_add_poll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_add_poll(GMainContext *context, GPollFD *fd, gint priority)
     * }
     */
    public static void g_main_context_add_poll(MemorySegment context, MemorySegment fd, int priority) {
        var mh$ = g_main_context_add_poll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_add_poll", context, fd, priority);
            }
            mh$.invokeExact(context, fd, priority);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_remove_poll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_remove_poll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_remove_poll(GMainContext *context, GPollFD *fd)
     * }
     */
    public static FunctionDescriptor g_main_context_remove_poll$descriptor() {
        return g_main_context_remove_poll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_remove_poll(GMainContext *context, GPollFD *fd)
     * }
     */
    public static MethodHandle g_main_context_remove_poll$handle() {
        return g_main_context_remove_poll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_remove_poll(GMainContext *context, GPollFD *fd)
     * }
     */
    public static MemorySegment g_main_context_remove_poll$address() {
        return g_main_context_remove_poll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_remove_poll(GMainContext *context, GPollFD *fd)
     * }
     */
    public static void g_main_context_remove_poll(MemorySegment context, MemorySegment fd) {
        var mh$ = g_main_context_remove_poll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_remove_poll", context, fd);
            }
            mh$.invokeExact(context, fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_main_depth()
     * }
     */
    public static FunctionDescriptor g_main_depth$descriptor() {
        return g_main_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_main_depth()
     * }
     */
    public static MethodHandle g_main_depth$handle() {
        return g_main_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_main_depth()
     * }
     */
    public static MemorySegment g_main_depth$address() {
        return g_main_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_main_depth()
     * }
     */
    public static int g_main_depth() {
        var mh$ = g_main_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_depth");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_current_source {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_current_source");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_main_current_source()
     * }
     */
    public static FunctionDescriptor g_main_current_source$descriptor() {
        return g_main_current_source.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_main_current_source()
     * }
     */
    public static MethodHandle g_main_current_source$handle() {
        return g_main_current_source.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_main_current_source()
     * }
     */
    public static MemorySegment g_main_current_source$address() {
        return g_main_current_source.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_main_current_source()
     * }
     */
    public static MemorySegment g_main_current_source() {
        var mh$ = g_main_current_source.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_current_source");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_push_thread_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_push_thread_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_push_thread_default(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_push_thread_default$descriptor() {
        return g_main_context_push_thread_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_push_thread_default(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_push_thread_default$handle() {
        return g_main_context_push_thread_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_push_thread_default(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_push_thread_default$address() {
        return g_main_context_push_thread_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_push_thread_default(GMainContext *context)
     * }
     */
    public static void g_main_context_push_thread_default(MemorySegment context) {
        var mh$ = g_main_context_push_thread_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_push_thread_default", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_pop_thread_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_pop_thread_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_pop_thread_default(GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_main_context_pop_thread_default$descriptor() {
        return g_main_context_pop_thread_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_pop_thread_default(GMainContext *context)
     * }
     */
    public static MethodHandle g_main_context_pop_thread_default$handle() {
        return g_main_context_pop_thread_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_pop_thread_default(GMainContext *context)
     * }
     */
    public static MemorySegment g_main_context_pop_thread_default$address() {
        return g_main_context_pop_thread_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_pop_thread_default(GMainContext *context)
     * }
     */
    public static void g_main_context_pop_thread_default(MemorySegment context) {
        var mh$ = g_main_context_pop_thread_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_pop_thread_default", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_get_thread_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_get_thread_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_get_thread_default()
     * }
     */
    public static FunctionDescriptor g_main_context_get_thread_default$descriptor() {
        return g_main_context_get_thread_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_get_thread_default()
     * }
     */
    public static MethodHandle g_main_context_get_thread_default$handle() {
        return g_main_context_get_thread_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_get_thread_default()
     * }
     */
    public static MemorySegment g_main_context_get_thread_default$address() {
        return g_main_context_get_thread_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_get_thread_default()
     * }
     */
    public static MemorySegment g_main_context_get_thread_default() {
        var mh$ = g_main_context_get_thread_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_get_thread_default");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_ref_thread_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_ref_thread_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_ref_thread_default()
     * }
     */
    public static FunctionDescriptor g_main_context_ref_thread_default$descriptor() {
        return g_main_context_ref_thread_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_ref_thread_default()
     * }
     */
    public static MethodHandle g_main_context_ref_thread_default$handle() {
        return g_main_context_ref_thread_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_ref_thread_default()
     * }
     */
    public static MemorySegment g_main_context_ref_thread_default$address() {
        return g_main_context_ref_thread_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainContext *g_main_context_ref_thread_default()
     * }
     */
    public static MemorySegment g_main_context_ref_thread_default() {
        var mh$ = g_main_context_ref_thread_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_ref_thread_default");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_loop_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_loop_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainLoop *g_main_loop_new(GMainContext *context, gboolean is_running)
     * }
     */
    public static FunctionDescriptor g_main_loop_new$descriptor() {
        return g_main_loop_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainLoop *g_main_loop_new(GMainContext *context, gboolean is_running)
     * }
     */
    public static MethodHandle g_main_loop_new$handle() {
        return g_main_loop_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainLoop *g_main_loop_new(GMainContext *context, gboolean is_running)
     * }
     */
    public static MemorySegment g_main_loop_new$address() {
        return g_main_loop_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainLoop *g_main_loop_new(GMainContext *context, gboolean is_running)
     * }
     */
    public static MemorySegment g_main_loop_new(MemorySegment context, int is_running) {
        var mh$ = g_main_loop_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_loop_new", context, is_running);
            }
            return (MemorySegment)mh$.invokeExact(context, is_running);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_loop_run {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_loop_run");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_loop_run(GMainLoop *loop)
     * }
     */
    public static FunctionDescriptor g_main_loop_run$descriptor() {
        return g_main_loop_run.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_loop_run(GMainLoop *loop)
     * }
     */
    public static MethodHandle g_main_loop_run$handle() {
        return g_main_loop_run.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_loop_run(GMainLoop *loop)
     * }
     */
    public static MemorySegment g_main_loop_run$address() {
        return g_main_loop_run.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_loop_run(GMainLoop *loop)
     * }
     */
    public static void g_main_loop_run(MemorySegment loop) {
        var mh$ = g_main_loop_run.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_loop_run", loop);
            }
            mh$.invokeExact(loop);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_loop_quit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_loop_quit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_loop_quit(GMainLoop *loop)
     * }
     */
    public static FunctionDescriptor g_main_loop_quit$descriptor() {
        return g_main_loop_quit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_loop_quit(GMainLoop *loop)
     * }
     */
    public static MethodHandle g_main_loop_quit$handle() {
        return g_main_loop_quit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_loop_quit(GMainLoop *loop)
     * }
     */
    public static MemorySegment g_main_loop_quit$address() {
        return g_main_loop_quit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_loop_quit(GMainLoop *loop)
     * }
     */
    public static void g_main_loop_quit(MemorySegment loop) {
        var mh$ = g_main_loop_quit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_loop_quit", loop);
            }
            mh$.invokeExact(loop);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_loop_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_loop_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainLoop *g_main_loop_ref(GMainLoop *loop)
     * }
     */
    public static FunctionDescriptor g_main_loop_ref$descriptor() {
        return g_main_loop_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainLoop *g_main_loop_ref(GMainLoop *loop)
     * }
     */
    public static MethodHandle g_main_loop_ref$handle() {
        return g_main_loop_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainLoop *g_main_loop_ref(GMainLoop *loop)
     * }
     */
    public static MemorySegment g_main_loop_ref$address() {
        return g_main_loop_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainLoop *g_main_loop_ref(GMainLoop *loop)
     * }
     */
    public static MemorySegment g_main_loop_ref(MemorySegment loop) {
        var mh$ = g_main_loop_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_loop_ref", loop);
            }
            return (MemorySegment)mh$.invokeExact(loop);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_loop_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_loop_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_loop_unref(GMainLoop *loop)
     * }
     */
    public static FunctionDescriptor g_main_loop_unref$descriptor() {
        return g_main_loop_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_loop_unref(GMainLoop *loop)
     * }
     */
    public static MethodHandle g_main_loop_unref$handle() {
        return g_main_loop_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_loop_unref(GMainLoop *loop)
     * }
     */
    public static MemorySegment g_main_loop_unref$address() {
        return g_main_loop_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_loop_unref(GMainLoop *loop)
     * }
     */
    public static void g_main_loop_unref(MemorySegment loop) {
        var mh$ = g_main_loop_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_loop_unref", loop);
            }
            mh$.invokeExact(loop);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_loop_is_running {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_loop_is_running");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_main_loop_is_running(GMainLoop *loop)
     * }
     */
    public static FunctionDescriptor g_main_loop_is_running$descriptor() {
        return g_main_loop_is_running.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_main_loop_is_running(GMainLoop *loop)
     * }
     */
    public static MethodHandle g_main_loop_is_running$handle() {
        return g_main_loop_is_running.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_main_loop_is_running(GMainLoop *loop)
     * }
     */
    public static MemorySegment g_main_loop_is_running$address() {
        return g_main_loop_is_running.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_main_loop_is_running(GMainLoop *loop)
     * }
     */
    public static int g_main_loop_is_running(MemorySegment loop) {
        var mh$ = g_main_loop_is_running.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_loop_is_running", loop);
            }
            return (int)mh$.invokeExact(loop);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_loop_get_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_loop_get_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_loop_get_context(GMainLoop *loop)
     * }
     */
    public static FunctionDescriptor g_main_loop_get_context$descriptor() {
        return g_main_loop_get_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_loop_get_context(GMainLoop *loop)
     * }
     */
    public static MethodHandle g_main_loop_get_context$handle() {
        return g_main_loop_get_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainContext *g_main_loop_get_context(GMainLoop *loop)
     * }
     */
    public static MemorySegment g_main_loop_get_context$address() {
        return g_main_loop_get_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainContext *g_main_loop_get_context(GMainLoop *loop)
     * }
     */
    public static MemorySegment g_main_loop_get_context(MemorySegment loop) {
        var mh$ = g_main_loop_get_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_loop_get_context", loop);
            }
            return (MemorySegment)mh$.invokeExact(loop);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_source_new(GSourceFuncs *source_funcs, guint struct_size)
     * }
     */
    public static FunctionDescriptor g_source_new$descriptor() {
        return g_source_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_source_new(GSourceFuncs *source_funcs, guint struct_size)
     * }
     */
    public static MethodHandle g_source_new$handle() {
        return g_source_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_source_new(GSourceFuncs *source_funcs, guint struct_size)
     * }
     */
    public static MemorySegment g_source_new$address() {
        return g_source_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_source_new(GSourceFuncs *source_funcs, guint struct_size)
     * }
     */
    public static MemorySegment g_source_new(MemorySegment source_funcs, int struct_size) {
        var mh$ = g_source_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_new", source_funcs, struct_size);
            }
            return (MemorySegment)mh$.invokeExact(source_funcs, struct_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_dispose_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_dispose_function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_dispose_function(GSource *source, GSourceDisposeFunc dispose)
     * }
     */
    public static FunctionDescriptor g_source_set_dispose_function$descriptor() {
        return g_source_set_dispose_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_dispose_function(GSource *source, GSourceDisposeFunc dispose)
     * }
     */
    public static MethodHandle g_source_set_dispose_function$handle() {
        return g_source_set_dispose_function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_dispose_function(GSource *source, GSourceDisposeFunc dispose)
     * }
     */
    public static MemorySegment g_source_set_dispose_function$address() {
        return g_source_set_dispose_function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_dispose_function(GSource *source, GSourceDisposeFunc dispose)
     * }
     */
    public static void g_source_set_dispose_function(MemorySegment source, MemorySegment dispose) {
        var mh$ = g_source_set_dispose_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_dispose_function", source, dispose);
            }
            mh$.invokeExact(source, dispose);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_source_ref(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_ref$descriptor() {
        return g_source_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_source_ref(GSource *source)
     * }
     */
    public static MethodHandle g_source_ref$handle() {
        return g_source_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_source_ref(GSource *source)
     * }
     */
    public static MemorySegment g_source_ref$address() {
        return g_source_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_source_ref(GSource *source)
     * }
     */
    public static MemorySegment g_source_ref(MemorySegment source) {
        var mh$ = g_source_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_ref", source);
            }
            return (MemorySegment)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_unref(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_unref$descriptor() {
        return g_source_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_unref(GSource *source)
     * }
     */
    public static MethodHandle g_source_unref$handle() {
        return g_source_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_unref(GSource *source)
     * }
     */
    public static MemorySegment g_source_unref$address() {
        return g_source_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_unref(GSource *source)
     * }
     */
    public static void g_source_unref(MemorySegment source) {
        var mh$ = g_source_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_unref", source);
            }
            mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_attach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_attach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_source_attach(GSource *source, GMainContext *context)
     * }
     */
    public static FunctionDescriptor g_source_attach$descriptor() {
        return g_source_attach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_source_attach(GSource *source, GMainContext *context)
     * }
     */
    public static MethodHandle g_source_attach$handle() {
        return g_source_attach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_source_attach(GSource *source, GMainContext *context)
     * }
     */
    public static MemorySegment g_source_attach$address() {
        return g_source_attach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_source_attach(GSource *source, GMainContext *context)
     * }
     */
    public static int g_source_attach(MemorySegment source, MemorySegment context) {
        var mh$ = g_source_attach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_attach", source, context);
            }
            return (int)mh$.invokeExact(source, context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_destroy(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_destroy$descriptor() {
        return g_source_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_destroy(GSource *source)
     * }
     */
    public static MethodHandle g_source_destroy$handle() {
        return g_source_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_destroy(GSource *source)
     * }
     */
    public static MemorySegment g_source_destroy$address() {
        return g_source_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_destroy(GSource *source)
     * }
     */
    public static void g_source_destroy(MemorySegment source) {
        var mh$ = g_source_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_destroy", source);
            }
            mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_priority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_priority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_priority(GSource *source, gint priority)
     * }
     */
    public static FunctionDescriptor g_source_set_priority$descriptor() {
        return g_source_set_priority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_priority(GSource *source, gint priority)
     * }
     */
    public static MethodHandle g_source_set_priority$handle() {
        return g_source_set_priority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_priority(GSource *source, gint priority)
     * }
     */
    public static MemorySegment g_source_set_priority$address() {
        return g_source_set_priority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_priority(GSource *source, gint priority)
     * }
     */
    public static void g_source_set_priority(MemorySegment source, int priority) {
        var mh$ = g_source_set_priority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_priority", source, priority);
            }
            mh$.invokeExact(source, priority);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_priority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_priority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_source_get_priority(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_get_priority$descriptor() {
        return g_source_get_priority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_source_get_priority(GSource *source)
     * }
     */
    public static MethodHandle g_source_get_priority$handle() {
        return g_source_get_priority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_source_get_priority(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_priority$address() {
        return g_source_get_priority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_source_get_priority(GSource *source)
     * }
     */
    public static int g_source_get_priority(MemorySegment source) {
        var mh$ = g_source_get_priority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_priority", source);
            }
            return (int)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_can_recurse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_can_recurse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_can_recurse(GSource *source, gboolean can_recurse)
     * }
     */
    public static FunctionDescriptor g_source_set_can_recurse$descriptor() {
        return g_source_set_can_recurse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_can_recurse(GSource *source, gboolean can_recurse)
     * }
     */
    public static MethodHandle g_source_set_can_recurse$handle() {
        return g_source_set_can_recurse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_can_recurse(GSource *source, gboolean can_recurse)
     * }
     */
    public static MemorySegment g_source_set_can_recurse$address() {
        return g_source_set_can_recurse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_can_recurse(GSource *source, gboolean can_recurse)
     * }
     */
    public static void g_source_set_can_recurse(MemorySegment source, int can_recurse) {
        var mh$ = g_source_set_can_recurse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_can_recurse", source, can_recurse);
            }
            mh$.invokeExact(source, can_recurse);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_can_recurse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_can_recurse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_source_get_can_recurse(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_get_can_recurse$descriptor() {
        return g_source_get_can_recurse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_source_get_can_recurse(GSource *source)
     * }
     */
    public static MethodHandle g_source_get_can_recurse$handle() {
        return g_source_get_can_recurse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_source_get_can_recurse(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_can_recurse$address() {
        return g_source_get_can_recurse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_source_get_can_recurse(GSource *source)
     * }
     */
    public static int g_source_get_can_recurse(MemorySegment source) {
        var mh$ = g_source_get_can_recurse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_can_recurse", source);
            }
            return (int)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_source_get_id(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_get_id$descriptor() {
        return g_source_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_source_get_id(GSource *source)
     * }
     */
    public static MethodHandle g_source_get_id$handle() {
        return g_source_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_source_get_id(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_id$address() {
        return g_source_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_source_get_id(GSource *source)
     * }
     */
    public static int g_source_get_id(MemorySegment source) {
        var mh$ = g_source_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_id", source);
            }
            return (int)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMainContext *g_source_get_context(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_get_context$descriptor() {
        return g_source_get_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMainContext *g_source_get_context(GSource *source)
     * }
     */
    public static MethodHandle g_source_get_context$handle() {
        return g_source_get_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMainContext *g_source_get_context(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_context$address() {
        return g_source_get_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMainContext *g_source_get_context(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_context(MemorySegment source) {
        var mh$ = g_source_get_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_context", source);
            }
            return (MemorySegment)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_callback(GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_source_set_callback$descriptor() {
        return g_source_set_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_callback(GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_source_set_callback$handle() {
        return g_source_set_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_callback(GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_source_set_callback$address() {
        return g_source_set_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_callback(GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify)
     * }
     */
    public static void g_source_set_callback(MemorySegment source, MemorySegment func, MemorySegment data, MemorySegment notify) {
        var mh$ = g_source_set_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_callback", source, func, data, notify);
            }
            mh$.invokeExact(source, func, data, notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_funcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_funcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_funcs(GSource *source, GSourceFuncs *funcs)
     * }
     */
    public static FunctionDescriptor g_source_set_funcs$descriptor() {
        return g_source_set_funcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_funcs(GSource *source, GSourceFuncs *funcs)
     * }
     */
    public static MethodHandle g_source_set_funcs$handle() {
        return g_source_set_funcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_funcs(GSource *source, GSourceFuncs *funcs)
     * }
     */
    public static MemorySegment g_source_set_funcs$address() {
        return g_source_set_funcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_funcs(GSource *source, GSourceFuncs *funcs)
     * }
     */
    public static void g_source_set_funcs(MemorySegment source, MemorySegment funcs) {
        var mh$ = g_source_set_funcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_funcs", source, funcs);
            }
            mh$.invokeExact(source, funcs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_is_destroyed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_is_destroyed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_source_is_destroyed(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_is_destroyed$descriptor() {
        return g_source_is_destroyed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_source_is_destroyed(GSource *source)
     * }
     */
    public static MethodHandle g_source_is_destroyed$handle() {
        return g_source_is_destroyed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_source_is_destroyed(GSource *source)
     * }
     */
    public static MemorySegment g_source_is_destroyed$address() {
        return g_source_is_destroyed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_source_is_destroyed(GSource *source)
     * }
     */
    public static int g_source_is_destroyed(MemorySegment source) {
        var mh$ = g_source_is_destroyed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_is_destroyed", source);
            }
            return (int)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_name(GSource *source, const char *name)
     * }
     */
    public static FunctionDescriptor g_source_set_name$descriptor() {
        return g_source_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_name(GSource *source, const char *name)
     * }
     */
    public static MethodHandle g_source_set_name$handle() {
        return g_source_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_name(GSource *source, const char *name)
     * }
     */
    public static MemorySegment g_source_set_name$address() {
        return g_source_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_name(GSource *source, const char *name)
     * }
     */
    public static void g_source_set_name(MemorySegment source, MemorySegment name) {
        var mh$ = g_source_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_name", source, name);
            }
            mh$.invokeExact(source, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_static_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_static_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_static_name(GSource *source, const char *name)
     * }
     */
    public static FunctionDescriptor g_source_set_static_name$descriptor() {
        return g_source_set_static_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_static_name(GSource *source, const char *name)
     * }
     */
    public static MethodHandle g_source_set_static_name$handle() {
        return g_source_set_static_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_static_name(GSource *source, const char *name)
     * }
     */
    public static MemorySegment g_source_set_static_name$address() {
        return g_source_set_static_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_static_name(GSource *source, const char *name)
     * }
     */
    public static void g_source_set_static_name(MemorySegment source, MemorySegment name) {
        var mh$ = g_source_set_static_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_static_name", source, name);
            }
            mh$.invokeExact(source, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *g_source_get_name(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_get_name$descriptor() {
        return g_source_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *g_source_get_name(GSource *source)
     * }
     */
    public static MethodHandle g_source_get_name$handle() {
        return g_source_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *g_source_get_name(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_name$address() {
        return g_source_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *g_source_get_name(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_name(MemorySegment source) {
        var mh$ = g_source_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_name", source);
            }
            return (MemorySegment)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_name_by_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_name_by_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_name_by_id(guint tag, const char *name)
     * }
     */
    public static FunctionDescriptor g_source_set_name_by_id$descriptor() {
        return g_source_set_name_by_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_name_by_id(guint tag, const char *name)
     * }
     */
    public static MethodHandle g_source_set_name_by_id$handle() {
        return g_source_set_name_by_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_name_by_id(guint tag, const char *name)
     * }
     */
    public static MemorySegment g_source_set_name_by_id$address() {
        return g_source_set_name_by_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_name_by_id(guint tag, const char *name)
     * }
     */
    public static void g_source_set_name_by_id(int tag, MemorySegment name) {
        var mh$ = g_source_set_name_by_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_name_by_id", tag, name);
            }
            mh$.invokeExact(tag, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_ready_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_ready_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_ready_time(GSource *source, gint64 ready_time)
     * }
     */
    public static FunctionDescriptor g_source_set_ready_time$descriptor() {
        return g_source_set_ready_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_ready_time(GSource *source, gint64 ready_time)
     * }
     */
    public static MethodHandle g_source_set_ready_time$handle() {
        return g_source_set_ready_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_ready_time(GSource *source, gint64 ready_time)
     * }
     */
    public static MemorySegment g_source_set_ready_time$address() {
        return g_source_set_ready_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_ready_time(GSource *source, gint64 ready_time)
     * }
     */
    public static void g_source_set_ready_time(MemorySegment source, long ready_time) {
        var mh$ = g_source_set_ready_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_ready_time", source, ready_time);
            }
            mh$.invokeExact(source, ready_time);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_ready_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_ready_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_source_get_ready_time(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_get_ready_time$descriptor() {
        return g_source_get_ready_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_source_get_ready_time(GSource *source)
     * }
     */
    public static MethodHandle g_source_get_ready_time$handle() {
        return g_source_get_ready_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_source_get_ready_time(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_ready_time$address() {
        return g_source_get_ready_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_source_get_ready_time(GSource *source)
     * }
     */
    public static long g_source_get_ready_time(MemorySegment source) {
        var mh$ = g_source_get_ready_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_ready_time", source);
            }
            return (long)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_set_callback_indirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_set_callback_indirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_set_callback_indirect(GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs)
     * }
     */
    public static FunctionDescriptor g_source_set_callback_indirect$descriptor() {
        return g_source_set_callback_indirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_set_callback_indirect(GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs)
     * }
     */
    public static MethodHandle g_source_set_callback_indirect$handle() {
        return g_source_set_callback_indirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_set_callback_indirect(GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs)
     * }
     */
    public static MemorySegment g_source_set_callback_indirect$address() {
        return g_source_set_callback_indirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_set_callback_indirect(GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs)
     * }
     */
    public static void g_source_set_callback_indirect(MemorySegment source, MemorySegment callback_data, MemorySegment callback_funcs) {
        var mh$ = g_source_set_callback_indirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_set_callback_indirect", source, callback_data, callback_funcs);
            }
            mh$.invokeExact(source, callback_data, callback_funcs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_add_poll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_add_poll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_add_poll(GSource *source, GPollFD *fd)
     * }
     */
    public static FunctionDescriptor g_source_add_poll$descriptor() {
        return g_source_add_poll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_add_poll(GSource *source, GPollFD *fd)
     * }
     */
    public static MethodHandle g_source_add_poll$handle() {
        return g_source_add_poll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_add_poll(GSource *source, GPollFD *fd)
     * }
     */
    public static MemorySegment g_source_add_poll$address() {
        return g_source_add_poll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_add_poll(GSource *source, GPollFD *fd)
     * }
     */
    public static void g_source_add_poll(MemorySegment source, MemorySegment fd) {
        var mh$ = g_source_add_poll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_add_poll", source, fd);
            }
            mh$.invokeExact(source, fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_remove_poll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_remove_poll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_remove_poll(GSource *source, GPollFD *fd)
     * }
     */
    public static FunctionDescriptor g_source_remove_poll$descriptor() {
        return g_source_remove_poll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_remove_poll(GSource *source, GPollFD *fd)
     * }
     */
    public static MethodHandle g_source_remove_poll$handle() {
        return g_source_remove_poll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_remove_poll(GSource *source, GPollFD *fd)
     * }
     */
    public static MemorySegment g_source_remove_poll$address() {
        return g_source_remove_poll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_remove_poll(GSource *source, GPollFD *fd)
     * }
     */
    public static void g_source_remove_poll(MemorySegment source, MemorySegment fd) {
        var mh$ = g_source_remove_poll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_remove_poll", source, fd);
            }
            mh$.invokeExact(source, fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_add_child_source {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_add_child_source");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_add_child_source(GSource *source, GSource *child_source)
     * }
     */
    public static FunctionDescriptor g_source_add_child_source$descriptor() {
        return g_source_add_child_source.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_add_child_source(GSource *source, GSource *child_source)
     * }
     */
    public static MethodHandle g_source_add_child_source$handle() {
        return g_source_add_child_source.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_add_child_source(GSource *source, GSource *child_source)
     * }
     */
    public static MemorySegment g_source_add_child_source$address() {
        return g_source_add_child_source.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_add_child_source(GSource *source, GSource *child_source)
     * }
     */
    public static void g_source_add_child_source(MemorySegment source, MemorySegment child_source) {
        var mh$ = g_source_add_child_source.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_add_child_source", source, child_source);
            }
            mh$.invokeExact(source, child_source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_remove_child_source {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_remove_child_source");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_remove_child_source(GSource *source, GSource *child_source)
     * }
     */
    public static FunctionDescriptor g_source_remove_child_source$descriptor() {
        return g_source_remove_child_source.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_remove_child_source(GSource *source, GSource *child_source)
     * }
     */
    public static MethodHandle g_source_remove_child_source$handle() {
        return g_source_remove_child_source.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_remove_child_source(GSource *source, GSource *child_source)
     * }
     */
    public static MemorySegment g_source_remove_child_source$address() {
        return g_source_remove_child_source.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_remove_child_source(GSource *source, GSource *child_source)
     * }
     */
    public static void g_source_remove_child_source(MemorySegment source, MemorySegment child_source) {
        var mh$ = g_source_remove_child_source.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_remove_child_source", source, child_source);
            }
            mh$.invokeExact(source, child_source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_current_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_current_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_source_get_current_time(GSource *source, GTimeVal *timeval)
     * }
     */
    public static FunctionDescriptor g_source_get_current_time$descriptor() {
        return g_source_get_current_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_source_get_current_time(GSource *source, GTimeVal *timeval)
     * }
     */
    public static MethodHandle g_source_get_current_time$handle() {
        return g_source_get_current_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_source_get_current_time(GSource *source, GTimeVal *timeval)
     * }
     */
    public static MemorySegment g_source_get_current_time$address() {
        return g_source_get_current_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_source_get_current_time(GSource *source, GTimeVal *timeval)
     * }
     */
    public static void g_source_get_current_time(MemorySegment source, MemorySegment timeval) {
        var mh$ = g_source_get_current_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_current_time", source, timeval);
            }
            mh$.invokeExact(source, timeval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_get_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_get_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_source_get_time(GSource *source)
     * }
     */
    public static FunctionDescriptor g_source_get_time$descriptor() {
        return g_source_get_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_source_get_time(GSource *source)
     * }
     */
    public static MethodHandle g_source_get_time$handle() {
        return g_source_get_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_source_get_time(GSource *source)
     * }
     */
    public static MemorySegment g_source_get_time$address() {
        return g_source_get_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_source_get_time(GSource *source)
     * }
     */
    public static long g_source_get_time(MemorySegment source) {
        var mh$ = g_source_get_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_get_time", source);
            }
            return (long)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_idle_source_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_idle_source_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_idle_source_new()
     * }
     */
    public static FunctionDescriptor g_idle_source_new$descriptor() {
        return g_idle_source_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_idle_source_new()
     * }
     */
    public static MethodHandle g_idle_source_new$handle() {
        return g_idle_source_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_idle_source_new()
     * }
     */
    public static MemorySegment g_idle_source_new$address() {
        return g_idle_source_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_idle_source_new()
     * }
     */
    public static MemorySegment g_idle_source_new() {
        var mh$ = g_idle_source_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_idle_source_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_child_watch_source_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_child_watch_source_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_child_watch_source_new(GPid pid)
     * }
     */
    public static FunctionDescriptor g_child_watch_source_new$descriptor() {
        return g_child_watch_source_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_child_watch_source_new(GPid pid)
     * }
     */
    public static MethodHandle g_child_watch_source_new$handle() {
        return g_child_watch_source_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_child_watch_source_new(GPid pid)
     * }
     */
    public static MemorySegment g_child_watch_source_new$address() {
        return g_child_watch_source_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_child_watch_source_new(GPid pid)
     * }
     */
    public static MemorySegment g_child_watch_source_new(MemorySegment pid) {
        var mh$ = g_child_watch_source_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_child_watch_source_new", pid);
            }
            return (MemorySegment)mh$.invokeExact(pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_source_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timeout_source_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_timeout_source_new(guint interval)
     * }
     */
    public static FunctionDescriptor g_timeout_source_new$descriptor() {
        return g_timeout_source_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_timeout_source_new(guint interval)
     * }
     */
    public static MethodHandle g_timeout_source_new$handle() {
        return g_timeout_source_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_timeout_source_new(guint interval)
     * }
     */
    public static MemorySegment g_timeout_source_new$address() {
        return g_timeout_source_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_timeout_source_new(guint interval)
     * }
     */
    public static MemorySegment g_timeout_source_new(int interval) {
        var mh$ = g_timeout_source_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timeout_source_new", interval);
            }
            return (MemorySegment)mh$.invokeExact(interval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_source_new_seconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timeout_source_new_seconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_timeout_source_new_seconds(guint interval)
     * }
     */
    public static FunctionDescriptor g_timeout_source_new_seconds$descriptor() {
        return g_timeout_source_new_seconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_timeout_source_new_seconds(guint interval)
     * }
     */
    public static MethodHandle g_timeout_source_new_seconds$handle() {
        return g_timeout_source_new_seconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_timeout_source_new_seconds(guint interval)
     * }
     */
    public static MemorySegment g_timeout_source_new_seconds$address() {
        return g_timeout_source_new_seconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_timeout_source_new_seconds(guint interval)
     * }
     */
    public static MemorySegment g_timeout_source_new_seconds(int interval) {
        var mh$ = g_timeout_source_new_seconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timeout_source_new_seconds", interval);
            }
            return (MemorySegment)mh$.invokeExact(interval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_current_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_current_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_get_current_time(GTimeVal *result)
     * }
     */
    public static FunctionDescriptor g_get_current_time$descriptor() {
        return g_get_current_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_get_current_time(GTimeVal *result)
     * }
     */
    public static MethodHandle g_get_current_time$handle() {
        return g_get_current_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_get_current_time(GTimeVal *result)
     * }
     */
    public static MemorySegment g_get_current_time$address() {
        return g_get_current_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_get_current_time(GTimeVal *result)
     * }
     */
    public static void g_get_current_time(MemorySegment result) {
        var mh$ = g_get_current_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_current_time", result);
            }
            mh$.invokeExact(result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_monotonic_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_monotonic_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_get_monotonic_time()
     * }
     */
    public static FunctionDescriptor g_get_monotonic_time$descriptor() {
        return g_get_monotonic_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_get_monotonic_time()
     * }
     */
    public static MethodHandle g_get_monotonic_time$handle() {
        return g_get_monotonic_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_get_monotonic_time()
     * }
     */
    public static MemorySegment g_get_monotonic_time$address() {
        return g_get_monotonic_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_get_monotonic_time()
     * }
     */
    public static long g_get_monotonic_time() {
        var mh$ = g_get_monotonic_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_monotonic_time");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_get_real_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_get_real_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_get_real_time()
     * }
     */
    public static FunctionDescriptor g_get_real_time$descriptor() {
        return g_get_real_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_get_real_time()
     * }
     */
    public static MethodHandle g_get_real_time$handle() {
        return g_get_real_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_get_real_time()
     * }
     */
    public static MemorySegment g_get_real_time$address() {
        return g_get_real_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_get_real_time()
     * }
     */
    public static long g_get_real_time() {
        var mh$ = g_get_real_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_get_real_time");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove(guint tag)
     * }
     */
    public static FunctionDescriptor g_source_remove$descriptor() {
        return g_source_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove(guint tag)
     * }
     */
    public static MethodHandle g_source_remove$handle() {
        return g_source_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove(guint tag)
     * }
     */
    public static MemorySegment g_source_remove$address() {
        return g_source_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_source_remove(guint tag)
     * }
     */
    public static int g_source_remove(int tag) {
        var mh$ = g_source_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_remove", tag);
            }
            return (int)mh$.invokeExact(tag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_remove_by_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_remove_by_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove_by_user_data(gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_source_remove_by_user_data$descriptor() {
        return g_source_remove_by_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove_by_user_data(gpointer user_data)
     * }
     */
    public static MethodHandle g_source_remove_by_user_data$handle() {
        return g_source_remove_by_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove_by_user_data(gpointer user_data)
     * }
     */
    public static MemorySegment g_source_remove_by_user_data$address() {
        return g_source_remove_by_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_source_remove_by_user_data(gpointer user_data)
     * }
     */
    public static int g_source_remove_by_user_data(MemorySegment user_data) {
        var mh$ = g_source_remove_by_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_remove_by_user_data", user_data);
            }
            return (int)mh$.invokeExact(user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_source_remove_by_funcs_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_source_remove_by_funcs_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_source_remove_by_funcs_user_data$descriptor() {
        return g_source_remove_by_funcs_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs, gpointer user_data)
     * }
     */
    public static MethodHandle g_source_remove_by_funcs_user_data$handle() {
        return g_source_remove_by_funcs_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs, gpointer user_data)
     * }
     */
    public static MemorySegment g_source_remove_by_funcs_user_data$address() {
        return g_source_remove_by_funcs_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs, gpointer user_data)
     * }
     */
    public static int g_source_remove_by_funcs_user_data(MemorySegment funcs, MemorySegment user_data) {
        var mh$ = g_source_remove_by_funcs_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_source_remove_by_funcs_user_data", funcs, user_data);
            }
            return (int)mh$.invokeExact(funcs, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_clear_handle_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_clear_handle_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_clear_handle_id(guint *tag_ptr, GClearHandleFunc clear_func)
     * }
     */
    public static FunctionDescriptor g_clear_handle_id$descriptor() {
        return g_clear_handle_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_clear_handle_id(guint *tag_ptr, GClearHandleFunc clear_func)
     * }
     */
    public static MethodHandle g_clear_handle_id$handle() {
        return g_clear_handle_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_clear_handle_id(guint *tag_ptr, GClearHandleFunc clear_func)
     * }
     */
    public static MemorySegment g_clear_handle_id$address() {
        return g_clear_handle_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_clear_handle_id(guint *tag_ptr, GClearHandleFunc clear_func)
     * }
     */
    public static void g_clear_handle_id(MemorySegment tag_ptr, MemorySegment clear_func) {
        var mh$ = g_clear_handle_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_clear_handle_id", tag_ptr, clear_func);
            }
            mh$.invokeExact(tag_ptr, clear_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_add_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timeout_add_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_timeout_add_full$descriptor() {
        return g_timeout_add_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_timeout_add_full$handle() {
        return g_timeout_add_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_timeout_add_full$address() {
        return g_timeout_add_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_timeout_add_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static int g_timeout_add_full(int priority, int interval, MemorySegment function, MemorySegment data, MemorySegment notify) {
        var mh$ = g_timeout_add_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timeout_add_full", priority, interval, function, data, notify);
            }
            return (int)mh$.invokeExact(priority, interval, function, data, notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timeout_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_timeout_add(guint interval, GSourceFunc function, gpointer data)
     * }
     */
    public static FunctionDescriptor g_timeout_add$descriptor() {
        return g_timeout_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_timeout_add(guint interval, GSourceFunc function, gpointer data)
     * }
     */
    public static MethodHandle g_timeout_add$handle() {
        return g_timeout_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_timeout_add(guint interval, GSourceFunc function, gpointer data)
     * }
     */
    public static MemorySegment g_timeout_add$address() {
        return g_timeout_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_timeout_add(guint interval, GSourceFunc function, gpointer data)
     * }
     */
    public static int g_timeout_add(int interval, MemorySegment function, MemorySegment data) {
        var mh$ = g_timeout_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timeout_add", interval, function, data);
            }
            return (int)mh$.invokeExact(interval, function, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_add_once {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timeout_add_once");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_once(guint interval, GSourceOnceFunc function, gpointer data)
     * }
     */
    public static FunctionDescriptor g_timeout_add_once$descriptor() {
        return g_timeout_add_once.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_once(guint interval, GSourceOnceFunc function, gpointer data)
     * }
     */
    public static MethodHandle g_timeout_add_once$handle() {
        return g_timeout_add_once.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_once(guint interval, GSourceOnceFunc function, gpointer data)
     * }
     */
    public static MemorySegment g_timeout_add_once$address() {
        return g_timeout_add_once.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_timeout_add_once(guint interval, GSourceOnceFunc function, gpointer data)
     * }
     */
    public static int g_timeout_add_once(int interval, MemorySegment function, MemorySegment data) {
        var mh$ = g_timeout_add_once.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timeout_add_once", interval, function, data);
            }
            return (int)mh$.invokeExact(interval, function, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_add_seconds_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timeout_add_seconds_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_timeout_add_seconds_full$descriptor() {
        return g_timeout_add_seconds_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_timeout_add_seconds_full$handle() {
        return g_timeout_add_seconds_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_timeout_add_seconds_full$address() {
        return g_timeout_add_seconds_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static int g_timeout_add_seconds_full(int priority, int interval, MemorySegment function, MemorySegment data, MemorySegment notify) {
        var mh$ = g_timeout_add_seconds_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timeout_add_seconds_full", priority, interval, function, data, notify);
            }
            return (int)mh$.invokeExact(priority, interval, function, data, notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_add_seconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timeout_add_seconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds(guint interval, GSourceFunc function, gpointer data)
     * }
     */
    public static FunctionDescriptor g_timeout_add_seconds$descriptor() {
        return g_timeout_add_seconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds(guint interval, GSourceFunc function, gpointer data)
     * }
     */
    public static MethodHandle g_timeout_add_seconds$handle() {
        return g_timeout_add_seconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds(guint interval, GSourceFunc function, gpointer data)
     * }
     */
    public static MemorySegment g_timeout_add_seconds$address() {
        return g_timeout_add_seconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds(guint interval, GSourceFunc function, gpointer data)
     * }
     */
    public static int g_timeout_add_seconds(int interval, MemorySegment function, MemorySegment data) {
        var mh$ = g_timeout_add_seconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timeout_add_seconds", interval, function, data);
            }
            return (int)mh$.invokeExact(interval, function, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_add_seconds_once {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_timeout_add_seconds_once");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds_once(guint interval, GSourceOnceFunc function, gpointer data)
     * }
     */
    public static FunctionDescriptor g_timeout_add_seconds_once$descriptor() {
        return g_timeout_add_seconds_once.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds_once(guint interval, GSourceOnceFunc function, gpointer data)
     * }
     */
    public static MethodHandle g_timeout_add_seconds_once$handle() {
        return g_timeout_add_seconds_once.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds_once(guint interval, GSourceOnceFunc function, gpointer data)
     * }
     */
    public static MemorySegment g_timeout_add_seconds_once$address() {
        return g_timeout_add_seconds_once.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_timeout_add_seconds_once(guint interval, GSourceOnceFunc function, gpointer data)
     * }
     */
    public static int g_timeout_add_seconds_once(int interval, MemorySegment function, MemorySegment data) {
        var mh$ = g_timeout_add_seconds_once.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_timeout_add_seconds_once", interval, function, data);
            }
            return (int)mh$.invokeExact(interval, function, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_child_watch_add_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_child_watch_add_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_child_watch_add_full(gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_child_watch_add_full$descriptor() {
        return g_child_watch_add_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_child_watch_add_full(gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_child_watch_add_full$handle() {
        return g_child_watch_add_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_child_watch_add_full(gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_child_watch_add_full$address() {
        return g_child_watch_add_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_child_watch_add_full(gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static int g_child_watch_add_full(int priority, MemorySegment pid, MemorySegment function, MemorySegment data, MemorySegment notify) {
        var mh$ = g_child_watch_add_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_child_watch_add_full", priority, pid, function, data, notify);
            }
            return (int)mh$.invokeExact(priority, pid, function, data, notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_child_watch_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_child_watch_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_child_watch_add(GPid pid, GChildWatchFunc function, gpointer data)
     * }
     */
    public static FunctionDescriptor g_child_watch_add$descriptor() {
        return g_child_watch_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_child_watch_add(GPid pid, GChildWatchFunc function, gpointer data)
     * }
     */
    public static MethodHandle g_child_watch_add$handle() {
        return g_child_watch_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_child_watch_add(GPid pid, GChildWatchFunc function, gpointer data)
     * }
     */
    public static MemorySegment g_child_watch_add$address() {
        return g_child_watch_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_child_watch_add(GPid pid, GChildWatchFunc function, gpointer data)
     * }
     */
    public static int g_child_watch_add(MemorySegment pid, MemorySegment function, MemorySegment data) {
        var mh$ = g_child_watch_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_child_watch_add", pid, function, data);
            }
            return (int)mh$.invokeExact(pid, function, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_idle_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_idle_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_idle_add(GSourceFunc function, gpointer data)
     * }
     */
    public static FunctionDescriptor g_idle_add$descriptor() {
        return g_idle_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_idle_add(GSourceFunc function, gpointer data)
     * }
     */
    public static MethodHandle g_idle_add$handle() {
        return g_idle_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_idle_add(GSourceFunc function, gpointer data)
     * }
     */
    public static MemorySegment g_idle_add$address() {
        return g_idle_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_idle_add(GSourceFunc function, gpointer data)
     * }
     */
    public static int g_idle_add(MemorySegment function, MemorySegment data) {
        var mh$ = g_idle_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_idle_add", function, data);
            }
            return (int)mh$.invokeExact(function, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_idle_add_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_idle_add_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_idle_add_full(gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_idle_add_full$descriptor() {
        return g_idle_add_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_idle_add_full(gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_idle_add_full$handle() {
        return g_idle_add_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_idle_add_full(gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_idle_add_full$address() {
        return g_idle_add_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_idle_add_full(gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static int g_idle_add_full(int priority, MemorySegment function, MemorySegment data, MemorySegment notify) {
        var mh$ = g_idle_add_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_idle_add_full", priority, function, data, notify);
            }
            return (int)mh$.invokeExact(priority, function, data, notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_idle_add_once {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_idle_add_once");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_idle_add_once(GSourceOnceFunc function, gpointer data)
     * }
     */
    public static FunctionDescriptor g_idle_add_once$descriptor() {
        return g_idle_add_once.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_idle_add_once(GSourceOnceFunc function, gpointer data)
     * }
     */
    public static MethodHandle g_idle_add_once$handle() {
        return g_idle_add_once.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_idle_add_once(GSourceOnceFunc function, gpointer data)
     * }
     */
    public static MemorySegment g_idle_add_once$address() {
        return g_idle_add_once.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_idle_add_once(GSourceOnceFunc function, gpointer data)
     * }
     */
    public static int g_idle_add_once(MemorySegment function, MemorySegment data) {
        var mh$ = g_idle_add_once.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_idle_add_once", function, data);
            }
            return (int)mh$.invokeExact(function, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_idle_remove_by_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_idle_remove_by_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_idle_remove_by_data(gpointer data)
     * }
     */
    public static FunctionDescriptor g_idle_remove_by_data$descriptor() {
        return g_idle_remove_by_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_idle_remove_by_data(gpointer data)
     * }
     */
    public static MethodHandle g_idle_remove_by_data$handle() {
        return g_idle_remove_by_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_idle_remove_by_data(gpointer data)
     * }
     */
    public static MemorySegment g_idle_remove_by_data$address() {
        return g_idle_remove_by_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_idle_remove_by_data(gpointer data)
     * }
     */
    public static int g_idle_remove_by_data(MemorySegment data) {
        var mh$ = g_idle_remove_by_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_idle_remove_by_data", data);
            }
            return (int)mh$.invokeExact(data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_invoke_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_invoke_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_invoke_full(GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_main_context_invoke_full$descriptor() {
        return g_main_context_invoke_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_invoke_full(GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_main_context_invoke_full$handle() {
        return g_main_context_invoke_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_invoke_full(GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_main_context_invoke_full$address() {
        return g_main_context_invoke_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_invoke_full(GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify)
     * }
     */
    public static void g_main_context_invoke_full(MemorySegment context, int priority, MemorySegment function, MemorySegment data, MemorySegment notify) {
        var mh$ = g_main_context_invoke_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_invoke_full", context, priority, function, data, notify);
            }
            mh$.invokeExact(context, priority, function, data, notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_main_context_invoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_main_context_invoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_main_context_invoke(GMainContext *context, GSourceFunc function, gpointer data)
     * }
     */
    public static FunctionDescriptor g_main_context_invoke$descriptor() {
        return g_main_context_invoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_main_context_invoke(GMainContext *context, GSourceFunc function, gpointer data)
     * }
     */
    public static MethodHandle g_main_context_invoke$handle() {
        return g_main_context_invoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_main_context_invoke(GMainContext *context, GSourceFunc function, gpointer data)
     * }
     */
    public static MemorySegment g_main_context_invoke$address() {
        return g_main_context_invoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_main_context_invoke(GMainContext *context, GSourceFunc function, gpointer data)
     * }
     */
    public static void g_main_context_invoke(MemorySegment context, MemorySegment function, MemorySegment data) {
        var mh$ = g_main_context_invoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_main_context_invoke", context, function, data);
            }
            mh$.invokeExact(context, function, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_timeout_funcs$constants {
        public static final GroupLayout LAYOUT = _GSourceFuncs.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_timeout_funcs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_timeout_funcs
     * }
     */
    public static GroupLayout g_timeout_funcs$layout() {
        return g_timeout_funcs$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_timeout_funcs
     * }
     */
    public static MemorySegment g_timeout_funcs() {
        return g_timeout_funcs$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_timeout_funcs
     * }
     */
    public static void g_timeout_funcs(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, g_timeout_funcs$constants.SEGMENT, 0L, g_timeout_funcs$constants.LAYOUT.byteSize());
    }

    private static class g_child_watch_funcs$constants {
        public static final GroupLayout LAYOUT = _GSourceFuncs.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_child_watch_funcs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_child_watch_funcs
     * }
     */
    public static GroupLayout g_child_watch_funcs$layout() {
        return g_child_watch_funcs$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_child_watch_funcs
     * }
     */
    public static MemorySegment g_child_watch_funcs() {
        return g_child_watch_funcs$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_child_watch_funcs
     * }
     */
    public static void g_child_watch_funcs(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, g_child_watch_funcs$constants.SEGMENT, 0L, g_child_watch_funcs$constants.LAYOUT.byteSize());
    }

    private static class g_idle_funcs$constants {
        public static final GroupLayout LAYOUT = _GSourceFuncs.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_idle_funcs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_idle_funcs
     * }
     */
    public static GroupLayout g_idle_funcs$layout() {
        return g_idle_funcs$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_idle_funcs
     * }
     */
    public static MemorySegment g_idle_funcs() {
        return g_idle_funcs$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_idle_funcs
     * }
     */
    public static void g_idle_funcs(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, g_idle_funcs$constants.SEGMENT, 0L, g_idle_funcs$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef guint32 gunichar
     * }
     */
    public static final OfInt gunichar = gst_min_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef guint16 gunichar2
     * }
     */
    public static final OfShort gunichar2 = gst_min_h.C_SHORT;
    private static final int G_UNICODE_CONTROL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_CONTROL = 0
     * }
     */
    public static int G_UNICODE_CONTROL() {
        return G_UNICODE_CONTROL;
    }
    private static final int G_UNICODE_FORMAT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_FORMAT = 1
     * }
     */
    public static int G_UNICODE_FORMAT() {
        return G_UNICODE_FORMAT;
    }
    private static final int G_UNICODE_UNASSIGNED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_UNASSIGNED = 2
     * }
     */
    public static int G_UNICODE_UNASSIGNED() {
        return G_UNICODE_UNASSIGNED;
    }
    private static final int G_UNICODE_PRIVATE_USE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_PRIVATE_USE = 3
     * }
     */
    public static int G_UNICODE_PRIVATE_USE() {
        return G_UNICODE_PRIVATE_USE;
    }
    private static final int G_UNICODE_SURROGATE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SURROGATE = 4
     * }
     */
    public static int G_UNICODE_SURROGATE() {
        return G_UNICODE_SURROGATE;
    }
    private static final int G_UNICODE_LOWERCASE_LETTER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_LOWERCASE_LETTER = 5
     * }
     */
    public static int G_UNICODE_LOWERCASE_LETTER() {
        return G_UNICODE_LOWERCASE_LETTER;
    }
    private static final int G_UNICODE_MODIFIER_LETTER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_MODIFIER_LETTER = 6
     * }
     */
    public static int G_UNICODE_MODIFIER_LETTER() {
        return G_UNICODE_MODIFIER_LETTER;
    }
    private static final int G_UNICODE_OTHER_LETTER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_OTHER_LETTER = 7
     * }
     */
    public static int G_UNICODE_OTHER_LETTER() {
        return G_UNICODE_OTHER_LETTER;
    }
    private static final int G_UNICODE_TITLECASE_LETTER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_TITLECASE_LETTER = 8
     * }
     */
    public static int G_UNICODE_TITLECASE_LETTER() {
        return G_UNICODE_TITLECASE_LETTER;
    }
    private static final int G_UNICODE_UPPERCASE_LETTER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_UPPERCASE_LETTER = 9
     * }
     */
    public static int G_UNICODE_UPPERCASE_LETTER() {
        return G_UNICODE_UPPERCASE_LETTER;
    }
    private static final int G_UNICODE_SPACING_MARK = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SPACING_MARK = 10
     * }
     */
    public static int G_UNICODE_SPACING_MARK() {
        return G_UNICODE_SPACING_MARK;
    }
    private static final int G_UNICODE_ENCLOSING_MARK = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_ENCLOSING_MARK = 11
     * }
     */
    public static int G_UNICODE_ENCLOSING_MARK() {
        return G_UNICODE_ENCLOSING_MARK;
    }
    private static final int G_UNICODE_NON_SPACING_MARK = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_NON_SPACING_MARK = 12
     * }
     */
    public static int G_UNICODE_NON_SPACING_MARK() {
        return G_UNICODE_NON_SPACING_MARK;
    }
    private static final int G_UNICODE_DECIMAL_NUMBER = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_DECIMAL_NUMBER = 13
     * }
     */
    public static int G_UNICODE_DECIMAL_NUMBER() {
        return G_UNICODE_DECIMAL_NUMBER;
    }
    private static final int G_UNICODE_LETTER_NUMBER = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_LETTER_NUMBER = 14
     * }
     */
    public static int G_UNICODE_LETTER_NUMBER() {
        return G_UNICODE_LETTER_NUMBER;
    }
    private static final int G_UNICODE_OTHER_NUMBER = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_OTHER_NUMBER = 15
     * }
     */
    public static int G_UNICODE_OTHER_NUMBER() {
        return G_UNICODE_OTHER_NUMBER;
    }
    private static final int G_UNICODE_CONNECT_PUNCTUATION = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_CONNECT_PUNCTUATION = 16
     * }
     */
    public static int G_UNICODE_CONNECT_PUNCTUATION() {
        return G_UNICODE_CONNECT_PUNCTUATION;
    }
    private static final int G_UNICODE_DASH_PUNCTUATION = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_DASH_PUNCTUATION = 17
     * }
     */
    public static int G_UNICODE_DASH_PUNCTUATION() {
        return G_UNICODE_DASH_PUNCTUATION;
    }
    private static final int G_UNICODE_CLOSE_PUNCTUATION = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_CLOSE_PUNCTUATION = 18
     * }
     */
    public static int G_UNICODE_CLOSE_PUNCTUATION() {
        return G_UNICODE_CLOSE_PUNCTUATION;
    }
    private static final int G_UNICODE_FINAL_PUNCTUATION = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_FINAL_PUNCTUATION = 19
     * }
     */
    public static int G_UNICODE_FINAL_PUNCTUATION() {
        return G_UNICODE_FINAL_PUNCTUATION;
    }
    private static final int G_UNICODE_INITIAL_PUNCTUATION = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_INITIAL_PUNCTUATION = 20
     * }
     */
    public static int G_UNICODE_INITIAL_PUNCTUATION() {
        return G_UNICODE_INITIAL_PUNCTUATION;
    }
    private static final int G_UNICODE_OTHER_PUNCTUATION = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_OTHER_PUNCTUATION = 21
     * }
     */
    public static int G_UNICODE_OTHER_PUNCTUATION() {
        return G_UNICODE_OTHER_PUNCTUATION;
    }
    private static final int G_UNICODE_OPEN_PUNCTUATION = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_OPEN_PUNCTUATION = 22
     * }
     */
    public static int G_UNICODE_OPEN_PUNCTUATION() {
        return G_UNICODE_OPEN_PUNCTUATION;
    }
    private static final int G_UNICODE_CURRENCY_SYMBOL = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_CURRENCY_SYMBOL = 23
     * }
     */
    public static int G_UNICODE_CURRENCY_SYMBOL() {
        return G_UNICODE_CURRENCY_SYMBOL;
    }
    private static final int G_UNICODE_MODIFIER_SYMBOL = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_MODIFIER_SYMBOL = 24
     * }
     */
    public static int G_UNICODE_MODIFIER_SYMBOL() {
        return G_UNICODE_MODIFIER_SYMBOL;
    }
    private static final int G_UNICODE_MATH_SYMBOL = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_MATH_SYMBOL = 25
     * }
     */
    public static int G_UNICODE_MATH_SYMBOL() {
        return G_UNICODE_MATH_SYMBOL;
    }
    private static final int G_UNICODE_OTHER_SYMBOL = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_OTHER_SYMBOL = 26
     * }
     */
    public static int G_UNICODE_OTHER_SYMBOL() {
        return G_UNICODE_OTHER_SYMBOL;
    }
    private static final int G_UNICODE_LINE_SEPARATOR = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_LINE_SEPARATOR = 27
     * }
     */
    public static int G_UNICODE_LINE_SEPARATOR() {
        return G_UNICODE_LINE_SEPARATOR;
    }
    private static final int G_UNICODE_PARAGRAPH_SEPARATOR = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_PARAGRAPH_SEPARATOR = 28
     * }
     */
    public static int G_UNICODE_PARAGRAPH_SEPARATOR() {
        return G_UNICODE_PARAGRAPH_SEPARATOR;
    }
    private static final int G_UNICODE_SPACE_SEPARATOR = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SPACE_SEPARATOR = 29
     * }
     */
    public static int G_UNICODE_SPACE_SEPARATOR() {
        return G_UNICODE_SPACE_SEPARATOR;
    }
    private static final int G_UNICODE_BREAK_MANDATORY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_MANDATORY = 0
     * }
     */
    public static int G_UNICODE_BREAK_MANDATORY() {
        return G_UNICODE_BREAK_MANDATORY;
    }
    private static final int G_UNICODE_BREAK_CARRIAGE_RETURN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_CARRIAGE_RETURN = 1
     * }
     */
    public static int G_UNICODE_BREAK_CARRIAGE_RETURN() {
        return G_UNICODE_BREAK_CARRIAGE_RETURN;
    }
    private static final int G_UNICODE_BREAK_LINE_FEED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_LINE_FEED = 2
     * }
     */
    public static int G_UNICODE_BREAK_LINE_FEED() {
        return G_UNICODE_BREAK_LINE_FEED;
    }
    private static final int G_UNICODE_BREAK_COMBINING_MARK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_COMBINING_MARK = 3
     * }
     */
    public static int G_UNICODE_BREAK_COMBINING_MARK() {
        return G_UNICODE_BREAK_COMBINING_MARK;
    }
    private static final int G_UNICODE_BREAK_SURROGATE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_SURROGATE = 4
     * }
     */
    public static int G_UNICODE_BREAK_SURROGATE() {
        return G_UNICODE_BREAK_SURROGATE;
    }
    private static final int G_UNICODE_BREAK_ZERO_WIDTH_SPACE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5
     * }
     */
    public static int G_UNICODE_BREAK_ZERO_WIDTH_SPACE() {
        return G_UNICODE_BREAK_ZERO_WIDTH_SPACE;
    }
    private static final int G_UNICODE_BREAK_INSEPARABLE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_INSEPARABLE = 6
     * }
     */
    public static int G_UNICODE_BREAK_INSEPARABLE() {
        return G_UNICODE_BREAK_INSEPARABLE;
    }
    private static final int G_UNICODE_BREAK_NON_BREAKING_GLUE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_NON_BREAKING_GLUE = 7
     * }
     */
    public static int G_UNICODE_BREAK_NON_BREAKING_GLUE() {
        return G_UNICODE_BREAK_NON_BREAKING_GLUE;
    }
    private static final int G_UNICODE_BREAK_CONTINGENT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_CONTINGENT = 8
     * }
     */
    public static int G_UNICODE_BREAK_CONTINGENT() {
        return G_UNICODE_BREAK_CONTINGENT;
    }
    private static final int G_UNICODE_BREAK_SPACE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_SPACE = 9
     * }
     */
    public static int G_UNICODE_BREAK_SPACE() {
        return G_UNICODE_BREAK_SPACE;
    }
    private static final int G_UNICODE_BREAK_AFTER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_AFTER = 10
     * }
     */
    public static int G_UNICODE_BREAK_AFTER() {
        return G_UNICODE_BREAK_AFTER;
    }
    private static final int G_UNICODE_BREAK_BEFORE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_BEFORE = 11
     * }
     */
    public static int G_UNICODE_BREAK_BEFORE() {
        return G_UNICODE_BREAK_BEFORE;
    }
    private static final int G_UNICODE_BREAK_BEFORE_AND_AFTER = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_BEFORE_AND_AFTER = 12
     * }
     */
    public static int G_UNICODE_BREAK_BEFORE_AND_AFTER() {
        return G_UNICODE_BREAK_BEFORE_AND_AFTER;
    }
    private static final int G_UNICODE_BREAK_HYPHEN = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_HYPHEN = 13
     * }
     */
    public static int G_UNICODE_BREAK_HYPHEN() {
        return G_UNICODE_BREAK_HYPHEN;
    }
    private static final int G_UNICODE_BREAK_NON_STARTER = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_NON_STARTER = 14
     * }
     */
    public static int G_UNICODE_BREAK_NON_STARTER() {
        return G_UNICODE_BREAK_NON_STARTER;
    }
    private static final int G_UNICODE_BREAK_OPEN_PUNCTUATION = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_OPEN_PUNCTUATION = 15
     * }
     */
    public static int G_UNICODE_BREAK_OPEN_PUNCTUATION() {
        return G_UNICODE_BREAK_OPEN_PUNCTUATION;
    }
    private static final int G_UNICODE_BREAK_CLOSE_PUNCTUATION = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16
     * }
     */
    public static int G_UNICODE_BREAK_CLOSE_PUNCTUATION() {
        return G_UNICODE_BREAK_CLOSE_PUNCTUATION;
    }
    private static final int G_UNICODE_BREAK_QUOTATION = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_QUOTATION = 17
     * }
     */
    public static int G_UNICODE_BREAK_QUOTATION() {
        return G_UNICODE_BREAK_QUOTATION;
    }
    private static final int G_UNICODE_BREAK_EXCLAMATION = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_EXCLAMATION = 18
     * }
     */
    public static int G_UNICODE_BREAK_EXCLAMATION() {
        return G_UNICODE_BREAK_EXCLAMATION;
    }
    private static final int G_UNICODE_BREAK_IDEOGRAPHIC = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_IDEOGRAPHIC = 19
     * }
     */
    public static int G_UNICODE_BREAK_IDEOGRAPHIC() {
        return G_UNICODE_BREAK_IDEOGRAPHIC;
    }
    private static final int G_UNICODE_BREAK_NUMERIC = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_NUMERIC = 20
     * }
     */
    public static int G_UNICODE_BREAK_NUMERIC() {
        return G_UNICODE_BREAK_NUMERIC;
    }
    private static final int G_UNICODE_BREAK_INFIX_SEPARATOR = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_INFIX_SEPARATOR = 21
     * }
     */
    public static int G_UNICODE_BREAK_INFIX_SEPARATOR() {
        return G_UNICODE_BREAK_INFIX_SEPARATOR;
    }
    private static final int G_UNICODE_BREAK_SYMBOL = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_SYMBOL = 22
     * }
     */
    public static int G_UNICODE_BREAK_SYMBOL() {
        return G_UNICODE_BREAK_SYMBOL;
    }
    private static final int G_UNICODE_BREAK_ALPHABETIC = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_ALPHABETIC = 23
     * }
     */
    public static int G_UNICODE_BREAK_ALPHABETIC() {
        return G_UNICODE_BREAK_ALPHABETIC;
    }
    private static final int G_UNICODE_BREAK_PREFIX = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_PREFIX = 24
     * }
     */
    public static int G_UNICODE_BREAK_PREFIX() {
        return G_UNICODE_BREAK_PREFIX;
    }
    private static final int G_UNICODE_BREAK_POSTFIX = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_POSTFIX = 25
     * }
     */
    public static int G_UNICODE_BREAK_POSTFIX() {
        return G_UNICODE_BREAK_POSTFIX;
    }
    private static final int G_UNICODE_BREAK_COMPLEX_CONTEXT = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_COMPLEX_CONTEXT = 26
     * }
     */
    public static int G_UNICODE_BREAK_COMPLEX_CONTEXT() {
        return G_UNICODE_BREAK_COMPLEX_CONTEXT;
    }
    private static final int G_UNICODE_BREAK_AMBIGUOUS = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_AMBIGUOUS = 27
     * }
     */
    public static int G_UNICODE_BREAK_AMBIGUOUS() {
        return G_UNICODE_BREAK_AMBIGUOUS;
    }
    private static final int G_UNICODE_BREAK_UNKNOWN = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_UNKNOWN = 28
     * }
     */
    public static int G_UNICODE_BREAK_UNKNOWN() {
        return G_UNICODE_BREAK_UNKNOWN;
    }
    private static final int G_UNICODE_BREAK_NEXT_LINE = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_NEXT_LINE = 29
     * }
     */
    public static int G_UNICODE_BREAK_NEXT_LINE() {
        return G_UNICODE_BREAK_NEXT_LINE;
    }
    private static final int G_UNICODE_BREAK_WORD_JOINER = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_WORD_JOINER = 30
     * }
     */
    public static int G_UNICODE_BREAK_WORD_JOINER() {
        return G_UNICODE_BREAK_WORD_JOINER;
    }
    private static final int G_UNICODE_BREAK_HANGUL_L_JAMO = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_HANGUL_L_JAMO = 31
     * }
     */
    public static int G_UNICODE_BREAK_HANGUL_L_JAMO() {
        return G_UNICODE_BREAK_HANGUL_L_JAMO;
    }
    private static final int G_UNICODE_BREAK_HANGUL_V_JAMO = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_HANGUL_V_JAMO = 32
     * }
     */
    public static int G_UNICODE_BREAK_HANGUL_V_JAMO() {
        return G_UNICODE_BREAK_HANGUL_V_JAMO;
    }
    private static final int G_UNICODE_BREAK_HANGUL_T_JAMO = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_HANGUL_T_JAMO = 33
     * }
     */
    public static int G_UNICODE_BREAK_HANGUL_T_JAMO() {
        return G_UNICODE_BREAK_HANGUL_T_JAMO;
    }
    private static final int G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34
     * }
     */
    public static int G_UNICODE_BREAK_HANGUL_LV_SYLLABLE() {
        return G_UNICODE_BREAK_HANGUL_LV_SYLLABLE;
    }
    private static final int G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35
     * }
     */
    public static int G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE() {
        return G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE;
    }
    private static final int G_UNICODE_BREAK_CLOSE_PARANTHESIS = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36
     * }
     */
    public static int G_UNICODE_BREAK_CLOSE_PARANTHESIS() {
        return G_UNICODE_BREAK_CLOSE_PARANTHESIS;
    }
    private static final int G_UNICODE_BREAK_CLOSE_PARENTHESIS = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_CLOSE_PARENTHESIS = 36
     * }
     */
    public static int G_UNICODE_BREAK_CLOSE_PARENTHESIS() {
        return G_UNICODE_BREAK_CLOSE_PARENTHESIS;
    }
    private static final int G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37
     * }
     */
    public static int G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER() {
        return G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER;
    }
    private static final int G_UNICODE_BREAK_HEBREW_LETTER = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_HEBREW_LETTER = 38
     * }
     */
    public static int G_UNICODE_BREAK_HEBREW_LETTER() {
        return G_UNICODE_BREAK_HEBREW_LETTER;
    }
    private static final int G_UNICODE_BREAK_REGIONAL_INDICATOR = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_REGIONAL_INDICATOR = 39
     * }
     */
    public static int G_UNICODE_BREAK_REGIONAL_INDICATOR() {
        return G_UNICODE_BREAK_REGIONAL_INDICATOR;
    }
    private static final int G_UNICODE_BREAK_EMOJI_BASE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_EMOJI_BASE = 40
     * }
     */
    public static int G_UNICODE_BREAK_EMOJI_BASE() {
        return G_UNICODE_BREAK_EMOJI_BASE;
    }
    private static final int G_UNICODE_BREAK_EMOJI_MODIFIER = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_EMOJI_MODIFIER = 41
     * }
     */
    public static int G_UNICODE_BREAK_EMOJI_MODIFIER() {
        return G_UNICODE_BREAK_EMOJI_MODIFIER;
    }
    private static final int G_UNICODE_BREAK_ZERO_WIDTH_JOINER = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42
     * }
     */
    public static int G_UNICODE_BREAK_ZERO_WIDTH_JOINER() {
        return G_UNICODE_BREAK_ZERO_WIDTH_JOINER;
    }
    private static final int G_UNICODE_BREAK_AKSARA = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_AKSARA = 43
     * }
     */
    public static int G_UNICODE_BREAK_AKSARA() {
        return G_UNICODE_BREAK_AKSARA;
    }
    private static final int G_UNICODE_BREAK_AKSARA_PRE_BASE = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_AKSARA_PRE_BASE = 44
     * }
     */
    public static int G_UNICODE_BREAK_AKSARA_PRE_BASE() {
        return G_UNICODE_BREAK_AKSARA_PRE_BASE;
    }
    private static final int G_UNICODE_BREAK_AKSARA_START = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_AKSARA_START = 45
     * }
     */
    public static int G_UNICODE_BREAK_AKSARA_START() {
        return G_UNICODE_BREAK_AKSARA_START;
    }
    private static final int G_UNICODE_BREAK_VIRAMA_FINAL = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_VIRAMA_FINAL = 46
     * }
     */
    public static int G_UNICODE_BREAK_VIRAMA_FINAL() {
        return G_UNICODE_BREAK_VIRAMA_FINAL;
    }
    private static final int G_UNICODE_BREAK_VIRAMA = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_BREAK_VIRAMA = 47
     * }
     */
    public static int G_UNICODE_BREAK_VIRAMA() {
        return G_UNICODE_BREAK_VIRAMA;
    }
    private static final int G_UNICODE_SCRIPT_INVALID_CODE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_INVALID_CODE = -1
     * }
     */
    public static int G_UNICODE_SCRIPT_INVALID_CODE() {
        return G_UNICODE_SCRIPT_INVALID_CODE;
    }
    private static final int G_UNICODE_SCRIPT_COMMON = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_COMMON = 0
     * }
     */
    public static int G_UNICODE_SCRIPT_COMMON() {
        return G_UNICODE_SCRIPT_COMMON;
    }
    private static final int G_UNICODE_SCRIPT_INHERITED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_INHERITED = 1
     * }
     */
    public static int G_UNICODE_SCRIPT_INHERITED() {
        return G_UNICODE_SCRIPT_INHERITED;
    }
    private static final int G_UNICODE_SCRIPT_ARABIC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ARABIC = 2
     * }
     */
    public static int G_UNICODE_SCRIPT_ARABIC() {
        return G_UNICODE_SCRIPT_ARABIC;
    }
    private static final int G_UNICODE_SCRIPT_ARMENIAN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ARMENIAN = 3
     * }
     */
    public static int G_UNICODE_SCRIPT_ARMENIAN() {
        return G_UNICODE_SCRIPT_ARMENIAN;
    }
    private static final int G_UNICODE_SCRIPT_BENGALI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BENGALI = 4
     * }
     */
    public static int G_UNICODE_SCRIPT_BENGALI() {
        return G_UNICODE_SCRIPT_BENGALI;
    }
    private static final int G_UNICODE_SCRIPT_BOPOMOFO = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BOPOMOFO = 5
     * }
     */
    public static int G_UNICODE_SCRIPT_BOPOMOFO() {
        return G_UNICODE_SCRIPT_BOPOMOFO;
    }
    private static final int G_UNICODE_SCRIPT_CHEROKEE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CHEROKEE = 6
     * }
     */
    public static int G_UNICODE_SCRIPT_CHEROKEE() {
        return G_UNICODE_SCRIPT_CHEROKEE;
    }
    private static final int G_UNICODE_SCRIPT_COPTIC = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_COPTIC = 7
     * }
     */
    public static int G_UNICODE_SCRIPT_COPTIC() {
        return G_UNICODE_SCRIPT_COPTIC;
    }
    private static final int G_UNICODE_SCRIPT_CYRILLIC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CYRILLIC = 8
     * }
     */
    public static int G_UNICODE_SCRIPT_CYRILLIC() {
        return G_UNICODE_SCRIPT_CYRILLIC;
    }
    private static final int G_UNICODE_SCRIPT_DESERET = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_DESERET = 9
     * }
     */
    public static int G_UNICODE_SCRIPT_DESERET() {
        return G_UNICODE_SCRIPT_DESERET;
    }
    private static final int G_UNICODE_SCRIPT_DEVANAGARI = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_DEVANAGARI = 10
     * }
     */
    public static int G_UNICODE_SCRIPT_DEVANAGARI() {
        return G_UNICODE_SCRIPT_DEVANAGARI;
    }
    private static final int G_UNICODE_SCRIPT_ETHIOPIC = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ETHIOPIC = 11
     * }
     */
    public static int G_UNICODE_SCRIPT_ETHIOPIC() {
        return G_UNICODE_SCRIPT_ETHIOPIC;
    }
    private static final int G_UNICODE_SCRIPT_GEORGIAN = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_GEORGIAN = 12
     * }
     */
    public static int G_UNICODE_SCRIPT_GEORGIAN() {
        return G_UNICODE_SCRIPT_GEORGIAN;
    }
    private static final int G_UNICODE_SCRIPT_GOTHIC = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_GOTHIC = 13
     * }
     */
    public static int G_UNICODE_SCRIPT_GOTHIC() {
        return G_UNICODE_SCRIPT_GOTHIC;
    }
    private static final int G_UNICODE_SCRIPT_GREEK = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_GREEK = 14
     * }
     */
    public static int G_UNICODE_SCRIPT_GREEK() {
        return G_UNICODE_SCRIPT_GREEK;
    }
    private static final int G_UNICODE_SCRIPT_GUJARATI = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_GUJARATI = 15
     * }
     */
    public static int G_UNICODE_SCRIPT_GUJARATI() {
        return G_UNICODE_SCRIPT_GUJARATI;
    }
    private static final int G_UNICODE_SCRIPT_GURMUKHI = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_GURMUKHI = 16
     * }
     */
    public static int G_UNICODE_SCRIPT_GURMUKHI() {
        return G_UNICODE_SCRIPT_GURMUKHI;
    }
    private static final int G_UNICODE_SCRIPT_HAN = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_HAN = 17
     * }
     */
    public static int G_UNICODE_SCRIPT_HAN() {
        return G_UNICODE_SCRIPT_HAN;
    }
    private static final int G_UNICODE_SCRIPT_HANGUL = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_HANGUL = 18
     * }
     */
    public static int G_UNICODE_SCRIPT_HANGUL() {
        return G_UNICODE_SCRIPT_HANGUL;
    }
    private static final int G_UNICODE_SCRIPT_HEBREW = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_HEBREW = 19
     * }
     */
    public static int G_UNICODE_SCRIPT_HEBREW() {
        return G_UNICODE_SCRIPT_HEBREW;
    }
    private static final int G_UNICODE_SCRIPT_HIRAGANA = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_HIRAGANA = 20
     * }
     */
    public static int G_UNICODE_SCRIPT_HIRAGANA() {
        return G_UNICODE_SCRIPT_HIRAGANA;
    }
    private static final int G_UNICODE_SCRIPT_KANNADA = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KANNADA = 21
     * }
     */
    public static int G_UNICODE_SCRIPT_KANNADA() {
        return G_UNICODE_SCRIPT_KANNADA;
    }
    private static final int G_UNICODE_SCRIPT_KATAKANA = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KATAKANA = 22
     * }
     */
    public static int G_UNICODE_SCRIPT_KATAKANA() {
        return G_UNICODE_SCRIPT_KATAKANA;
    }
    private static final int G_UNICODE_SCRIPT_KHMER = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KHMER = 23
     * }
     */
    public static int G_UNICODE_SCRIPT_KHMER() {
        return G_UNICODE_SCRIPT_KHMER;
    }
    private static final int G_UNICODE_SCRIPT_LAO = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LAO = 24
     * }
     */
    public static int G_UNICODE_SCRIPT_LAO() {
        return G_UNICODE_SCRIPT_LAO;
    }
    private static final int G_UNICODE_SCRIPT_LATIN = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LATIN = 25
     * }
     */
    public static int G_UNICODE_SCRIPT_LATIN() {
        return G_UNICODE_SCRIPT_LATIN;
    }
    private static final int G_UNICODE_SCRIPT_MALAYALAM = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MALAYALAM = 26
     * }
     */
    public static int G_UNICODE_SCRIPT_MALAYALAM() {
        return G_UNICODE_SCRIPT_MALAYALAM;
    }
    private static final int G_UNICODE_SCRIPT_MONGOLIAN = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MONGOLIAN = 27
     * }
     */
    public static int G_UNICODE_SCRIPT_MONGOLIAN() {
        return G_UNICODE_SCRIPT_MONGOLIAN;
    }
    private static final int G_UNICODE_SCRIPT_MYANMAR = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MYANMAR = 28
     * }
     */
    public static int G_UNICODE_SCRIPT_MYANMAR() {
        return G_UNICODE_SCRIPT_MYANMAR;
    }
    private static final int G_UNICODE_SCRIPT_OGHAM = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OGHAM = 29
     * }
     */
    public static int G_UNICODE_SCRIPT_OGHAM() {
        return G_UNICODE_SCRIPT_OGHAM;
    }
    private static final int G_UNICODE_SCRIPT_OLD_ITALIC = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_ITALIC = 30
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_ITALIC() {
        return G_UNICODE_SCRIPT_OLD_ITALIC;
    }
    private static final int G_UNICODE_SCRIPT_ORIYA = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ORIYA = 31
     * }
     */
    public static int G_UNICODE_SCRIPT_ORIYA() {
        return G_UNICODE_SCRIPT_ORIYA;
    }
    private static final int G_UNICODE_SCRIPT_RUNIC = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_RUNIC = 32
     * }
     */
    public static int G_UNICODE_SCRIPT_RUNIC() {
        return G_UNICODE_SCRIPT_RUNIC;
    }
    private static final int G_UNICODE_SCRIPT_SINHALA = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SINHALA = 33
     * }
     */
    public static int G_UNICODE_SCRIPT_SINHALA() {
        return G_UNICODE_SCRIPT_SINHALA;
    }
    private static final int G_UNICODE_SCRIPT_SYRIAC = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SYRIAC = 34
     * }
     */
    public static int G_UNICODE_SCRIPT_SYRIAC() {
        return G_UNICODE_SCRIPT_SYRIAC;
    }
    private static final int G_UNICODE_SCRIPT_TAMIL = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TAMIL = 35
     * }
     */
    public static int G_UNICODE_SCRIPT_TAMIL() {
        return G_UNICODE_SCRIPT_TAMIL;
    }
    private static final int G_UNICODE_SCRIPT_TELUGU = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TELUGU = 36
     * }
     */
    public static int G_UNICODE_SCRIPT_TELUGU() {
        return G_UNICODE_SCRIPT_TELUGU;
    }
    private static final int G_UNICODE_SCRIPT_THAANA = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_THAANA = 37
     * }
     */
    public static int G_UNICODE_SCRIPT_THAANA() {
        return G_UNICODE_SCRIPT_THAANA;
    }
    private static final int G_UNICODE_SCRIPT_THAI = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_THAI = 38
     * }
     */
    public static int G_UNICODE_SCRIPT_THAI() {
        return G_UNICODE_SCRIPT_THAI;
    }
    private static final int G_UNICODE_SCRIPT_TIBETAN = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TIBETAN = 39
     * }
     */
    public static int G_UNICODE_SCRIPT_TIBETAN() {
        return G_UNICODE_SCRIPT_TIBETAN;
    }
    private static final int G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40
     * }
     */
    public static int G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL() {
        return G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL;
    }
    private static final int G_UNICODE_SCRIPT_YI = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_YI = 41
     * }
     */
    public static int G_UNICODE_SCRIPT_YI() {
        return G_UNICODE_SCRIPT_YI;
    }
    private static final int G_UNICODE_SCRIPT_TAGALOG = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TAGALOG = 42
     * }
     */
    public static int G_UNICODE_SCRIPT_TAGALOG() {
        return G_UNICODE_SCRIPT_TAGALOG;
    }
    private static final int G_UNICODE_SCRIPT_HANUNOO = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_HANUNOO = 43
     * }
     */
    public static int G_UNICODE_SCRIPT_HANUNOO() {
        return G_UNICODE_SCRIPT_HANUNOO;
    }
    private static final int G_UNICODE_SCRIPT_BUHID = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BUHID = 44
     * }
     */
    public static int G_UNICODE_SCRIPT_BUHID() {
        return G_UNICODE_SCRIPT_BUHID;
    }
    private static final int G_UNICODE_SCRIPT_TAGBANWA = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TAGBANWA = 45
     * }
     */
    public static int G_UNICODE_SCRIPT_TAGBANWA() {
        return G_UNICODE_SCRIPT_TAGBANWA;
    }
    private static final int G_UNICODE_SCRIPT_BRAILLE = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BRAILLE = 46
     * }
     */
    public static int G_UNICODE_SCRIPT_BRAILLE() {
        return G_UNICODE_SCRIPT_BRAILLE;
    }
    private static final int G_UNICODE_SCRIPT_CYPRIOT = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CYPRIOT = 47
     * }
     */
    public static int G_UNICODE_SCRIPT_CYPRIOT() {
        return G_UNICODE_SCRIPT_CYPRIOT;
    }
    private static final int G_UNICODE_SCRIPT_LIMBU = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LIMBU = 48
     * }
     */
    public static int G_UNICODE_SCRIPT_LIMBU() {
        return G_UNICODE_SCRIPT_LIMBU;
    }
    private static final int G_UNICODE_SCRIPT_OSMANYA = (int)49L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OSMANYA = 49
     * }
     */
    public static int G_UNICODE_SCRIPT_OSMANYA() {
        return G_UNICODE_SCRIPT_OSMANYA;
    }
    private static final int G_UNICODE_SCRIPT_SHAVIAN = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SHAVIAN = 50
     * }
     */
    public static int G_UNICODE_SCRIPT_SHAVIAN() {
        return G_UNICODE_SCRIPT_SHAVIAN;
    }
    private static final int G_UNICODE_SCRIPT_LINEAR_B = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LINEAR_B = 51
     * }
     */
    public static int G_UNICODE_SCRIPT_LINEAR_B() {
        return G_UNICODE_SCRIPT_LINEAR_B;
    }
    private static final int G_UNICODE_SCRIPT_TAI_LE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TAI_LE = 52
     * }
     */
    public static int G_UNICODE_SCRIPT_TAI_LE() {
        return G_UNICODE_SCRIPT_TAI_LE;
    }
    private static final int G_UNICODE_SCRIPT_UGARITIC = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_UGARITIC = 53
     * }
     */
    public static int G_UNICODE_SCRIPT_UGARITIC() {
        return G_UNICODE_SCRIPT_UGARITIC;
    }
    private static final int G_UNICODE_SCRIPT_NEW_TAI_LUE = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_NEW_TAI_LUE = 54
     * }
     */
    public static int G_UNICODE_SCRIPT_NEW_TAI_LUE() {
        return G_UNICODE_SCRIPT_NEW_TAI_LUE;
    }
    private static final int G_UNICODE_SCRIPT_BUGINESE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BUGINESE = 55
     * }
     */
    public static int G_UNICODE_SCRIPT_BUGINESE() {
        return G_UNICODE_SCRIPT_BUGINESE;
    }
    private static final int G_UNICODE_SCRIPT_GLAGOLITIC = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_GLAGOLITIC = 56
     * }
     */
    public static int G_UNICODE_SCRIPT_GLAGOLITIC() {
        return G_UNICODE_SCRIPT_GLAGOLITIC;
    }
    private static final int G_UNICODE_SCRIPT_TIFINAGH = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TIFINAGH = 57
     * }
     */
    public static int G_UNICODE_SCRIPT_TIFINAGH() {
        return G_UNICODE_SCRIPT_TIFINAGH;
    }
    private static final int G_UNICODE_SCRIPT_SYLOTI_NAGRI = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58
     * }
     */
    public static int G_UNICODE_SCRIPT_SYLOTI_NAGRI() {
        return G_UNICODE_SCRIPT_SYLOTI_NAGRI;
    }
    private static final int G_UNICODE_SCRIPT_OLD_PERSIAN = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_PERSIAN = 59
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_PERSIAN() {
        return G_UNICODE_SCRIPT_OLD_PERSIAN;
    }
    private static final int G_UNICODE_SCRIPT_KHAROSHTHI = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KHAROSHTHI = 60
     * }
     */
    public static int G_UNICODE_SCRIPT_KHAROSHTHI() {
        return G_UNICODE_SCRIPT_KHAROSHTHI;
    }
    private static final int G_UNICODE_SCRIPT_UNKNOWN = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_UNKNOWN = 61
     * }
     */
    public static int G_UNICODE_SCRIPT_UNKNOWN() {
        return G_UNICODE_SCRIPT_UNKNOWN;
    }
    private static final int G_UNICODE_SCRIPT_BALINESE = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BALINESE = 62
     * }
     */
    public static int G_UNICODE_SCRIPT_BALINESE() {
        return G_UNICODE_SCRIPT_BALINESE;
    }
    private static final int G_UNICODE_SCRIPT_CUNEIFORM = (int)63L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CUNEIFORM = 63
     * }
     */
    public static int G_UNICODE_SCRIPT_CUNEIFORM() {
        return G_UNICODE_SCRIPT_CUNEIFORM;
    }
    private static final int G_UNICODE_SCRIPT_PHOENICIAN = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_PHOENICIAN = 64
     * }
     */
    public static int G_UNICODE_SCRIPT_PHOENICIAN() {
        return G_UNICODE_SCRIPT_PHOENICIAN;
    }
    private static final int G_UNICODE_SCRIPT_PHAGS_PA = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_PHAGS_PA = 65
     * }
     */
    public static int G_UNICODE_SCRIPT_PHAGS_PA() {
        return G_UNICODE_SCRIPT_PHAGS_PA;
    }
    private static final int G_UNICODE_SCRIPT_NKO = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_NKO = 66
     * }
     */
    public static int G_UNICODE_SCRIPT_NKO() {
        return G_UNICODE_SCRIPT_NKO;
    }
    private static final int G_UNICODE_SCRIPT_KAYAH_LI = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KAYAH_LI = 67
     * }
     */
    public static int G_UNICODE_SCRIPT_KAYAH_LI() {
        return G_UNICODE_SCRIPT_KAYAH_LI;
    }
    private static final int G_UNICODE_SCRIPT_LEPCHA = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LEPCHA = 68
     * }
     */
    public static int G_UNICODE_SCRIPT_LEPCHA() {
        return G_UNICODE_SCRIPT_LEPCHA;
    }
    private static final int G_UNICODE_SCRIPT_REJANG = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_REJANG = 69
     * }
     */
    public static int G_UNICODE_SCRIPT_REJANG() {
        return G_UNICODE_SCRIPT_REJANG;
    }
    private static final int G_UNICODE_SCRIPT_SUNDANESE = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SUNDANESE = 70
     * }
     */
    public static int G_UNICODE_SCRIPT_SUNDANESE() {
        return G_UNICODE_SCRIPT_SUNDANESE;
    }
    private static final int G_UNICODE_SCRIPT_SAURASHTRA = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SAURASHTRA = 71
     * }
     */
    public static int G_UNICODE_SCRIPT_SAURASHTRA() {
        return G_UNICODE_SCRIPT_SAURASHTRA;
    }
    private static final int G_UNICODE_SCRIPT_CHAM = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CHAM = 72
     * }
     */
    public static int G_UNICODE_SCRIPT_CHAM() {
        return G_UNICODE_SCRIPT_CHAM;
    }
    private static final int G_UNICODE_SCRIPT_OL_CHIKI = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OL_CHIKI = 73
     * }
     */
    public static int G_UNICODE_SCRIPT_OL_CHIKI() {
        return G_UNICODE_SCRIPT_OL_CHIKI;
    }
    private static final int G_UNICODE_SCRIPT_VAI = (int)74L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_VAI = 74
     * }
     */
    public static int G_UNICODE_SCRIPT_VAI() {
        return G_UNICODE_SCRIPT_VAI;
    }
    private static final int G_UNICODE_SCRIPT_CARIAN = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CARIAN = 75
     * }
     */
    public static int G_UNICODE_SCRIPT_CARIAN() {
        return G_UNICODE_SCRIPT_CARIAN;
    }
    private static final int G_UNICODE_SCRIPT_LYCIAN = (int)76L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LYCIAN = 76
     * }
     */
    public static int G_UNICODE_SCRIPT_LYCIAN() {
        return G_UNICODE_SCRIPT_LYCIAN;
    }
    private static final int G_UNICODE_SCRIPT_LYDIAN = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LYDIAN = 77
     * }
     */
    public static int G_UNICODE_SCRIPT_LYDIAN() {
        return G_UNICODE_SCRIPT_LYDIAN;
    }
    private static final int G_UNICODE_SCRIPT_AVESTAN = (int)78L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_AVESTAN = 78
     * }
     */
    public static int G_UNICODE_SCRIPT_AVESTAN() {
        return G_UNICODE_SCRIPT_AVESTAN;
    }
    private static final int G_UNICODE_SCRIPT_BAMUM = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BAMUM = 79
     * }
     */
    public static int G_UNICODE_SCRIPT_BAMUM() {
        return G_UNICODE_SCRIPT_BAMUM;
    }
    private static final int G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80
     * }
     */
    public static int G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS() {
        return G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS;
    }
    private static final int G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81
     * }
     */
    public static int G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC() {
        return G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC;
    }
    private static final int G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82
     * }
     */
    public static int G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI() {
        return G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI;
    }
    private static final int G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83
     * }
     */
    public static int G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN() {
        return G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN;
    }
    private static final int G_UNICODE_SCRIPT_JAVANESE = (int)84L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_JAVANESE = 84
     * }
     */
    public static int G_UNICODE_SCRIPT_JAVANESE() {
        return G_UNICODE_SCRIPT_JAVANESE;
    }
    private static final int G_UNICODE_SCRIPT_KAITHI = (int)85L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KAITHI = 85
     * }
     */
    public static int G_UNICODE_SCRIPT_KAITHI() {
        return G_UNICODE_SCRIPT_KAITHI;
    }
    private static final int G_UNICODE_SCRIPT_LISU = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LISU = 86
     * }
     */
    public static int G_UNICODE_SCRIPT_LISU() {
        return G_UNICODE_SCRIPT_LISU;
    }
    private static final int G_UNICODE_SCRIPT_MEETEI_MAYEK = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MEETEI_MAYEK = 87
     * }
     */
    public static int G_UNICODE_SCRIPT_MEETEI_MAYEK() {
        return G_UNICODE_SCRIPT_MEETEI_MAYEK;
    }
    private static final int G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN() {
        return G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN;
    }
    private static final int G_UNICODE_SCRIPT_OLD_TURKIC = (int)89L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_TURKIC = 89
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_TURKIC() {
        return G_UNICODE_SCRIPT_OLD_TURKIC;
    }
    private static final int G_UNICODE_SCRIPT_SAMARITAN = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SAMARITAN = 90
     * }
     */
    public static int G_UNICODE_SCRIPT_SAMARITAN() {
        return G_UNICODE_SCRIPT_SAMARITAN;
    }
    private static final int G_UNICODE_SCRIPT_TAI_THAM = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TAI_THAM = 91
     * }
     */
    public static int G_UNICODE_SCRIPT_TAI_THAM() {
        return G_UNICODE_SCRIPT_TAI_THAM;
    }
    private static final int G_UNICODE_SCRIPT_TAI_VIET = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TAI_VIET = 92
     * }
     */
    public static int G_UNICODE_SCRIPT_TAI_VIET() {
        return G_UNICODE_SCRIPT_TAI_VIET;
    }
    private static final int G_UNICODE_SCRIPT_BATAK = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BATAK = 93
     * }
     */
    public static int G_UNICODE_SCRIPT_BATAK() {
        return G_UNICODE_SCRIPT_BATAK;
    }
    private static final int G_UNICODE_SCRIPT_BRAHMI = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BRAHMI = 94
     * }
     */
    public static int G_UNICODE_SCRIPT_BRAHMI() {
        return G_UNICODE_SCRIPT_BRAHMI;
    }
    private static final int G_UNICODE_SCRIPT_MANDAIC = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MANDAIC = 95
     * }
     */
    public static int G_UNICODE_SCRIPT_MANDAIC() {
        return G_UNICODE_SCRIPT_MANDAIC;
    }
    private static final int G_UNICODE_SCRIPT_CHAKMA = (int)96L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CHAKMA = 96
     * }
     */
    public static int G_UNICODE_SCRIPT_CHAKMA() {
        return G_UNICODE_SCRIPT_CHAKMA;
    }
    private static final int G_UNICODE_SCRIPT_MEROITIC_CURSIVE = (int)97L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97
     * }
     */
    public static int G_UNICODE_SCRIPT_MEROITIC_CURSIVE() {
        return G_UNICODE_SCRIPT_MEROITIC_CURSIVE;
    }
    private static final int G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98
     * }
     */
    public static int G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS() {
        return G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS;
    }
    private static final int G_UNICODE_SCRIPT_MIAO = (int)99L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MIAO = 99
     * }
     */
    public static int G_UNICODE_SCRIPT_MIAO() {
        return G_UNICODE_SCRIPT_MIAO;
    }
    private static final int G_UNICODE_SCRIPT_SHARADA = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SHARADA = 100
     * }
     */
    public static int G_UNICODE_SCRIPT_SHARADA() {
        return G_UNICODE_SCRIPT_SHARADA;
    }
    private static final int G_UNICODE_SCRIPT_SORA_SOMPENG = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SORA_SOMPENG = 101
     * }
     */
    public static int G_UNICODE_SCRIPT_SORA_SOMPENG() {
        return G_UNICODE_SCRIPT_SORA_SOMPENG;
    }
    private static final int G_UNICODE_SCRIPT_TAKRI = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TAKRI = 102
     * }
     */
    public static int G_UNICODE_SCRIPT_TAKRI() {
        return G_UNICODE_SCRIPT_TAKRI;
    }
    private static final int G_UNICODE_SCRIPT_BASSA_VAH = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BASSA_VAH = 103
     * }
     */
    public static int G_UNICODE_SCRIPT_BASSA_VAH() {
        return G_UNICODE_SCRIPT_BASSA_VAH;
    }
    private static final int G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = (int)104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104
     * }
     */
    public static int G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN() {
        return G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN;
    }
    private static final int G_UNICODE_SCRIPT_DUPLOYAN = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_DUPLOYAN = 105
     * }
     */
    public static int G_UNICODE_SCRIPT_DUPLOYAN() {
        return G_UNICODE_SCRIPT_DUPLOYAN;
    }
    private static final int G_UNICODE_SCRIPT_ELBASAN = (int)106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ELBASAN = 106
     * }
     */
    public static int G_UNICODE_SCRIPT_ELBASAN() {
        return G_UNICODE_SCRIPT_ELBASAN;
    }
    private static final int G_UNICODE_SCRIPT_GRANTHA = (int)107L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_GRANTHA = 107
     * }
     */
    public static int G_UNICODE_SCRIPT_GRANTHA() {
        return G_UNICODE_SCRIPT_GRANTHA;
    }
    private static final int G_UNICODE_SCRIPT_KHOJKI = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KHOJKI = 108
     * }
     */
    public static int G_UNICODE_SCRIPT_KHOJKI() {
        return G_UNICODE_SCRIPT_KHOJKI;
    }
    private static final int G_UNICODE_SCRIPT_KHUDAWADI = (int)109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KHUDAWADI = 109
     * }
     */
    public static int G_UNICODE_SCRIPT_KHUDAWADI() {
        return G_UNICODE_SCRIPT_KHUDAWADI;
    }
    private static final int G_UNICODE_SCRIPT_LINEAR_A = (int)110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_LINEAR_A = 110
     * }
     */
    public static int G_UNICODE_SCRIPT_LINEAR_A() {
        return G_UNICODE_SCRIPT_LINEAR_A;
    }
    private static final int G_UNICODE_SCRIPT_MAHAJANI = (int)111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MAHAJANI = 111
     * }
     */
    public static int G_UNICODE_SCRIPT_MAHAJANI() {
        return G_UNICODE_SCRIPT_MAHAJANI;
    }
    private static final int G_UNICODE_SCRIPT_MANICHAEAN = (int)112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MANICHAEAN = 112
     * }
     */
    public static int G_UNICODE_SCRIPT_MANICHAEAN() {
        return G_UNICODE_SCRIPT_MANICHAEAN;
    }
    private static final int G_UNICODE_SCRIPT_MENDE_KIKAKUI = (int)113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113
     * }
     */
    public static int G_UNICODE_SCRIPT_MENDE_KIKAKUI() {
        return G_UNICODE_SCRIPT_MENDE_KIKAKUI;
    }
    private static final int G_UNICODE_SCRIPT_MODI = (int)114L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MODI = 114
     * }
     */
    public static int G_UNICODE_SCRIPT_MODI() {
        return G_UNICODE_SCRIPT_MODI;
    }
    private static final int G_UNICODE_SCRIPT_MRO = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MRO = 115
     * }
     */
    public static int G_UNICODE_SCRIPT_MRO() {
        return G_UNICODE_SCRIPT_MRO;
    }
    private static final int G_UNICODE_SCRIPT_NABATAEAN = (int)116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_NABATAEAN = 116
     * }
     */
    public static int G_UNICODE_SCRIPT_NABATAEAN() {
        return G_UNICODE_SCRIPT_NABATAEAN;
    }
    private static final int G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = (int)117L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN() {
        return G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN;
    }
    private static final int G_UNICODE_SCRIPT_OLD_PERMIC = (int)118L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_PERMIC = 118
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_PERMIC() {
        return G_UNICODE_SCRIPT_OLD_PERMIC;
    }
    private static final int G_UNICODE_SCRIPT_PAHAWH_HMONG = (int)119L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_PAHAWH_HMONG = 119
     * }
     */
    public static int G_UNICODE_SCRIPT_PAHAWH_HMONG() {
        return G_UNICODE_SCRIPT_PAHAWH_HMONG;
    }
    private static final int G_UNICODE_SCRIPT_PALMYRENE = (int)120L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_PALMYRENE = 120
     * }
     */
    public static int G_UNICODE_SCRIPT_PALMYRENE() {
        return G_UNICODE_SCRIPT_PALMYRENE;
    }
    private static final int G_UNICODE_SCRIPT_PAU_CIN_HAU = (int)121L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_PAU_CIN_HAU = 121
     * }
     */
    public static int G_UNICODE_SCRIPT_PAU_CIN_HAU() {
        return G_UNICODE_SCRIPT_PAU_CIN_HAU;
    }
    private static final int G_UNICODE_SCRIPT_PSALTER_PAHLAVI = (int)122L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122
     * }
     */
    public static int G_UNICODE_SCRIPT_PSALTER_PAHLAVI() {
        return G_UNICODE_SCRIPT_PSALTER_PAHLAVI;
    }
    private static final int G_UNICODE_SCRIPT_SIDDHAM = (int)123L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SIDDHAM = 123
     * }
     */
    public static int G_UNICODE_SCRIPT_SIDDHAM() {
        return G_UNICODE_SCRIPT_SIDDHAM;
    }
    private static final int G_UNICODE_SCRIPT_TIRHUTA = (int)124L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TIRHUTA = 124
     * }
     */
    public static int G_UNICODE_SCRIPT_TIRHUTA() {
        return G_UNICODE_SCRIPT_TIRHUTA;
    }
    private static final int G_UNICODE_SCRIPT_WARANG_CITI = (int)125L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_WARANG_CITI = 125
     * }
     */
    public static int G_UNICODE_SCRIPT_WARANG_CITI() {
        return G_UNICODE_SCRIPT_WARANG_CITI;
    }
    private static final int G_UNICODE_SCRIPT_AHOM = (int)126L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_AHOM = 126
     * }
     */
    public static int G_UNICODE_SCRIPT_AHOM() {
        return G_UNICODE_SCRIPT_AHOM;
    }
    private static final int G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = (int)127L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127
     * }
     */
    public static int G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS() {
        return G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS;
    }
    private static final int G_UNICODE_SCRIPT_HATRAN = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_HATRAN = 128
     * }
     */
    public static int G_UNICODE_SCRIPT_HATRAN() {
        return G_UNICODE_SCRIPT_HATRAN;
    }
    private static final int G_UNICODE_SCRIPT_MULTANI = (int)129L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MULTANI = 129
     * }
     */
    public static int G_UNICODE_SCRIPT_MULTANI() {
        return G_UNICODE_SCRIPT_MULTANI;
    }
    private static final int G_UNICODE_SCRIPT_OLD_HUNGARIAN = (int)130L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_HUNGARIAN() {
        return G_UNICODE_SCRIPT_OLD_HUNGARIAN;
    }
    private static final int G_UNICODE_SCRIPT_SIGNWRITING = (int)131L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SIGNWRITING = 131
     * }
     */
    public static int G_UNICODE_SCRIPT_SIGNWRITING() {
        return G_UNICODE_SCRIPT_SIGNWRITING;
    }
    private static final int G_UNICODE_SCRIPT_ADLAM = (int)132L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ADLAM = 132
     * }
     */
    public static int G_UNICODE_SCRIPT_ADLAM() {
        return G_UNICODE_SCRIPT_ADLAM;
    }
    private static final int G_UNICODE_SCRIPT_BHAIKSUKI = (int)133L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_BHAIKSUKI = 133
     * }
     */
    public static int G_UNICODE_SCRIPT_BHAIKSUKI() {
        return G_UNICODE_SCRIPT_BHAIKSUKI;
    }
    private static final int G_UNICODE_SCRIPT_MARCHEN = (int)134L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MARCHEN = 134
     * }
     */
    public static int G_UNICODE_SCRIPT_MARCHEN() {
        return G_UNICODE_SCRIPT_MARCHEN;
    }
    private static final int G_UNICODE_SCRIPT_NEWA = (int)135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_NEWA = 135
     * }
     */
    public static int G_UNICODE_SCRIPT_NEWA() {
        return G_UNICODE_SCRIPT_NEWA;
    }
    private static final int G_UNICODE_SCRIPT_OSAGE = (int)136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OSAGE = 136
     * }
     */
    public static int G_UNICODE_SCRIPT_OSAGE() {
        return G_UNICODE_SCRIPT_OSAGE;
    }
    private static final int G_UNICODE_SCRIPT_TANGUT = (int)137L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TANGUT = 137
     * }
     */
    public static int G_UNICODE_SCRIPT_TANGUT() {
        return G_UNICODE_SCRIPT_TANGUT;
    }
    private static final int G_UNICODE_SCRIPT_MASARAM_GONDI = (int)138L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MASARAM_GONDI = 138
     * }
     */
    public static int G_UNICODE_SCRIPT_MASARAM_GONDI() {
        return G_UNICODE_SCRIPT_MASARAM_GONDI;
    }
    private static final int G_UNICODE_SCRIPT_NUSHU = (int)139L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_NUSHU = 139
     * }
     */
    public static int G_UNICODE_SCRIPT_NUSHU() {
        return G_UNICODE_SCRIPT_NUSHU;
    }
    private static final int G_UNICODE_SCRIPT_SOYOMBO = (int)140L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SOYOMBO = 140
     * }
     */
    public static int G_UNICODE_SCRIPT_SOYOMBO() {
        return G_UNICODE_SCRIPT_SOYOMBO;
    }
    private static final int G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = (int)141L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141
     * }
     */
    public static int G_UNICODE_SCRIPT_ZANABAZAR_SQUARE() {
        return G_UNICODE_SCRIPT_ZANABAZAR_SQUARE;
    }
    private static final int G_UNICODE_SCRIPT_DOGRA = (int)142L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_DOGRA = 142
     * }
     */
    public static int G_UNICODE_SCRIPT_DOGRA() {
        return G_UNICODE_SCRIPT_DOGRA;
    }
    private static final int G_UNICODE_SCRIPT_GUNJALA_GONDI = (int)143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_GUNJALA_GONDI = 143
     * }
     */
    public static int G_UNICODE_SCRIPT_GUNJALA_GONDI() {
        return G_UNICODE_SCRIPT_GUNJALA_GONDI;
    }
    private static final int G_UNICODE_SCRIPT_HANIFI_ROHINGYA = (int)144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144
     * }
     */
    public static int G_UNICODE_SCRIPT_HANIFI_ROHINGYA() {
        return G_UNICODE_SCRIPT_HANIFI_ROHINGYA;
    }
    private static final int G_UNICODE_SCRIPT_MAKASAR = (int)145L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MAKASAR = 145
     * }
     */
    public static int G_UNICODE_SCRIPT_MAKASAR() {
        return G_UNICODE_SCRIPT_MAKASAR;
    }
    private static final int G_UNICODE_SCRIPT_MEDEFAIDRIN = (int)146L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MEDEFAIDRIN = 146
     * }
     */
    public static int G_UNICODE_SCRIPT_MEDEFAIDRIN() {
        return G_UNICODE_SCRIPT_MEDEFAIDRIN;
    }
    private static final int G_UNICODE_SCRIPT_OLD_SOGDIAN = (int)147L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_SOGDIAN = 147
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_SOGDIAN() {
        return G_UNICODE_SCRIPT_OLD_SOGDIAN;
    }
    private static final int G_UNICODE_SCRIPT_SOGDIAN = (int)148L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_SOGDIAN = 148
     * }
     */
    public static int G_UNICODE_SCRIPT_SOGDIAN() {
        return G_UNICODE_SCRIPT_SOGDIAN;
    }
    private static final int G_UNICODE_SCRIPT_ELYMAIC = (int)149L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_ELYMAIC = 149
     * }
     */
    public static int G_UNICODE_SCRIPT_ELYMAIC() {
        return G_UNICODE_SCRIPT_ELYMAIC;
    }
    private static final int G_UNICODE_SCRIPT_NANDINAGARI = (int)150L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_NANDINAGARI = 150
     * }
     */
    public static int G_UNICODE_SCRIPT_NANDINAGARI() {
        return G_UNICODE_SCRIPT_NANDINAGARI;
    }
    private static final int G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = (int)151L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151
     * }
     */
    public static int G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG() {
        return G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG;
    }
    private static final int G_UNICODE_SCRIPT_WANCHO = (int)152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_WANCHO = 152
     * }
     */
    public static int G_UNICODE_SCRIPT_WANCHO() {
        return G_UNICODE_SCRIPT_WANCHO;
    }
    private static final int G_UNICODE_SCRIPT_CHORASMIAN = (int)153L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CHORASMIAN = 153
     * }
     */
    public static int G_UNICODE_SCRIPT_CHORASMIAN() {
        return G_UNICODE_SCRIPT_CHORASMIAN;
    }
    private static final int G_UNICODE_SCRIPT_DIVES_AKURU = (int)154L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_DIVES_AKURU = 154
     * }
     */
    public static int G_UNICODE_SCRIPT_DIVES_AKURU() {
        return G_UNICODE_SCRIPT_DIVES_AKURU;
    }
    private static final int G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT = (int)155L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT = 155
     * }
     */
    public static int G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT() {
        return G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT;
    }
    private static final int G_UNICODE_SCRIPT_YEZIDI = (int)156L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_YEZIDI = 156
     * }
     */
    public static int G_UNICODE_SCRIPT_YEZIDI() {
        return G_UNICODE_SCRIPT_YEZIDI;
    }
    private static final int G_UNICODE_SCRIPT_CYPRO_MINOAN = (int)157L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_CYPRO_MINOAN = 157
     * }
     */
    public static int G_UNICODE_SCRIPT_CYPRO_MINOAN() {
        return G_UNICODE_SCRIPT_CYPRO_MINOAN;
    }
    private static final int G_UNICODE_SCRIPT_OLD_UYGHUR = (int)158L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_OLD_UYGHUR = 158
     * }
     */
    public static int G_UNICODE_SCRIPT_OLD_UYGHUR() {
        return G_UNICODE_SCRIPT_OLD_UYGHUR;
    }
    private static final int G_UNICODE_SCRIPT_TANGSA = (int)159L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TANGSA = 159
     * }
     */
    public static int G_UNICODE_SCRIPT_TANGSA() {
        return G_UNICODE_SCRIPT_TANGSA;
    }
    private static final int G_UNICODE_SCRIPT_TOTO = (int)160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_TOTO = 160
     * }
     */
    public static int G_UNICODE_SCRIPT_TOTO() {
        return G_UNICODE_SCRIPT_TOTO;
    }
    private static final int G_UNICODE_SCRIPT_VITHKUQI = (int)161L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_VITHKUQI = 161
     * }
     */
    public static int G_UNICODE_SCRIPT_VITHKUQI() {
        return G_UNICODE_SCRIPT_VITHKUQI;
    }
    private static final int G_UNICODE_SCRIPT_MATH = (int)162L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_MATH = 162
     * }
     */
    public static int G_UNICODE_SCRIPT_MATH() {
        return G_UNICODE_SCRIPT_MATH;
    }
    private static final int G_UNICODE_SCRIPT_KAWI = (int)163L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_KAWI = 163
     * }
     */
    public static int G_UNICODE_SCRIPT_KAWI() {
        return G_UNICODE_SCRIPT_KAWI;
    }
    private static final int G_UNICODE_SCRIPT_NAG_MUNDARI = (int)164L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_UNICODE_SCRIPT_NAG_MUNDARI = 164
     * }
     */
    public static int G_UNICODE_SCRIPT_NAG_MUNDARI() {
        return G_UNICODE_SCRIPT_NAG_MUNDARI;
    }

    private static class g_unicode_script_to_iso15924 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unicode_script_to_iso15924");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script)
     * }
     */
    public static FunctionDescriptor g_unicode_script_to_iso15924$descriptor() {
        return g_unicode_script_to_iso15924.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script)
     * }
     */
    public static MethodHandle g_unicode_script_to_iso15924$handle() {
        return g_unicode_script_to_iso15924.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script)
     * }
     */
    public static MemorySegment g_unicode_script_to_iso15924$address() {
        return g_unicode_script_to_iso15924.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script)
     * }
     */
    public static int g_unicode_script_to_iso15924(int script) {
        var mh$ = g_unicode_script_to_iso15924.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unicode_script_to_iso15924", script);
            }
            return (int)mh$.invokeExact(script);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unicode_script_from_iso15924 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unicode_script_from_iso15924");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924)
     * }
     */
    public static FunctionDescriptor g_unicode_script_from_iso15924$descriptor() {
        return g_unicode_script_from_iso15924.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924)
     * }
     */
    public static MethodHandle g_unicode_script_from_iso15924$handle() {
        return g_unicode_script_from_iso15924.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924)
     * }
     */
    public static MemorySegment g_unicode_script_from_iso15924$address() {
        return g_unicode_script_from_iso15924.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924)
     * }
     */
    public static int g_unicode_script_from_iso15924(int iso15924) {
        var mh$ = g_unicode_script_from_iso15924.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unicode_script_from_iso15924", iso15924);
            }
            return (int)mh$.invokeExact(iso15924);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isalnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isalnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isalnum(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isalnum$descriptor() {
        return g_unichar_isalnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isalnum(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isalnum$handle() {
        return g_unichar_isalnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isalnum(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isalnum$address() {
        return g_unichar_isalnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isalnum(gunichar c)
     * }
     */
    public static int g_unichar_isalnum(int c) {
        var mh$ = g_unichar_isalnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isalnum", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isalpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isalpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isalpha(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isalpha$descriptor() {
        return g_unichar_isalpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isalpha(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isalpha$handle() {
        return g_unichar_isalpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isalpha(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isalpha$address() {
        return g_unichar_isalpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isalpha(gunichar c)
     * }
     */
    public static int g_unichar_isalpha(int c) {
        var mh$ = g_unichar_isalpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isalpha", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_iscntrl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_iscntrl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iscntrl(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_iscntrl$descriptor() {
        return g_unichar_iscntrl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iscntrl(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_iscntrl$handle() {
        return g_unichar_iscntrl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iscntrl(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_iscntrl$address() {
        return g_unichar_iscntrl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_iscntrl(gunichar c)
     * }
     */
    public static int g_unichar_iscntrl(int c) {
        var mh$ = g_unichar_iscntrl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_iscntrl", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isdigit(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isdigit$descriptor() {
        return g_unichar_isdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isdigit(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isdigit$handle() {
        return g_unichar_isdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isdigit(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isdigit$address() {
        return g_unichar_isdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isdigit(gunichar c)
     * }
     */
    public static int g_unichar_isdigit(int c) {
        var mh$ = g_unichar_isdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isdigit", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isgraph(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isgraph$descriptor() {
        return g_unichar_isgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isgraph(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isgraph$handle() {
        return g_unichar_isgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isgraph(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isgraph$address() {
        return g_unichar_isgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isgraph(gunichar c)
     * }
     */
    public static int g_unichar_isgraph(int c) {
        var mh$ = g_unichar_isgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isgraph", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_islower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_islower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_islower(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_islower$descriptor() {
        return g_unichar_islower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_islower(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_islower$handle() {
        return g_unichar_islower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_islower(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_islower$address() {
        return g_unichar_islower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_islower(gunichar c)
     * }
     */
    public static int g_unichar_islower(int c) {
        var mh$ = g_unichar_islower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_islower", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isprint(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isprint$descriptor() {
        return g_unichar_isprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isprint(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isprint$handle() {
        return g_unichar_isprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isprint(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isprint$address() {
        return g_unichar_isprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isprint(gunichar c)
     * }
     */
    public static int g_unichar_isprint(int c) {
        var mh$ = g_unichar_isprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isprint", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_ispunct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_ispunct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_ispunct(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_ispunct$descriptor() {
        return g_unichar_ispunct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_ispunct(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_ispunct$handle() {
        return g_unichar_ispunct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_ispunct(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_ispunct$address() {
        return g_unichar_ispunct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_ispunct(gunichar c)
     * }
     */
    public static int g_unichar_ispunct(int c) {
        var mh$ = g_unichar_ispunct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_ispunct", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isspace(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isspace$descriptor() {
        return g_unichar_isspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isspace(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isspace$handle() {
        return g_unichar_isspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isspace(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isspace$address() {
        return g_unichar_isspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isspace(gunichar c)
     * }
     */
    public static int g_unichar_isspace(int c) {
        var mh$ = g_unichar_isspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isspace", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isupper(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isupper$descriptor() {
        return g_unichar_isupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isupper(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isupper$handle() {
        return g_unichar_isupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isupper(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isupper$address() {
        return g_unichar_isupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isupper(gunichar c)
     * }
     */
    public static int g_unichar_isupper(int c) {
        var mh$ = g_unichar_isupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isupper", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isxdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isxdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isxdigit(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isxdigit$descriptor() {
        return g_unichar_isxdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isxdigit(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isxdigit$handle() {
        return g_unichar_isxdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isxdigit(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isxdigit$address() {
        return g_unichar_isxdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isxdigit(gunichar c)
     * }
     */
    public static int g_unichar_isxdigit(int c) {
        var mh$ = g_unichar_isxdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isxdigit", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_istitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_istitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_istitle(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_istitle$descriptor() {
        return g_unichar_istitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_istitle(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_istitle$handle() {
        return g_unichar_istitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_istitle(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_istitle$address() {
        return g_unichar_istitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_istitle(gunichar c)
     * }
     */
    public static int g_unichar_istitle(int c) {
        var mh$ = g_unichar_istitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_istitle", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_isdefined {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_isdefined");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isdefined(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_isdefined$descriptor() {
        return g_unichar_isdefined.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isdefined(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_isdefined$handle() {
        return g_unichar_isdefined.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_isdefined(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_isdefined$address() {
        return g_unichar_isdefined.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_isdefined(gunichar c)
     * }
     */
    public static int g_unichar_isdefined(int c) {
        var mh$ = g_unichar_isdefined.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_isdefined", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_iswide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_iswide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iswide(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_iswide$descriptor() {
        return g_unichar_iswide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iswide(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_iswide$handle() {
        return g_unichar_iswide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iswide(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_iswide$address() {
        return g_unichar_iswide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_iswide(gunichar c)
     * }
     */
    public static int g_unichar_iswide(int c) {
        var mh$ = g_unichar_iswide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_iswide", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_iswide_cjk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_iswide_cjk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iswide_cjk(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_iswide_cjk$descriptor() {
        return g_unichar_iswide_cjk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iswide_cjk(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_iswide_cjk$handle() {
        return g_unichar_iswide_cjk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iswide_cjk(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_iswide_cjk$address() {
        return g_unichar_iswide_cjk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_iswide_cjk(gunichar c)
     * }
     */
    public static int g_unichar_iswide_cjk(int c) {
        var mh$ = g_unichar_iswide_cjk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_iswide_cjk", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_iszerowidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_iszerowidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iszerowidth(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_iszerowidth$descriptor() {
        return g_unichar_iszerowidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iszerowidth(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_iszerowidth$handle() {
        return g_unichar_iszerowidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_iszerowidth(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_iszerowidth$address() {
        return g_unichar_iszerowidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_iszerowidth(gunichar c)
     * }
     */
    public static int g_unichar_iszerowidth(int c) {
        var mh$ = g_unichar_iszerowidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_iszerowidth", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_ismark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_ismark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_ismark(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_ismark$descriptor() {
        return g_unichar_ismark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_ismark(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_ismark$handle() {
        return g_unichar_ismark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_ismark(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_ismark$address() {
        return g_unichar_ismark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_ismark(gunichar c)
     * }
     */
    public static int g_unichar_ismark(int c) {
        var mh$ = g_unichar_ismark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_ismark", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_toupper(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_toupper$descriptor() {
        return g_unichar_toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_toupper(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_toupper$handle() {
        return g_unichar_toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_toupper(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_toupper$address() {
        return g_unichar_toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar g_unichar_toupper(gunichar c)
     * }
     */
    public static int g_unichar_toupper(int c) {
        var mh$ = g_unichar_toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_toupper", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_tolower(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_tolower$descriptor() {
        return g_unichar_tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_tolower(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_tolower$handle() {
        return g_unichar_tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_tolower(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_tolower$address() {
        return g_unichar_tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar g_unichar_tolower(gunichar c)
     * }
     */
    public static int g_unichar_tolower(int c) {
        var mh$ = g_unichar_tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_tolower", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_totitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_totitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_totitle(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_totitle$descriptor() {
        return g_unichar_totitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_totitle(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_totitle$handle() {
        return g_unichar_totitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar g_unichar_totitle(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_totitle$address() {
        return g_unichar_totitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar g_unichar_totitle(gunichar c)
     * }
     */
    public static int g_unichar_totitle(int c) {
        var mh$ = g_unichar_totitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_totitle", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_digit_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_digit_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_unichar_digit_value(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_digit_value$descriptor() {
        return g_unichar_digit_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_unichar_digit_value(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_digit_value$handle() {
        return g_unichar_digit_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_unichar_digit_value(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_digit_value$address() {
        return g_unichar_digit_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_unichar_digit_value(gunichar c)
     * }
     */
    public static int g_unichar_digit_value(int c) {
        var mh$ = g_unichar_digit_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_digit_value", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_xdigit_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_xdigit_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_unichar_xdigit_value(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_xdigit_value$descriptor() {
        return g_unichar_xdigit_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_unichar_xdigit_value(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_xdigit_value$handle() {
        return g_unichar_xdigit_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_unichar_xdigit_value(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_xdigit_value$address() {
        return g_unichar_xdigit_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_unichar_xdigit_value(gunichar c)
     * }
     */
    public static int g_unichar_xdigit_value(int c) {
        var mh$ = g_unichar_xdigit_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_xdigit_value", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUnicodeType g_unichar_type(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_type$descriptor() {
        return g_unichar_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUnicodeType g_unichar_type(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_type$handle() {
        return g_unichar_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUnicodeType g_unichar_type(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_type$address() {
        return g_unichar_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUnicodeType g_unichar_type(gunichar c)
     * }
     */
    public static int g_unichar_type(int c) {
        var mh$ = g_unichar_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_type", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_break_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_break_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUnicodeBreakType g_unichar_break_type(gunichar c)
     * }
     */
    public static FunctionDescriptor g_unichar_break_type$descriptor() {
        return g_unichar_break_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUnicodeBreakType g_unichar_break_type(gunichar c)
     * }
     */
    public static MethodHandle g_unichar_break_type$handle() {
        return g_unichar_break_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUnicodeBreakType g_unichar_break_type(gunichar c)
     * }
     */
    public static MemorySegment g_unichar_break_type$address() {
        return g_unichar_break_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUnicodeBreakType g_unichar_break_type(gunichar c)
     * }
     */
    public static int g_unichar_break_type(int c) {
        var mh$ = g_unichar_break_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_break_type", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_combining_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_combining_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_unichar_combining_class(gunichar uc)
     * }
     */
    public static FunctionDescriptor g_unichar_combining_class$descriptor() {
        return g_unichar_combining_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_unichar_combining_class(gunichar uc)
     * }
     */
    public static MethodHandle g_unichar_combining_class$handle() {
        return g_unichar_combining_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_unichar_combining_class(gunichar uc)
     * }
     */
    public static MemorySegment g_unichar_combining_class$address() {
        return g_unichar_combining_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_unichar_combining_class(gunichar uc)
     * }
     */
    public static int g_unichar_combining_class(int uc) {
        var mh$ = g_unichar_combining_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_combining_class", uc);
            }
            return (int)mh$.invokeExact(uc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_get_mirror_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_get_mirror_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_get_mirror_char(gunichar ch, gunichar *mirrored_ch)
     * }
     */
    public static FunctionDescriptor g_unichar_get_mirror_char$descriptor() {
        return g_unichar_get_mirror_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_get_mirror_char(gunichar ch, gunichar *mirrored_ch)
     * }
     */
    public static MethodHandle g_unichar_get_mirror_char$handle() {
        return g_unichar_get_mirror_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_get_mirror_char(gunichar ch, gunichar *mirrored_ch)
     * }
     */
    public static MemorySegment g_unichar_get_mirror_char$address() {
        return g_unichar_get_mirror_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_get_mirror_char(gunichar ch, gunichar *mirrored_ch)
     * }
     */
    public static int g_unichar_get_mirror_char(int ch, MemorySegment mirrored_ch) {
        var mh$ = g_unichar_get_mirror_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_get_mirror_char", ch, mirrored_ch);
            }
            return (int)mh$.invokeExact(ch, mirrored_ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_get_script {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_get_script");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GUnicodeScript g_unichar_get_script(gunichar ch)
     * }
     */
    public static FunctionDescriptor g_unichar_get_script$descriptor() {
        return g_unichar_get_script.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GUnicodeScript g_unichar_get_script(gunichar ch)
     * }
     */
    public static MethodHandle g_unichar_get_script$handle() {
        return g_unichar_get_script.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GUnicodeScript g_unichar_get_script(gunichar ch)
     * }
     */
    public static MemorySegment g_unichar_get_script$address() {
        return g_unichar_get_script.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GUnicodeScript g_unichar_get_script(gunichar ch)
     * }
     */
    public static int g_unichar_get_script(int ch) {
        var mh$ = g_unichar_get_script.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_get_script", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_validate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_validate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_validate(gunichar ch)
     * }
     */
    public static FunctionDescriptor g_unichar_validate$descriptor() {
        return g_unichar_validate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_validate(gunichar ch)
     * }
     */
    public static MethodHandle g_unichar_validate$handle() {
        return g_unichar_validate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_validate(gunichar ch)
     * }
     */
    public static MemorySegment g_unichar_validate$address() {
        return g_unichar_validate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_validate(gunichar ch)
     * }
     */
    public static int g_unichar_validate(int ch) {
        var mh$ = g_unichar_validate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_validate", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_compose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_compose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_compose(gunichar a, gunichar b, gunichar *ch)
     * }
     */
    public static FunctionDescriptor g_unichar_compose$descriptor() {
        return g_unichar_compose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_compose(gunichar a, gunichar b, gunichar *ch)
     * }
     */
    public static MethodHandle g_unichar_compose$handle() {
        return g_unichar_compose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_compose(gunichar a, gunichar b, gunichar *ch)
     * }
     */
    public static MemorySegment g_unichar_compose$address() {
        return g_unichar_compose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_compose(gunichar a, gunichar b, gunichar *ch)
     * }
     */
    public static int g_unichar_compose(int a, int b, MemorySegment ch) {
        var mh$ = g_unichar_compose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_compose", a, b, ch);
            }
            return (int)mh$.invokeExact(a, b, ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_decompose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_decompose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_decompose(gunichar ch, gunichar *a, gunichar *b)
     * }
     */
    public static FunctionDescriptor g_unichar_decompose$descriptor() {
        return g_unichar_decompose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_decompose(gunichar ch, gunichar *a, gunichar *b)
     * }
     */
    public static MethodHandle g_unichar_decompose$handle() {
        return g_unichar_decompose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_unichar_decompose(gunichar ch, gunichar *a, gunichar *b)
     * }
     */
    public static MemorySegment g_unichar_decompose$address() {
        return g_unichar_decompose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_unichar_decompose(gunichar ch, gunichar *a, gunichar *b)
     * }
     */
    public static int g_unichar_decompose(int ch, MemorySegment a, MemorySegment b) {
        var mh$ = g_unichar_decompose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_decompose", ch, a, b);
            }
            return (int)mh$.invokeExact(ch, a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_fully_decompose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_fully_decompose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_unichar_fully_decompose(gunichar ch, gboolean compat, gunichar *result, gsize result_len)
     * }
     */
    public static FunctionDescriptor g_unichar_fully_decompose$descriptor() {
        return g_unichar_fully_decompose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_unichar_fully_decompose(gunichar ch, gboolean compat, gunichar *result, gsize result_len)
     * }
     */
    public static MethodHandle g_unichar_fully_decompose$handle() {
        return g_unichar_fully_decompose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_unichar_fully_decompose(gunichar ch, gboolean compat, gunichar *result, gsize result_len)
     * }
     */
    public static MemorySegment g_unichar_fully_decompose$address() {
        return g_unichar_fully_decompose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_unichar_fully_decompose(gunichar ch, gboolean compat, gunichar *result, gsize result_len)
     * }
     */
    public static long g_unichar_fully_decompose(int ch, int compat, MemorySegment result, long result_len) {
        var mh$ = g_unichar_fully_decompose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_fully_decompose", ch, compat, result, result_len);
            }
            return (long)mh$.invokeExact(ch, compat, result, result_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unicode_canonical_ordering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unicode_canonical_ordering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_unicode_canonical_ordering(gunichar *string, gsize len)
     * }
     */
    public static FunctionDescriptor g_unicode_canonical_ordering$descriptor() {
        return g_unicode_canonical_ordering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_unicode_canonical_ordering(gunichar *string, gsize len)
     * }
     */
    public static MethodHandle g_unicode_canonical_ordering$handle() {
        return g_unicode_canonical_ordering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_unicode_canonical_ordering(gunichar *string, gsize len)
     * }
     */
    public static MemorySegment g_unicode_canonical_ordering$address() {
        return g_unicode_canonical_ordering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_unicode_canonical_ordering(gunichar *string, gsize len)
     * }
     */
    public static void g_unicode_canonical_ordering(MemorySegment string, long len) {
        var mh$ = g_unicode_canonical_ordering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unicode_canonical_ordering", string, len);
            }
            mh$.invokeExact(string, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unicode_canonical_decomposition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unicode_canonical_decomposition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar *g_unicode_canonical_decomposition(gunichar ch, gsize *result_len)
     * }
     */
    public static FunctionDescriptor g_unicode_canonical_decomposition$descriptor() {
        return g_unicode_canonical_decomposition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar *g_unicode_canonical_decomposition(gunichar ch, gsize *result_len)
     * }
     */
    public static MethodHandle g_unicode_canonical_decomposition$handle() {
        return g_unicode_canonical_decomposition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar *g_unicode_canonical_decomposition(gunichar ch, gsize *result_len)
     * }
     */
    public static MemorySegment g_unicode_canonical_decomposition$address() {
        return g_unicode_canonical_decomposition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar *g_unicode_canonical_decomposition(gunichar ch, gsize *result_len)
     * }
     */
    public static MemorySegment g_unicode_canonical_decomposition(int ch, MemorySegment result_len) {
        var mh$ = g_unicode_canonical_decomposition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unicode_canonical_decomposition", ch, result_len);
            }
            return (MemorySegment)mh$.invokeExact(ch, result_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_skip$constants {
        public static final AddressLayout LAYOUT = gst_min_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_utf8_skip").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const gchar *const g_utf8_skip
     * }
     */
    public static AddressLayout g_utf8_skip$layout() {
        return g_utf8_skip$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const gchar *const g_utf8_skip
     * }
     */
    public static MemorySegment g_utf8_skip$segment() {
        return g_utf8_skip$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const gchar *const g_utf8_skip
     * }
     */
    public static MemorySegment g_utf8_skip() {
        return g_utf8_skip$constants.SEGMENT.get(g_utf8_skip$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const gchar *const g_utf8_skip
     * }
     */
    public static void g_utf8_skip(MemorySegment varValue) {
        g_utf8_skip$constants.SEGMENT.set(g_utf8_skip$constants.LAYOUT, 0L, varValue);
    }

    private static class g_utf8_get_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_get_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar g_utf8_get_char(const gchar *p)
     * }
     */
    public static FunctionDescriptor g_utf8_get_char$descriptor() {
        return g_utf8_get_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar g_utf8_get_char(const gchar *p)
     * }
     */
    public static MethodHandle g_utf8_get_char$handle() {
        return g_utf8_get_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar g_utf8_get_char(const gchar *p)
     * }
     */
    public static MemorySegment g_utf8_get_char$address() {
        return g_utf8_get_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar g_utf8_get_char(const gchar *p)
     * }
     */
    public static int g_utf8_get_char(MemorySegment p) {
        var mh$ = g_utf8_get_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_get_char", p);
            }
            return (int)mh$.invokeExact(p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_get_char_validated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_get_char_validated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar g_utf8_get_char_validated(const gchar *p, gssize max_len)
     * }
     */
    public static FunctionDescriptor g_utf8_get_char_validated$descriptor() {
        return g_utf8_get_char_validated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar g_utf8_get_char_validated(const gchar *p, gssize max_len)
     * }
     */
    public static MethodHandle g_utf8_get_char_validated$handle() {
        return g_utf8_get_char_validated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar g_utf8_get_char_validated(const gchar *p, gssize max_len)
     * }
     */
    public static MemorySegment g_utf8_get_char_validated$address() {
        return g_utf8_get_char_validated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar g_utf8_get_char_validated(const gchar *p, gssize max_len)
     * }
     */
    public static int g_utf8_get_char_validated(MemorySegment p, long max_len) {
        var mh$ = g_utf8_get_char_validated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_get_char_validated", p, max_len);
            }
            return (int)mh$.invokeExact(p, max_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_offset_to_pointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_offset_to_pointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_offset_to_pointer(const gchar *str, glong offset)
     * }
     */
    public static FunctionDescriptor g_utf8_offset_to_pointer$descriptor() {
        return g_utf8_offset_to_pointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_offset_to_pointer(const gchar *str, glong offset)
     * }
     */
    public static MethodHandle g_utf8_offset_to_pointer$handle() {
        return g_utf8_offset_to_pointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_offset_to_pointer(const gchar *str, glong offset)
     * }
     */
    public static MemorySegment g_utf8_offset_to_pointer$address() {
        return g_utf8_offset_to_pointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_offset_to_pointer(const gchar *str, glong offset)
     * }
     */
    public static MemorySegment g_utf8_offset_to_pointer(MemorySegment str, int offset) {
        var mh$ = g_utf8_offset_to_pointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_offset_to_pointer", str, offset);
            }
            return (MemorySegment)mh$.invokeExact(str, offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_pointer_to_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_pointer_to_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern glong g_utf8_pointer_to_offset(const gchar *str, const gchar *pos)
     * }
     */
    public static FunctionDescriptor g_utf8_pointer_to_offset$descriptor() {
        return g_utf8_pointer_to_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern glong g_utf8_pointer_to_offset(const gchar *str, const gchar *pos)
     * }
     */
    public static MethodHandle g_utf8_pointer_to_offset$handle() {
        return g_utf8_pointer_to_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern glong g_utf8_pointer_to_offset(const gchar *str, const gchar *pos)
     * }
     */
    public static MemorySegment g_utf8_pointer_to_offset$address() {
        return g_utf8_pointer_to_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern glong g_utf8_pointer_to_offset(const gchar *str, const gchar *pos)
     * }
     */
    public static int g_utf8_pointer_to_offset(MemorySegment str, MemorySegment pos) {
        var mh$ = g_utf8_pointer_to_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_pointer_to_offset", str, pos);
            }
            return (int)mh$.invokeExact(str, pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_prev_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_prev_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_prev_char(const gchar *p)
     * }
     */
    public static FunctionDescriptor g_utf8_prev_char$descriptor() {
        return g_utf8_prev_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_prev_char(const gchar *p)
     * }
     */
    public static MethodHandle g_utf8_prev_char$handle() {
        return g_utf8_prev_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_prev_char(const gchar *p)
     * }
     */
    public static MemorySegment g_utf8_prev_char$address() {
        return g_utf8_prev_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_prev_char(const gchar *p)
     * }
     */
    public static MemorySegment g_utf8_prev_char(MemorySegment p) {
        var mh$ = g_utf8_prev_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_prev_char", p);
            }
            return (MemorySegment)mh$.invokeExact(p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_find_next_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_find_next_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_find_next_char(const gchar *p, const gchar *end)
     * }
     */
    public static FunctionDescriptor g_utf8_find_next_char$descriptor() {
        return g_utf8_find_next_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_find_next_char(const gchar *p, const gchar *end)
     * }
     */
    public static MethodHandle g_utf8_find_next_char$handle() {
        return g_utf8_find_next_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_find_next_char(const gchar *p, const gchar *end)
     * }
     */
    public static MemorySegment g_utf8_find_next_char$address() {
        return g_utf8_find_next_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_find_next_char(const gchar *p, const gchar *end)
     * }
     */
    public static MemorySegment g_utf8_find_next_char(MemorySegment p, MemorySegment end) {
        var mh$ = g_utf8_find_next_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_find_next_char", p, end);
            }
            return (MemorySegment)mh$.invokeExact(p, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_find_prev_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_find_prev_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_find_prev_char(const gchar *str, const gchar *p)
     * }
     */
    public static FunctionDescriptor g_utf8_find_prev_char$descriptor() {
        return g_utf8_find_prev_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_find_prev_char(const gchar *str, const gchar *p)
     * }
     */
    public static MethodHandle g_utf8_find_prev_char$handle() {
        return g_utf8_find_prev_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_find_prev_char(const gchar *str, const gchar *p)
     * }
     */
    public static MemorySegment g_utf8_find_prev_char$address() {
        return g_utf8_find_prev_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_find_prev_char(const gchar *str, const gchar *p)
     * }
     */
    public static MemorySegment g_utf8_find_prev_char(MemorySegment str, MemorySegment p) {
        var mh$ = g_utf8_find_prev_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_find_prev_char", str, p);
            }
            return (MemorySegment)mh$.invokeExact(str, p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern glong g_utf8_strlen(const gchar *p, gssize max)
     * }
     */
    public static FunctionDescriptor g_utf8_strlen$descriptor() {
        return g_utf8_strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern glong g_utf8_strlen(const gchar *p, gssize max)
     * }
     */
    public static MethodHandle g_utf8_strlen$handle() {
        return g_utf8_strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern glong g_utf8_strlen(const gchar *p, gssize max)
     * }
     */
    public static MemorySegment g_utf8_strlen$address() {
        return g_utf8_strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern glong g_utf8_strlen(const gchar *p, gssize max)
     * }
     */
    public static int g_utf8_strlen(MemorySegment p, long max) {
        var mh$ = g_utf8_strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_strlen", p, max);
            }
            return (int)mh$.invokeExact(p, max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_substring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_substring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_substring(const gchar *str, glong start_pos, glong end_pos)
     * }
     */
    public static FunctionDescriptor g_utf8_substring$descriptor() {
        return g_utf8_substring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_substring(const gchar *str, glong start_pos, glong end_pos)
     * }
     */
    public static MethodHandle g_utf8_substring$handle() {
        return g_utf8_substring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_substring(const gchar *str, glong start_pos, glong end_pos)
     * }
     */
    public static MemorySegment g_utf8_substring$address() {
        return g_utf8_substring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_substring(const gchar *str, glong start_pos, glong end_pos)
     * }
     */
    public static MemorySegment g_utf8_substring(MemorySegment str, int start_pos, int end_pos) {
        var mh$ = g_utf8_substring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_substring", str, start_pos, end_pos);
            }
            return (MemorySegment)mh$.invokeExact(str, start_pos, end_pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strncpy(gchar *dest, const gchar *src, gsize n)
     * }
     */
    public static FunctionDescriptor g_utf8_strncpy$descriptor() {
        return g_utf8_strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strncpy(gchar *dest, const gchar *src, gsize n)
     * }
     */
    public static MethodHandle g_utf8_strncpy$handle() {
        return g_utf8_strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strncpy(gchar *dest, const gchar *src, gsize n)
     * }
     */
    public static MemorySegment g_utf8_strncpy$address() {
        return g_utf8_strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_strncpy(gchar *dest, const gchar *src, gsize n)
     * }
     */
    public static MemorySegment g_utf8_strncpy(MemorySegment dest, MemorySegment src, long n) {
        var mh$ = g_utf8_strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_strncpy", dest, src, n);
            }
            return (MemorySegment)mh$.invokeExact(dest, src, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_truncate_middle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_truncate_middle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_truncate_middle(const gchar *string, gsize truncate_length)
     * }
     */
    public static FunctionDescriptor g_utf8_truncate_middle$descriptor() {
        return g_utf8_truncate_middle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_truncate_middle(const gchar *string, gsize truncate_length)
     * }
     */
    public static MethodHandle g_utf8_truncate_middle$handle() {
        return g_utf8_truncate_middle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_truncate_middle(const gchar *string, gsize truncate_length)
     * }
     */
    public static MemorySegment g_utf8_truncate_middle$address() {
        return g_utf8_truncate_middle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_truncate_middle(const gchar *string, gsize truncate_length)
     * }
     */
    public static MemorySegment g_utf8_truncate_middle(MemorySegment string, long truncate_length) {
        var mh$ = g_utf8_truncate_middle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_truncate_middle", string, truncate_length);
            }
            return (MemorySegment)mh$.invokeExact(string, truncate_length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strchr(const gchar *p, gssize len, gunichar c)
     * }
     */
    public static FunctionDescriptor g_utf8_strchr$descriptor() {
        return g_utf8_strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strchr(const gchar *p, gssize len, gunichar c)
     * }
     */
    public static MethodHandle g_utf8_strchr$handle() {
        return g_utf8_strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strchr(const gchar *p, gssize len, gunichar c)
     * }
     */
    public static MemorySegment g_utf8_strchr$address() {
        return g_utf8_strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_strchr(const gchar *p, gssize len, gunichar c)
     * }
     */
    public static MemorySegment g_utf8_strchr(MemorySegment p, long len, int c) {
        var mh$ = g_utf8_strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_strchr", p, len, c);
            }
            return (MemorySegment)mh$.invokeExact(p, len, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strrchr(const gchar *p, gssize len, gunichar c)
     * }
     */
    public static FunctionDescriptor g_utf8_strrchr$descriptor() {
        return g_utf8_strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strrchr(const gchar *p, gssize len, gunichar c)
     * }
     */
    public static MethodHandle g_utf8_strrchr$handle() {
        return g_utf8_strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strrchr(const gchar *p, gssize len, gunichar c)
     * }
     */
    public static MemorySegment g_utf8_strrchr$address() {
        return g_utf8_strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_strrchr(const gchar *p, gssize len, gunichar c)
     * }
     */
    public static MemorySegment g_utf8_strrchr(MemorySegment p, long len, int c) {
        var mh$ = g_utf8_strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_strrchr", p, len, c);
            }
            return (MemorySegment)mh$.invokeExact(p, len, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_strreverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_strreverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strreverse(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_utf8_strreverse$descriptor() {
        return g_utf8_strreverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strreverse(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_utf8_strreverse$handle() {
        return g_utf8_strreverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strreverse(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_strreverse$address() {
        return g_utf8_strreverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_strreverse(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_strreverse(MemorySegment str, long len) {
        var mh$ = g_utf8_strreverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_strreverse", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_to_utf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_to_utf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar2 *g_utf8_to_utf16(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_utf8_to_utf16$descriptor() {
        return g_utf8_to_utf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar2 *g_utf8_to_utf16(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MethodHandle g_utf8_to_utf16$handle() {
        return g_utf8_to_utf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar2 *g_utf8_to_utf16(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_utf8_to_utf16$address() {
        return g_utf8_to_utf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar2 *g_utf8_to_utf16(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_utf8_to_utf16(MemorySegment str, int len, MemorySegment items_read, MemorySegment items_written, MemorySegment error) {
        var mh$ = g_utf8_to_utf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_to_utf16", str, len, items_read, items_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, items_read, items_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_to_ucs4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_to_ucs4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar *g_utf8_to_ucs4(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_utf8_to_ucs4$descriptor() {
        return g_utf8_to_ucs4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar *g_utf8_to_ucs4(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MethodHandle g_utf8_to_ucs4$handle() {
        return g_utf8_to_ucs4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar *g_utf8_to_ucs4(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_utf8_to_ucs4$address() {
        return g_utf8_to_ucs4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar *g_utf8_to_ucs4(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_utf8_to_ucs4(MemorySegment str, int len, MemorySegment items_read, MemorySegment items_written, MemorySegment error) {
        var mh$ = g_utf8_to_ucs4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_to_ucs4", str, len, items_read, items_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, items_read, items_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_to_ucs4_fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_to_ucs4_fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar *g_utf8_to_ucs4_fast(const gchar *str, glong len, glong *items_written)
     * }
     */
    public static FunctionDescriptor g_utf8_to_ucs4_fast$descriptor() {
        return g_utf8_to_ucs4_fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar *g_utf8_to_ucs4_fast(const gchar *str, glong len, glong *items_written)
     * }
     */
    public static MethodHandle g_utf8_to_ucs4_fast$handle() {
        return g_utf8_to_ucs4_fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar *g_utf8_to_ucs4_fast(const gchar *str, glong len, glong *items_written)
     * }
     */
    public static MemorySegment g_utf8_to_ucs4_fast$address() {
        return g_utf8_to_ucs4_fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar *g_utf8_to_ucs4_fast(const gchar *str, glong len, glong *items_written)
     * }
     */
    public static MemorySegment g_utf8_to_ucs4_fast(MemorySegment str, int len, MemorySegment items_written) {
        var mh$ = g_utf8_to_ucs4_fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_to_ucs4_fast", str, len, items_written);
            }
            return (MemorySegment)mh$.invokeExact(str, len, items_written);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf16_to_ucs4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf16_to_ucs4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar *g_utf16_to_ucs4(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_utf16_to_ucs4$descriptor() {
        return g_utf16_to_ucs4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar *g_utf16_to_ucs4(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MethodHandle g_utf16_to_ucs4$handle() {
        return g_utf16_to_ucs4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar *g_utf16_to_ucs4(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_utf16_to_ucs4$address() {
        return g_utf16_to_ucs4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar *g_utf16_to_ucs4(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_utf16_to_ucs4(MemorySegment str, int len, MemorySegment items_read, MemorySegment items_written, MemorySegment error) {
        var mh$ = g_utf16_to_ucs4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf16_to_ucs4", str, len, items_read, items_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, items_read, items_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf16_to_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf16_to_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf16_to_utf8(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_utf16_to_utf8$descriptor() {
        return g_utf16_to_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf16_to_utf8(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MethodHandle g_utf16_to_utf8$handle() {
        return g_utf16_to_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf16_to_utf8(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_utf16_to_utf8$address() {
        return g_utf16_to_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf16_to_utf8(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_utf16_to_utf8(MemorySegment str, int len, MemorySegment items_read, MemorySegment items_written, MemorySegment error) {
        var mh$ = g_utf16_to_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf16_to_utf8", str, len, items_read, items_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, items_read, items_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ucs4_to_utf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ucs4_to_utf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gunichar2 *g_ucs4_to_utf16(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_ucs4_to_utf16$descriptor() {
        return g_ucs4_to_utf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gunichar2 *g_ucs4_to_utf16(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MethodHandle g_ucs4_to_utf16$handle() {
        return g_ucs4_to_utf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gunichar2 *g_ucs4_to_utf16(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_ucs4_to_utf16$address() {
        return g_ucs4_to_utf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gunichar2 *g_ucs4_to_utf16(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_ucs4_to_utf16(MemorySegment str, int len, MemorySegment items_read, MemorySegment items_written, MemorySegment error) {
        var mh$ = g_ucs4_to_utf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ucs4_to_utf16", str, len, items_read, items_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, items_read, items_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ucs4_to_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ucs4_to_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_ucs4_to_utf8(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_ucs4_to_utf8$descriptor() {
        return g_ucs4_to_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_ucs4_to_utf8(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MethodHandle g_ucs4_to_utf8$handle() {
        return g_ucs4_to_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_ucs4_to_utf8(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_ucs4_to_utf8$address() {
        return g_ucs4_to_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_ucs4_to_utf8(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
     * }
     */
    public static MemorySegment g_ucs4_to_utf8(MemorySegment str, int len, MemorySegment items_read, MemorySegment items_written, MemorySegment error) {
        var mh$ = g_ucs4_to_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ucs4_to_utf8", str, len, items_read, items_written, error);
            }
            return (MemorySegment)mh$.invokeExact(str, len, items_read, items_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_unichar_to_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_unichar_to_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_unichar_to_utf8(gunichar c, gchar *outbuf)
     * }
     */
    public static FunctionDescriptor g_unichar_to_utf8$descriptor() {
        return g_unichar_to_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_unichar_to_utf8(gunichar c, gchar *outbuf)
     * }
     */
    public static MethodHandle g_unichar_to_utf8$handle() {
        return g_unichar_to_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_unichar_to_utf8(gunichar c, gchar *outbuf)
     * }
     */
    public static MemorySegment g_unichar_to_utf8$address() {
        return g_unichar_to_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_unichar_to_utf8(gunichar c, gchar *outbuf)
     * }
     */
    public static int g_unichar_to_utf8(int c, MemorySegment outbuf) {
        var mh$ = g_unichar_to_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_unichar_to_utf8", c, outbuf);
            }
            return (int)mh$.invokeExact(c, outbuf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_validate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_validate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_utf8_validate(const gchar *str, gssize max_len, const gchar **end)
     * }
     */
    public static FunctionDescriptor g_utf8_validate$descriptor() {
        return g_utf8_validate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_utf8_validate(const gchar *str, gssize max_len, const gchar **end)
     * }
     */
    public static MethodHandle g_utf8_validate$handle() {
        return g_utf8_validate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_utf8_validate(const gchar *str, gssize max_len, const gchar **end)
     * }
     */
    public static MemorySegment g_utf8_validate$address() {
        return g_utf8_validate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_utf8_validate(const gchar *str, gssize max_len, const gchar **end)
     * }
     */
    public static int g_utf8_validate(MemorySegment str, long max_len, MemorySegment end) {
        var mh$ = g_utf8_validate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_validate", str, max_len, end);
            }
            return (int)mh$.invokeExact(str, max_len, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_validate_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_validate_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_utf8_validate_len(const gchar *str, gsize max_len, const gchar **end)
     * }
     */
    public static FunctionDescriptor g_utf8_validate_len$descriptor() {
        return g_utf8_validate_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_utf8_validate_len(const gchar *str, gsize max_len, const gchar **end)
     * }
     */
    public static MethodHandle g_utf8_validate_len$handle() {
        return g_utf8_validate_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_utf8_validate_len(const gchar *str, gsize max_len, const gchar **end)
     * }
     */
    public static MemorySegment g_utf8_validate_len$address() {
        return g_utf8_validate_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_utf8_validate_len(const gchar *str, gsize max_len, const gchar **end)
     * }
     */
    public static int g_utf8_validate_len(MemorySegment str, long max_len, MemorySegment end) {
        var mh$ = g_utf8_validate_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_validate_len", str, max_len, end);
            }
            return (int)mh$.invokeExact(str, max_len, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_strup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_strup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strup(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_utf8_strup$descriptor() {
        return g_utf8_strup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strup(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_utf8_strup$handle() {
        return g_utf8_strup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strup(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_strup$address() {
        return g_utf8_strup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_strup(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_strup(MemorySegment str, long len) {
        var mh$ = g_utf8_strup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_strup", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_strdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_strdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strdown(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_utf8_strdown$descriptor() {
        return g_utf8_strdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strdown(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_utf8_strdown$handle() {
        return g_utf8_strdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_strdown(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_strdown$address() {
        return g_utf8_strdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_strdown(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_strdown(MemorySegment str, long len) {
        var mh$ = g_utf8_strdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_strdown", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_casefold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_casefold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_casefold(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_utf8_casefold$descriptor() {
        return g_utf8_casefold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_casefold(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_utf8_casefold$handle() {
        return g_utf8_casefold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_casefold(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_casefold$address() {
        return g_utf8_casefold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_casefold(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_casefold(MemorySegment str, long len) {
        var mh$ = g_utf8_casefold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_casefold", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_NORMALIZE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NORMALIZE_DEFAULT = 0
     * }
     */
    public static int G_NORMALIZE_DEFAULT() {
        return G_NORMALIZE_DEFAULT;
    }
    private static final int G_NORMALIZE_NFD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NORMALIZE_NFD = 0
     * }
     */
    public static int G_NORMALIZE_NFD() {
        return G_NORMALIZE_NFD;
    }
    private static final int G_NORMALIZE_DEFAULT_COMPOSE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NORMALIZE_DEFAULT_COMPOSE = 1
     * }
     */
    public static int G_NORMALIZE_DEFAULT_COMPOSE() {
        return G_NORMALIZE_DEFAULT_COMPOSE;
    }
    private static final int G_NORMALIZE_NFC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NORMALIZE_NFC = 1
     * }
     */
    public static int G_NORMALIZE_NFC() {
        return G_NORMALIZE_NFC;
    }
    private static final int G_NORMALIZE_ALL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NORMALIZE_ALL = 2
     * }
     */
    public static int G_NORMALIZE_ALL() {
        return G_NORMALIZE_ALL;
    }
    private static final int G_NORMALIZE_NFKD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NORMALIZE_NFKD = 2
     * }
     */
    public static int G_NORMALIZE_NFKD() {
        return G_NORMALIZE_NFKD;
    }
    private static final int G_NORMALIZE_ALL_COMPOSE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NORMALIZE_ALL_COMPOSE = 3
     * }
     */
    public static int G_NORMALIZE_ALL_COMPOSE() {
        return G_NORMALIZE_ALL_COMPOSE;
    }
    private static final int G_NORMALIZE_NFKC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NORMALIZE_NFKC = 3
     * }
     */
    public static int G_NORMALIZE_NFKC() {
        return G_NORMALIZE_NFKC;
    }

    private static class g_utf8_normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_normalize(const gchar *str, gssize len, GNormalizeMode mode)
     * }
     */
    public static FunctionDescriptor g_utf8_normalize$descriptor() {
        return g_utf8_normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_normalize(const gchar *str, gssize len, GNormalizeMode mode)
     * }
     */
    public static MethodHandle g_utf8_normalize$handle() {
        return g_utf8_normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_normalize(const gchar *str, gssize len, GNormalizeMode mode)
     * }
     */
    public static MemorySegment g_utf8_normalize$address() {
        return g_utf8_normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_normalize(const gchar *str, gssize len, GNormalizeMode mode)
     * }
     */
    public static MemorySegment g_utf8_normalize(MemorySegment str, long len, int mode) {
        var mh$ = g_utf8_normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_normalize", str, len, mode);
            }
            return (MemorySegment)mh$.invokeExact(str, len, mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_collate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_collate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_utf8_collate(const gchar *str1, const gchar *str2)
     * }
     */
    public static FunctionDescriptor g_utf8_collate$descriptor() {
        return g_utf8_collate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_utf8_collate(const gchar *str1, const gchar *str2)
     * }
     */
    public static MethodHandle g_utf8_collate$handle() {
        return g_utf8_collate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_utf8_collate(const gchar *str1, const gchar *str2)
     * }
     */
    public static MemorySegment g_utf8_collate$address() {
        return g_utf8_collate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_utf8_collate(const gchar *str1, const gchar *str2)
     * }
     */
    public static int g_utf8_collate(MemorySegment str1, MemorySegment str2) {
        var mh$ = g_utf8_collate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_collate", str1, str2);
            }
            return (int)mh$.invokeExact(str1, str2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_collate_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_collate_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_collate_key(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_utf8_collate_key$descriptor() {
        return g_utf8_collate_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_collate_key(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_utf8_collate_key$handle() {
        return g_utf8_collate_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_collate_key(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_collate_key$address() {
        return g_utf8_collate_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_collate_key(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_collate_key(MemorySegment str, long len) {
        var mh$ = g_utf8_collate_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_collate_key", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_collate_key_for_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_collate_key_for_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_collate_key_for_filename(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_utf8_collate_key_for_filename$descriptor() {
        return g_utf8_collate_key_for_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_collate_key_for_filename(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_utf8_collate_key_for_filename$handle() {
        return g_utf8_collate_key_for_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_collate_key_for_filename(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_collate_key_for_filename$address() {
        return g_utf8_collate_key_for_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_collate_key_for_filename(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_collate_key_for_filename(MemorySegment str, long len) {
        var mh$ = g_utf8_collate_key_for_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_collate_key_for_filename", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_utf8_make_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_utf8_make_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_make_valid(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_utf8_make_valid$descriptor() {
        return g_utf8_make_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_make_valid(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_utf8_make_valid$handle() {
        return g_utf8_make_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_utf8_make_valid(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_make_valid$address() {
        return g_utf8_make_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_utf8_make_valid(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_utf8_make_valid(MemorySegment str, long len) {
        var mh$ = g_utf8_make_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_utf8_make_valid", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_ASCII_ALNUM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_ALNUM = 1
     * }
     */
    public static int G_ASCII_ALNUM() {
        return G_ASCII_ALNUM;
    }
    private static final int G_ASCII_ALPHA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_ALPHA = 2
     * }
     */
    public static int G_ASCII_ALPHA() {
        return G_ASCII_ALPHA;
    }
    private static final int G_ASCII_CNTRL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_CNTRL = 4
     * }
     */
    public static int G_ASCII_CNTRL() {
        return G_ASCII_CNTRL;
    }
    private static final int G_ASCII_DIGIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_DIGIT = 8
     * }
     */
    public static int G_ASCII_DIGIT() {
        return G_ASCII_DIGIT;
    }
    private static final int G_ASCII_GRAPH = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_GRAPH = 16
     * }
     */
    public static int G_ASCII_GRAPH() {
        return G_ASCII_GRAPH;
    }
    private static final int G_ASCII_LOWER = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_LOWER = 32
     * }
     */
    public static int G_ASCII_LOWER() {
        return G_ASCII_LOWER;
    }
    private static final int G_ASCII_PRINT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_PRINT = 64
     * }
     */
    public static int G_ASCII_PRINT() {
        return G_ASCII_PRINT;
    }
    private static final int G_ASCII_PUNCT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_PUNCT = 128
     * }
     */
    public static int G_ASCII_PUNCT() {
        return G_ASCII_PUNCT;
    }
    private static final int G_ASCII_SPACE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_SPACE = 256
     * }
     */
    public static int G_ASCII_SPACE() {
        return G_ASCII_SPACE;
    }
    private static final int G_ASCII_UPPER = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_UPPER = 512
     * }
     */
    public static int G_ASCII_UPPER() {
        return G_ASCII_UPPER;
    }
    private static final int G_ASCII_XDIGIT = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ASCII_XDIGIT = 1024
     * }
     */
    public static int G_ASCII_XDIGIT() {
        return G_ASCII_XDIGIT;
    }

    private static class g_ascii_table$constants {
        public static final AddressLayout LAYOUT = gst_min_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_ascii_table").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const guint16 *const g_ascii_table
     * }
     */
    public static AddressLayout g_ascii_table$layout() {
        return g_ascii_table$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const guint16 *const g_ascii_table
     * }
     */
    public static MemorySegment g_ascii_table$segment() {
        return g_ascii_table$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const guint16 *const g_ascii_table
     * }
     */
    public static MemorySegment g_ascii_table() {
        return g_ascii_table$constants.SEGMENT.get(g_ascii_table$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const guint16 *const g_ascii_table
     * }
     */
    public static void g_ascii_table(MemorySegment varValue) {
        g_ascii_table$constants.SEGMENT.set(g_ascii_table$constants.LAYOUT, 0L, varValue);
    }

    private static class g_ascii_tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_CHAR,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar g_ascii_tolower(gchar c)
     * }
     */
    public static FunctionDescriptor g_ascii_tolower$descriptor() {
        return g_ascii_tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar g_ascii_tolower(gchar c)
     * }
     */
    public static MethodHandle g_ascii_tolower$handle() {
        return g_ascii_tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar g_ascii_tolower(gchar c)
     * }
     */
    public static MemorySegment g_ascii_tolower$address() {
        return g_ascii_tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar g_ascii_tolower(gchar c)
     * }
     */
    public static byte g_ascii_tolower(byte c) {
        var mh$ = g_ascii_tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_tolower", c);
            }
            return (byte)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_CHAR,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar g_ascii_toupper(gchar c)
     * }
     */
    public static FunctionDescriptor g_ascii_toupper$descriptor() {
        return g_ascii_toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar g_ascii_toupper(gchar c)
     * }
     */
    public static MethodHandle g_ascii_toupper$handle() {
        return g_ascii_toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar g_ascii_toupper(gchar c)
     * }
     */
    public static MemorySegment g_ascii_toupper$address() {
        return g_ascii_toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar g_ascii_toupper(gchar c)
     * }
     */
    public static byte g_ascii_toupper(byte c) {
        var mh$ = g_ascii_toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_toupper", c);
            }
            return (byte)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_digit_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_digit_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_ascii_digit_value(gchar c)
     * }
     */
    public static FunctionDescriptor g_ascii_digit_value$descriptor() {
        return g_ascii_digit_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_ascii_digit_value(gchar c)
     * }
     */
    public static MethodHandle g_ascii_digit_value$handle() {
        return g_ascii_digit_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_ascii_digit_value(gchar c)
     * }
     */
    public static MemorySegment g_ascii_digit_value$address() {
        return g_ascii_digit_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_ascii_digit_value(gchar c)
     * }
     */
    public static int g_ascii_digit_value(byte c) {
        var mh$ = g_ascii_digit_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_digit_value", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_xdigit_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_xdigit_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_ascii_xdigit_value(gchar c)
     * }
     */
    public static FunctionDescriptor g_ascii_xdigit_value$descriptor() {
        return g_ascii_xdigit_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_ascii_xdigit_value(gchar c)
     * }
     */
    public static MethodHandle g_ascii_xdigit_value$handle() {
        return g_ascii_xdigit_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_ascii_xdigit_value(gchar c)
     * }
     */
    public static MemorySegment g_ascii_xdigit_value$address() {
        return g_ascii_xdigit_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_ascii_xdigit_value(gchar c)
     * }
     */
    public static int g_ascii_xdigit_value(byte c) {
        var mh$ = g_ascii_xdigit_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_xdigit_value", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strdelimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strdelimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strdelimit(gchar *string, const gchar *delimiters, gchar new_delimiter)
     * }
     */
    public static FunctionDescriptor g_strdelimit$descriptor() {
        return g_strdelimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strdelimit(gchar *string, const gchar *delimiters, gchar new_delimiter)
     * }
     */
    public static MethodHandle g_strdelimit$handle() {
        return g_strdelimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strdelimit(gchar *string, const gchar *delimiters, gchar new_delimiter)
     * }
     */
    public static MemorySegment g_strdelimit$address() {
        return g_strdelimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strdelimit(gchar *string, const gchar *delimiters, gchar new_delimiter)
     * }
     */
    public static MemorySegment g_strdelimit(MemorySegment string, MemorySegment delimiters, byte new_delimiter) {
        var mh$ = g_strdelimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strdelimit", string, delimiters, new_delimiter);
            }
            return (MemorySegment)mh$.invokeExact(string, delimiters, new_delimiter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strcanon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strcanon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strcanon(gchar *string, const gchar *valid_chars, gchar substitutor)
     * }
     */
    public static FunctionDescriptor g_strcanon$descriptor() {
        return g_strcanon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strcanon(gchar *string, const gchar *valid_chars, gchar substitutor)
     * }
     */
    public static MethodHandle g_strcanon$handle() {
        return g_strcanon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strcanon(gchar *string, const gchar *valid_chars, gchar substitutor)
     * }
     */
    public static MemorySegment g_strcanon$address() {
        return g_strcanon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strcanon(gchar *string, const gchar *valid_chars, gchar substitutor)
     * }
     */
    public static MemorySegment g_strcanon(MemorySegment string, MemorySegment valid_chars, byte substitutor) {
        var mh$ = g_strcanon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strcanon", string, valid_chars, substitutor);
            }
            return (MemorySegment)mh$.invokeExact(string, valid_chars, substitutor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_strerror(gint errnum)
     * }
     */
    public static FunctionDescriptor g_strerror$descriptor() {
        return g_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_strerror(gint errnum)
     * }
     */
    public static MethodHandle g_strerror$handle() {
        return g_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_strerror(gint errnum)
     * }
     */
    public static MemorySegment g_strerror$address() {
        return g_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_strerror(gint errnum)
     * }
     */
    public static MemorySegment g_strerror(int errnum) {
        var mh$ = g_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strerror", errnum);
            }
            return (MemorySegment)mh$.invokeExact(errnum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_strsignal(gint signum)
     * }
     */
    public static FunctionDescriptor g_strsignal$descriptor() {
        return g_strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_strsignal(gint signum)
     * }
     */
    public static MethodHandle g_strsignal$handle() {
        return g_strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_strsignal(gint signum)
     * }
     */
    public static MemorySegment g_strsignal$address() {
        return g_strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_strsignal(gint signum)
     * }
     */
    public static MemorySegment g_strsignal(int signum) {
        var mh$ = g_strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strsignal", signum);
            }
            return (MemorySegment)mh$.invokeExact(signum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strreverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strreverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strreverse(gchar *string)
     * }
     */
    public static FunctionDescriptor g_strreverse$descriptor() {
        return g_strreverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strreverse(gchar *string)
     * }
     */
    public static MethodHandle g_strreverse$handle() {
        return g_strreverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strreverse(gchar *string)
     * }
     */
    public static MemorySegment g_strreverse$address() {
        return g_strreverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strreverse(gchar *string)
     * }
     */
    public static MemorySegment g_strreverse(MemorySegment string) {
        var mh$ = g_strreverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strreverse", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_strlcpy(gchar *dest, const gchar *src, gsize dest_size)
     * }
     */
    public static FunctionDescriptor g_strlcpy$descriptor() {
        return g_strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_strlcpy(gchar *dest, const gchar *src, gsize dest_size)
     * }
     */
    public static MethodHandle g_strlcpy$handle() {
        return g_strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_strlcpy(gchar *dest, const gchar *src, gsize dest_size)
     * }
     */
    public static MemorySegment g_strlcpy$address() {
        return g_strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_strlcpy(gchar *dest, const gchar *src, gsize dest_size)
     * }
     */
    public static long g_strlcpy(MemorySegment dest, MemorySegment src, long dest_size) {
        var mh$ = g_strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strlcpy", dest, src, dest_size);
            }
            return (long)mh$.invokeExact(dest, src, dest_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_strlcat(gchar *dest, const gchar *src, gsize dest_size)
     * }
     */
    public static FunctionDescriptor g_strlcat$descriptor() {
        return g_strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_strlcat(gchar *dest, const gchar *src, gsize dest_size)
     * }
     */
    public static MethodHandle g_strlcat$handle() {
        return g_strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_strlcat(gchar *dest, const gchar *src, gsize dest_size)
     * }
     */
    public static MemorySegment g_strlcat$address() {
        return g_strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_strlcat(gchar *dest, const gchar *src, gsize dest_size)
     * }
     */
    public static long g_strlcat(MemorySegment dest, MemorySegment src, long dest_size) {
        var mh$ = g_strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strlcat", dest, src, dest_size);
            }
            return (long)mh$.invokeExact(dest, src, dest_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strstr_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strstr_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strstr_len(const gchar *haystack, gssize haystack_len, const gchar *needle)
     * }
     */
    public static FunctionDescriptor g_strstr_len$descriptor() {
        return g_strstr_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strstr_len(const gchar *haystack, gssize haystack_len, const gchar *needle)
     * }
     */
    public static MethodHandle g_strstr_len$handle() {
        return g_strstr_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strstr_len(const gchar *haystack, gssize haystack_len, const gchar *needle)
     * }
     */
    public static MemorySegment g_strstr_len$address() {
        return g_strstr_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strstr_len(const gchar *haystack, gssize haystack_len, const gchar *needle)
     * }
     */
    public static MemorySegment g_strstr_len(MemorySegment haystack, long haystack_len, MemorySegment needle) {
        var mh$ = g_strstr_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strstr_len", haystack, haystack_len, needle);
            }
            return (MemorySegment)mh$.invokeExact(haystack, haystack_len, needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strrstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strrstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strrstr(const gchar *haystack, const gchar *needle)
     * }
     */
    public static FunctionDescriptor g_strrstr$descriptor() {
        return g_strrstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strrstr(const gchar *haystack, const gchar *needle)
     * }
     */
    public static MethodHandle g_strrstr$handle() {
        return g_strrstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strrstr(const gchar *haystack, const gchar *needle)
     * }
     */
    public static MemorySegment g_strrstr$address() {
        return g_strrstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strrstr(const gchar *haystack, const gchar *needle)
     * }
     */
    public static MemorySegment g_strrstr(MemorySegment haystack, MemorySegment needle) {
        var mh$ = g_strrstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strrstr", haystack, needle);
            }
            return (MemorySegment)mh$.invokeExact(haystack, needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strrstr_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strrstr_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strrstr_len(const gchar *haystack, gssize haystack_len, const gchar *needle)
     * }
     */
    public static FunctionDescriptor g_strrstr_len$descriptor() {
        return g_strrstr_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strrstr_len(const gchar *haystack, gssize haystack_len, const gchar *needle)
     * }
     */
    public static MethodHandle g_strrstr_len$handle() {
        return g_strrstr_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strrstr_len(const gchar *haystack, gssize haystack_len, const gchar *needle)
     * }
     */
    public static MemorySegment g_strrstr_len$address() {
        return g_strrstr_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strrstr_len(const gchar *haystack, gssize haystack_len, const gchar *needle)
     * }
     */
    public static MemorySegment g_strrstr_len(MemorySegment haystack, long haystack_len, MemorySegment needle) {
        var mh$ = g_strrstr_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strrstr_len", haystack, haystack_len, needle);
            }
            return (MemorySegment)mh$.invokeExact(haystack, haystack_len, needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_str_has_suffix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_str_has_suffix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean (g_str_has_suffix)(const gchar *str, const gchar *suffix)
     * }
     */
    public static FunctionDescriptor g_str_has_suffix$descriptor() {
        return g_str_has_suffix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean (g_str_has_suffix)(const gchar *str, const gchar *suffix)
     * }
     */
    public static MethodHandle g_str_has_suffix$handle() {
        return g_str_has_suffix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean (g_str_has_suffix)(const gchar *str, const gchar *suffix)
     * }
     */
    public static MemorySegment g_str_has_suffix$address() {
        return g_str_has_suffix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean (g_str_has_suffix)(const gchar *str, const gchar *suffix)
     * }
     */
    public static int g_str_has_suffix(MemorySegment str, MemorySegment suffix) {
        var mh$ = g_str_has_suffix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_str_has_suffix", str, suffix);
            }
            return (int)mh$.invokeExact(str, suffix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_str_has_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_str_has_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean (g_str_has_prefix)(const gchar *str, const gchar *prefix)
     * }
     */
    public static FunctionDescriptor g_str_has_prefix$descriptor() {
        return g_str_has_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean (g_str_has_prefix)(const gchar *str, const gchar *prefix)
     * }
     */
    public static MethodHandle g_str_has_prefix$handle() {
        return g_str_has_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean (g_str_has_prefix)(const gchar *str, const gchar *prefix)
     * }
     */
    public static MemorySegment g_str_has_prefix$address() {
        return g_str_has_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean (g_str_has_prefix)(const gchar *str, const gchar *prefix)
     * }
     */
    public static int g_str_has_prefix(MemorySegment str, MemorySegment prefix) {
        var mh$ = g_str_has_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_str_has_prefix", str, prefix);
            }
            return (int)mh$.invokeExact(str, prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_strtod(const gchar *nptr, gchar **endptr)
     * }
     */
    public static FunctionDescriptor g_strtod$descriptor() {
        return g_strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_strtod(const gchar *nptr, gchar **endptr)
     * }
     */
    public static MethodHandle g_strtod$handle() {
        return g_strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_strtod(const gchar *nptr, gchar **endptr)
     * }
     */
    public static MemorySegment g_strtod$address() {
        return g_strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_strtod(const gchar *nptr, gchar **endptr)
     * }
     */
    public static double g_strtod(MemorySegment nptr, MemorySegment endptr) {
        var mh$ = g_strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strtod", nptr, endptr);
            }
            return (double)mh$.invokeExact(nptr, endptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_ascii_strtod(const gchar *nptr, gchar **endptr)
     * }
     */
    public static FunctionDescriptor g_ascii_strtod$descriptor() {
        return g_ascii_strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_ascii_strtod(const gchar *nptr, gchar **endptr)
     * }
     */
    public static MethodHandle g_ascii_strtod$handle() {
        return g_ascii_strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_ascii_strtod(const gchar *nptr, gchar **endptr)
     * }
     */
    public static MemorySegment g_ascii_strtod$address() {
        return g_ascii_strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_ascii_strtod(const gchar *nptr, gchar **endptr)
     * }
     */
    public static double g_ascii_strtod(MemorySegment nptr, MemorySegment endptr) {
        var mh$ = g_ascii_strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_strtod", nptr, endptr);
            }
            return (double)mh$.invokeExact(nptr, endptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint64 g_ascii_strtoull(const gchar *nptr, gchar **endptr, guint base)
     * }
     */
    public static FunctionDescriptor g_ascii_strtoull$descriptor() {
        return g_ascii_strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint64 g_ascii_strtoull(const gchar *nptr, gchar **endptr, guint base)
     * }
     */
    public static MethodHandle g_ascii_strtoull$handle() {
        return g_ascii_strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint64 g_ascii_strtoull(const gchar *nptr, gchar **endptr, guint base)
     * }
     */
    public static MemorySegment g_ascii_strtoull$address() {
        return g_ascii_strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint64 g_ascii_strtoull(const gchar *nptr, gchar **endptr, guint base)
     * }
     */
    public static long g_ascii_strtoull(MemorySegment nptr, MemorySegment endptr, int base) {
        var mh$ = g_ascii_strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_strtoull", nptr, endptr, base);
            }
            return (long)mh$.invokeExact(nptr, endptr, base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_ascii_strtoll(const gchar *nptr, gchar **endptr, guint base)
     * }
     */
    public static FunctionDescriptor g_ascii_strtoll$descriptor() {
        return g_ascii_strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_ascii_strtoll(const gchar *nptr, gchar **endptr, guint base)
     * }
     */
    public static MethodHandle g_ascii_strtoll$handle() {
        return g_ascii_strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_ascii_strtoll(const gchar *nptr, gchar **endptr, guint base)
     * }
     */
    public static MemorySegment g_ascii_strtoll$address() {
        return g_ascii_strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_ascii_strtoll(const gchar *nptr, gchar **endptr, guint base)
     * }
     */
    public static long g_ascii_strtoll(MemorySegment nptr, MemorySegment endptr, int base) {
        var mh$ = g_ascii_strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_strtoll", nptr, endptr, base);
            }
            return (long)mh$.invokeExact(nptr, endptr, base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_dtostr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_dtostr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_dtostr(gchar *buffer, gint buf_len, gdouble d)
     * }
     */
    public static FunctionDescriptor g_ascii_dtostr$descriptor() {
        return g_ascii_dtostr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_dtostr(gchar *buffer, gint buf_len, gdouble d)
     * }
     */
    public static MethodHandle g_ascii_dtostr$handle() {
        return g_ascii_dtostr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_dtostr(gchar *buffer, gint buf_len, gdouble d)
     * }
     */
    public static MemorySegment g_ascii_dtostr$address() {
        return g_ascii_dtostr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_ascii_dtostr(gchar *buffer, gint buf_len, gdouble d)
     * }
     */
    public static MemorySegment g_ascii_dtostr(MemorySegment buffer, int buf_len, double d) {
        var mh$ = g_ascii_dtostr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_dtostr", buffer, buf_len, d);
            }
            return (MemorySegment)mh$.invokeExact(buffer, buf_len, d);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_formatd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_formatd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_formatd(gchar *buffer, gint buf_len, const gchar *format, gdouble d)
     * }
     */
    public static FunctionDescriptor g_ascii_formatd$descriptor() {
        return g_ascii_formatd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_formatd(gchar *buffer, gint buf_len, const gchar *format, gdouble d)
     * }
     */
    public static MethodHandle g_ascii_formatd$handle() {
        return g_ascii_formatd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_formatd(gchar *buffer, gint buf_len, const gchar *format, gdouble d)
     * }
     */
    public static MemorySegment g_ascii_formatd$address() {
        return g_ascii_formatd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_ascii_formatd(gchar *buffer, gint buf_len, const gchar *format, gdouble d)
     * }
     */
    public static MemorySegment g_ascii_formatd(MemorySegment buffer, int buf_len, MemorySegment format, double d) {
        var mh$ = g_ascii_formatd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_formatd", buffer, buf_len, format, d);
            }
            return (MemorySegment)mh$.invokeExact(buffer, buf_len, format, d);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strchug {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strchug");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strchug(gchar *string)
     * }
     */
    public static FunctionDescriptor g_strchug$descriptor() {
        return g_strchug.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strchug(gchar *string)
     * }
     */
    public static MethodHandle g_strchug$handle() {
        return g_strchug.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strchug(gchar *string)
     * }
     */
    public static MemorySegment g_strchug$address() {
        return g_strchug.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strchug(gchar *string)
     * }
     */
    public static MemorySegment g_strchug(MemorySegment string) {
        var mh$ = g_strchug.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strchug", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strchomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strchomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strchomp(gchar *string)
     * }
     */
    public static FunctionDescriptor g_strchomp$descriptor() {
        return g_strchomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strchomp(gchar *string)
     * }
     */
    public static MethodHandle g_strchomp$handle() {
        return g_strchomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strchomp(gchar *string)
     * }
     */
    public static MemorySegment g_strchomp$address() {
        return g_strchomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strchomp(gchar *string)
     * }
     */
    public static MemorySegment g_strchomp(MemorySegment string) {
        var mh$ = g_strchomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strchomp", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_ascii_strcasecmp(const gchar *s1, const gchar *s2)
     * }
     */
    public static FunctionDescriptor g_ascii_strcasecmp$descriptor() {
        return g_ascii_strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_ascii_strcasecmp(const gchar *s1, const gchar *s2)
     * }
     */
    public static MethodHandle g_ascii_strcasecmp$handle() {
        return g_ascii_strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_ascii_strcasecmp(const gchar *s1, const gchar *s2)
     * }
     */
    public static MemorySegment g_ascii_strcasecmp$address() {
        return g_ascii_strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_ascii_strcasecmp(const gchar *s1, const gchar *s2)
     * }
     */
    public static int g_ascii_strcasecmp(MemorySegment s1, MemorySegment s2) {
        var mh$ = g_ascii_strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_strcasecmp", s1, s2);
            }
            return (int)mh$.invokeExact(s1, s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_ascii_strncasecmp(const gchar *s1, const gchar *s2, gsize n)
     * }
     */
    public static FunctionDescriptor g_ascii_strncasecmp$descriptor() {
        return g_ascii_strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_ascii_strncasecmp(const gchar *s1, const gchar *s2, gsize n)
     * }
     */
    public static MethodHandle g_ascii_strncasecmp$handle() {
        return g_ascii_strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_ascii_strncasecmp(const gchar *s1, const gchar *s2, gsize n)
     * }
     */
    public static MemorySegment g_ascii_strncasecmp$address() {
        return g_ascii_strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_ascii_strncasecmp(const gchar *s1, const gchar *s2, gsize n)
     * }
     */
    public static int g_ascii_strncasecmp(MemorySegment s1, MemorySegment s2, long n) {
        var mh$ = g_ascii_strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_strncasecmp", s1, s2, n);
            }
            return (int)mh$.invokeExact(s1, s2, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_strdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_strdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_strdown(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_ascii_strdown$descriptor() {
        return g_ascii_strdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_strdown(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_ascii_strdown$handle() {
        return g_ascii_strdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_strdown(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_ascii_strdown$address() {
        return g_ascii_strdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_ascii_strdown(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_ascii_strdown(MemorySegment str, long len) {
        var mh$ = g_ascii_strdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_strdown", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_strup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_strup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_strup(const gchar *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_ascii_strup$descriptor() {
        return g_ascii_strup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_strup(const gchar *str, gssize len)
     * }
     */
    public static MethodHandle g_ascii_strup$handle() {
        return g_ascii_strup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_ascii_strup(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_ascii_strup$address() {
        return g_ascii_strup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_ascii_strup(const gchar *str, gssize len)
     * }
     */
    public static MemorySegment g_ascii_strup(MemorySegment str, long len) {
        var mh$ = g_ascii_strup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_strup", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_str_is_ascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_str_is_ascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_str_is_ascii(const gchar *str)
     * }
     */
    public static FunctionDescriptor g_str_is_ascii$descriptor() {
        return g_str_is_ascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_str_is_ascii(const gchar *str)
     * }
     */
    public static MethodHandle g_str_is_ascii$handle() {
        return g_str_is_ascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_str_is_ascii(const gchar *str)
     * }
     */
    public static MemorySegment g_str_is_ascii$address() {
        return g_str_is_ascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_str_is_ascii(const gchar *str)
     * }
     */
    public static int g_str_is_ascii(MemorySegment str) {
        var mh$ = g_str_is_ascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_str_is_ascii", str);
            }
            return (int)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_strcasecmp(const gchar *s1, const gchar *s2)
     * }
     */
    public static FunctionDescriptor g_strcasecmp$descriptor() {
        return g_strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_strcasecmp(const gchar *s1, const gchar *s2)
     * }
     */
    public static MethodHandle g_strcasecmp$handle() {
        return g_strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_strcasecmp(const gchar *s1, const gchar *s2)
     * }
     */
    public static MemorySegment g_strcasecmp$address() {
        return g_strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_strcasecmp(const gchar *s1, const gchar *s2)
     * }
     */
    public static int g_strcasecmp(MemorySegment s1, MemorySegment s2) {
        var mh$ = g_strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strcasecmp", s1, s2);
            }
            return (int)mh$.invokeExact(s1, s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_strncasecmp(const gchar *s1, const gchar *s2, guint n)
     * }
     */
    public static FunctionDescriptor g_strncasecmp$descriptor() {
        return g_strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_strncasecmp(const gchar *s1, const gchar *s2, guint n)
     * }
     */
    public static MethodHandle g_strncasecmp$handle() {
        return g_strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_strncasecmp(const gchar *s1, const gchar *s2, guint n)
     * }
     */
    public static MemorySegment g_strncasecmp$address() {
        return g_strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_strncasecmp(const gchar *s1, const gchar *s2, guint n)
     * }
     */
    public static int g_strncasecmp(MemorySegment s1, MemorySegment s2, int n) {
        var mh$ = g_strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strncasecmp", s1, s2, n);
            }
            return (int)mh$.invokeExact(s1, s2, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strdown(gchar *string)
     * }
     */
    public static FunctionDescriptor g_strdown$descriptor() {
        return g_strdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strdown(gchar *string)
     * }
     */
    public static MethodHandle g_strdown$handle() {
        return g_strdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strdown(gchar *string)
     * }
     */
    public static MemorySegment g_strdown$address() {
        return g_strdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strdown(gchar *string)
     * }
     */
    public static MemorySegment g_strdown(MemorySegment string) {
        var mh$ = g_strdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strdown", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strup(gchar *string)
     * }
     */
    public static FunctionDescriptor g_strup$descriptor() {
        return g_strup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strup(gchar *string)
     * }
     */
    public static MethodHandle g_strup$handle() {
        return g_strup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strup(gchar *string)
     * }
     */
    public static MemorySegment g_strup$address() {
        return g_strup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strup(gchar *string)
     * }
     */
    public static MemorySegment g_strup(MemorySegment string) {
        var mh$ = g_strup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strup", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *(g_strdup)(const gchar *str)
     * }
     */
    public static FunctionDescriptor g_strdup$descriptor() {
        return g_strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *(g_strdup)(const gchar *str)
     * }
     */
    public static MethodHandle g_strdup$handle() {
        return g_strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *(g_strdup)(const gchar *str)
     * }
     */
    public static MemorySegment g_strdup$address() {
        return g_strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *(g_strdup)(const gchar *str)
     * }
     */
    public static MemorySegment g_strdup(MemorySegment str) {
        var mh$ = g_strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strdup", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gchar *g_strdup_printf(const gchar *format, ...)
     * }
     */
    public static class g_strdup_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strdup_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_strdup_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gchar *g_strdup_printf(const gchar *format, ...)
         * }
         */
        public static g_strdup_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_strdup_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_strdup_printf", format, x1);
                }
                return (MemorySegment) spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_strdup_vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strdup_vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strdup_vprintf(const gchar *format, va_list args)
     * }
     */
    public static FunctionDescriptor g_strdup_vprintf$descriptor() {
        return g_strdup_vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strdup_vprintf(const gchar *format, va_list args)
     * }
     */
    public static MethodHandle g_strdup_vprintf$handle() {
        return g_strdup_vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strdup_vprintf(const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_strdup_vprintf$address() {
        return g_strdup_vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strdup_vprintf(const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_strdup_vprintf(MemorySegment format, MemorySegment args) {
        var mh$ = g_strdup_vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strdup_vprintf", format, args);
            }
            return (MemorySegment)mh$.invokeExact(format, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strndup(const gchar *str, gsize n)
     * }
     */
    public static FunctionDescriptor g_strndup$descriptor() {
        return g_strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strndup(const gchar *str, gsize n)
     * }
     */
    public static MethodHandle g_strndup$handle() {
        return g_strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strndup(const gchar *str, gsize n)
     * }
     */
    public static MemorySegment g_strndup$address() {
        return g_strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strndup(const gchar *str, gsize n)
     * }
     */
    public static MemorySegment g_strndup(MemorySegment str, long n) {
        var mh$ = g_strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strndup", str, n);
            }
            return (MemorySegment)mh$.invokeExact(str, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strnfill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strnfill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strnfill(gsize length, gchar fill_char)
     * }
     */
    public static FunctionDescriptor g_strnfill$descriptor() {
        return g_strnfill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strnfill(gsize length, gchar fill_char)
     * }
     */
    public static MethodHandle g_strnfill$handle() {
        return g_strnfill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strnfill(gsize length, gchar fill_char)
     * }
     */
    public static MemorySegment g_strnfill$address() {
        return g_strnfill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strnfill(gsize length, gchar fill_char)
     * }
     */
    public static MemorySegment g_strnfill(long length, byte fill_char) {
        var mh$ = g_strnfill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strnfill", length, fill_char);
            }
            return (MemorySegment)mh$.invokeExact(length, fill_char);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gchar *g_strconcat(const gchar *string1, ...)
     * }
     */
    public static class g_strconcat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strconcat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_strconcat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gchar *g_strconcat(const gchar *string1, ...)
         * }
         */
        public static g_strconcat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_strconcat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment string1, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_strconcat", string1, x1);
                }
                return (MemorySegment) spreader.invokeExact(string1, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gchar *g_strjoin(const gchar *separator, ...)
     * }
     */
    public static class g_strjoin {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strjoin");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_strjoin(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gchar *g_strjoin(const gchar *separator, ...)
         * }
         */
        public static g_strjoin makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_strjoin(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment separator, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_strjoin", separator, x1);
                }
                return (MemorySegment) spreader.invokeExact(separator, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_strcompress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strcompress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strcompress(const gchar *source)
     * }
     */
    public static FunctionDescriptor g_strcompress$descriptor() {
        return g_strcompress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strcompress(const gchar *source)
     * }
     */
    public static MethodHandle g_strcompress$handle() {
        return g_strcompress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strcompress(const gchar *source)
     * }
     */
    public static MemorySegment g_strcompress$address() {
        return g_strcompress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strcompress(const gchar *source)
     * }
     */
    public static MemorySegment g_strcompress(MemorySegment source) {
        var mh$ = g_strcompress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strcompress", source);
            }
            return (MemorySegment)mh$.invokeExact(source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strescape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strescape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strescape(const gchar *source, const gchar *exceptions)
     * }
     */
    public static FunctionDescriptor g_strescape$descriptor() {
        return g_strescape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strescape(const gchar *source, const gchar *exceptions)
     * }
     */
    public static MethodHandle g_strescape$handle() {
        return g_strescape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strescape(const gchar *source, const gchar *exceptions)
     * }
     */
    public static MemorySegment g_strescape$address() {
        return g_strescape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strescape(const gchar *source, const gchar *exceptions)
     * }
     */
    public static MemorySegment g_strescape(MemorySegment source, MemorySegment exceptions) {
        var mh$ = g_strescape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strescape", source, exceptions);
            }
            return (MemorySegment)mh$.invokeExact(source, exceptions);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_memdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_memdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_memdup(gconstpointer mem, guint byte_size)
     * }
     */
    public static FunctionDescriptor g_memdup$descriptor() {
        return g_memdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_memdup(gconstpointer mem, guint byte_size)
     * }
     */
    public static MethodHandle g_memdup$handle() {
        return g_memdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_memdup(gconstpointer mem, guint byte_size)
     * }
     */
    public static MemorySegment g_memdup$address() {
        return g_memdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_memdup(gconstpointer mem, guint byte_size)
     * }
     */
    public static MemorySegment g_memdup(MemorySegment mem, int byte_size) {
        var mh$ = g_memdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_memdup", mem, byte_size);
            }
            return (MemorySegment)mh$.invokeExact(mem, byte_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_memdup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_memdup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_memdup2(gconstpointer mem, gsize byte_size)
     * }
     */
    public static FunctionDescriptor g_memdup2$descriptor() {
        return g_memdup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_memdup2(gconstpointer mem, gsize byte_size)
     * }
     */
    public static MethodHandle g_memdup2$handle() {
        return g_memdup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_memdup2(gconstpointer mem, gsize byte_size)
     * }
     */
    public static MemorySegment g_memdup2$address() {
        return g_memdup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_memdup2(gconstpointer mem, gsize byte_size)
     * }
     */
    public static MemorySegment g_memdup2(MemorySegment mem, long byte_size) {
        var mh$ = g_memdup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_memdup2", mem, byte_size);
            }
            return (MemorySegment)mh$.invokeExact(mem, byte_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef gchar **GStrv
     * }
     */
    public static final AddressLayout GStrv = gst_min_h.C_POINTER;

    private static class g_strsplit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strsplit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_strsplit(const gchar *string, const gchar *delimiter, gint max_tokens)
     * }
     */
    public static FunctionDescriptor g_strsplit$descriptor() {
        return g_strsplit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_strsplit(const gchar *string, const gchar *delimiter, gint max_tokens)
     * }
     */
    public static MethodHandle g_strsplit$handle() {
        return g_strsplit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_strsplit(const gchar *string, const gchar *delimiter, gint max_tokens)
     * }
     */
    public static MemorySegment g_strsplit$address() {
        return g_strsplit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_strsplit(const gchar *string, const gchar *delimiter, gint max_tokens)
     * }
     */
    public static MemorySegment g_strsplit(MemorySegment string, MemorySegment delimiter, int max_tokens) {
        var mh$ = g_strsplit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strsplit", string, delimiter, max_tokens);
            }
            return (MemorySegment)mh$.invokeExact(string, delimiter, max_tokens);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strsplit_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strsplit_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_strsplit_set(const gchar *string, const gchar *delimiters, gint max_tokens)
     * }
     */
    public static FunctionDescriptor g_strsplit_set$descriptor() {
        return g_strsplit_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_strsplit_set(const gchar *string, const gchar *delimiters, gint max_tokens)
     * }
     */
    public static MethodHandle g_strsplit_set$handle() {
        return g_strsplit_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_strsplit_set(const gchar *string, const gchar *delimiters, gint max_tokens)
     * }
     */
    public static MemorySegment g_strsplit_set$address() {
        return g_strsplit_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_strsplit_set(const gchar *string, const gchar *delimiters, gint max_tokens)
     * }
     */
    public static MemorySegment g_strsplit_set(MemorySegment string, MemorySegment delimiters, int max_tokens) {
        var mh$ = g_strsplit_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strsplit_set", string, delimiters, max_tokens);
            }
            return (MemorySegment)mh$.invokeExact(string, delimiters, max_tokens);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strjoinv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strjoinv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_strjoinv(const gchar *separator, gchar **str_array)
     * }
     */
    public static FunctionDescriptor g_strjoinv$descriptor() {
        return g_strjoinv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_strjoinv(const gchar *separator, gchar **str_array)
     * }
     */
    public static MethodHandle g_strjoinv$handle() {
        return g_strjoinv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_strjoinv(const gchar *separator, gchar **str_array)
     * }
     */
    public static MemorySegment g_strjoinv$address() {
        return g_strjoinv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_strjoinv(const gchar *separator, gchar **str_array)
     * }
     */
    public static MemorySegment g_strjoinv(MemorySegment separator, MemorySegment str_array) {
        var mh$ = g_strjoinv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strjoinv", separator, str_array);
            }
            return (MemorySegment)mh$.invokeExact(separator, str_array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strfreev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strfreev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_strfreev(gchar **str_array)
     * }
     */
    public static FunctionDescriptor g_strfreev$descriptor() {
        return g_strfreev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_strfreev(gchar **str_array)
     * }
     */
    public static MethodHandle g_strfreev$handle() {
        return g_strfreev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_strfreev(gchar **str_array)
     * }
     */
    public static MemorySegment g_strfreev$address() {
        return g_strfreev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_strfreev(gchar **str_array)
     * }
     */
    public static void g_strfreev(MemorySegment str_array) {
        var mh$ = g_strfreev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strfreev", str_array);
            }
            mh$.invokeExact(str_array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strdupv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strdupv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_strdupv(gchar **str_array)
     * }
     */
    public static FunctionDescriptor g_strdupv$descriptor() {
        return g_strdupv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_strdupv(gchar **str_array)
     * }
     */
    public static MethodHandle g_strdupv$handle() {
        return g_strdupv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_strdupv(gchar **str_array)
     * }
     */
    public static MemorySegment g_strdupv$address() {
        return g_strdupv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_strdupv(gchar **str_array)
     * }
     */
    public static MemorySegment g_strdupv(MemorySegment str_array) {
        var mh$ = g_strdupv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strdupv", str_array);
            }
            return (MemorySegment)mh$.invokeExact(str_array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_strv_length(gchar **str_array)
     * }
     */
    public static FunctionDescriptor g_strv_length$descriptor() {
        return g_strv_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_strv_length(gchar **str_array)
     * }
     */
    public static MethodHandle g_strv_length$handle() {
        return g_strv_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_strv_length(gchar **str_array)
     * }
     */
    public static MemorySegment g_strv_length$address() {
        return g_strv_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_strv_length(gchar **str_array)
     * }
     */
    public static int g_strv_length(MemorySegment str_array) {
        var mh$ = g_strv_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_length", str_array);
            }
            return (int)mh$.invokeExact(str_array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_stpcpy(gchar *dest, const char *src)
     * }
     */
    public static FunctionDescriptor g_stpcpy$descriptor() {
        return g_stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_stpcpy(gchar *dest, const char *src)
     * }
     */
    public static MethodHandle g_stpcpy$handle() {
        return g_stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_stpcpy(gchar *dest, const char *src)
     * }
     */
    public static MemorySegment g_stpcpy$address() {
        return g_stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_stpcpy(gchar *dest, const char *src)
     * }
     */
    public static MemorySegment g_stpcpy(MemorySegment dest, MemorySegment src) {
        var mh$ = g_stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_stpcpy", dest, src);
            }
            return (MemorySegment)mh$.invokeExact(dest, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_str_to_ascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_str_to_ascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_str_to_ascii(const gchar *str, const gchar *from_locale)
     * }
     */
    public static FunctionDescriptor g_str_to_ascii$descriptor() {
        return g_str_to_ascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_str_to_ascii(const gchar *str, const gchar *from_locale)
     * }
     */
    public static MethodHandle g_str_to_ascii$handle() {
        return g_str_to_ascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_str_to_ascii(const gchar *str, const gchar *from_locale)
     * }
     */
    public static MemorySegment g_str_to_ascii$address() {
        return g_str_to_ascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_str_to_ascii(const gchar *str, const gchar *from_locale)
     * }
     */
    public static MemorySegment g_str_to_ascii(MemorySegment str, MemorySegment from_locale) {
        var mh$ = g_str_to_ascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_str_to_ascii", str, from_locale);
            }
            return (MemorySegment)mh$.invokeExact(str, from_locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_str_tokenize_and_fold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_str_tokenize_and_fold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_str_tokenize_and_fold(const gchar *string, const gchar *translit_locale, gchar ***ascii_alternates)
     * }
     */
    public static FunctionDescriptor g_str_tokenize_and_fold$descriptor() {
        return g_str_tokenize_and_fold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_str_tokenize_and_fold(const gchar *string, const gchar *translit_locale, gchar ***ascii_alternates)
     * }
     */
    public static MethodHandle g_str_tokenize_and_fold$handle() {
        return g_str_tokenize_and_fold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_str_tokenize_and_fold(const gchar *string, const gchar *translit_locale, gchar ***ascii_alternates)
     * }
     */
    public static MemorySegment g_str_tokenize_and_fold$address() {
        return g_str_tokenize_and_fold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_str_tokenize_and_fold(const gchar *string, const gchar *translit_locale, gchar ***ascii_alternates)
     * }
     */
    public static MemorySegment g_str_tokenize_and_fold(MemorySegment string, MemorySegment translit_locale, MemorySegment ascii_alternates) {
        var mh$ = g_str_tokenize_and_fold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_str_tokenize_and_fold", string, translit_locale, ascii_alternates);
            }
            return (MemorySegment)mh$.invokeExact(string, translit_locale, ascii_alternates);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_str_match_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_str_match_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_str_match_string(const gchar *search_term, const gchar *potential_hit, gboolean accept_alternates)
     * }
     */
    public static FunctionDescriptor g_str_match_string$descriptor() {
        return g_str_match_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_str_match_string(const gchar *search_term, const gchar *potential_hit, gboolean accept_alternates)
     * }
     */
    public static MethodHandle g_str_match_string$handle() {
        return g_str_match_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_str_match_string(const gchar *search_term, const gchar *potential_hit, gboolean accept_alternates)
     * }
     */
    public static MemorySegment g_str_match_string$address() {
        return g_str_match_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_str_match_string(const gchar *search_term, const gchar *potential_hit, gboolean accept_alternates)
     * }
     */
    public static int g_str_match_string(MemorySegment search_term, MemorySegment potential_hit, int accept_alternates) {
        var mh$ = g_str_match_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_str_match_string", search_term, potential_hit, accept_alternates);
            }
            return (int)mh$.invokeExact(search_term, potential_hit, accept_alternates);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_strv_contains(const gchar *const *strv, const gchar *str)
     * }
     */
    public static FunctionDescriptor g_strv_contains$descriptor() {
        return g_strv_contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_strv_contains(const gchar *const *strv, const gchar *str)
     * }
     */
    public static MethodHandle g_strv_contains$handle() {
        return g_strv_contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_strv_contains(const gchar *const *strv, const gchar *str)
     * }
     */
    public static MemorySegment g_strv_contains$address() {
        return g_strv_contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_strv_contains(const gchar *const *strv, const gchar *str)
     * }
     */
    public static int g_strv_contains(MemorySegment strv, MemorySegment str) {
        var mh$ = g_strv_contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_contains", strv, str);
            }
            return (int)mh$.invokeExact(strv, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_strv_equal(const gchar *const *strv1, const gchar *const *strv2)
     * }
     */
    public static FunctionDescriptor g_strv_equal$descriptor() {
        return g_strv_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_strv_equal(const gchar *const *strv1, const gchar *const *strv2)
     * }
     */
    public static MethodHandle g_strv_equal$handle() {
        return g_strv_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_strv_equal(const gchar *const *strv1, const gchar *const *strv2)
     * }
     */
    public static MemorySegment g_strv_equal$address() {
        return g_strv_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_strv_equal(const gchar *const *strv1, const gchar *const *strv2)
     * }
     */
    public static int g_strv_equal(MemorySegment strv1, MemorySegment strv2) {
        var mh$ = g_strv_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_equal", strv1, strv2);
            }
            return (int)mh$.invokeExact(strv1, strv2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_NUMBER_PARSER_ERROR_INVALID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NUMBER_PARSER_ERROR_INVALID = 0
     * }
     */
    public static int G_NUMBER_PARSER_ERROR_INVALID() {
        return G_NUMBER_PARSER_ERROR_INVALID;
    }
    private static final int G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1
     * }
     */
    public static int G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS() {
        return G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS;
    }

    private static class g_number_parser_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_number_parser_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_number_parser_error_quark()
     * }
     */
    public static FunctionDescriptor g_number_parser_error_quark$descriptor() {
        return g_number_parser_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_number_parser_error_quark()
     * }
     */
    public static MethodHandle g_number_parser_error_quark$handle() {
        return g_number_parser_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_number_parser_error_quark()
     * }
     */
    public static MemorySegment g_number_parser_error_quark$address() {
        return g_number_parser_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_number_parser_error_quark()
     * }
     */
    public static int g_number_parser_error_quark() {
        var mh$ = g_number_parser_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_number_parser_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_string_to_signed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_string_to_signed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ascii_string_to_signed(const gchar *str, guint base, gint64 min, gint64 max, gint64 *out_num, GError **error)
     * }
     */
    public static FunctionDescriptor g_ascii_string_to_signed$descriptor() {
        return g_ascii_string_to_signed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ascii_string_to_signed(const gchar *str, guint base, gint64 min, gint64 max, gint64 *out_num, GError **error)
     * }
     */
    public static MethodHandle g_ascii_string_to_signed$handle() {
        return g_ascii_string_to_signed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ascii_string_to_signed(const gchar *str, guint base, gint64 min, gint64 max, gint64 *out_num, GError **error)
     * }
     */
    public static MemorySegment g_ascii_string_to_signed$address() {
        return g_ascii_string_to_signed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ascii_string_to_signed(const gchar *str, guint base, gint64 min, gint64 max, gint64 *out_num, GError **error)
     * }
     */
    public static int g_ascii_string_to_signed(MemorySegment str, int base, long min, long max, MemorySegment out_num, MemorySegment error) {
        var mh$ = g_ascii_string_to_signed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_string_to_signed", str, base, min, max, out_num, error);
            }
            return (int)mh$.invokeExact(str, base, min, max, out_num, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ascii_string_to_unsigned {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ascii_string_to_unsigned");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ascii_string_to_unsigned(const gchar *str, guint base, guint64 min, guint64 max, guint64 *out_num, GError **error)
     * }
     */
    public static FunctionDescriptor g_ascii_string_to_unsigned$descriptor() {
        return g_ascii_string_to_unsigned.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ascii_string_to_unsigned(const gchar *str, guint base, guint64 min, guint64 max, guint64 *out_num, GError **error)
     * }
     */
    public static MethodHandle g_ascii_string_to_unsigned$handle() {
        return g_ascii_string_to_unsigned.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ascii_string_to_unsigned(const gchar *str, guint base, guint64 min, guint64 max, guint64 *out_num, GError **error)
     * }
     */
    public static MemorySegment g_ascii_string_to_unsigned$address() {
        return g_ascii_string_to_unsigned.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ascii_string_to_unsigned(const gchar *str, guint base, guint64 min, guint64 max, guint64 *out_num, GError **error)
     * }
     */
    public static int g_ascii_string_to_unsigned(MemorySegment str, int base, long min, long max, MemorySegment out_num, MemorySegment error) {
        var mh$ = g_ascii_string_to_unsigned.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ascii_string_to_unsigned", str, base, min, max, out_num, error);
            }
            return (int)mh$.invokeExact(str, base, min, max, out_num, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_new(const gchar *init)
     * }
     */
    public static FunctionDescriptor g_string_new$descriptor() {
        return g_string_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_new(const gchar *init)
     * }
     */
    public static MethodHandle g_string_new$handle() {
        return g_string_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_new(const gchar *init)
     * }
     */
    public static MemorySegment g_string_new$address() {
        return g_string_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_new(const gchar *init)
     * }
     */
    public static MemorySegment g_string_new(MemorySegment init) {
        var mh$ = g_string_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_new", init);
            }
            return (MemorySegment)mh$.invokeExact(init);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_new_take {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_new_take");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_new_take(gchar *init)
     * }
     */
    public static FunctionDescriptor g_string_new_take$descriptor() {
        return g_string_new_take.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_new_take(gchar *init)
     * }
     */
    public static MethodHandle g_string_new_take$handle() {
        return g_string_new_take.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_new_take(gchar *init)
     * }
     */
    public static MemorySegment g_string_new_take$address() {
        return g_string_new_take.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_new_take(gchar *init)
     * }
     */
    public static MemorySegment g_string_new_take(MemorySegment init) {
        var mh$ = g_string_new_take.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_new_take", init);
            }
            return (MemorySegment)mh$.invokeExact(init);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_new_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_new_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_new_len(const gchar *init, gssize len)
     * }
     */
    public static FunctionDescriptor g_string_new_len$descriptor() {
        return g_string_new_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_new_len(const gchar *init, gssize len)
     * }
     */
    public static MethodHandle g_string_new_len$handle() {
        return g_string_new_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_new_len(const gchar *init, gssize len)
     * }
     */
    public static MemorySegment g_string_new_len$address() {
        return g_string_new_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_new_len(const gchar *init, gssize len)
     * }
     */
    public static MemorySegment g_string_new_len(MemorySegment init, long len) {
        var mh$ = g_string_new_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_new_len", init, len);
            }
            return (MemorySegment)mh$.invokeExact(init, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_sized_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_sized_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_sized_new(gsize dfl_size)
     * }
     */
    public static FunctionDescriptor g_string_sized_new$descriptor() {
        return g_string_sized_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_sized_new(gsize dfl_size)
     * }
     */
    public static MethodHandle g_string_sized_new$handle() {
        return g_string_sized_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_sized_new(gsize dfl_size)
     * }
     */
    public static MemorySegment g_string_sized_new$address() {
        return g_string_sized_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_sized_new(gsize dfl_size)
     * }
     */
    public static MemorySegment g_string_sized_new(long dfl_size) {
        var mh$ = g_string_sized_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_sized_new", dfl_size);
            }
            return (MemorySegment)mh$.invokeExact(dfl_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *(g_string_free)(GString *string, gboolean free_segment)
     * }
     */
    public static FunctionDescriptor g_string_free$descriptor() {
        return g_string_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *(g_string_free)(GString *string, gboolean free_segment)
     * }
     */
    public static MethodHandle g_string_free$handle() {
        return g_string_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *(g_string_free)(GString *string, gboolean free_segment)
     * }
     */
    public static MemorySegment g_string_free$address() {
        return g_string_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *(g_string_free)(GString *string, gboolean free_segment)
     * }
     */
    public static MemorySegment g_string_free(MemorySegment string, int free_segment) {
        var mh$ = g_string_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_free", string, free_segment);
            }
            return (MemorySegment)mh$.invokeExact(string, free_segment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_free_and_steal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_free_and_steal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_string_free_and_steal(GString *string)
     * }
     */
    public static FunctionDescriptor g_string_free_and_steal$descriptor() {
        return g_string_free_and_steal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_string_free_and_steal(GString *string)
     * }
     */
    public static MethodHandle g_string_free_and_steal$handle() {
        return g_string_free_and_steal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_string_free_and_steal(GString *string)
     * }
     */
    public static MemorySegment g_string_free_and_steal$address() {
        return g_string_free_and_steal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_string_free_and_steal(GString *string)
     * }
     */
    public static MemorySegment g_string_free_and_steal(MemorySegment string) {
        var mh$ = g_string_free_and_steal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_free_and_steal", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_free_to_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_free_to_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_string_free_to_bytes(GString *string)
     * }
     */
    public static FunctionDescriptor g_string_free_to_bytes$descriptor() {
        return g_string_free_to_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_string_free_to_bytes(GString *string)
     * }
     */
    public static MethodHandle g_string_free_to_bytes$handle() {
        return g_string_free_to_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_string_free_to_bytes(GString *string)
     * }
     */
    public static MemorySegment g_string_free_to_bytes$address() {
        return g_string_free_to_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_string_free_to_bytes(GString *string)
     * }
     */
    public static MemorySegment g_string_free_to_bytes(MemorySegment string) {
        var mh$ = g_string_free_to_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_free_to_bytes", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_string_equal(const GString *v, const GString *v2)
     * }
     */
    public static FunctionDescriptor g_string_equal$descriptor() {
        return g_string_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_string_equal(const GString *v, const GString *v2)
     * }
     */
    public static MethodHandle g_string_equal$handle() {
        return g_string_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_string_equal(const GString *v, const GString *v2)
     * }
     */
    public static MemorySegment g_string_equal$address() {
        return g_string_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_string_equal(const GString *v, const GString *v2)
     * }
     */
    public static int g_string_equal(MemorySegment v, MemorySegment v2) {
        var mh$ = g_string_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_equal", v, v2);
            }
            return (int)mh$.invokeExact(v, v2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_string_hash(const GString *str)
     * }
     */
    public static FunctionDescriptor g_string_hash$descriptor() {
        return g_string_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_string_hash(const GString *str)
     * }
     */
    public static MethodHandle g_string_hash$handle() {
        return g_string_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_string_hash(const GString *str)
     * }
     */
    public static MemorySegment g_string_hash$address() {
        return g_string_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_string_hash(const GString *str)
     * }
     */
    public static int g_string_hash(MemorySegment str) {
        var mh$ = g_string_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_hash", str);
            }
            return (int)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_assign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_assign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_assign(GString *string, const gchar *rval)
     * }
     */
    public static FunctionDescriptor g_string_assign$descriptor() {
        return g_string_assign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_assign(GString *string, const gchar *rval)
     * }
     */
    public static MethodHandle g_string_assign$handle() {
        return g_string_assign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_assign(GString *string, const gchar *rval)
     * }
     */
    public static MemorySegment g_string_assign$address() {
        return g_string_assign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_assign(GString *string, const gchar *rval)
     * }
     */
    public static MemorySegment g_string_assign(MemorySegment string, MemorySegment rval) {
        var mh$ = g_string_assign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_assign", string, rval);
            }
            return (MemorySegment)mh$.invokeExact(string, rval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_truncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_truncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_truncate(GString *string, gsize len)
     * }
     */
    public static FunctionDescriptor g_string_truncate$descriptor() {
        return g_string_truncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_truncate(GString *string, gsize len)
     * }
     */
    public static MethodHandle g_string_truncate$handle() {
        return g_string_truncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_truncate(GString *string, gsize len)
     * }
     */
    public static MemorySegment g_string_truncate$address() {
        return g_string_truncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_truncate(GString *string, gsize len)
     * }
     */
    public static MemorySegment g_string_truncate(MemorySegment string, long len) {
        var mh$ = g_string_truncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_truncate", string, len);
            }
            return (MemorySegment)mh$.invokeExact(string, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_set_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_set_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_set_size(GString *string, gsize len)
     * }
     */
    public static FunctionDescriptor g_string_set_size$descriptor() {
        return g_string_set_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_set_size(GString *string, gsize len)
     * }
     */
    public static MethodHandle g_string_set_size$handle() {
        return g_string_set_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_set_size(GString *string, gsize len)
     * }
     */
    public static MemorySegment g_string_set_size$address() {
        return g_string_set_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_set_size(GString *string, gsize len)
     * }
     */
    public static MemorySegment g_string_set_size(MemorySegment string, long len) {
        var mh$ = g_string_set_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_set_size", string, len);
            }
            return (MemorySegment)mh$.invokeExact(string, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_insert_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_insert_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_len(GString *string, gssize pos, const gchar *val, gssize len)
     * }
     */
    public static FunctionDescriptor g_string_insert_len$descriptor() {
        return g_string_insert_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_len(GString *string, gssize pos, const gchar *val, gssize len)
     * }
     */
    public static MethodHandle g_string_insert_len$handle() {
        return g_string_insert_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_len(GString *string, gssize pos, const gchar *val, gssize len)
     * }
     */
    public static MemorySegment g_string_insert_len$address() {
        return g_string_insert_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_insert_len(GString *string, gssize pos, const gchar *val, gssize len)
     * }
     */
    public static MemorySegment g_string_insert_len(MemorySegment string, long pos, MemorySegment val, long len) {
        var mh$ = g_string_insert_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_insert_len", string, pos, val, len);
            }
            return (MemorySegment)mh$.invokeExact(string, pos, val, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_append(GString *string, const gchar *val)
     * }
     */
    public static FunctionDescriptor g_string_append$descriptor() {
        return g_string_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_append(GString *string, const gchar *val)
     * }
     */
    public static MethodHandle g_string_append$handle() {
        return g_string_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_append(GString *string, const gchar *val)
     * }
     */
    public static MemorySegment g_string_append$address() {
        return g_string_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_append(GString *string, const gchar *val)
     * }
     */
    public static MemorySegment g_string_append(MemorySegment string, MemorySegment val) {
        var mh$ = g_string_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_append", string, val);
            }
            return (MemorySegment)mh$.invokeExact(string, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_append_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_append_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_append_len(GString *string, const gchar *val, gssize len)
     * }
     */
    public static FunctionDescriptor g_string_append_len$descriptor() {
        return g_string_append_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_append_len(GString *string, const gchar *val, gssize len)
     * }
     */
    public static MethodHandle g_string_append_len$handle() {
        return g_string_append_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_append_len(GString *string, const gchar *val, gssize len)
     * }
     */
    public static MemorySegment g_string_append_len$address() {
        return g_string_append_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_append_len(GString *string, const gchar *val, gssize len)
     * }
     */
    public static MemorySegment g_string_append_len(MemorySegment string, MemorySegment val, long len) {
        var mh$ = g_string_append_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_append_len", string, val, len);
            }
            return (MemorySegment)mh$.invokeExact(string, val, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_append_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_append_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_append_c(GString *string, gchar c)
     * }
     */
    public static FunctionDescriptor g_string_append_c$descriptor() {
        return g_string_append_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_append_c(GString *string, gchar c)
     * }
     */
    public static MethodHandle g_string_append_c$handle() {
        return g_string_append_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_append_c(GString *string, gchar c)
     * }
     */
    public static MemorySegment g_string_append_c$address() {
        return g_string_append_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_append_c(GString *string, gchar c)
     * }
     */
    public static MemorySegment g_string_append_c(MemorySegment string, byte c) {
        var mh$ = g_string_append_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_append_c", string, c);
            }
            return (MemorySegment)mh$.invokeExact(string, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_append_unichar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_append_unichar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_append_unichar(GString *string, gunichar wc)
     * }
     */
    public static FunctionDescriptor g_string_append_unichar$descriptor() {
        return g_string_append_unichar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_append_unichar(GString *string, gunichar wc)
     * }
     */
    public static MethodHandle g_string_append_unichar$handle() {
        return g_string_append_unichar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_append_unichar(GString *string, gunichar wc)
     * }
     */
    public static MemorySegment g_string_append_unichar$address() {
        return g_string_append_unichar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_append_unichar(GString *string, gunichar wc)
     * }
     */
    public static MemorySegment g_string_append_unichar(MemorySegment string, int wc) {
        var mh$ = g_string_append_unichar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_append_unichar", string, wc);
            }
            return (MemorySegment)mh$.invokeExact(string, wc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_prepend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_prepend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend(GString *string, const gchar *val)
     * }
     */
    public static FunctionDescriptor g_string_prepend$descriptor() {
        return g_string_prepend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend(GString *string, const gchar *val)
     * }
     */
    public static MethodHandle g_string_prepend$handle() {
        return g_string_prepend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend(GString *string, const gchar *val)
     * }
     */
    public static MemorySegment g_string_prepend$address() {
        return g_string_prepend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_prepend(GString *string, const gchar *val)
     * }
     */
    public static MemorySegment g_string_prepend(MemorySegment string, MemorySegment val) {
        var mh$ = g_string_prepend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_prepend", string, val);
            }
            return (MemorySegment)mh$.invokeExact(string, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_prepend_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_prepend_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_c(GString *string, gchar c)
     * }
     */
    public static FunctionDescriptor g_string_prepend_c$descriptor() {
        return g_string_prepend_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_c(GString *string, gchar c)
     * }
     */
    public static MethodHandle g_string_prepend_c$handle() {
        return g_string_prepend_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_c(GString *string, gchar c)
     * }
     */
    public static MemorySegment g_string_prepend_c$address() {
        return g_string_prepend_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_prepend_c(GString *string, gchar c)
     * }
     */
    public static MemorySegment g_string_prepend_c(MemorySegment string, byte c) {
        var mh$ = g_string_prepend_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_prepend_c", string, c);
            }
            return (MemorySegment)mh$.invokeExact(string, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_prepend_unichar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_prepend_unichar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_unichar(GString *string, gunichar wc)
     * }
     */
    public static FunctionDescriptor g_string_prepend_unichar$descriptor() {
        return g_string_prepend_unichar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_unichar(GString *string, gunichar wc)
     * }
     */
    public static MethodHandle g_string_prepend_unichar$handle() {
        return g_string_prepend_unichar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_unichar(GString *string, gunichar wc)
     * }
     */
    public static MemorySegment g_string_prepend_unichar$address() {
        return g_string_prepend_unichar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_prepend_unichar(GString *string, gunichar wc)
     * }
     */
    public static MemorySegment g_string_prepend_unichar(MemorySegment string, int wc) {
        var mh$ = g_string_prepend_unichar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_prepend_unichar", string, wc);
            }
            return (MemorySegment)mh$.invokeExact(string, wc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_prepend_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_prepend_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_len(GString *string, const gchar *val, gssize len)
     * }
     */
    public static FunctionDescriptor g_string_prepend_len$descriptor() {
        return g_string_prepend_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_len(GString *string, const gchar *val, gssize len)
     * }
     */
    public static MethodHandle g_string_prepend_len$handle() {
        return g_string_prepend_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_prepend_len(GString *string, const gchar *val, gssize len)
     * }
     */
    public static MemorySegment g_string_prepend_len$address() {
        return g_string_prepend_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_prepend_len(GString *string, const gchar *val, gssize len)
     * }
     */
    public static MemorySegment g_string_prepend_len(MemorySegment string, MemorySegment val, long len) {
        var mh$ = g_string_prepend_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_prepend_len", string, val, len);
            }
            return (MemorySegment)mh$.invokeExact(string, val, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_insert(GString *string, gssize pos, const gchar *val)
     * }
     */
    public static FunctionDescriptor g_string_insert$descriptor() {
        return g_string_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_insert(GString *string, gssize pos, const gchar *val)
     * }
     */
    public static MethodHandle g_string_insert$handle() {
        return g_string_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_insert(GString *string, gssize pos, const gchar *val)
     * }
     */
    public static MemorySegment g_string_insert$address() {
        return g_string_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_insert(GString *string, gssize pos, const gchar *val)
     * }
     */
    public static MemorySegment g_string_insert(MemorySegment string, long pos, MemorySegment val) {
        var mh$ = g_string_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_insert", string, pos, val);
            }
            return (MemorySegment)mh$.invokeExact(string, pos, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_insert_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_insert_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_c(GString *string, gssize pos, gchar c)
     * }
     */
    public static FunctionDescriptor g_string_insert_c$descriptor() {
        return g_string_insert_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_c(GString *string, gssize pos, gchar c)
     * }
     */
    public static MethodHandle g_string_insert_c$handle() {
        return g_string_insert_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_c(GString *string, gssize pos, gchar c)
     * }
     */
    public static MemorySegment g_string_insert_c$address() {
        return g_string_insert_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_insert_c(GString *string, gssize pos, gchar c)
     * }
     */
    public static MemorySegment g_string_insert_c(MemorySegment string, long pos, byte c) {
        var mh$ = g_string_insert_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_insert_c", string, pos, c);
            }
            return (MemorySegment)mh$.invokeExact(string, pos, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_insert_unichar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_insert_unichar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_unichar(GString *string, gssize pos, gunichar wc)
     * }
     */
    public static FunctionDescriptor g_string_insert_unichar$descriptor() {
        return g_string_insert_unichar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_unichar(GString *string, gssize pos, gunichar wc)
     * }
     */
    public static MethodHandle g_string_insert_unichar$handle() {
        return g_string_insert_unichar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_insert_unichar(GString *string, gssize pos, gunichar wc)
     * }
     */
    public static MemorySegment g_string_insert_unichar$address() {
        return g_string_insert_unichar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_insert_unichar(GString *string, gssize pos, gunichar wc)
     * }
     */
    public static MemorySegment g_string_insert_unichar(MemorySegment string, long pos, int wc) {
        var mh$ = g_string_insert_unichar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_insert_unichar", string, pos, wc);
            }
            return (MemorySegment)mh$.invokeExact(string, pos, wc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_overwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_overwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_overwrite(GString *string, gsize pos, const gchar *val)
     * }
     */
    public static FunctionDescriptor g_string_overwrite$descriptor() {
        return g_string_overwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_overwrite(GString *string, gsize pos, const gchar *val)
     * }
     */
    public static MethodHandle g_string_overwrite$handle() {
        return g_string_overwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_overwrite(GString *string, gsize pos, const gchar *val)
     * }
     */
    public static MemorySegment g_string_overwrite$address() {
        return g_string_overwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_overwrite(GString *string, gsize pos, const gchar *val)
     * }
     */
    public static MemorySegment g_string_overwrite(MemorySegment string, long pos, MemorySegment val) {
        var mh$ = g_string_overwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_overwrite", string, pos, val);
            }
            return (MemorySegment)mh$.invokeExact(string, pos, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_overwrite_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_overwrite_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_overwrite_len(GString *string, gsize pos, const gchar *val, gssize len)
     * }
     */
    public static FunctionDescriptor g_string_overwrite_len$descriptor() {
        return g_string_overwrite_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_overwrite_len(GString *string, gsize pos, const gchar *val, gssize len)
     * }
     */
    public static MethodHandle g_string_overwrite_len$handle() {
        return g_string_overwrite_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_overwrite_len(GString *string, gsize pos, const gchar *val, gssize len)
     * }
     */
    public static MemorySegment g_string_overwrite_len$address() {
        return g_string_overwrite_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_overwrite_len(GString *string, gsize pos, const gchar *val, gssize len)
     * }
     */
    public static MemorySegment g_string_overwrite_len(MemorySegment string, long pos, MemorySegment val, long len) {
        var mh$ = g_string_overwrite_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_overwrite_len", string, pos, val, len);
            }
            return (MemorySegment)mh$.invokeExact(string, pos, val, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_erase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_erase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_erase(GString *string, gssize pos, gssize len)
     * }
     */
    public static FunctionDescriptor g_string_erase$descriptor() {
        return g_string_erase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_erase(GString *string, gssize pos, gssize len)
     * }
     */
    public static MethodHandle g_string_erase$handle() {
        return g_string_erase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_erase(GString *string, gssize pos, gssize len)
     * }
     */
    public static MemorySegment g_string_erase$address() {
        return g_string_erase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_erase(GString *string, gssize pos, gssize len)
     * }
     */
    public static MemorySegment g_string_erase(MemorySegment string, long pos, long len) {
        var mh$ = g_string_erase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_erase", string, pos, len);
            }
            return (MemorySegment)mh$.invokeExact(string, pos, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_string_replace(GString *string, const gchar *find, const gchar *replace, guint limit)
     * }
     */
    public static FunctionDescriptor g_string_replace$descriptor() {
        return g_string_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_string_replace(GString *string, const gchar *find, const gchar *replace, guint limit)
     * }
     */
    public static MethodHandle g_string_replace$handle() {
        return g_string_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_string_replace(GString *string, const gchar *find, const gchar *replace, guint limit)
     * }
     */
    public static MemorySegment g_string_replace$address() {
        return g_string_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_string_replace(GString *string, const gchar *find, const gchar *replace, guint limit)
     * }
     */
    public static int g_string_replace(MemorySegment string, MemorySegment find, MemorySegment replace, int limit) {
        var mh$ = g_string_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_replace", string, find, replace, limit);
            }
            return (int)mh$.invokeExact(string, find, replace, limit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_ascii_down {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_ascii_down");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_ascii_down(GString *string)
     * }
     */
    public static FunctionDescriptor g_string_ascii_down$descriptor() {
        return g_string_ascii_down.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_ascii_down(GString *string)
     * }
     */
    public static MethodHandle g_string_ascii_down$handle() {
        return g_string_ascii_down.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_ascii_down(GString *string)
     * }
     */
    public static MemorySegment g_string_ascii_down$address() {
        return g_string_ascii_down.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_ascii_down(GString *string)
     * }
     */
    public static MemorySegment g_string_ascii_down(MemorySegment string) {
        var mh$ = g_string_ascii_down.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_ascii_down", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_ascii_up {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_ascii_up");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_ascii_up(GString *string)
     * }
     */
    public static FunctionDescriptor g_string_ascii_up$descriptor() {
        return g_string_ascii_up.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_ascii_up(GString *string)
     * }
     */
    public static MethodHandle g_string_ascii_up$handle() {
        return g_string_ascii_up.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_ascii_up(GString *string)
     * }
     */
    public static MemorySegment g_string_ascii_up$address() {
        return g_string_ascii_up.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_ascii_up(GString *string)
     * }
     */
    public static MemorySegment g_string_ascii_up(MemorySegment string) {
        var mh$ = g_string_ascii_up.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_ascii_up", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_string_vprintf(GString *string, const gchar *format, va_list args)
     * }
     */
    public static FunctionDescriptor g_string_vprintf$descriptor() {
        return g_string_vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_string_vprintf(GString *string, const gchar *format, va_list args)
     * }
     */
    public static MethodHandle g_string_vprintf$handle() {
        return g_string_vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_string_vprintf(GString *string, const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_string_vprintf$address() {
        return g_string_vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_string_vprintf(GString *string, const gchar *format, va_list args)
     * }
     */
    public static void g_string_vprintf(MemorySegment string, MemorySegment format, MemorySegment args) {
        var mh$ = g_string_vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_vprintf", string, format, args);
            }
            mh$.invokeExact(string, format, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_string_printf(GString *string, const gchar *format, ...)
     * }
     */
    public static class g_string_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_string_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_string_printf(GString *string, const gchar *format, ...)
         * }
         */
        public static g_string_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_string_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment string, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_string_printf", string, format, x2);
                }
                 spreader.invokeExact(string, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_string_append_vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_append_vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_string_append_vprintf(GString *string, const gchar *format, va_list args)
     * }
     */
    public static FunctionDescriptor g_string_append_vprintf$descriptor() {
        return g_string_append_vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_string_append_vprintf(GString *string, const gchar *format, va_list args)
     * }
     */
    public static MethodHandle g_string_append_vprintf$handle() {
        return g_string_append_vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_string_append_vprintf(GString *string, const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_string_append_vprintf$address() {
        return g_string_append_vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_string_append_vprintf(GString *string, const gchar *format, va_list args)
     * }
     */
    public static void g_string_append_vprintf(MemorySegment string, MemorySegment format, MemorySegment args) {
        var mh$ = g_string_append_vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_append_vprintf", string, format, args);
            }
            mh$.invokeExact(string, format, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_string_append_printf(GString *string, const gchar *format, ...)
     * }
     */
    public static class g_string_append_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_append_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_string_append_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_string_append_printf(GString *string, const gchar *format, ...)
         * }
         */
        public static g_string_append_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_string_append_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment string, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_string_append_printf", string, format, x2);
                }
                 spreader.invokeExact(string, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_string_append_uri_escaped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_append_uri_escaped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_append_uri_escaped(GString *string, const gchar *unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8)
     * }
     */
    public static FunctionDescriptor g_string_append_uri_escaped$descriptor() {
        return g_string_append_uri_escaped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_append_uri_escaped(GString *string, const gchar *unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8)
     * }
     */
    public static MethodHandle g_string_append_uri_escaped$handle() {
        return g_string_append_uri_escaped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_append_uri_escaped(GString *string, const gchar *unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8)
     * }
     */
    public static MemorySegment g_string_append_uri_escaped$address() {
        return g_string_append_uri_escaped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_append_uri_escaped(GString *string, const gchar *unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8)
     * }
     */
    public static MemorySegment g_string_append_uri_escaped(MemorySegment string, MemorySegment unescaped, MemorySegment reserved_chars_allowed, int allow_utf8) {
        var mh$ = g_string_append_uri_escaped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_append_uri_escaped", string, unescaped, reserved_chars_allowed, allow_utf8);
            }
            return (MemorySegment)mh$.invokeExact(string, unescaped, reserved_chars_allowed, allow_utf8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_down {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_down");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_down(GString *string)
     * }
     */
    public static FunctionDescriptor g_string_down$descriptor() {
        return g_string_down.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_down(GString *string)
     * }
     */
    public static MethodHandle g_string_down$handle() {
        return g_string_down.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_down(GString *string)
     * }
     */
    public static MemorySegment g_string_down$address() {
        return g_string_down.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_down(GString *string)
     * }
     */
    public static MemorySegment g_string_down(MemorySegment string) {
        var mh$ = g_string_down.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_down", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_up {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_up");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_string_up(GString *string)
     * }
     */
    public static FunctionDescriptor g_string_up$descriptor() {
        return g_string_up.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_string_up(GString *string)
     * }
     */
    public static MethodHandle g_string_up$handle() {
        return g_string_up.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_string_up(GString *string)
     * }
     */
    public static MemorySegment g_string_up$address() {
        return g_string_up.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_string_up(GString *string)
     * }
     */
    public static MemorySegment g_string_up(MemorySegment string) {
        var mh$ = g_string_up.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_up", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_IO_ERROR_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_ERROR_NONE = 0
     * }
     */
    public static int G_IO_ERROR_NONE() {
        return G_IO_ERROR_NONE;
    }
    private static final int G_IO_ERROR_AGAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_ERROR_AGAIN = 1
     * }
     */
    public static int G_IO_ERROR_AGAIN() {
        return G_IO_ERROR_AGAIN;
    }
    private static final int G_IO_ERROR_INVAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_ERROR_INVAL = 2
     * }
     */
    public static int G_IO_ERROR_INVAL() {
        return G_IO_ERROR_INVAL;
    }
    private static final int G_IO_ERROR_UNKNOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_ERROR_UNKNOWN = 3
     * }
     */
    public static int G_IO_ERROR_UNKNOWN() {
        return G_IO_ERROR_UNKNOWN;
    }
    private static final int G_IO_CHANNEL_ERROR_FBIG = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_FBIG = 0
     * }
     */
    public static int G_IO_CHANNEL_ERROR_FBIG() {
        return G_IO_CHANNEL_ERROR_FBIG;
    }
    private static final int G_IO_CHANNEL_ERROR_INVAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_INVAL = 1
     * }
     */
    public static int G_IO_CHANNEL_ERROR_INVAL() {
        return G_IO_CHANNEL_ERROR_INVAL;
    }
    private static final int G_IO_CHANNEL_ERROR_IO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_IO = 2
     * }
     */
    public static int G_IO_CHANNEL_ERROR_IO() {
        return G_IO_CHANNEL_ERROR_IO;
    }
    private static final int G_IO_CHANNEL_ERROR_ISDIR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_ISDIR = 3
     * }
     */
    public static int G_IO_CHANNEL_ERROR_ISDIR() {
        return G_IO_CHANNEL_ERROR_ISDIR;
    }
    private static final int G_IO_CHANNEL_ERROR_NOSPC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_NOSPC = 4
     * }
     */
    public static int G_IO_CHANNEL_ERROR_NOSPC() {
        return G_IO_CHANNEL_ERROR_NOSPC;
    }
    private static final int G_IO_CHANNEL_ERROR_NXIO = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_NXIO = 5
     * }
     */
    public static int G_IO_CHANNEL_ERROR_NXIO() {
        return G_IO_CHANNEL_ERROR_NXIO;
    }
    private static final int G_IO_CHANNEL_ERROR_OVERFLOW = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_OVERFLOW = 6
     * }
     */
    public static int G_IO_CHANNEL_ERROR_OVERFLOW() {
        return G_IO_CHANNEL_ERROR_OVERFLOW;
    }
    private static final int G_IO_CHANNEL_ERROR_PIPE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_PIPE = 7
     * }
     */
    public static int G_IO_CHANNEL_ERROR_PIPE() {
        return G_IO_CHANNEL_ERROR_PIPE;
    }
    private static final int G_IO_CHANNEL_ERROR_FAILED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_CHANNEL_ERROR_FAILED = 8
     * }
     */
    public static int G_IO_CHANNEL_ERROR_FAILED() {
        return G_IO_CHANNEL_ERROR_FAILED;
    }
    private static final int G_IO_STATUS_ERROR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_STATUS_ERROR = 0
     * }
     */
    public static int G_IO_STATUS_ERROR() {
        return G_IO_STATUS_ERROR;
    }
    private static final int G_IO_STATUS_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_STATUS_NORMAL = 1
     * }
     */
    public static int G_IO_STATUS_NORMAL() {
        return G_IO_STATUS_NORMAL;
    }
    private static final int G_IO_STATUS_EOF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_STATUS_EOF = 2
     * }
     */
    public static int G_IO_STATUS_EOF() {
        return G_IO_STATUS_EOF;
    }
    private static final int G_IO_STATUS_AGAIN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_STATUS_AGAIN = 3
     * }
     */
    public static int G_IO_STATUS_AGAIN() {
        return G_IO_STATUS_AGAIN;
    }
    private static final int G_SEEK_CUR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SEEK_CUR = 0
     * }
     */
    public static int G_SEEK_CUR() {
        return G_SEEK_CUR;
    }
    private static final int G_SEEK_SET = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SEEK_SET = 1
     * }
     */
    public static int G_SEEK_SET() {
        return G_SEEK_SET;
    }
    private static final int G_SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SEEK_END = 2
     * }
     */
    public static int G_SEEK_END() {
        return G_SEEK_END;
    }
    private static final int G_IO_FLAG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_NONE = 0
     * }
     */
    public static int G_IO_FLAG_NONE() {
        return G_IO_FLAG_NONE;
    }
    private static final int G_IO_FLAG_APPEND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_APPEND = 1
     * }
     */
    public static int G_IO_FLAG_APPEND() {
        return G_IO_FLAG_APPEND;
    }
    private static final int G_IO_FLAG_NONBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_NONBLOCK = 2
     * }
     */
    public static int G_IO_FLAG_NONBLOCK() {
        return G_IO_FLAG_NONBLOCK;
    }
    private static final int G_IO_FLAG_IS_READABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_IS_READABLE = 4
     * }
     */
    public static int G_IO_FLAG_IS_READABLE() {
        return G_IO_FLAG_IS_READABLE;
    }
    private static final int G_IO_FLAG_IS_WRITABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_IS_WRITABLE = 8
     * }
     */
    public static int G_IO_FLAG_IS_WRITABLE() {
        return G_IO_FLAG_IS_WRITABLE;
    }
}

