// Generated by jextract

package com.nz.media.gst.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GstAggregatorClass {
 *     GstElementClass parent_class;
 *     GstFlowReturn (*flush)(GstAggregator *);
 *     GstBuffer *(*clip)(GstAggregator *, GstAggregatorPad *, GstBuffer *);
 *     GstFlowReturn (*finish_buffer)(GstAggregator *, GstBuffer *);
 *     gboolean (*sink_event)(GstAggregator *, GstAggregatorPad *, GstEvent *);
 *     gboolean (*sink_query)(GstAggregator *, GstAggregatorPad *, GstQuery *);
 *     gboolean (*src_event)(GstAggregator *, GstEvent *);
 *     gboolean (*src_query)(GstAggregator *, GstQuery *);
 *     gboolean (*src_activate)(GstAggregator *, GstPadMode, gboolean);
 *     GstFlowReturn (*aggregate)(GstAggregator *, gboolean);
 *     gboolean (*stop)(GstAggregator *);
 *     gboolean (*start)(GstAggregator *);
 *     GstClockTime (*get_next_time)(GstAggregator *);
 *     GstAggregatorPad *(*create_new_pad)(GstAggregator *, GstPadTemplate *, const gchar *, const GstCaps *);
 *     GstFlowReturn (*update_src_caps)(GstAggregator *, GstCaps *, GstCaps **);
 *     GstCaps *(*fixate_src_caps)(GstAggregator *, GstCaps *);
 *     gboolean (*negotiated_src_caps)(GstAggregator *, GstCaps *);
 *     gboolean (*decide_allocation)(GstAggregator *, GstQuery *);
 *     gboolean (*propose_allocation)(GstAggregator *, GstAggregatorPad *, GstQuery *, GstQuery *);
 *     gboolean (*negotiate)(GstAggregator *);
 *     GstFlowReturn (*sink_event_pre_queue)(GstAggregator *, GstAggregatorPad *, GstEvent *);
 *     gboolean (*sink_query_pre_queue)(GstAggregator *, GstAggregatorPad *, GstQuery *);
 *     GstFlowReturn (*finish_buffer_list)(GstAggregator *, GstBufferList *);
 *     GstSample *(*peek_next_sample)(GstAggregator *, GstAggregatorPad *);
 *     gpointer _gst_reserved[15];
 * }
 * }
 */
public class _GstAggregatorClass {

    _GstAggregatorClass() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GstElementClass.layout().withName("parent_class"),
        gst_min_h.C_POINTER.withName("flush"),
        gst_min_h.C_POINTER.withName("clip"),
        gst_min_h.C_POINTER.withName("finish_buffer"),
        gst_min_h.C_POINTER.withName("sink_event"),
        gst_min_h.C_POINTER.withName("sink_query"),
        gst_min_h.C_POINTER.withName("src_event"),
        gst_min_h.C_POINTER.withName("src_query"),
        gst_min_h.C_POINTER.withName("src_activate"),
        gst_min_h.C_POINTER.withName("aggregate"),
        gst_min_h.C_POINTER.withName("stop"),
        gst_min_h.C_POINTER.withName("start"),
        gst_min_h.C_POINTER.withName("get_next_time"),
        gst_min_h.C_POINTER.withName("create_new_pad"),
        gst_min_h.C_POINTER.withName("update_src_caps"),
        gst_min_h.C_POINTER.withName("fixate_src_caps"),
        gst_min_h.C_POINTER.withName("negotiated_src_caps"),
        gst_min_h.C_POINTER.withName("decide_allocation"),
        gst_min_h.C_POINTER.withName("propose_allocation"),
        gst_min_h.C_POINTER.withName("negotiate"),
        gst_min_h.C_POINTER.withName("sink_event_pre_queue"),
        gst_min_h.C_POINTER.withName("sink_query_pre_queue"),
        gst_min_h.C_POINTER.withName("finish_buffer_list"),
        gst_min_h.C_POINTER.withName("peek_next_sample"),
        MemoryLayout.sequenceLayout(15, gst_min_h.C_POINTER).withName("_gst_reserved")
    ).withName("_GstAggregatorClass");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout parent_class$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("parent_class"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstElementClass parent_class
     * }
     */
    public static final GroupLayout parent_class$layout() {
        return parent_class$LAYOUT;
    }

    private static final long parent_class$OFFSET = $LAYOUT.byteOffset(groupElement("parent_class"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstElementClass parent_class
     * }
     */
    public static final long parent_class$offset() {
        return parent_class$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstElementClass parent_class
     * }
     */
    public static MemorySegment parent_class(MemorySegment struct) {
        return struct.asSlice(parent_class$OFFSET, parent_class$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstElementClass parent_class
     * }
     */
    public static void parent_class(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, parent_class$OFFSET, parent_class$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*flush)(GstAggregator *)
     * }
     */
    public final static class flush {

        private flush() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(flush.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(flush.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout flush$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("flush"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*flush)(GstAggregator *)
     * }
     */
    public static final AddressLayout flush$layout() {
        return flush$LAYOUT;
    }

    private static final long flush$OFFSET = $LAYOUT.byteOffset(groupElement("flush"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*flush)(GstAggregator *)
     * }
     */
    public static final long flush$offset() {
        return flush$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*flush)(GstAggregator *)
     * }
     */
    public static MemorySegment flush(MemorySegment struct) {
        return struct.get(flush$LAYOUT, flush$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*flush)(GstAggregator *)
     * }
     */
    public static void flush(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(flush$LAYOUT, flush$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstBuffer *(*clip)(GstAggregator *, GstAggregatorPad *, GstBuffer *)
     * }
     */
    public final static class clip {

        private clip() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(clip.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(clip.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout clip$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("clip"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstBuffer *(*clip)(GstAggregator *, GstAggregatorPad *, GstBuffer *)
     * }
     */
    public static final AddressLayout clip$layout() {
        return clip$LAYOUT;
    }

    private static final long clip$OFFSET = $LAYOUT.byteOffset(groupElement("clip"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstBuffer *(*clip)(GstAggregator *, GstAggregatorPad *, GstBuffer *)
     * }
     */
    public static final long clip$offset() {
        return clip$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstBuffer *(*clip)(GstAggregator *, GstAggregatorPad *, GstBuffer *)
     * }
     */
    public static MemorySegment clip(MemorySegment struct) {
        return struct.get(clip$LAYOUT, clip$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstBuffer *(*clip)(GstAggregator *, GstAggregatorPad *, GstBuffer *)
     * }
     */
    public static void clip(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(clip$LAYOUT, clip$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer)(GstAggregator *, GstBuffer *)
     * }
     */
    public final static class finish_buffer {

        private finish_buffer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(finish_buffer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(finish_buffer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout finish_buffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("finish_buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer)(GstAggregator *, GstBuffer *)
     * }
     */
    public static final AddressLayout finish_buffer$layout() {
        return finish_buffer$LAYOUT;
    }

    private static final long finish_buffer$OFFSET = $LAYOUT.byteOffset(groupElement("finish_buffer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer)(GstAggregator *, GstBuffer *)
     * }
     */
    public static final long finish_buffer$offset() {
        return finish_buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer)(GstAggregator *, GstBuffer *)
     * }
     */
    public static MemorySegment finish_buffer(MemorySegment struct) {
        return struct.get(finish_buffer$LAYOUT, finish_buffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer)(GstAggregator *, GstBuffer *)
     * }
     */
    public static void finish_buffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(finish_buffer$LAYOUT, finish_buffer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public final static class sink_event {

        private sink_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(sink_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sink_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sink_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sink_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public static final AddressLayout sink_event$layout() {
        return sink_event$LAYOUT;
    }

    private static final long sink_event$OFFSET = $LAYOUT.byteOffset(groupElement("sink_event"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public static final long sink_event$offset() {
        return sink_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public static MemorySegment sink_event(MemorySegment struct) {
        return struct.get(sink_event$LAYOUT, sink_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*sink_event)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public static void sink_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sink_event$LAYOUT, sink_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public final static class sink_query {

        private sink_query() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(sink_query.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sink_query.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sink_query$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sink_query"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public static final AddressLayout sink_query$layout() {
        return sink_query$LAYOUT;
    }

    private static final long sink_query$OFFSET = $LAYOUT.byteOffset(groupElement("sink_query"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public static final long sink_query$offset() {
        return sink_query$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public static MemorySegment sink_query(MemorySegment struct) {
        return struct.get(sink_query$LAYOUT, sink_query$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*sink_query)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public static void sink_query(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sink_query$LAYOUT, sink_query$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*src_event)(GstAggregator *, GstEvent *)
     * }
     */
    public final static class src_event {

        private src_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(src_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(src_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout src_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("src_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*src_event)(GstAggregator *, GstEvent *)
     * }
     */
    public static final AddressLayout src_event$layout() {
        return src_event$LAYOUT;
    }

    private static final long src_event$OFFSET = $LAYOUT.byteOffset(groupElement("src_event"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*src_event)(GstAggregator *, GstEvent *)
     * }
     */
    public static final long src_event$offset() {
        return src_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*src_event)(GstAggregator *, GstEvent *)
     * }
     */
    public static MemorySegment src_event(MemorySegment struct) {
        return struct.get(src_event$LAYOUT, src_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*src_event)(GstAggregator *, GstEvent *)
     * }
     */
    public static void src_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(src_event$LAYOUT, src_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*src_query)(GstAggregator *, GstQuery *)
     * }
     */
    public final static class src_query {

        private src_query() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(src_query.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(src_query.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout src_query$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("src_query"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*src_query)(GstAggregator *, GstQuery *)
     * }
     */
    public static final AddressLayout src_query$layout() {
        return src_query$LAYOUT;
    }

    private static final long src_query$OFFSET = $LAYOUT.byteOffset(groupElement("src_query"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*src_query)(GstAggregator *, GstQuery *)
     * }
     */
    public static final long src_query$offset() {
        return src_query$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*src_query)(GstAggregator *, GstQuery *)
     * }
     */
    public static MemorySegment src_query(MemorySegment struct) {
        return struct.get(src_query$LAYOUT, src_query$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*src_query)(GstAggregator *, GstQuery *)
     * }
     */
    public static void src_query(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(src_query$LAYOUT, src_query$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*src_activate)(GstAggregator *, GstPadMode, gboolean)
     * }
     */
    public final static class src_activate {

        private src_activate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(src_activate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(src_activate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout src_activate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("src_activate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*src_activate)(GstAggregator *, GstPadMode, gboolean)
     * }
     */
    public static final AddressLayout src_activate$layout() {
        return src_activate$LAYOUT;
    }

    private static final long src_activate$OFFSET = $LAYOUT.byteOffset(groupElement("src_activate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*src_activate)(GstAggregator *, GstPadMode, gboolean)
     * }
     */
    public static final long src_activate$offset() {
        return src_activate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*src_activate)(GstAggregator *, GstPadMode, gboolean)
     * }
     */
    public static MemorySegment src_activate(MemorySegment struct) {
        return struct.get(src_activate$LAYOUT, src_activate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*src_activate)(GstAggregator *, GstPadMode, gboolean)
     * }
     */
    public static void src_activate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(src_activate$LAYOUT, src_activate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*aggregate)(GstAggregator *, gboolean)
     * }
     */
    public final static class aggregate {

        private aggregate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(aggregate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(aggregate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout aggregate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("aggregate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*aggregate)(GstAggregator *, gboolean)
     * }
     */
    public static final AddressLayout aggregate$layout() {
        return aggregate$LAYOUT;
    }

    private static final long aggregate$OFFSET = $LAYOUT.byteOffset(groupElement("aggregate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*aggregate)(GstAggregator *, gboolean)
     * }
     */
    public static final long aggregate$offset() {
        return aggregate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*aggregate)(GstAggregator *, gboolean)
     * }
     */
    public static MemorySegment aggregate(MemorySegment struct) {
        return struct.get(aggregate$LAYOUT, aggregate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*aggregate)(GstAggregator *, gboolean)
     * }
     */
    public static void aggregate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(aggregate$LAYOUT, aggregate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*stop)(GstAggregator *)
     * }
     */
    public final static class stop {

        private stop() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(stop.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(stop.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout stop$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("stop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*stop)(GstAggregator *)
     * }
     */
    public static final AddressLayout stop$layout() {
        return stop$LAYOUT;
    }

    private static final long stop$OFFSET = $LAYOUT.byteOffset(groupElement("stop"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*stop)(GstAggregator *)
     * }
     */
    public static final long stop$offset() {
        return stop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*stop)(GstAggregator *)
     * }
     */
    public static MemorySegment stop(MemorySegment struct) {
        return struct.get(stop$LAYOUT, stop$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*stop)(GstAggregator *)
     * }
     */
    public static void stop(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(stop$LAYOUT, stop$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*start)(GstAggregator *)
     * }
     */
    public final static class start {

        private start() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(start.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(start.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout start$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("start"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*start)(GstAggregator *)
     * }
     */
    public static final AddressLayout start$layout() {
        return start$LAYOUT;
    }

    private static final long start$OFFSET = $LAYOUT.byteOffset(groupElement("start"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*start)(GstAggregator *)
     * }
     */
    public static final long start$offset() {
        return start$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*start)(GstAggregator *)
     * }
     */
    public static MemorySegment start(MemorySegment struct) {
        return struct.get(start$LAYOUT, start$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*start)(GstAggregator *)
     * }
     */
    public static void start(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(start$LAYOUT, start$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstClockTime (*get_next_time)(GstAggregator *)
     * }
     */
    public final static class get_next_time {

        private get_next_time() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(get_next_time.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_next_time.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_next_time$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_next_time"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstClockTime (*get_next_time)(GstAggregator *)
     * }
     */
    public static final AddressLayout get_next_time$layout() {
        return get_next_time$LAYOUT;
    }

    private static final long get_next_time$OFFSET = $LAYOUT.byteOffset(groupElement("get_next_time"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstClockTime (*get_next_time)(GstAggregator *)
     * }
     */
    public static final long get_next_time$offset() {
        return get_next_time$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstClockTime (*get_next_time)(GstAggregator *)
     * }
     */
    public static MemorySegment get_next_time(MemorySegment struct) {
        return struct.get(get_next_time$LAYOUT, get_next_time$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstClockTime (*get_next_time)(GstAggregator *)
     * }
     */
    public static void get_next_time(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_next_time$LAYOUT, get_next_time$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstAggregatorPad *(*create_new_pad)(GstAggregator *, GstPadTemplate *, const gchar *, const GstCaps *)
     * }
     */
    public final static class create_new_pad {

        private create_new_pad() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(create_new_pad.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_new_pad.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_new_pad$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_new_pad"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstAggregatorPad *(*create_new_pad)(GstAggregator *, GstPadTemplate *, const gchar *, const GstCaps *)
     * }
     */
    public static final AddressLayout create_new_pad$layout() {
        return create_new_pad$LAYOUT;
    }

    private static final long create_new_pad$OFFSET = $LAYOUT.byteOffset(groupElement("create_new_pad"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstAggregatorPad *(*create_new_pad)(GstAggregator *, GstPadTemplate *, const gchar *, const GstCaps *)
     * }
     */
    public static final long create_new_pad$offset() {
        return create_new_pad$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstAggregatorPad *(*create_new_pad)(GstAggregator *, GstPadTemplate *, const gchar *, const GstCaps *)
     * }
     */
    public static MemorySegment create_new_pad(MemorySegment struct) {
        return struct.get(create_new_pad$LAYOUT, create_new_pad$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstAggregatorPad *(*create_new_pad)(GstAggregator *, GstPadTemplate *, const gchar *, const GstCaps *)
     * }
     */
    public static void create_new_pad(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_new_pad$LAYOUT, create_new_pad$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*update_src_caps)(GstAggregator *, GstCaps *, GstCaps **)
     * }
     */
    public final static class update_src_caps {

        private update_src_caps() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(update_src_caps.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(update_src_caps.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout update_src_caps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("update_src_caps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*update_src_caps)(GstAggregator *, GstCaps *, GstCaps **)
     * }
     */
    public static final AddressLayout update_src_caps$layout() {
        return update_src_caps$LAYOUT;
    }

    private static final long update_src_caps$OFFSET = $LAYOUT.byteOffset(groupElement("update_src_caps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*update_src_caps)(GstAggregator *, GstCaps *, GstCaps **)
     * }
     */
    public static final long update_src_caps$offset() {
        return update_src_caps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*update_src_caps)(GstAggregator *, GstCaps *, GstCaps **)
     * }
     */
    public static MemorySegment update_src_caps(MemorySegment struct) {
        return struct.get(update_src_caps$LAYOUT, update_src_caps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*update_src_caps)(GstAggregator *, GstCaps *, GstCaps **)
     * }
     */
    public static void update_src_caps(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(update_src_caps$LAYOUT, update_src_caps$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstCaps *(*fixate_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public final static class fixate_src_caps {

        private fixate_src_caps() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(fixate_src_caps.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fixate_src_caps.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fixate_src_caps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fixate_src_caps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstCaps *(*fixate_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public static final AddressLayout fixate_src_caps$layout() {
        return fixate_src_caps$LAYOUT;
    }

    private static final long fixate_src_caps$OFFSET = $LAYOUT.byteOffset(groupElement("fixate_src_caps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstCaps *(*fixate_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public static final long fixate_src_caps$offset() {
        return fixate_src_caps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstCaps *(*fixate_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public static MemorySegment fixate_src_caps(MemorySegment struct) {
        return struct.get(fixate_src_caps$LAYOUT, fixate_src_caps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstCaps *(*fixate_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public static void fixate_src_caps(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fixate_src_caps$LAYOUT, fixate_src_caps$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*negotiated_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public final static class negotiated_src_caps {

        private negotiated_src_caps() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(negotiated_src_caps.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(negotiated_src_caps.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout negotiated_src_caps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("negotiated_src_caps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*negotiated_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public static final AddressLayout negotiated_src_caps$layout() {
        return negotiated_src_caps$LAYOUT;
    }

    private static final long negotiated_src_caps$OFFSET = $LAYOUT.byteOffset(groupElement("negotiated_src_caps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*negotiated_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public static final long negotiated_src_caps$offset() {
        return negotiated_src_caps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*negotiated_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public static MemorySegment negotiated_src_caps(MemorySegment struct) {
        return struct.get(negotiated_src_caps$LAYOUT, negotiated_src_caps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*negotiated_src_caps)(GstAggregator *, GstCaps *)
     * }
     */
    public static void negotiated_src_caps(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(negotiated_src_caps$LAYOUT, negotiated_src_caps$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstAggregator *, GstQuery *)
     * }
     */
    public final static class decide_allocation {

        private decide_allocation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(decide_allocation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(decide_allocation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout decide_allocation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("decide_allocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstAggregator *, GstQuery *)
     * }
     */
    public static final AddressLayout decide_allocation$layout() {
        return decide_allocation$LAYOUT;
    }

    private static final long decide_allocation$OFFSET = $LAYOUT.byteOffset(groupElement("decide_allocation"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstAggregator *, GstQuery *)
     * }
     */
    public static final long decide_allocation$offset() {
        return decide_allocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstAggregator *, GstQuery *)
     * }
     */
    public static MemorySegment decide_allocation(MemorySegment struct) {
        return struct.get(decide_allocation$LAYOUT, decide_allocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*decide_allocation)(GstAggregator *, GstQuery *)
     * }
     */
    public static void decide_allocation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(decide_allocation$LAYOUT, decide_allocation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstAggregator *, GstAggregatorPad *, GstQuery *, GstQuery *)
     * }
     */
    public final static class propose_allocation {

        private propose_allocation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(propose_allocation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(propose_allocation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout propose_allocation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("propose_allocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstAggregator *, GstAggregatorPad *, GstQuery *, GstQuery *)
     * }
     */
    public static final AddressLayout propose_allocation$layout() {
        return propose_allocation$LAYOUT;
    }

    private static final long propose_allocation$OFFSET = $LAYOUT.byteOffset(groupElement("propose_allocation"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstAggregator *, GstAggregatorPad *, GstQuery *, GstQuery *)
     * }
     */
    public static final long propose_allocation$offset() {
        return propose_allocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstAggregator *, GstAggregatorPad *, GstQuery *, GstQuery *)
     * }
     */
    public static MemorySegment propose_allocation(MemorySegment struct) {
        return struct.get(propose_allocation$LAYOUT, propose_allocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*propose_allocation)(GstAggregator *, GstAggregatorPad *, GstQuery *, GstQuery *)
     * }
     */
    public static void propose_allocation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(propose_allocation$LAYOUT, propose_allocation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstAggregator *)
     * }
     */
    public final static class negotiate {

        private negotiate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(negotiate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(negotiate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout negotiate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("negotiate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstAggregator *)
     * }
     */
    public static final AddressLayout negotiate$layout() {
        return negotiate$LAYOUT;
    }

    private static final long negotiate$OFFSET = $LAYOUT.byteOffset(groupElement("negotiate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstAggregator *)
     * }
     */
    public static final long negotiate$offset() {
        return negotiate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstAggregator *)
     * }
     */
    public static MemorySegment negotiate(MemorySegment struct) {
        return struct.get(negotiate$LAYOUT, negotiate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*negotiate)(GstAggregator *)
     * }
     */
    public static void negotiate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(negotiate$LAYOUT, negotiate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*sink_event_pre_queue)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public final static class sink_event_pre_queue {

        private sink_event_pre_queue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(sink_event_pre_queue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sink_event_pre_queue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sink_event_pre_queue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sink_event_pre_queue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*sink_event_pre_queue)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public static final AddressLayout sink_event_pre_queue$layout() {
        return sink_event_pre_queue$LAYOUT;
    }

    private static final long sink_event_pre_queue$OFFSET = $LAYOUT.byteOffset(groupElement("sink_event_pre_queue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*sink_event_pre_queue)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public static final long sink_event_pre_queue$offset() {
        return sink_event_pre_queue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*sink_event_pre_queue)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public static MemorySegment sink_event_pre_queue(MemorySegment struct) {
        return struct.get(sink_event_pre_queue$LAYOUT, sink_event_pre_queue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*sink_event_pre_queue)(GstAggregator *, GstAggregatorPad *, GstEvent *)
     * }
     */
    public static void sink_event_pre_queue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sink_event_pre_queue$LAYOUT, sink_event_pre_queue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*sink_query_pre_queue)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public final static class sink_query_pre_queue {

        private sink_query_pre_queue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(sink_query_pre_queue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sink_query_pre_queue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sink_query_pre_queue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sink_query_pre_queue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*sink_query_pre_queue)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public static final AddressLayout sink_query_pre_queue$layout() {
        return sink_query_pre_queue$LAYOUT;
    }

    private static final long sink_query_pre_queue$OFFSET = $LAYOUT.byteOffset(groupElement("sink_query_pre_queue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*sink_query_pre_queue)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public static final long sink_query_pre_queue$offset() {
        return sink_query_pre_queue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*sink_query_pre_queue)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public static MemorySegment sink_query_pre_queue(MemorySegment struct) {
        return struct.get(sink_query_pre_queue$LAYOUT, sink_query_pre_queue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*sink_query_pre_queue)(GstAggregator *, GstAggregatorPad *, GstQuery *)
     * }
     */
    public static void sink_query_pre_queue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sink_query_pre_queue$LAYOUT, sink_query_pre_queue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer_list)(GstAggregator *, GstBufferList *)
     * }
     */
    public final static class finish_buffer_list {

        private finish_buffer_list() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(finish_buffer_list.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(finish_buffer_list.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout finish_buffer_list$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("finish_buffer_list"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer_list)(GstAggregator *, GstBufferList *)
     * }
     */
    public static final AddressLayout finish_buffer_list$layout() {
        return finish_buffer_list$LAYOUT;
    }

    private static final long finish_buffer_list$OFFSET = $LAYOUT.byteOffset(groupElement("finish_buffer_list"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer_list)(GstAggregator *, GstBufferList *)
     * }
     */
    public static final long finish_buffer_list$offset() {
        return finish_buffer_list$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer_list)(GstAggregator *, GstBufferList *)
     * }
     */
    public static MemorySegment finish_buffer_list(MemorySegment struct) {
        return struct.get(finish_buffer_list$LAYOUT, finish_buffer_list$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstFlowReturn (*finish_buffer_list)(GstAggregator *, GstBufferList *)
     * }
     */
    public static void finish_buffer_list(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(finish_buffer_list$LAYOUT, finish_buffer_list$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GstSample *(*peek_next_sample)(GstAggregator *, GstAggregatorPad *)
     * }
     */
    public final static class peek_next_sample {

        private peek_next_sample() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(peek_next_sample.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(peek_next_sample.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout peek_next_sample$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("peek_next_sample"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstSample *(*peek_next_sample)(GstAggregator *, GstAggregatorPad *)
     * }
     */
    public static final AddressLayout peek_next_sample$layout() {
        return peek_next_sample$LAYOUT;
    }

    private static final long peek_next_sample$OFFSET = $LAYOUT.byteOffset(groupElement("peek_next_sample"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstSample *(*peek_next_sample)(GstAggregator *, GstAggregatorPad *)
     * }
     */
    public static final long peek_next_sample$offset() {
        return peek_next_sample$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstSample *(*peek_next_sample)(GstAggregator *, GstAggregatorPad *)
     * }
     */
    public static MemorySegment peek_next_sample(MemorySegment struct) {
        return struct.get(peek_next_sample$LAYOUT, peek_next_sample$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstSample *(*peek_next_sample)(GstAggregator *, GstAggregatorPad *)
     * }
     */
    public static void peek_next_sample(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(peek_next_sample$LAYOUT, peek_next_sample$OFFSET, fieldValue);
    }

    private static final SequenceLayout _gst_reserved$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("_gst_reserved"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gpointer _gst_reserved[15]
     * }
     */
    public static final SequenceLayout _gst_reserved$layout() {
        return _gst_reserved$LAYOUT;
    }

    private static final long _gst_reserved$OFFSET = $LAYOUT.byteOffset(groupElement("_gst_reserved"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gpointer _gst_reserved[15]
     * }
     */
    public static final long _gst_reserved$offset() {
        return _gst_reserved$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gpointer _gst_reserved[15]
     * }
     */
    public static MemorySegment _gst_reserved(MemorySegment struct) {
        return struct.asSlice(_gst_reserved$OFFSET, _gst_reserved$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gpointer _gst_reserved[15]
     * }
     */
    public static void _gst_reserved(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, _gst_reserved$OFFSET, _gst_reserved$LAYOUT.byteSize());
    }

    private static long[] _gst_reserved$DIMS = { 15 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * gpointer _gst_reserved[15]
     * }
     */
    public static long[] _gst_reserved$dimensions() {
        return _gst_reserved$DIMS;
    }
    private static final VarHandle _gst_reserved$ELEM_HANDLE = _gst_reserved$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * gpointer _gst_reserved[15]
     * }
     */
    public static MemorySegment _gst_reserved(MemorySegment struct, long index0) {
        return (MemorySegment)_gst_reserved$ELEM_HANDLE.get(struct, _gst_reserved$OFFSET, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * gpointer _gst_reserved[15]
     * }
     */
    public static void _gst_reserved(MemorySegment struct, long index0, MemorySegment fieldValue) {
        _gst_reserved$ELEM_HANDLE.set(struct, _gst_reserved$OFFSET, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

