// Generated by jextract

package com.nz.media.gst.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GstVideoMeta {
 *     GstMeta meta;
 *     GstBuffer *buffer;
 *     GstVideoFrameFlags flags;
 *     GstVideoFormat format;
 *     gint id;
 *     guint width;
 *     guint height;
 *     guint n_planes;
 *     gsize offset[4];
 *     gint stride[4];
 *     gboolean (*map)(GstVideoMeta *, guint, GstMapInfo *, gpointer *, gint *, GstMapFlags);
 *     gboolean (*unmap)(GstVideoMeta *, guint, GstMapInfo *);
 *     GstVideoAlignment alignment;
 * }
 * }
 */
public class _GstVideoMeta {

    _GstVideoMeta() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GstMeta.layout().withName("meta"),
        gst_min_h.C_POINTER.withName("buffer"),
        gst_min_h.C_INT.withName("flags"),
        gst_min_h.C_INT.withName("format"),
        gst_min_h.C_INT.withName("id"),
        gst_min_h.C_INT.withName("width"),
        gst_min_h.C_INT.withName("height"),
        gst_min_h.C_INT.withName("n_planes"),
        MemoryLayout.sequenceLayout(4, gst_min_h.C_LONG_LONG).withName("offset"),
        MemoryLayout.sequenceLayout(4, gst_min_h.C_INT).withName("stride"),
        gst_min_h.C_POINTER.withName("map"),
        gst_min_h.C_POINTER.withName("unmap"),
        _GstVideoAlignment.layout().withName("alignment")
    ).withName("_GstVideoMeta");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout meta$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("meta"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstMeta meta
     * }
     */
    public static final GroupLayout meta$layout() {
        return meta$LAYOUT;
    }

    private static final long meta$OFFSET = $LAYOUT.byteOffset(groupElement("meta"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstMeta meta
     * }
     */
    public static final long meta$offset() {
        return meta$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstMeta meta
     * }
     */
    public static MemorySegment meta(MemorySegment struct) {
        return struct.asSlice(meta$OFFSET, meta$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstMeta meta
     * }
     */
    public static void meta(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, meta$OFFSET, meta$LAYOUT.byteSize());
    }

    private static final AddressLayout buffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstBuffer *buffer
     * }
     */
    public static final AddressLayout buffer$layout() {
        return buffer$LAYOUT;
    }

    private static final long buffer$OFFSET = $LAYOUT.byteOffset(groupElement("buffer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstBuffer *buffer
     * }
     */
    public static final long buffer$offset() {
        return buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstBuffer *buffer
     * }
     */
    public static MemorySegment buffer(MemorySegment struct) {
        return struct.get(buffer$LAYOUT, buffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstBuffer *buffer
     * }
     */
    public static void buffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(buffer$LAYOUT, buffer$OFFSET, fieldValue);
    }

    private static final OfInt flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstVideoFrameFlags flags
     * }
     */
    public static final OfInt flags$layout() {
        return flags$LAYOUT;
    }

    private static final long flags$OFFSET = $LAYOUT.byteOffset(groupElement("flags"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstVideoFrameFlags flags
     * }
     */
    public static final long flags$offset() {
        return flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstVideoFrameFlags flags
     * }
     */
    public static int flags(MemorySegment struct) {
        return struct.get(flags$LAYOUT, flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstVideoFrameFlags flags
     * }
     */
    public static void flags(MemorySegment struct, int fieldValue) {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    private static final OfInt format$LAYOUT = (OfInt)$LAYOUT.select(groupElement("format"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstVideoFormat format
     * }
     */
    public static final OfInt format$layout() {
        return format$LAYOUT;
    }

    private static final long format$OFFSET = $LAYOUT.byteOffset(groupElement("format"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstVideoFormat format
     * }
     */
    public static final long format$offset() {
        return format$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstVideoFormat format
     * }
     */
    public static int format(MemorySegment struct) {
        return struct.get(format$LAYOUT, format$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstVideoFormat format
     * }
     */
    public static void format(MemorySegment struct, int fieldValue) {
        struct.set(format$LAYOUT, format$OFFSET, fieldValue);
    }

    private static final OfInt id$LAYOUT = (OfInt)$LAYOUT.select(groupElement("id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint id
     * }
     */
    public static final OfInt id$layout() {
        return id$LAYOUT;
    }

    private static final long id$OFFSET = $LAYOUT.byteOffset(groupElement("id"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint id
     * }
     */
    public static final long id$offset() {
        return id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint id
     * }
     */
    public static int id(MemorySegment struct) {
        return struct.get(id$LAYOUT, id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint id
     * }
     */
    public static void id(MemorySegment struct, int fieldValue) {
        struct.set(id$LAYOUT, id$OFFSET, fieldValue);
    }

    private static final OfInt width$LAYOUT = (OfInt)$LAYOUT.select(groupElement("width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * guint width
     * }
     */
    public static final OfInt width$layout() {
        return width$LAYOUT;
    }

    private static final long width$OFFSET = $LAYOUT.byteOffset(groupElement("width"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * guint width
     * }
     */
    public static final long width$offset() {
        return width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * guint width
     * }
     */
    public static int width(MemorySegment struct) {
        return struct.get(width$LAYOUT, width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * guint width
     * }
     */
    public static void width(MemorySegment struct, int fieldValue) {
        struct.set(width$LAYOUT, width$OFFSET, fieldValue);
    }

    private static final OfInt height$LAYOUT = (OfInt)$LAYOUT.select(groupElement("height"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * guint height
     * }
     */
    public static final OfInt height$layout() {
        return height$LAYOUT;
    }

    private static final long height$OFFSET = $LAYOUT.byteOffset(groupElement("height"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * guint height
     * }
     */
    public static final long height$offset() {
        return height$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * guint height
     * }
     */
    public static int height(MemorySegment struct) {
        return struct.get(height$LAYOUT, height$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * guint height
     * }
     */
    public static void height(MemorySegment struct, int fieldValue) {
        struct.set(height$LAYOUT, height$OFFSET, fieldValue);
    }

    private static final OfInt n_planes$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_planes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * guint n_planes
     * }
     */
    public static final OfInt n_planes$layout() {
        return n_planes$LAYOUT;
    }

    private static final long n_planes$OFFSET = $LAYOUT.byteOffset(groupElement("n_planes"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * guint n_planes
     * }
     */
    public static final long n_planes$offset() {
        return n_planes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * guint n_planes
     * }
     */
    public static int n_planes(MemorySegment struct) {
        return struct.get(n_planes$LAYOUT, n_planes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * guint n_planes
     * }
     */
    public static void n_planes(MemorySegment struct, int fieldValue) {
        struct.set(n_planes$LAYOUT, n_planes$OFFSET, fieldValue);
    }

    private static final SequenceLayout offset$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gsize offset[4]
     * }
     */
    public static final SequenceLayout offset$layout() {
        return offset$LAYOUT;
    }

    private static final long offset$OFFSET = $LAYOUT.byteOffset(groupElement("offset"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gsize offset[4]
     * }
     */
    public static final long offset$offset() {
        return offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gsize offset[4]
     * }
     */
    public static MemorySegment offset(MemorySegment struct) {
        return struct.asSlice(offset$OFFSET, offset$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gsize offset[4]
     * }
     */
    public static void offset(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, offset$OFFSET, offset$LAYOUT.byteSize());
    }

    private static long[] offset$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * gsize offset[4]
     * }
     */
    public static long[] offset$dimensions() {
        return offset$DIMS;
    }
    private static final VarHandle offset$ELEM_HANDLE = offset$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * gsize offset[4]
     * }
     */
    public static long offset(MemorySegment struct, long index0) {
        return (long)offset$ELEM_HANDLE.get(struct, offset$OFFSET, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * gsize offset[4]
     * }
     */
    public static void offset(MemorySegment struct, long index0, long fieldValue) {
        offset$ELEM_HANDLE.set(struct, offset$OFFSET, index0, fieldValue);
    }

    private static final SequenceLayout stride$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("stride"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint stride[4]
     * }
     */
    public static final SequenceLayout stride$layout() {
        return stride$LAYOUT;
    }

    private static final long stride$OFFSET = $LAYOUT.byteOffset(groupElement("stride"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint stride[4]
     * }
     */
    public static final long stride$offset() {
        return stride$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint stride[4]
     * }
     */
    public static MemorySegment stride(MemorySegment struct) {
        return struct.asSlice(stride$OFFSET, stride$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint stride[4]
     * }
     */
    public static void stride(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, stride$OFFSET, stride$LAYOUT.byteSize());
    }

    private static long[] stride$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * gint stride[4]
     * }
     */
    public static long[] stride$dimensions() {
        return stride$DIMS;
    }
    private static final VarHandle stride$ELEM_HANDLE = stride$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * gint stride[4]
     * }
     */
    public static int stride(MemorySegment struct, long index0) {
        return (int)stride$ELEM_HANDLE.get(struct, stride$OFFSET, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * gint stride[4]
     * }
     */
    public static void stride(MemorySegment struct, long index0, int fieldValue) {
        stride$ELEM_HANDLE.set(struct, stride$OFFSET, index0, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*map)(GstVideoMeta *, guint, GstMapInfo *, gpointer *, gint *, GstMapFlags)
     * }
     */
    public final static class map {

        private map() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(map.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(map.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, int _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout map$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("map"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*map)(GstVideoMeta *, guint, GstMapInfo *, gpointer *, gint *, GstMapFlags)
     * }
     */
    public static final AddressLayout map$layout() {
        return map$LAYOUT;
    }

    private static final long map$OFFSET = $LAYOUT.byteOffset(groupElement("map"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*map)(GstVideoMeta *, guint, GstMapInfo *, gpointer *, gint *, GstMapFlags)
     * }
     */
    public static final long map$offset() {
        return map$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*map)(GstVideoMeta *, guint, GstMapInfo *, gpointer *, gint *, GstMapFlags)
     * }
     */
    public static MemorySegment map(MemorySegment struct) {
        return struct.get(map$LAYOUT, map$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*map)(GstVideoMeta *, guint, GstMapInfo *, gpointer *, gint *, GstMapFlags)
     * }
     */
    public static void map(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(map$LAYOUT, map$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*unmap)(GstVideoMeta *, guint, GstMapInfo *)
     * }
     */
    public final static class unmap {

        private unmap() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = gst_min_h.upcallHandle(unmap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unmap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unmap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unmap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*unmap)(GstVideoMeta *, guint, GstMapInfo *)
     * }
     */
    public static final AddressLayout unmap$layout() {
        return unmap$LAYOUT;
    }

    private static final long unmap$OFFSET = $LAYOUT.byteOffset(groupElement("unmap"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*unmap)(GstVideoMeta *, guint, GstMapInfo *)
     * }
     */
    public static final long unmap$offset() {
        return unmap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*unmap)(GstVideoMeta *, guint, GstMapInfo *)
     * }
     */
    public static MemorySegment unmap(MemorySegment struct) {
        return struct.get(unmap$LAYOUT, unmap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*unmap)(GstVideoMeta *, guint, GstMapInfo *)
     * }
     */
    public static void unmap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unmap$LAYOUT, unmap$OFFSET, fieldValue);
    }

    private static final GroupLayout alignment$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("alignment"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GstVideoAlignment alignment
     * }
     */
    public static final GroupLayout alignment$layout() {
        return alignment$LAYOUT;
    }

    private static final long alignment$OFFSET = $LAYOUT.byteOffset(groupElement("alignment"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GstVideoAlignment alignment
     * }
     */
    public static final long alignment$offset() {
        return alignment$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GstVideoAlignment alignment
     * }
     */
    public static MemorySegment alignment(MemorySegment struct) {
        return struct.asSlice(alignment$OFFSET, alignment$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GstVideoAlignment alignment
     * }
     */
    public static void alignment(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, alignment$OFFSET, alignment$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

