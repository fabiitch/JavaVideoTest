// Generated by jextract

package com.nz.media.gst.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class gst_min_h_7 extends gst_min_h_8 {

    gst_min_h_7() {
        // Should not be called directly
    }
    private static final int G_IO_FLAG_IS_WRITEABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_IS_WRITEABLE = 8
     * }
     */
    public static int G_IO_FLAG_IS_WRITEABLE() {
        return G_IO_FLAG_IS_WRITEABLE;
    }
    private static final int G_IO_FLAG_IS_SEEKABLE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_IS_SEEKABLE = 16
     * }
     */
    public static int G_IO_FLAG_IS_SEEKABLE() {
        return G_IO_FLAG_IS_SEEKABLE;
    }
    private static final int G_IO_FLAG_MASK = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_MASK = 31
     * }
     */
    public static int G_IO_FLAG_MASK() {
        return G_IO_FLAG_MASK;
    }
    private static final int G_IO_FLAG_GET_MASK = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_GET_MASK = 31
     * }
     */
    public static int G_IO_FLAG_GET_MASK() {
        return G_IO_FLAG_GET_MASK;
    }
    private static final int G_IO_FLAG_SET_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_IO_FLAG_SET_MASK = 3
     * }
     */
    public static int G_IO_FLAG_SET_MASK() {
        return G_IO_FLAG_SET_MASK;
    }

    private static class g_io_channel_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_init(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_init$descriptor() {
        return g_io_channel_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_init(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_init$handle() {
        return g_io_channel_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_init(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_init$address() {
        return g_io_channel_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_init(GIOChannel *channel)
     * }
     */
    public static void g_io_channel_init(MemorySegment channel) {
        var mh$ = g_io_channel_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_init", channel);
            }
            mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_ref(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_ref$descriptor() {
        return g_io_channel_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_ref(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_ref$handle() {
        return g_io_channel_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_ref(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_ref$address() {
        return g_io_channel_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_ref(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_ref(MemorySegment channel) {
        var mh$ = g_io_channel_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_ref", channel);
            }
            return (MemorySegment)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_unref(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_unref$descriptor() {
        return g_io_channel_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_unref(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_unref$handle() {
        return g_io_channel_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_unref(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_unref$address() {
        return g_io_channel_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_unref(GIOChannel *channel)
     * }
     */
    public static void g_io_channel_unref(MemorySegment channel) {
        var mh$ = g_io_channel_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_unref", channel);
            }
            mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_read(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read)
     * }
     */
    public static FunctionDescriptor g_io_channel_read$descriptor() {
        return g_io_channel_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_read(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read)
     * }
     */
    public static MethodHandle g_io_channel_read$handle() {
        return g_io_channel_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_read(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read)
     * }
     */
    public static MemorySegment g_io_channel_read$address() {
        return g_io_channel_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOError g_io_channel_read(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read)
     * }
     */
    public static int g_io_channel_read(MemorySegment channel, MemorySegment buf, long count, MemorySegment bytes_read) {
        var mh$ = g_io_channel_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_read", channel, buf, count, bytes_read);
            }
            return (int)mh$.invokeExact(channel, buf, count, bytes_read);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_write(GIOChannel *channel, const gchar *buf, gsize count, gsize *bytes_written)
     * }
     */
    public static FunctionDescriptor g_io_channel_write$descriptor() {
        return g_io_channel_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_write(GIOChannel *channel, const gchar *buf, gsize count, gsize *bytes_written)
     * }
     */
    public static MethodHandle g_io_channel_write$handle() {
        return g_io_channel_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_write(GIOChannel *channel, const gchar *buf, gsize count, gsize *bytes_written)
     * }
     */
    public static MemorySegment g_io_channel_write$address() {
        return g_io_channel_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOError g_io_channel_write(GIOChannel *channel, const gchar *buf, gsize count, gsize *bytes_written)
     * }
     */
    public static int g_io_channel_write(MemorySegment channel, MemorySegment buf, long count, MemorySegment bytes_written) {
        var mh$ = g_io_channel_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_write", channel, buf, count, bytes_written);
            }
            return (int)mh$.invokeExact(channel, buf, count, bytes_written);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_seek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_seek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_seek(GIOChannel *channel, gint64 offset, GSeekType type)
     * }
     */
    public static FunctionDescriptor g_io_channel_seek$descriptor() {
        return g_io_channel_seek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_seek(GIOChannel *channel, gint64 offset, GSeekType type)
     * }
     */
    public static MethodHandle g_io_channel_seek$handle() {
        return g_io_channel_seek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOError g_io_channel_seek(GIOChannel *channel, gint64 offset, GSeekType type)
     * }
     */
    public static MemorySegment g_io_channel_seek$address() {
        return g_io_channel_seek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOError g_io_channel_seek(GIOChannel *channel, gint64 offset, GSeekType type)
     * }
     */
    public static int g_io_channel_seek(MemorySegment channel, long offset, int type) {
        var mh$ = g_io_channel_seek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_seek", channel, offset, type);
            }
            return (int)mh$.invokeExact(channel, offset, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_close(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_close$descriptor() {
        return g_io_channel_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_close(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_close$handle() {
        return g_io_channel_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_close(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_close$address() {
        return g_io_channel_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_close(GIOChannel *channel)
     * }
     */
    public static void g_io_channel_close(MemorySegment channel) {
        var mh$ = g_io_channel_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_close", channel);
            }
            mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_shutdown(GIOChannel *channel, gboolean flush, GError **err)
     * }
     */
    public static FunctionDescriptor g_io_channel_shutdown$descriptor() {
        return g_io_channel_shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_shutdown(GIOChannel *channel, gboolean flush, GError **err)
     * }
     */
    public static MethodHandle g_io_channel_shutdown$handle() {
        return g_io_channel_shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_shutdown(GIOChannel *channel, gboolean flush, GError **err)
     * }
     */
    public static MemorySegment g_io_channel_shutdown$address() {
        return g_io_channel_shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_shutdown(GIOChannel *channel, gboolean flush, GError **err)
     * }
     */
    public static int g_io_channel_shutdown(MemorySegment channel, int flush, MemorySegment err) {
        var mh$ = g_io_channel_shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_shutdown", channel, flush, err);
            }
            return (int)mh$.invokeExact(channel, flush, err);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_add_watch_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_add_watch_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_io_add_watch_full(GIOChannel *channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify)
     * }
     */
    public static FunctionDescriptor g_io_add_watch_full$descriptor() {
        return g_io_add_watch_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_io_add_watch_full(GIOChannel *channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify)
     * }
     */
    public static MethodHandle g_io_add_watch_full$handle() {
        return g_io_add_watch_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_io_add_watch_full(GIOChannel *channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify)
     * }
     */
    public static MemorySegment g_io_add_watch_full$address() {
        return g_io_add_watch_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_io_add_watch_full(GIOChannel *channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify)
     * }
     */
    public static int g_io_add_watch_full(MemorySegment channel, int priority, int condition, MemorySegment func, MemorySegment user_data, MemorySegment notify) {
        var mh$ = g_io_add_watch_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_add_watch_full", channel, priority, condition, func, user_data, notify);
            }
            return (int)mh$.invokeExact(channel, priority, condition, func, user_data, notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_create_watch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_create_watch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSource *g_io_create_watch(GIOChannel *channel, GIOCondition condition)
     * }
     */
    public static FunctionDescriptor g_io_create_watch$descriptor() {
        return g_io_create_watch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSource *g_io_create_watch(GIOChannel *channel, GIOCondition condition)
     * }
     */
    public static MethodHandle g_io_create_watch$handle() {
        return g_io_create_watch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSource *g_io_create_watch(GIOChannel *channel, GIOCondition condition)
     * }
     */
    public static MemorySegment g_io_create_watch$address() {
        return g_io_create_watch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSource *g_io_create_watch(GIOChannel *channel, GIOCondition condition)
     * }
     */
    public static MemorySegment g_io_create_watch(MemorySegment channel, int condition) {
        var mh$ = g_io_create_watch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_create_watch", channel, condition);
            }
            return (MemorySegment)mh$.invokeExact(channel, condition);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_add_watch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_add_watch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_io_add_watch(GIOChannel *channel, GIOCondition condition, GIOFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_io_add_watch$descriptor() {
        return g_io_add_watch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_io_add_watch(GIOChannel *channel, GIOCondition condition, GIOFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_io_add_watch$handle() {
        return g_io_add_watch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_io_add_watch(GIOChannel *channel, GIOCondition condition, GIOFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_io_add_watch$address() {
        return g_io_add_watch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_io_add_watch(GIOChannel *channel, GIOCondition condition, GIOFunc func, gpointer user_data)
     * }
     */
    public static int g_io_add_watch(MemorySegment channel, int condition, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_io_add_watch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_add_watch", channel, condition, func, user_data);
            }
            return (int)mh$.invokeExact(channel, condition, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_set_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_set_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_buffer_size(GIOChannel *channel, gsize size)
     * }
     */
    public static FunctionDescriptor g_io_channel_set_buffer_size$descriptor() {
        return g_io_channel_set_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_buffer_size(GIOChannel *channel, gsize size)
     * }
     */
    public static MethodHandle g_io_channel_set_buffer_size$handle() {
        return g_io_channel_set_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_buffer_size(GIOChannel *channel, gsize size)
     * }
     */
    public static MemorySegment g_io_channel_set_buffer_size$address() {
        return g_io_channel_set_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_set_buffer_size(GIOChannel *channel, gsize size)
     * }
     */
    public static void g_io_channel_set_buffer_size(MemorySegment channel, long size) {
        var mh$ = g_io_channel_set_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_set_buffer_size", channel, size);
            }
            mh$.invokeExact(channel, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_io_channel_get_buffer_size(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_get_buffer_size$descriptor() {
        return g_io_channel_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_io_channel_get_buffer_size(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_get_buffer_size$handle() {
        return g_io_channel_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_io_channel_get_buffer_size(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_get_buffer_size$address() {
        return g_io_channel_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_io_channel_get_buffer_size(GIOChannel *channel)
     * }
     */
    public static long g_io_channel_get_buffer_size(MemorySegment channel) {
        var mh$ = g_io_channel_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_get_buffer_size", channel);
            }
            return (long)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_get_buffer_condition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_get_buffer_condition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_get_buffer_condition$descriptor() {
        return g_io_channel_get_buffer_condition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_get_buffer_condition$handle() {
        return g_io_channel_get_buffer_condition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_get_buffer_condition$address() {
        return g_io_channel_get_buffer_condition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel)
     * }
     */
    public static int g_io_channel_get_buffer_condition(MemorySegment channel) {
        var mh$ = g_io_channel_get_buffer_condition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_get_buffer_condition", channel);
            }
            return (int)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_set_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_set_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_set_flags(GIOChannel *channel, GIOFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_set_flags$descriptor() {
        return g_io_channel_set_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_set_flags(GIOChannel *channel, GIOFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_set_flags$handle() {
        return g_io_channel_set_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_set_flags(GIOChannel *channel, GIOFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_set_flags$address() {
        return g_io_channel_set_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_set_flags(GIOChannel *channel, GIOFlags flags, GError **error)
     * }
     */
    public static int g_io_channel_set_flags(MemorySegment channel, int flags, MemorySegment error) {
        var mh$ = g_io_channel_set_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_set_flags", channel, flags, error);
            }
            return (int)mh$.invokeExact(channel, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOFlags g_io_channel_get_flags(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_get_flags$descriptor() {
        return g_io_channel_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOFlags g_io_channel_get_flags(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_get_flags$handle() {
        return g_io_channel_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOFlags g_io_channel_get_flags(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_get_flags$address() {
        return g_io_channel_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOFlags g_io_channel_get_flags(GIOChannel *channel)
     * }
     */
    public static int g_io_channel_get_flags(MemorySegment channel) {
        var mh$ = g_io_channel_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_get_flags", channel);
            }
            return (int)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_set_line_term {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_set_line_term");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_line_term(GIOChannel *channel, const gchar *line_term, gint length)
     * }
     */
    public static FunctionDescriptor g_io_channel_set_line_term$descriptor() {
        return g_io_channel_set_line_term.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_line_term(GIOChannel *channel, const gchar *line_term, gint length)
     * }
     */
    public static MethodHandle g_io_channel_set_line_term$handle() {
        return g_io_channel_set_line_term.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_line_term(GIOChannel *channel, const gchar *line_term, gint length)
     * }
     */
    public static MemorySegment g_io_channel_set_line_term$address() {
        return g_io_channel_set_line_term.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_set_line_term(GIOChannel *channel, const gchar *line_term, gint length)
     * }
     */
    public static void g_io_channel_set_line_term(MemorySegment channel, MemorySegment line_term, int length) {
        var mh$ = g_io_channel_set_line_term.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_set_line_term", channel, line_term, length);
            }
            mh$.invokeExact(channel, line_term, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_get_line_term {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_get_line_term");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_io_channel_get_line_term(GIOChannel *channel, gint *length)
     * }
     */
    public static FunctionDescriptor g_io_channel_get_line_term$descriptor() {
        return g_io_channel_get_line_term.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_io_channel_get_line_term(GIOChannel *channel, gint *length)
     * }
     */
    public static MethodHandle g_io_channel_get_line_term$handle() {
        return g_io_channel_get_line_term.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_io_channel_get_line_term(GIOChannel *channel, gint *length)
     * }
     */
    public static MemorySegment g_io_channel_get_line_term$address() {
        return g_io_channel_get_line_term.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_io_channel_get_line_term(GIOChannel *channel, gint *length)
     * }
     */
    public static MemorySegment g_io_channel_get_line_term(MemorySegment channel, MemorySegment length) {
        var mh$ = g_io_channel_get_line_term.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_get_line_term", channel, length);
            }
            return (MemorySegment)mh$.invokeExact(channel, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_set_buffered {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_set_buffered");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_buffered(GIOChannel *channel, gboolean buffered)
     * }
     */
    public static FunctionDescriptor g_io_channel_set_buffered$descriptor() {
        return g_io_channel_set_buffered.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_buffered(GIOChannel *channel, gboolean buffered)
     * }
     */
    public static MethodHandle g_io_channel_set_buffered$handle() {
        return g_io_channel_set_buffered.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_buffered(GIOChannel *channel, gboolean buffered)
     * }
     */
    public static MemorySegment g_io_channel_set_buffered$address() {
        return g_io_channel_set_buffered.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_set_buffered(GIOChannel *channel, gboolean buffered)
     * }
     */
    public static void g_io_channel_set_buffered(MemorySegment channel, int buffered) {
        var mh$ = g_io_channel_set_buffered.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_set_buffered", channel, buffered);
            }
            mh$.invokeExact(channel, buffered);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_get_buffered {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_get_buffered");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_io_channel_get_buffered(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_get_buffered$descriptor() {
        return g_io_channel_get_buffered.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_io_channel_get_buffered(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_get_buffered$handle() {
        return g_io_channel_get_buffered.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_io_channel_get_buffered(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_get_buffered$address() {
        return g_io_channel_get_buffered.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_io_channel_get_buffered(GIOChannel *channel)
     * }
     */
    public static int g_io_channel_get_buffered(MemorySegment channel) {
        var mh$ = g_io_channel_get_buffered.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_get_buffered", channel);
            }
            return (int)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_set_encoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_set_encoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel, const gchar *encoding, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_set_encoding$descriptor() {
        return g_io_channel_set_encoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel, const gchar *encoding, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_set_encoding$handle() {
        return g_io_channel_set_encoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel, const gchar *encoding, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_set_encoding$address() {
        return g_io_channel_set_encoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel, const gchar *encoding, GError **error)
     * }
     */
    public static int g_io_channel_set_encoding(MemorySegment channel, MemorySegment encoding, MemorySegment error) {
        var mh$ = g_io_channel_set_encoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_set_encoding", channel, encoding, error);
            }
            return (int)mh$.invokeExact(channel, encoding, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_get_encoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_get_encoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_io_channel_get_encoding(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_get_encoding$descriptor() {
        return g_io_channel_get_encoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_io_channel_get_encoding(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_get_encoding$handle() {
        return g_io_channel_get_encoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_io_channel_get_encoding(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_get_encoding$address() {
        return g_io_channel_get_encoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_io_channel_get_encoding(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_get_encoding(MemorySegment channel) {
        var mh$ = g_io_channel_get_encoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_get_encoding", channel);
            }
            return (MemorySegment)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_set_close_on_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_set_close_on_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_close_on_unref(GIOChannel *channel, gboolean do_close)
     * }
     */
    public static FunctionDescriptor g_io_channel_set_close_on_unref$descriptor() {
        return g_io_channel_set_close_on_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_close_on_unref(GIOChannel *channel, gboolean do_close)
     * }
     */
    public static MethodHandle g_io_channel_set_close_on_unref$handle() {
        return g_io_channel_set_close_on_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_set_close_on_unref(GIOChannel *channel, gboolean do_close)
     * }
     */
    public static MemorySegment g_io_channel_set_close_on_unref$address() {
        return g_io_channel_set_close_on_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_set_close_on_unref(GIOChannel *channel, gboolean do_close)
     * }
     */
    public static void g_io_channel_set_close_on_unref(MemorySegment channel, int do_close) {
        var mh$ = g_io_channel_set_close_on_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_set_close_on_unref", channel, do_close);
            }
            mh$.invokeExact(channel, do_close);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_get_close_on_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_get_close_on_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_get_close_on_unref$descriptor() {
        return g_io_channel_get_close_on_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_get_close_on_unref$handle() {
        return g_io_channel_get_close_on_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_get_close_on_unref$address() {
        return g_io_channel_get_close_on_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel)
     * }
     */
    public static int g_io_channel_get_close_on_unref(MemorySegment channel) {
        var mh$ = g_io_channel_get_close_on_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_get_close_on_unref", channel);
            }
            return (int)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_flush(GIOChannel *channel, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_flush$descriptor() {
        return g_io_channel_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_flush(GIOChannel *channel, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_flush$handle() {
        return g_io_channel_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_flush(GIOChannel *channel, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_flush$address() {
        return g_io_channel_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_flush(GIOChannel *channel, GError **error)
     * }
     */
    public static int g_io_channel_flush(MemorySegment channel, MemorySegment error) {
        var mh$ = g_io_channel_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_flush", channel, error);
            }
            return (int)mh$.invokeExact(channel, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_read_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_read_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_line(GIOChannel *channel, gchar **str_return, gsize *length, gsize *terminator_pos, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_read_line$descriptor() {
        return g_io_channel_read_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_line(GIOChannel *channel, gchar **str_return, gsize *length, gsize *terminator_pos, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_read_line$handle() {
        return g_io_channel_read_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_line(GIOChannel *channel, gchar **str_return, gsize *length, gsize *terminator_pos, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_read_line$address() {
        return g_io_channel_read_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_line(GIOChannel *channel, gchar **str_return, gsize *length, gsize *terminator_pos, GError **error)
     * }
     */
    public static int g_io_channel_read_line(MemorySegment channel, MemorySegment str_return, MemorySegment length, MemorySegment terminator_pos, MemorySegment error) {
        var mh$ = g_io_channel_read_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_read_line", channel, str_return, length, terminator_pos, error);
            }
            return (int)mh$.invokeExact(channel, str_return, length, terminator_pos, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_read_line_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_read_line_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel, GString *buffer, gsize *terminator_pos, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_read_line_string$descriptor() {
        return g_io_channel_read_line_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel, GString *buffer, gsize *terminator_pos, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_read_line_string$handle() {
        return g_io_channel_read_line_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel, GString *buffer, gsize *terminator_pos, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_read_line_string$address() {
        return g_io_channel_read_line_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel, GString *buffer, gsize *terminator_pos, GError **error)
     * }
     */
    public static int g_io_channel_read_line_string(MemorySegment channel, MemorySegment buffer, MemorySegment terminator_pos, MemorySegment error) {
        var mh$ = g_io_channel_read_line_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_read_line_string", channel, buffer, terminator_pos, error);
            }
            return (int)mh$.invokeExact(channel, buffer, terminator_pos, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_read_to_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_read_to_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel, gchar **str_return, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_read_to_end$descriptor() {
        return g_io_channel_read_to_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel, gchar **str_return, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_read_to_end$handle() {
        return g_io_channel_read_to_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel, gchar **str_return, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_read_to_end$address() {
        return g_io_channel_read_to_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel, gchar **str_return, gsize *length, GError **error)
     * }
     */
    public static int g_io_channel_read_to_end(MemorySegment channel, MemorySegment str_return, MemorySegment length, MemorySegment error) {
        var mh$ = g_io_channel_read_to_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_read_to_end", channel, str_return, length, error);
            }
            return (int)mh$.invokeExact(channel, str_return, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_read_chars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_read_chars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_chars(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_read_chars$descriptor() {
        return g_io_channel_read_chars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_chars(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_read_chars$handle() {
        return g_io_channel_read_chars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_chars(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_read_chars$address() {
        return g_io_channel_read_chars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_chars(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read, GError **error)
     * }
     */
    public static int g_io_channel_read_chars(MemorySegment channel, MemorySegment buf, long count, MemorySegment bytes_read, MemorySegment error) {
        var mh$ = g_io_channel_read_chars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_read_chars", channel, buf, count, bytes_read, error);
            }
            return (int)mh$.invokeExact(channel, buf, count, bytes_read, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_read_unichar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_read_unichar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel, gunichar *thechar, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_read_unichar$descriptor() {
        return g_io_channel_read_unichar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel, gunichar *thechar, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_read_unichar$handle() {
        return g_io_channel_read_unichar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel, gunichar *thechar, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_read_unichar$address() {
        return g_io_channel_read_unichar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel, gunichar *thechar, GError **error)
     * }
     */
    public static int g_io_channel_read_unichar(MemorySegment channel, MemorySegment thechar, MemorySegment error) {
        var mh$ = g_io_channel_read_unichar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_read_unichar", channel, thechar, error);
            }
            return (int)mh$.invokeExact(channel, thechar, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_write_chars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_write_chars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_write_chars(GIOChannel *channel, const gchar *buf, gssize count, gsize *bytes_written, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_write_chars$descriptor() {
        return g_io_channel_write_chars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_write_chars(GIOChannel *channel, const gchar *buf, gssize count, gsize *bytes_written, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_write_chars$handle() {
        return g_io_channel_write_chars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_write_chars(GIOChannel *channel, const gchar *buf, gssize count, gsize *bytes_written, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_write_chars$address() {
        return g_io_channel_write_chars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_write_chars(GIOChannel *channel, const gchar *buf, gssize count, gsize *bytes_written, GError **error)
     * }
     */
    public static int g_io_channel_write_chars(MemorySegment channel, MemorySegment buf, long count, MemorySegment bytes_written, MemorySegment error) {
        var mh$ = g_io_channel_write_chars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_write_chars", channel, buf, count, bytes_written, error);
            }
            return (int)mh$.invokeExact(channel, buf, count, bytes_written, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_write_unichar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_write_unichar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel, gunichar thechar, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_write_unichar$descriptor() {
        return g_io_channel_write_unichar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel, gunichar thechar, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_write_unichar$handle() {
        return g_io_channel_write_unichar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel, gunichar thechar, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_write_unichar$address() {
        return g_io_channel_write_unichar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel, gunichar thechar, GError **error)
     * }
     */
    public static int g_io_channel_write_unichar(MemorySegment channel, int thechar, MemorySegment error) {
        var mh$ = g_io_channel_write_unichar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_write_unichar", channel, thechar, error);
            }
            return (int)mh$.invokeExact(channel, thechar, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_seek_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_seek_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_seek_position(GIOChannel *channel, gint64 offset, GSeekType type, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_seek_position$descriptor() {
        return g_io_channel_seek_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_seek_position(GIOChannel *channel, gint64 offset, GSeekType type, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_seek_position$handle() {
        return g_io_channel_seek_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_seek_position(GIOChannel *channel, gint64 offset, GSeekType type, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_seek_position$address() {
        return g_io_channel_seek_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOStatus g_io_channel_seek_position(GIOChannel *channel, gint64 offset, GSeekType type, GError **error)
     * }
     */
    public static int g_io_channel_seek_position(MemorySegment channel, long offset, int type, MemorySegment error) {
        var mh$ = g_io_channel_seek_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_seek_position", channel, offset, type, error);
            }
            return (int)mh$.invokeExact(channel, offset, type, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_new_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_new_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_new_file(const gchar *filename, const gchar *mode, GError **error)
     * }
     */
    public static FunctionDescriptor g_io_channel_new_file$descriptor() {
        return g_io_channel_new_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_new_file(const gchar *filename, const gchar *mode, GError **error)
     * }
     */
    public static MethodHandle g_io_channel_new_file$handle() {
        return g_io_channel_new_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_new_file(const gchar *filename, const gchar *mode, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_new_file$address() {
        return g_io_channel_new_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_new_file(const gchar *filename, const gchar *mode, GError **error)
     * }
     */
    public static MemorySegment g_io_channel_new_file(MemorySegment filename, MemorySegment mode, MemorySegment error) {
        var mh$ = g_io_channel_new_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_new_file", filename, mode, error);
            }
            return (MemorySegment)mh$.invokeExact(filename, mode, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_io_channel_error_quark()
     * }
     */
    public static FunctionDescriptor g_io_channel_error_quark$descriptor() {
        return g_io_channel_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_io_channel_error_quark()
     * }
     */
    public static MethodHandle g_io_channel_error_quark$handle() {
        return g_io_channel_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_io_channel_error_quark()
     * }
     */
    public static MemorySegment g_io_channel_error_quark$address() {
        return g_io_channel_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_io_channel_error_quark()
     * }
     */
    public static int g_io_channel_error_quark() {
        var mh$ = g_io_channel_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_error_from_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_error_from_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOChannelError g_io_channel_error_from_errno(gint en)
     * }
     */
    public static FunctionDescriptor g_io_channel_error_from_errno$descriptor() {
        return g_io_channel_error_from_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOChannelError g_io_channel_error_from_errno(gint en)
     * }
     */
    public static MethodHandle g_io_channel_error_from_errno$handle() {
        return g_io_channel_error_from_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOChannelError g_io_channel_error_from_errno(gint en)
     * }
     */
    public static MemorySegment g_io_channel_error_from_errno$address() {
        return g_io_channel_error_from_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOChannelError g_io_channel_error_from_errno(gint en)
     * }
     */
    public static int g_io_channel_error_from_errno(int en) {
        var mh$ = g_io_channel_error_from_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_error_from_errno", en);
            }
            return (int)mh$.invokeExact(en);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_unix_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_unix_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_unix_new(int fd)
     * }
     */
    public static FunctionDescriptor g_io_channel_unix_new$descriptor() {
        return g_io_channel_unix_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_unix_new(int fd)
     * }
     */
    public static MethodHandle g_io_channel_unix_new$handle() {
        return g_io_channel_unix_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_unix_new(int fd)
     * }
     */
    public static MemorySegment g_io_channel_unix_new$address() {
        return g_io_channel_unix_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_unix_new(int fd)
     * }
     */
    public static MemorySegment g_io_channel_unix_new(int fd) {
        var mh$ = g_io_channel_unix_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_unix_new", fd);
            }
            return (MemorySegment)mh$.invokeExact(fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_unix_get_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_unix_get_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_io_channel_unix_get_fd(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_unix_get_fd$descriptor() {
        return g_io_channel_unix_get_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_io_channel_unix_get_fd(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_unix_get_fd$handle() {
        return g_io_channel_unix_get_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_io_channel_unix_get_fd(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_unix_get_fd$address() {
        return g_io_channel_unix_get_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_io_channel_unix_get_fd(GIOChannel *channel)
     * }
     */
    public static int g_io_channel_unix_get_fd(MemorySegment channel) {
        var mh$ = g_io_channel_unix_get_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_unix_get_fd", channel);
            }
            return (int)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_watch_funcs$constants {
        public static final GroupLayout LAYOUT = _GSourceFuncs.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("g_io_watch_funcs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_io_watch_funcs
     * }
     */
    public static GroupLayout g_io_watch_funcs$layout() {
        return g_io_watch_funcs$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_io_watch_funcs
     * }
     */
    public static MemorySegment g_io_watch_funcs() {
        return g_io_watch_funcs$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern GSourceFuncs g_io_watch_funcs
     * }
     */
    public static void g_io_watch_funcs(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, g_io_watch_funcs$constants.SEGMENT, 0L, g_io_watch_funcs$constants.LAYOUT.byteSize());
    }

    private static class g_io_channel_win32_make_pollfd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_win32_make_pollfd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_win32_make_pollfd(GIOChannel *channel, GIOCondition condition, GPollFD *fd)
     * }
     */
    public static FunctionDescriptor g_io_channel_win32_make_pollfd$descriptor() {
        return g_io_channel_win32_make_pollfd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_win32_make_pollfd(GIOChannel *channel, GIOCondition condition, GPollFD *fd)
     * }
     */
    public static MethodHandle g_io_channel_win32_make_pollfd$handle() {
        return g_io_channel_win32_make_pollfd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_win32_make_pollfd(GIOChannel *channel, GIOCondition condition, GPollFD *fd)
     * }
     */
    public static MemorySegment g_io_channel_win32_make_pollfd$address() {
        return g_io_channel_win32_make_pollfd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_win32_make_pollfd(GIOChannel *channel, GIOCondition condition, GPollFD *fd)
     * }
     */
    public static void g_io_channel_win32_make_pollfd(MemorySegment channel, int condition, MemorySegment fd) {
        var mh$ = g_io_channel_win32_make_pollfd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_win32_make_pollfd", channel, condition, fd);
            }
            mh$.invokeExact(channel, condition, fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_win32_poll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_win32_poll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_io_channel_win32_poll(GPollFD *fds, gint n_fds, gint timeout_)
     * }
     */
    public static FunctionDescriptor g_io_channel_win32_poll$descriptor() {
        return g_io_channel_win32_poll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_io_channel_win32_poll(GPollFD *fds, gint n_fds, gint timeout_)
     * }
     */
    public static MethodHandle g_io_channel_win32_poll$handle() {
        return g_io_channel_win32_poll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_io_channel_win32_poll(GPollFD *fds, gint n_fds, gint timeout_)
     * }
     */
    public static MemorySegment g_io_channel_win32_poll$address() {
        return g_io_channel_win32_poll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_io_channel_win32_poll(GPollFD *fds, gint n_fds, gint timeout_)
     * }
     */
    public static int g_io_channel_win32_poll(MemorySegment fds, int n_fds, int timeout_) {
        var mh$ = g_io_channel_win32_poll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_win32_poll", fds, n_fds, timeout_);
            }
            return (int)mh$.invokeExact(fds, n_fds, timeout_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_win32_new_messages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_win32_new_messages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_messages(gsize hwnd)
     * }
     */
    public static FunctionDescriptor g_io_channel_win32_new_messages$descriptor() {
        return g_io_channel_win32_new_messages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_messages(gsize hwnd)
     * }
     */
    public static MethodHandle g_io_channel_win32_new_messages$handle() {
        return g_io_channel_win32_new_messages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_messages(gsize hwnd)
     * }
     */
    public static MemorySegment g_io_channel_win32_new_messages$address() {
        return g_io_channel_win32_new_messages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_messages(gsize hwnd)
     * }
     */
    public static MemorySegment g_io_channel_win32_new_messages(long hwnd) {
        var mh$ = g_io_channel_win32_new_messages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_win32_new_messages", hwnd);
            }
            return (MemorySegment)mh$.invokeExact(hwnd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_win32_new_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_win32_new_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_fd(gint fd)
     * }
     */
    public static FunctionDescriptor g_io_channel_win32_new_fd$descriptor() {
        return g_io_channel_win32_new_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_fd(gint fd)
     * }
     */
    public static MethodHandle g_io_channel_win32_new_fd$handle() {
        return g_io_channel_win32_new_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_fd(gint fd)
     * }
     */
    public static MemorySegment g_io_channel_win32_new_fd$address() {
        return g_io_channel_win32_new_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_fd(gint fd)
     * }
     */
    public static MemorySegment g_io_channel_win32_new_fd(int fd) {
        var mh$ = g_io_channel_win32_new_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_win32_new_fd", fd);
            }
            return (MemorySegment)mh$.invokeExact(fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_win32_get_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_win32_get_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_io_channel_win32_get_fd(GIOChannel *channel)
     * }
     */
    public static FunctionDescriptor g_io_channel_win32_get_fd$descriptor() {
        return g_io_channel_win32_get_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_io_channel_win32_get_fd(GIOChannel *channel)
     * }
     */
    public static MethodHandle g_io_channel_win32_get_fd$handle() {
        return g_io_channel_win32_get_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_io_channel_win32_get_fd(GIOChannel *channel)
     * }
     */
    public static MemorySegment g_io_channel_win32_get_fd$address() {
        return g_io_channel_win32_get_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_io_channel_win32_get_fd(GIOChannel *channel)
     * }
     */
    public static int g_io_channel_win32_get_fd(MemorySegment channel) {
        var mh$ = g_io_channel_win32_get_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_win32_get_fd", channel);
            }
            return (int)mh$.invokeExact(channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_win32_new_socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_win32_new_socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_socket(gint socket)
     * }
     */
    public static FunctionDescriptor g_io_channel_win32_new_socket$descriptor() {
        return g_io_channel_win32_new_socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_socket(gint socket)
     * }
     */
    public static MethodHandle g_io_channel_win32_new_socket$handle() {
        return g_io_channel_win32_new_socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_socket(gint socket)
     * }
     */
    public static MemorySegment g_io_channel_win32_new_socket$address() {
        return g_io_channel_win32_new_socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_socket(gint socket)
     * }
     */
    public static MemorySegment g_io_channel_win32_new_socket(int socket) {
        var mh$ = g_io_channel_win32_new_socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_win32_new_socket", socket);
            }
            return (MemorySegment)mh$.invokeExact(socket);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_win32_new_stream_socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_win32_new_stream_socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_stream_socket(gint socket)
     * }
     */
    public static FunctionDescriptor g_io_channel_win32_new_stream_socket$descriptor() {
        return g_io_channel_win32_new_stream_socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_stream_socket(gint socket)
     * }
     */
    public static MethodHandle g_io_channel_win32_new_stream_socket$handle() {
        return g_io_channel_win32_new_stream_socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_stream_socket(gint socket)
     * }
     */
    public static MemorySegment g_io_channel_win32_new_stream_socket$address() {
        return g_io_channel_win32_new_stream_socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GIOChannel *g_io_channel_win32_new_stream_socket(gint socket)
     * }
     */
    public static MemorySegment g_io_channel_win32_new_stream_socket(int socket) {
        var mh$ = g_io_channel_win32_new_stream_socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_win32_new_stream_socket", socket);
            }
            return (MemorySegment)mh$.invokeExact(socket);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_io_channel_win32_set_debug {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_io_channel_win32_set_debug");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_io_channel_win32_set_debug(GIOChannel *channel, gboolean flag)
     * }
     */
    public static FunctionDescriptor g_io_channel_win32_set_debug$descriptor() {
        return g_io_channel_win32_set_debug.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_io_channel_win32_set_debug(GIOChannel *channel, gboolean flag)
     * }
     */
    public static MethodHandle g_io_channel_win32_set_debug$handle() {
        return g_io_channel_win32_set_debug.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_io_channel_win32_set_debug(GIOChannel *channel, gboolean flag)
     * }
     */
    public static MemorySegment g_io_channel_win32_set_debug$address() {
        return g_io_channel_win32_set_debug.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_io_channel_win32_set_debug(GIOChannel *channel, gboolean flag)
     * }
     */
    public static void g_io_channel_win32_set_debug(MemorySegment channel, int flag) {
        var mh$ = g_io_channel_win32_set_debug.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_io_channel_win32_set_debug", channel, flag);
            }
            mh$.invokeExact(channel, flag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_KEY_FILE_ERROR_UNKNOWN_ENCODING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0
     * }
     */
    public static int G_KEY_FILE_ERROR_UNKNOWN_ENCODING() {
        return G_KEY_FILE_ERROR_UNKNOWN_ENCODING;
    }
    private static final int G_KEY_FILE_ERROR_PARSE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_ERROR_PARSE = 1
     * }
     */
    public static int G_KEY_FILE_ERROR_PARSE() {
        return G_KEY_FILE_ERROR_PARSE;
    }
    private static final int G_KEY_FILE_ERROR_NOT_FOUND = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_ERROR_NOT_FOUND = 2
     * }
     */
    public static int G_KEY_FILE_ERROR_NOT_FOUND() {
        return G_KEY_FILE_ERROR_NOT_FOUND;
    }
    private static final int G_KEY_FILE_ERROR_KEY_NOT_FOUND = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3
     * }
     */
    public static int G_KEY_FILE_ERROR_KEY_NOT_FOUND() {
        return G_KEY_FILE_ERROR_KEY_NOT_FOUND;
    }
    private static final int G_KEY_FILE_ERROR_GROUP_NOT_FOUND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4
     * }
     */
    public static int G_KEY_FILE_ERROR_GROUP_NOT_FOUND() {
        return G_KEY_FILE_ERROR_GROUP_NOT_FOUND;
    }
    private static final int G_KEY_FILE_ERROR_INVALID_VALUE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_ERROR_INVALID_VALUE = 5
     * }
     */
    public static int G_KEY_FILE_ERROR_INVALID_VALUE() {
        return G_KEY_FILE_ERROR_INVALID_VALUE;
    }

    private static class g_key_file_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_key_file_error_quark()
     * }
     */
    public static FunctionDescriptor g_key_file_error_quark$descriptor() {
        return g_key_file_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_key_file_error_quark()
     * }
     */
    public static MethodHandle g_key_file_error_quark$handle() {
        return g_key_file_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_key_file_error_quark()
     * }
     */
    public static MemorySegment g_key_file_error_quark$address() {
        return g_key_file_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_key_file_error_quark()
     * }
     */
    public static int g_key_file_error_quark() {
        var mh$ = g_key_file_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_KEY_FILE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_NONE = 0
     * }
     */
    public static int G_KEY_FILE_NONE() {
        return G_KEY_FILE_NONE;
    }
    private static final int G_KEY_FILE_KEEP_COMMENTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_KEEP_COMMENTS = 1
     * }
     */
    public static int G_KEY_FILE_KEEP_COMMENTS() {
        return G_KEY_FILE_KEEP_COMMENTS;
    }
    private static final int G_KEY_FILE_KEEP_TRANSLATIONS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_KEY_FILE_KEEP_TRANSLATIONS = 2
     * }
     */
    public static int G_KEY_FILE_KEEP_TRANSLATIONS() {
        return G_KEY_FILE_KEEP_TRANSLATIONS;
    }

    private static class g_key_file_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GKeyFile *g_key_file_new()
     * }
     */
    public static FunctionDescriptor g_key_file_new$descriptor() {
        return g_key_file_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GKeyFile *g_key_file_new()
     * }
     */
    public static MethodHandle g_key_file_new$handle() {
        return g_key_file_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GKeyFile *g_key_file_new()
     * }
     */
    public static MemorySegment g_key_file_new$address() {
        return g_key_file_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GKeyFile *g_key_file_new()
     * }
     */
    public static MemorySegment g_key_file_new() {
        var mh$ = g_key_file_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GKeyFile *g_key_file_ref(GKeyFile *key_file)
     * }
     */
    public static FunctionDescriptor g_key_file_ref$descriptor() {
        return g_key_file_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GKeyFile *g_key_file_ref(GKeyFile *key_file)
     * }
     */
    public static MethodHandle g_key_file_ref$handle() {
        return g_key_file_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GKeyFile *g_key_file_ref(GKeyFile *key_file)
     * }
     */
    public static MemorySegment g_key_file_ref$address() {
        return g_key_file_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GKeyFile *g_key_file_ref(GKeyFile *key_file)
     * }
     */
    public static MemorySegment g_key_file_ref(MemorySegment key_file) {
        var mh$ = g_key_file_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_ref", key_file);
            }
            return (MemorySegment)mh$.invokeExact(key_file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_unref(GKeyFile *key_file)
     * }
     */
    public static FunctionDescriptor g_key_file_unref$descriptor() {
        return g_key_file_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_unref(GKeyFile *key_file)
     * }
     */
    public static MethodHandle g_key_file_unref$handle() {
        return g_key_file_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_unref(GKeyFile *key_file)
     * }
     */
    public static MemorySegment g_key_file_unref$address() {
        return g_key_file_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_unref(GKeyFile *key_file)
     * }
     */
    public static void g_key_file_unref(MemorySegment key_file) {
        var mh$ = g_key_file_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_unref", key_file);
            }
            mh$.invokeExact(key_file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_free(GKeyFile *key_file)
     * }
     */
    public static FunctionDescriptor g_key_file_free$descriptor() {
        return g_key_file_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_free(GKeyFile *key_file)
     * }
     */
    public static MethodHandle g_key_file_free$handle() {
        return g_key_file_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_free(GKeyFile *key_file)
     * }
     */
    public static MemorySegment g_key_file_free$address() {
        return g_key_file_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_free(GKeyFile *key_file)
     * }
     */
    public static void g_key_file_free(MemorySegment key_file) {
        var mh$ = g_key_file_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_free", key_file);
            }
            mh$.invokeExact(key_file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_list_separator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_list_separator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_list_separator(GKeyFile *key_file, gchar separator)
     * }
     */
    public static FunctionDescriptor g_key_file_set_list_separator$descriptor() {
        return g_key_file_set_list_separator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_list_separator(GKeyFile *key_file, gchar separator)
     * }
     */
    public static MethodHandle g_key_file_set_list_separator$handle() {
        return g_key_file_set_list_separator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_list_separator(GKeyFile *key_file, gchar separator)
     * }
     */
    public static MemorySegment g_key_file_set_list_separator$address() {
        return g_key_file_set_list_separator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_list_separator(GKeyFile *key_file, gchar separator)
     * }
     */
    public static void g_key_file_set_list_separator(MemorySegment key_file, byte separator) {
        var mh$ = g_key_file_set_list_separator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_list_separator", key_file, separator);
            }
            mh$.invokeExact(key_file, separator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_load_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_load_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_load_from_file$descriptor() {
        return g_key_file_load_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_key_file_load_from_file$handle() {
        return g_key_file_load_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_key_file_load_from_file$address() {
        return g_key_file_load_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error)
     * }
     */
    public static int g_key_file_load_from_file(MemorySegment key_file, MemorySegment file, int flags, MemorySegment error) {
        var mh$ = g_key_file_load_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_load_from_file", key_file, file, flags, error);
            }
            return (int)mh$.invokeExact(key_file, file, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_load_from_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_load_from_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_data(GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_load_from_data$descriptor() {
        return g_key_file_load_from_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_data(GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_key_file_load_from_data$handle() {
        return g_key_file_load_from_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_data(GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_key_file_load_from_data$address() {
        return g_key_file_load_from_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_data(GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error)
     * }
     */
    public static int g_key_file_load_from_data(MemorySegment key_file, MemorySegment data, long length, int flags, MemorySegment error) {
        var mh$ = g_key_file_load_from_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_load_from_data", key_file, data, length, flags, error);
            }
            return (int)mh$.invokeExact(key_file, data, length, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_load_from_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_load_from_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file, GBytes *bytes, GKeyFileFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_load_from_bytes$descriptor() {
        return g_key_file_load_from_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file, GBytes *bytes, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_key_file_load_from_bytes$handle() {
        return g_key_file_load_from_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file, GBytes *bytes, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_key_file_load_from_bytes$address() {
        return g_key_file_load_from_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file, GBytes *bytes, GKeyFileFlags flags, GError **error)
     * }
     */
    public static int g_key_file_load_from_bytes(MemorySegment key_file, MemorySegment bytes, int flags, MemorySegment error) {
        var mh$ = g_key_file_load_from_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_load_from_bytes", key_file, bytes, flags, error);
            }
            return (int)mh$.invokeExact(key_file, bytes, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_load_from_dirs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_load_from_dirs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_load_from_dirs$descriptor() {
        return g_key_file_load_from_dirs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_key_file_load_from_dirs$handle() {
        return g_key_file_load_from_dirs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_key_file_load_from_dirs$address() {
        return g_key_file_load_from_dirs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error)
     * }
     */
    public static int g_key_file_load_from_dirs(MemorySegment key_file, MemorySegment file, MemorySegment search_dirs, MemorySegment full_path, int flags, MemorySegment error) {
        var mh$ = g_key_file_load_from_dirs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_load_from_dirs", key_file, file, search_dirs, full_path, flags, error);
            }
            return (int)mh$.invokeExact(key_file, file, search_dirs, full_path, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_load_from_data_dirs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_load_from_data_dirs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_load_from_data_dirs$descriptor() {
        return g_key_file_load_from_data_dirs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MethodHandle g_key_file_load_from_data_dirs$handle() {
        return g_key_file_load_from_data_dirs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error)
     * }
     */
    public static MemorySegment g_key_file_load_from_data_dirs$address() {
        return g_key_file_load_from_data_dirs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error)
     * }
     */
    public static int g_key_file_load_from_data_dirs(MemorySegment key_file, MemorySegment file, MemorySegment full_path, int flags, MemorySegment error) {
        var mh$ = g_key_file_load_from_data_dirs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_load_from_data_dirs", key_file, file, full_path, flags, error);
            }
            return (int)mh$.invokeExact(key_file, file, full_path, flags, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_to_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_to_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_to_data(GKeyFile *key_file, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_to_data$descriptor() {
        return g_key_file_to_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_to_data(GKeyFile *key_file, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_key_file_to_data$handle() {
        return g_key_file_to_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_to_data(GKeyFile *key_file, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_to_data$address() {
        return g_key_file_to_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_key_file_to_data(GKeyFile *key_file, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_to_data(MemorySegment key_file, MemorySegment length, MemorySegment error) {
        var mh$ = g_key_file_to_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_to_data", key_file, length, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_save_to_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_save_to_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_save_to_file(GKeyFile *key_file, const gchar *filename, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_save_to_file$descriptor() {
        return g_key_file_save_to_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_save_to_file(GKeyFile *key_file, const gchar *filename, GError **error)
     * }
     */
    public static MethodHandle g_key_file_save_to_file$handle() {
        return g_key_file_save_to_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_save_to_file(GKeyFile *key_file, const gchar *filename, GError **error)
     * }
     */
    public static MemorySegment g_key_file_save_to_file$address() {
        return g_key_file_save_to_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_save_to_file(GKeyFile *key_file, const gchar *filename, GError **error)
     * }
     */
    public static int g_key_file_save_to_file(MemorySegment key_file, MemorySegment filename, MemorySegment error) {
        var mh$ = g_key_file_save_to_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_save_to_file", key_file, filename, error);
            }
            return (int)mh$.invokeExact(key_file, filename, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_start_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_start_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_start_group(GKeyFile *key_file)
     * }
     */
    public static FunctionDescriptor g_key_file_get_start_group$descriptor() {
        return g_key_file_get_start_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_start_group(GKeyFile *key_file)
     * }
     */
    public static MethodHandle g_key_file_get_start_group$handle() {
        return g_key_file_get_start_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_start_group(GKeyFile *key_file)
     * }
     */
    public static MemorySegment g_key_file_get_start_group$address() {
        return g_key_file_get_start_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_start_group(GKeyFile *key_file)
     * }
     */
    public static MemorySegment g_key_file_get_start_group(MemorySegment key_file) {
        var mh$ = g_key_file_get_start_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_start_group", key_file);
            }
            return (MemorySegment)mh$.invokeExact(key_file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_groups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_groups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_groups(GKeyFile *key_file, gsize *length)
     * }
     */
    public static FunctionDescriptor g_key_file_get_groups$descriptor() {
        return g_key_file_get_groups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_groups(GKeyFile *key_file, gsize *length)
     * }
     */
    public static MethodHandle g_key_file_get_groups$handle() {
        return g_key_file_get_groups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_groups(GKeyFile *key_file, gsize *length)
     * }
     */
    public static MemorySegment g_key_file_get_groups$address() {
        return g_key_file_get_groups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_groups(GKeyFile *key_file, gsize *length)
     * }
     */
    public static MemorySegment g_key_file_get_groups(MemorySegment key_file, MemorySegment length) {
        var mh$ = g_key_file_get_groups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_groups", key_file, length);
            }
            return (MemorySegment)mh$.invokeExact(key_file, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_keys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_keys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_keys(GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_keys$descriptor() {
        return g_key_file_get_keys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_keys(GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_keys$handle() {
        return g_key_file_get_keys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_keys(GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_keys$address() {
        return g_key_file_get_keys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_keys(GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_keys(MemorySegment key_file, MemorySegment group_name, MemorySegment length, MemorySegment error) {
        var mh$ = g_key_file_get_keys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_keys", key_file, group_name, length, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_has_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_has_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_has_group(GKeyFile *key_file, const gchar *group_name)
     * }
     */
    public static FunctionDescriptor g_key_file_has_group$descriptor() {
        return g_key_file_has_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_has_group(GKeyFile *key_file, const gchar *group_name)
     * }
     */
    public static MethodHandle g_key_file_has_group$handle() {
        return g_key_file_has_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_has_group(GKeyFile *key_file, const gchar *group_name)
     * }
     */
    public static MemorySegment g_key_file_has_group$address() {
        return g_key_file_has_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_has_group(GKeyFile *key_file, const gchar *group_name)
     * }
     */
    public static int g_key_file_has_group(MemorySegment key_file, MemorySegment group_name) {
        var mh$ = g_key_file_has_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_has_group", key_file, group_name);
            }
            return (int)mh$.invokeExact(key_file, group_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_has_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_has_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_has_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_has_key$descriptor() {
        return g_key_file_has_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_has_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_has_key$handle() {
        return g_key_file_has_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_has_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_has_key$address() {
        return g_key_file_has_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_has_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static int g_key_file_has_key(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_has_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_has_key", key_file, group_name, key, error);
            }
            return (int)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_value(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_value$descriptor() {
        return g_key_file_get_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_value(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_value$handle() {
        return g_key_file_get_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_value(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_value$address() {
        return g_key_file_get_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_value(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_value(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_get_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_value", key_file, group_name, key, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_value(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value)
     * }
     */
    public static FunctionDescriptor g_key_file_set_value$descriptor() {
        return g_key_file_set_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_value(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value)
     * }
     */
    public static MethodHandle g_key_file_set_value$handle() {
        return g_key_file_set_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_value(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value)
     * }
     */
    public static MemorySegment g_key_file_set_value$address() {
        return g_key_file_set_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_value(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value)
     * }
     */
    public static void g_key_file_set_value(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment value) {
        var mh$ = g_key_file_set_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_value", key_file, group_name, key, value);
            }
            mh$.invokeExact(key_file, group_name, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_string$descriptor() {
        return g_key_file_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_string$handle() {
        return g_key_file_get_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_string$address() {
        return g_key_file_get_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_string(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_string", key_file, group_name, key, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string)
     * }
     */
    public static FunctionDescriptor g_key_file_set_string$descriptor() {
        return g_key_file_set_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string)
     * }
     */
    public static MethodHandle g_key_file_set_string$handle() {
        return g_key_file_set_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string)
     * }
     */
    public static MemorySegment g_key_file_set_string$address() {
        return g_key_file_set_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string)
     * }
     */
    public static void g_key_file_set_string(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment string) {
        var mh$ = g_key_file_set_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_string", key_file, group_name, key, string);
            }
            mh$.invokeExact(key_file, group_name, key, string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_locale_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_locale_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_locale_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_locale_string$descriptor() {
        return g_key_file_get_locale_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_locale_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_locale_string$handle() {
        return g_key_file_get_locale_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_locale_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_locale_string$address() {
        return g_key_file_get_locale_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_locale_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_locale_string(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment locale, MemorySegment error) {
        var mh$ = g_key_file_get_locale_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_locale_string", key_file, group_name, key, locale, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, locale, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_locale_for_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_locale_for_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_locale_for_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale)
     * }
     */
    public static FunctionDescriptor g_key_file_get_locale_for_key$descriptor() {
        return g_key_file_get_locale_for_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_locale_for_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale)
     * }
     */
    public static MethodHandle g_key_file_get_locale_for_key$handle() {
        return g_key_file_get_locale_for_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_locale_for_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale)
     * }
     */
    public static MemorySegment g_key_file_get_locale_for_key$address() {
        return g_key_file_get_locale_for_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_locale_for_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale)
     * }
     */
    public static MemorySegment g_key_file_get_locale_for_key(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment locale) {
        var mh$ = g_key_file_get_locale_for_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_locale_for_key", key_file, group_name, key, locale);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_locale_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_locale_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_locale_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string)
     * }
     */
    public static FunctionDescriptor g_key_file_set_locale_string$descriptor() {
        return g_key_file_set_locale_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_locale_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string)
     * }
     */
    public static MethodHandle g_key_file_set_locale_string$handle() {
        return g_key_file_set_locale_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_locale_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string)
     * }
     */
    public static MemorySegment g_key_file_set_locale_string$address() {
        return g_key_file_set_locale_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_locale_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string)
     * }
     */
    public static void g_key_file_set_locale_string(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment locale, MemorySegment string) {
        var mh$ = g_key_file_set_locale_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_locale_string", key_file, group_name, key, locale, string);
            }
            mh$.invokeExact(key_file, group_name, key, locale, string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_boolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_boolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_get_boolean(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_boolean$descriptor() {
        return g_key_file_get_boolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_get_boolean(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_boolean$handle() {
        return g_key_file_get_boolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_get_boolean(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_boolean$address() {
        return g_key_file_get_boolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_get_boolean(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static int g_key_file_get_boolean(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_get_boolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_boolean", key_file, group_name, key, error);
            }
            return (int)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_boolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_boolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_boolean(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value)
     * }
     */
    public static FunctionDescriptor g_key_file_set_boolean$descriptor() {
        return g_key_file_set_boolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_boolean(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value)
     * }
     */
    public static MethodHandle g_key_file_set_boolean$handle() {
        return g_key_file_set_boolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_boolean(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value)
     * }
     */
    public static MemorySegment g_key_file_set_boolean$address() {
        return g_key_file_set_boolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_boolean(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value)
     * }
     */
    public static void g_key_file_set_boolean(MemorySegment key_file, MemorySegment group_name, MemorySegment key, int value) {
        var mh$ = g_key_file_set_boolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_boolean", key_file, group_name, key, value);
            }
            mh$.invokeExact(key_file, group_name, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_integer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_integer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_integer$descriptor() {
        return g_key_file_get_integer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_integer$handle() {
        return g_key_file_get_integer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_integer$address() {
        return g_key_file_get_integer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static int g_key_file_get_integer(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_get_integer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_integer", key_file, group_name, key, error);
            }
            return (int)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_integer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_integer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value)
     * }
     */
    public static FunctionDescriptor g_key_file_set_integer$descriptor() {
        return g_key_file_set_integer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value)
     * }
     */
    public static MethodHandle g_key_file_set_integer$handle() {
        return g_key_file_set_integer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value)
     * }
     */
    public static MemorySegment g_key_file_set_integer$address() {
        return g_key_file_set_integer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value)
     * }
     */
    public static void g_key_file_set_integer(MemorySegment key_file, MemorySegment group_name, MemorySegment key, int value) {
        var mh$ = g_key_file_set_integer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_integer", key_file, group_name, key, value);
            }
            mh$.invokeExact(key_file, group_name, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_key_file_get_int64(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_int64$descriptor() {
        return g_key_file_get_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_key_file_get_int64(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_int64$handle() {
        return g_key_file_get_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_key_file_get_int64(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_int64$address() {
        return g_key_file_get_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_key_file_get_int64(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static long g_key_file_get_int64(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_get_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_int64", key_file, group_name, key, error);
            }
            return (long)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_int64(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value)
     * }
     */
    public static FunctionDescriptor g_key_file_set_int64$descriptor() {
        return g_key_file_set_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_int64(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value)
     * }
     */
    public static MethodHandle g_key_file_set_int64$handle() {
        return g_key_file_set_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_int64(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value)
     * }
     */
    public static MemorySegment g_key_file_set_int64$address() {
        return g_key_file_set_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_int64(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value)
     * }
     */
    public static void g_key_file_set_int64(MemorySegment key_file, MemorySegment group_name, MemorySegment key, long value) {
        var mh$ = g_key_file_set_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_int64", key_file, group_name, key, value);
            }
            mh$.invokeExact(key_file, group_name, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint64 g_key_file_get_uint64(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_uint64$descriptor() {
        return g_key_file_get_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint64 g_key_file_get_uint64(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_uint64$handle() {
        return g_key_file_get_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint64 g_key_file_get_uint64(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_uint64$address() {
        return g_key_file_get_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint64 g_key_file_get_uint64(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static long g_key_file_get_uint64(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_get_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_uint64", key_file, group_name, key, error);
            }
            return (long)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_uint64(GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value)
     * }
     */
    public static FunctionDescriptor g_key_file_set_uint64$descriptor() {
        return g_key_file_set_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_uint64(GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value)
     * }
     */
    public static MethodHandle g_key_file_set_uint64$handle() {
        return g_key_file_set_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_uint64(GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value)
     * }
     */
    public static MemorySegment g_key_file_set_uint64$address() {
        return g_key_file_set_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_uint64(GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value)
     * }
     */
    public static void g_key_file_set_uint64(MemorySegment key_file, MemorySegment group_name, MemorySegment key, long value) {
        var mh$ = g_key_file_set_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_uint64", key_file, group_name, key, value);
            }
            mh$.invokeExact(key_file, group_name, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_key_file_get_double(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_double$descriptor() {
        return g_key_file_get_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_key_file_get_double(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_double$handle() {
        return g_key_file_get_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_key_file_get_double(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_double$address() {
        return g_key_file_get_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_key_file_get_double(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static double g_key_file_get_double(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_get_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_double", key_file, group_name, key, error);
            }
            return (double)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_double(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value)
     * }
     */
    public static FunctionDescriptor g_key_file_set_double$descriptor() {
        return g_key_file_set_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_double(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value)
     * }
     */
    public static MethodHandle g_key_file_set_double$handle() {
        return g_key_file_set_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_double(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value)
     * }
     */
    public static MemorySegment g_key_file_set_double$address() {
        return g_key_file_set_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_double(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value)
     * }
     */
    public static void g_key_file_set_double(MemorySegment key_file, MemorySegment group_name, MemorySegment key, double value) {
        var mh$ = g_key_file_set_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_double", key_file, group_name, key, value);
            }
            mh$.invokeExact(key_file, group_name, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_string_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_string_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_string_list$descriptor() {
        return g_key_file_get_string_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_string_list$handle() {
        return g_key_file_get_string_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_string_list$address() {
        return g_key_file_get_string_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_string_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment length, MemorySegment error) {
        var mh$ = g_key_file_get_string_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_string_list", key_file, group_name, key, length, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_string_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_string_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *const list[], gsize length)
     * }
     */
    public static FunctionDescriptor g_key_file_set_string_list$descriptor() {
        return g_key_file_set_string_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *const list[], gsize length)
     * }
     */
    public static MethodHandle g_key_file_set_string_list$handle() {
        return g_key_file_set_string_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *const list[], gsize length)
     * }
     */
    public static MemorySegment g_key_file_set_string_list$address() {
        return g_key_file_set_string_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *const list[], gsize length)
     * }
     */
    public static void g_key_file_set_string_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment list, long length) {
        var mh$ = g_key_file_set_string_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_string_list", key_file, group_name, key, list, length);
            }
            mh$.invokeExact(key_file, group_name, key, list, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_locale_string_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_locale_string_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_locale_string_list$descriptor() {
        return g_key_file_get_locale_string_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_locale_string_list$handle() {
        return g_key_file_get_locale_string_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_locale_string_list$address() {
        return g_key_file_get_locale_string_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_locale_string_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment locale, MemorySegment length, MemorySegment error) {
        var mh$ = g_key_file_get_locale_string_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_locale_string_list", key_file, group_name, key, locale, length, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, locale, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_locale_string_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_locale_string_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_locale_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *const list[], gsize length)
     * }
     */
    public static FunctionDescriptor g_key_file_set_locale_string_list$descriptor() {
        return g_key_file_set_locale_string_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_locale_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *const list[], gsize length)
     * }
     */
    public static MethodHandle g_key_file_set_locale_string_list$handle() {
        return g_key_file_set_locale_string_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_locale_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *const list[], gsize length)
     * }
     */
    public static MemorySegment g_key_file_set_locale_string_list$address() {
        return g_key_file_set_locale_string_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_locale_string_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *const list[], gsize length)
     * }
     */
    public static void g_key_file_set_locale_string_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment locale, MemorySegment list, long length) {
        var mh$ = g_key_file_set_locale_string_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_locale_string_list", key_file, group_name, key, locale, list, length);
            }
            mh$.invokeExact(key_file, group_name, key, locale, list, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_boolean_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_boolean_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_boolean_list$descriptor() {
        return g_key_file_get_boolean_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_boolean_list$handle() {
        return g_key_file_get_boolean_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_boolean_list$address() {
        return g_key_file_get_boolean_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_boolean_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment length, MemorySegment error) {
        var mh$ = g_key_file_get_boolean_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_boolean_list", key_file, group_name, key, length, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_boolean_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_boolean_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_boolean_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length)
     * }
     */
    public static FunctionDescriptor g_key_file_set_boolean_list$descriptor() {
        return g_key_file_set_boolean_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_boolean_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length)
     * }
     */
    public static MethodHandle g_key_file_set_boolean_list$handle() {
        return g_key_file_set_boolean_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_boolean_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length)
     * }
     */
    public static MemorySegment g_key_file_set_boolean_list$address() {
        return g_key_file_set_boolean_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_boolean_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length)
     * }
     */
    public static void g_key_file_set_boolean_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment list, long length) {
        var mh$ = g_key_file_set_boolean_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_boolean_list", key_file, group_name, key, list, length);
            }
            mh$.invokeExact(key_file, group_name, key, list, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_integer_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_integer_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint *g_key_file_get_integer_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_integer_list$descriptor() {
        return g_key_file_get_integer_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint *g_key_file_get_integer_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_integer_list$handle() {
        return g_key_file_get_integer_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint *g_key_file_get_integer_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_integer_list$address() {
        return g_key_file_get_integer_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint *g_key_file_get_integer_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_integer_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment length, MemorySegment error) {
        var mh$ = g_key_file_get_integer_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_integer_list", key_file, group_name, key, length, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_double_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_double_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_double_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length)
     * }
     */
    public static FunctionDescriptor g_key_file_set_double_list$descriptor() {
        return g_key_file_set_double_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_double_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length)
     * }
     */
    public static MethodHandle g_key_file_set_double_list$handle() {
        return g_key_file_set_double_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_double_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length)
     * }
     */
    public static MemorySegment g_key_file_set_double_list$address() {
        return g_key_file_set_double_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_double_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length)
     * }
     */
    public static void g_key_file_set_double_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment list, long length) {
        var mh$ = g_key_file_set_double_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_double_list", key_file, group_name, key, list, length);
            }
            mh$.invokeExact(key_file, group_name, key, list, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_double_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_double_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble *g_key_file_get_double_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_double_list$descriptor() {
        return g_key_file_get_double_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble *g_key_file_get_double_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_double_list$handle() {
        return g_key_file_get_double_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble *g_key_file_get_double_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_double_list$address() {
        return g_key_file_get_double_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble *g_key_file_get_double_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_double_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment length, MemorySegment error) {
        var mh$ = g_key_file_get_double_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_double_list", key_file, group_name, key, length, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, length, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_integer_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_integer_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_key_file_set_integer_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length)
     * }
     */
    public static FunctionDescriptor g_key_file_set_integer_list$descriptor() {
        return g_key_file_set_integer_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_key_file_set_integer_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length)
     * }
     */
    public static MethodHandle g_key_file_set_integer_list$handle() {
        return g_key_file_set_integer_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_key_file_set_integer_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length)
     * }
     */
    public static MemorySegment g_key_file_set_integer_list$address() {
        return g_key_file_set_integer_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_key_file_set_integer_list(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length)
     * }
     */
    public static void g_key_file_set_integer_list(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment list, long length) {
        var mh$ = g_key_file_set_integer_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_integer_list", key_file, group_name, key, list, length);
            }
            mh$.invokeExact(key_file, group_name, key, list, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_set_comment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_set_comment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_set_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_set_comment$descriptor() {
        return g_key_file_set_comment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_set_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error)
     * }
     */
    public static MethodHandle g_key_file_set_comment$handle() {
        return g_key_file_set_comment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_set_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error)
     * }
     */
    public static MemorySegment g_key_file_set_comment$address() {
        return g_key_file_set_comment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_set_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error)
     * }
     */
    public static int g_key_file_set_comment(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment comment, MemorySegment error) {
        var mh$ = g_key_file_set_comment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_set_comment", key_file, group_name, key, comment, error);
            }
            return (int)mh$.invokeExact(key_file, group_name, key, comment, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_get_comment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_get_comment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_get_comment$descriptor() {
        return g_key_file_get_comment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_get_comment$handle() {
        return g_key_file_get_comment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_comment$address() {
        return g_key_file_get_comment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_key_file_get_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_get_comment(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_get_comment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_get_comment", key_file, group_name, key, error);
            }
            return (MemorySegment)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_remove_comment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_remove_comment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_remove_comment$descriptor() {
        return g_key_file_remove_comment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_remove_comment$handle() {
        return g_key_file_remove_comment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_remove_comment$address() {
        return g_key_file_remove_comment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_comment(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static int g_key_file_remove_comment(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_remove_comment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_remove_comment", key_file, group_name, key, error);
            }
            return (int)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_remove_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_remove_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_remove_key$descriptor() {
        return g_key_file_remove_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MethodHandle g_key_file_remove_key$handle() {
        return g_key_file_remove_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static MemorySegment g_key_file_remove_key$address() {
        return g_key_file_remove_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_key(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error)
     * }
     */
    public static int g_key_file_remove_key(MemorySegment key_file, MemorySegment group_name, MemorySegment key, MemorySegment error) {
        var mh$ = g_key_file_remove_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_remove_key", key_file, group_name, key, error);
            }
            return (int)mh$.invokeExact(key_file, group_name, key, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_key_file_remove_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_key_file_remove_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_group(GKeyFile *key_file, const gchar *group_name, GError **error)
     * }
     */
    public static FunctionDescriptor g_key_file_remove_group$descriptor() {
        return g_key_file_remove_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_group(GKeyFile *key_file, const gchar *group_name, GError **error)
     * }
     */
    public static MethodHandle g_key_file_remove_group$handle() {
        return g_key_file_remove_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_group(GKeyFile *key_file, const gchar *group_name, GError **error)
     * }
     */
    public static MemorySegment g_key_file_remove_group$address() {
        return g_key_file_remove_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_key_file_remove_group(GKeyFile *key_file, const gchar *group_name, GError **error)
     * }
     */
    public static int g_key_file_remove_group(MemorySegment key_file, MemorySegment group_name, MemorySegment error) {
        var mh$ = g_key_file_remove_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_key_file_remove_group", key_file, group_name, error);
            }
            return (int)mh$.invokeExact(key_file, group_name, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_new(const gchar *filename, gboolean writable, GError **error)
     * }
     */
    public static FunctionDescriptor g_mapped_file_new$descriptor() {
        return g_mapped_file_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_new(const gchar *filename, gboolean writable, GError **error)
     * }
     */
    public static MethodHandle g_mapped_file_new$handle() {
        return g_mapped_file_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_new(const gchar *filename, gboolean writable, GError **error)
     * }
     */
    public static MemorySegment g_mapped_file_new$address() {
        return g_mapped_file_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_new(const gchar *filename, gboolean writable, GError **error)
     * }
     */
    public static MemorySegment g_mapped_file_new(MemorySegment filename, int writable, MemorySegment error) {
        var mh$ = g_mapped_file_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_new", filename, writable, error);
            }
            return (MemorySegment)mh$.invokeExact(filename, writable, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_new_from_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_new_from_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_new_from_fd(gint fd, gboolean writable, GError **error)
     * }
     */
    public static FunctionDescriptor g_mapped_file_new_from_fd$descriptor() {
        return g_mapped_file_new_from_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_new_from_fd(gint fd, gboolean writable, GError **error)
     * }
     */
    public static MethodHandle g_mapped_file_new_from_fd$handle() {
        return g_mapped_file_new_from_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_new_from_fd(gint fd, gboolean writable, GError **error)
     * }
     */
    public static MemorySegment g_mapped_file_new_from_fd$address() {
        return g_mapped_file_new_from_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_new_from_fd(gint fd, gboolean writable, GError **error)
     * }
     */
    public static MemorySegment g_mapped_file_new_from_fd(int fd, int writable, MemorySegment error) {
        var mh$ = g_mapped_file_new_from_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_new_from_fd", fd, writable, error);
            }
            return (MemorySegment)mh$.invokeExact(fd, writable, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_get_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_get_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_mapped_file_get_length(GMappedFile *file)
     * }
     */
    public static FunctionDescriptor g_mapped_file_get_length$descriptor() {
        return g_mapped_file_get_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_mapped_file_get_length(GMappedFile *file)
     * }
     */
    public static MethodHandle g_mapped_file_get_length$handle() {
        return g_mapped_file_get_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_mapped_file_get_length(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_get_length$address() {
        return g_mapped_file_get_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_mapped_file_get_length(GMappedFile *file)
     * }
     */
    public static long g_mapped_file_get_length(MemorySegment file) {
        var mh$ = g_mapped_file_get_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_get_length", file);
            }
            return (long)mh$.invokeExact(file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_get_contents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_get_contents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_mapped_file_get_contents(GMappedFile *file)
     * }
     */
    public static FunctionDescriptor g_mapped_file_get_contents$descriptor() {
        return g_mapped_file_get_contents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_mapped_file_get_contents(GMappedFile *file)
     * }
     */
    public static MethodHandle g_mapped_file_get_contents$handle() {
        return g_mapped_file_get_contents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_mapped_file_get_contents(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_get_contents$address() {
        return g_mapped_file_get_contents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_mapped_file_get_contents(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_get_contents(MemorySegment file) {
        var mh$ = g_mapped_file_get_contents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_get_contents", file);
            }
            return (MemorySegment)mh$.invokeExact(file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_get_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_get_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_mapped_file_get_bytes(GMappedFile *file)
     * }
     */
    public static FunctionDescriptor g_mapped_file_get_bytes$descriptor() {
        return g_mapped_file_get_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_mapped_file_get_bytes(GMappedFile *file)
     * }
     */
    public static MethodHandle g_mapped_file_get_bytes$handle() {
        return g_mapped_file_get_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_mapped_file_get_bytes(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_get_bytes$address() {
        return g_mapped_file_get_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_mapped_file_get_bytes(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_get_bytes(MemorySegment file) {
        var mh$ = g_mapped_file_get_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_get_bytes", file);
            }
            return (MemorySegment)mh$.invokeExact(file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_ref(GMappedFile *file)
     * }
     */
    public static FunctionDescriptor g_mapped_file_ref$descriptor() {
        return g_mapped_file_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_ref(GMappedFile *file)
     * }
     */
    public static MethodHandle g_mapped_file_ref$handle() {
        return g_mapped_file_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_ref(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_ref$address() {
        return g_mapped_file_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMappedFile *g_mapped_file_ref(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_ref(MemorySegment file) {
        var mh$ = g_mapped_file_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_ref", file);
            }
            return (MemorySegment)mh$.invokeExact(file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mapped_file_unref(GMappedFile *file)
     * }
     */
    public static FunctionDescriptor g_mapped_file_unref$descriptor() {
        return g_mapped_file_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mapped_file_unref(GMappedFile *file)
     * }
     */
    public static MethodHandle g_mapped_file_unref$handle() {
        return g_mapped_file_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mapped_file_unref(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_unref$address() {
        return g_mapped_file_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mapped_file_unref(GMappedFile *file)
     * }
     */
    public static void g_mapped_file_unref(MemorySegment file) {
        var mh$ = g_mapped_file_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_unref", file);
            }
            mh$.invokeExact(file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_mapped_file_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_mapped_file_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_mapped_file_free(GMappedFile *file)
     * }
     */
    public static FunctionDescriptor g_mapped_file_free$descriptor() {
        return g_mapped_file_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_mapped_file_free(GMappedFile *file)
     * }
     */
    public static MethodHandle g_mapped_file_free$handle() {
        return g_mapped_file_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_mapped_file_free(GMappedFile *file)
     * }
     */
    public static MemorySegment g_mapped_file_free$address() {
        return g_mapped_file_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_mapped_file_free(GMappedFile *file)
     * }
     */
    public static void g_mapped_file_free(MemorySegment file) {
        var mh$ = g_mapped_file_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_mapped_file_free", file);
            }
            mh$.invokeExact(file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_MARKUP_ERROR_BAD_UTF8 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_ERROR_BAD_UTF8 = 0
     * }
     */
    public static int G_MARKUP_ERROR_BAD_UTF8() {
        return G_MARKUP_ERROR_BAD_UTF8;
    }
    private static final int G_MARKUP_ERROR_EMPTY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_ERROR_EMPTY = 1
     * }
     */
    public static int G_MARKUP_ERROR_EMPTY() {
        return G_MARKUP_ERROR_EMPTY;
    }
    private static final int G_MARKUP_ERROR_PARSE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_ERROR_PARSE = 2
     * }
     */
    public static int G_MARKUP_ERROR_PARSE() {
        return G_MARKUP_ERROR_PARSE;
    }
    private static final int G_MARKUP_ERROR_UNKNOWN_ELEMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3
     * }
     */
    public static int G_MARKUP_ERROR_UNKNOWN_ELEMENT() {
        return G_MARKUP_ERROR_UNKNOWN_ELEMENT;
    }
    private static final int G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4
     * }
     */
    public static int G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE() {
        return G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE;
    }
    private static final int G_MARKUP_ERROR_INVALID_CONTENT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_ERROR_INVALID_CONTENT = 5
     * }
     */
    public static int G_MARKUP_ERROR_INVALID_CONTENT() {
        return G_MARKUP_ERROR_INVALID_CONTENT;
    }
    private static final int G_MARKUP_ERROR_MISSING_ATTRIBUTE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6
     * }
     */
    public static int G_MARKUP_ERROR_MISSING_ATTRIBUTE() {
        return G_MARKUP_ERROR_MISSING_ATTRIBUTE;
    }

    private static class g_markup_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_markup_error_quark()
     * }
     */
    public static FunctionDescriptor g_markup_error_quark$descriptor() {
        return g_markup_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_markup_error_quark()
     * }
     */
    public static MethodHandle g_markup_error_quark$handle() {
        return g_markup_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_markup_error_quark()
     * }
     */
    public static MemorySegment g_markup_error_quark$address() {
        return g_markup_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_markup_error_quark()
     * }
     */
    public static int g_markup_error_quark() {
        var mh$ = g_markup_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_MARKUP_DEFAULT_FLAGS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_DEFAULT_FLAGS = 0
     * }
     */
    public static int G_MARKUP_DEFAULT_FLAGS() {
        return G_MARKUP_DEFAULT_FLAGS;
    }
    private static final int G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1
     * }
     */
    public static int G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG() {
        return G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG;
    }
    private static final int G_MARKUP_TREAT_CDATA_AS_TEXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_TREAT_CDATA_AS_TEXT = 2
     * }
     */
    public static int G_MARKUP_TREAT_CDATA_AS_TEXT() {
        return G_MARKUP_TREAT_CDATA_AS_TEXT;
    }
    private static final int G_MARKUP_PREFIX_ERROR_POSITION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_PREFIX_ERROR_POSITION = 4
     * }
     */
    public static int G_MARKUP_PREFIX_ERROR_POSITION() {
        return G_MARKUP_PREFIX_ERROR_POSITION;
    }
    private static final int G_MARKUP_IGNORE_QUALIFIED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_IGNORE_QUALIFIED = 8
     * }
     */
    public static int G_MARKUP_IGNORE_QUALIFIED() {
        return G_MARKUP_IGNORE_QUALIFIED;
    }

    private static class g_markup_parse_context_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMarkupParseContext *g_markup_parse_context_new(const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_new$descriptor() {
        return g_markup_parse_context_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMarkupParseContext *g_markup_parse_context_new(const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify)
     * }
     */
    public static MethodHandle g_markup_parse_context_new$handle() {
        return g_markup_parse_context_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMarkupParseContext *g_markup_parse_context_new(const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify)
     * }
     */
    public static MemorySegment g_markup_parse_context_new$address() {
        return g_markup_parse_context_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMarkupParseContext *g_markup_parse_context_new(const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify)
     * }
     */
    public static MemorySegment g_markup_parse_context_new(MemorySegment parser, int flags, MemorySegment user_data, MemorySegment user_data_dnotify) {
        var mh$ = g_markup_parse_context_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_new", parser, flags, user_data, user_data_dnotify);
            }
            return (MemorySegment)mh$.invokeExact(parser, flags, user_data, user_data_dnotify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *context)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_ref$descriptor() {
        return g_markup_parse_context_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *context)
     * }
     */
    public static MethodHandle g_markup_parse_context_ref$handle() {
        return g_markup_parse_context_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_ref$address() {
        return g_markup_parse_context_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_ref(MemorySegment context) {
        var mh$ = g_markup_parse_context_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_ref", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_unref(GMarkupParseContext *context)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_unref$descriptor() {
        return g_markup_parse_context_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_unref(GMarkupParseContext *context)
     * }
     */
    public static MethodHandle g_markup_parse_context_unref$handle() {
        return g_markup_parse_context_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_unref(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_unref$address() {
        return g_markup_parse_context_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_markup_parse_context_unref(GMarkupParseContext *context)
     * }
     */
    public static void g_markup_parse_context_unref(MemorySegment context) {
        var mh$ = g_markup_parse_context_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_unref", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_free(GMarkupParseContext *context)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_free$descriptor() {
        return g_markup_parse_context_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_free(GMarkupParseContext *context)
     * }
     */
    public static MethodHandle g_markup_parse_context_free$handle() {
        return g_markup_parse_context_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_free(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_free$address() {
        return g_markup_parse_context_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_markup_parse_context_free(GMarkupParseContext *context)
     * }
     */
    public static void g_markup_parse_context_free(MemorySegment context) {
        var mh$ = g_markup_parse_context_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_free", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_parse$descriptor() {
        return g_markup_parse_context_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error)
     * }
     */
    public static MethodHandle g_markup_parse_context_parse$handle() {
        return g_markup_parse_context_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error)
     * }
     */
    public static MemorySegment g_markup_parse_context_parse$address() {
        return g_markup_parse_context_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error)
     * }
     */
    public static int g_markup_parse_context_parse(MemorySegment context, MemorySegment text, long text_len, MemorySegment error) {
        var mh$ = g_markup_parse_context_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_parse", context, text, text_len, error);
            }
            return (int)mh$.invokeExact(context, text, text_len, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_push(GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_push$descriptor() {
        return g_markup_parse_context_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_push(GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data)
     * }
     */
    public static MethodHandle g_markup_parse_context_push$handle() {
        return g_markup_parse_context_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_push(GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data)
     * }
     */
    public static MemorySegment g_markup_parse_context_push$address() {
        return g_markup_parse_context_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_markup_parse_context_push(GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data)
     * }
     */
    public static void g_markup_parse_context_push(MemorySegment context, MemorySegment parser, MemorySegment user_data) {
        var mh$ = g_markup_parse_context_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_push", context, parser, user_data);
            }
            mh$.invokeExact(context, parser, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_pop$descriptor() {
        return g_markup_parse_context_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context)
     * }
     */
    public static MethodHandle g_markup_parse_context_pop$handle() {
        return g_markup_parse_context_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_pop$address() {
        return g_markup_parse_context_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_pop(MemorySegment context) {
        var mh$ = g_markup_parse_context_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_pop", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_end_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_end_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *context, GError **error)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_end_parse$descriptor() {
        return g_markup_parse_context_end_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *context, GError **error)
     * }
     */
    public static MethodHandle g_markup_parse_context_end_parse$handle() {
        return g_markup_parse_context_end_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *context, GError **error)
     * }
     */
    public static MemorySegment g_markup_parse_context_end_parse$address() {
        return g_markup_parse_context_end_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *context, GError **error)
     * }
     */
    public static int g_markup_parse_context_end_parse(MemorySegment context, MemorySegment error) {
        var mh$ = g_markup_parse_context_end_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_end_parse", context, error);
            }
            return (int)mh$.invokeExact(context, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_get_element {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_get_element");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_markup_parse_context_get_element(GMarkupParseContext *context)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_get_element$descriptor() {
        return g_markup_parse_context_get_element.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_markup_parse_context_get_element(GMarkupParseContext *context)
     * }
     */
    public static MethodHandle g_markup_parse_context_get_element$handle() {
        return g_markup_parse_context_get_element.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_markup_parse_context_get_element(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_get_element$address() {
        return g_markup_parse_context_get_element.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_markup_parse_context_get_element(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_get_element(MemorySegment context) {
        var mh$ = g_markup_parse_context_get_element.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_get_element", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_get_element_stack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_get_element_stack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GSList *g_markup_parse_context_get_element_stack(GMarkupParseContext *context)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_get_element_stack$descriptor() {
        return g_markup_parse_context_get_element_stack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GSList *g_markup_parse_context_get_element_stack(GMarkupParseContext *context)
     * }
     */
    public static MethodHandle g_markup_parse_context_get_element_stack$handle() {
        return g_markup_parse_context_get_element_stack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GSList *g_markup_parse_context_get_element_stack(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_get_element_stack$address() {
        return g_markup_parse_context_get_element_stack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GSList *g_markup_parse_context_get_element_stack(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_get_element_stack(MemorySegment context) {
        var mh$ = g_markup_parse_context_get_element_stack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_get_element_stack", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_get_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_get_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_get_position(GMarkupParseContext *context, gint *line_number, gint *char_number)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_get_position$descriptor() {
        return g_markup_parse_context_get_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_get_position(GMarkupParseContext *context, gint *line_number, gint *char_number)
     * }
     */
    public static MethodHandle g_markup_parse_context_get_position$handle() {
        return g_markup_parse_context_get_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_markup_parse_context_get_position(GMarkupParseContext *context, gint *line_number, gint *char_number)
     * }
     */
    public static MemorySegment g_markup_parse_context_get_position$address() {
        return g_markup_parse_context_get_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_markup_parse_context_get_position(GMarkupParseContext *context, gint *line_number, gint *char_number)
     * }
     */
    public static void g_markup_parse_context_get_position(MemorySegment context, MemorySegment line_number, MemorySegment char_number) {
        var mh$ = g_markup_parse_context_get_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_get_position", context, line_number, char_number);
            }
            mh$.invokeExact(context, line_number, char_number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_parse_context_get_user_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_parse_context_get_user_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *context)
     * }
     */
    public static FunctionDescriptor g_markup_parse_context_get_user_data$descriptor() {
        return g_markup_parse_context_get_user_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *context)
     * }
     */
    public static MethodHandle g_markup_parse_context_get_user_data$handle() {
        return g_markup_parse_context_get_user_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_get_user_data$address() {
        return g_markup_parse_context_get_user_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *context)
     * }
     */
    public static MemorySegment g_markup_parse_context_get_user_data(MemorySegment context) {
        var mh$ = g_markup_parse_context_get_user_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_parse_context_get_user_data", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_markup_escape_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_escape_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_markup_escape_text(const gchar *text, gssize length)
     * }
     */
    public static FunctionDescriptor g_markup_escape_text$descriptor() {
        return g_markup_escape_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_markup_escape_text(const gchar *text, gssize length)
     * }
     */
    public static MethodHandle g_markup_escape_text$handle() {
        return g_markup_escape_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_markup_escape_text(const gchar *text, gssize length)
     * }
     */
    public static MemorySegment g_markup_escape_text$address() {
        return g_markup_escape_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_markup_escape_text(const gchar *text, gssize length)
     * }
     */
    public static MemorySegment g_markup_escape_text(MemorySegment text, long length) {
        var mh$ = g_markup_escape_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_escape_text", text, length);
            }
            return (MemorySegment)mh$.invokeExact(text, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gchar *g_markup_printf_escaped(const char *format, ...)
     * }
     */
    public static class g_markup_printf_escaped {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_printf_escaped");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_markup_printf_escaped(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gchar *g_markup_printf_escaped(const char *format, ...)
         * }
         */
        public static g_markup_printf_escaped makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_markup_printf_escaped(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_markup_printf_escaped", format, x1);
                }
                return (MemorySegment) spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_markup_vprintf_escaped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_vprintf_escaped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_markup_vprintf_escaped(const char *format, va_list args)
     * }
     */
    public static FunctionDescriptor g_markup_vprintf_escaped$descriptor() {
        return g_markup_vprintf_escaped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_markup_vprintf_escaped(const char *format, va_list args)
     * }
     */
    public static MethodHandle g_markup_vprintf_escaped$handle() {
        return g_markup_vprintf_escaped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_markup_vprintf_escaped(const char *format, va_list args)
     * }
     */
    public static MemorySegment g_markup_vprintf_escaped$address() {
        return g_markup_vprintf_escaped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_markup_vprintf_escaped(const char *format, va_list args)
     * }
     */
    public static MemorySegment g_markup_vprintf_escaped(MemorySegment format, MemorySegment args) {
        var mh$ = g_markup_vprintf_escaped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_markup_vprintf_escaped", format, args);
            }
            return (MemorySegment)mh$.invokeExact(format, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_MARKUP_COLLECT_INVALID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_COLLECT_INVALID = 0
     * }
     */
    public static int G_MARKUP_COLLECT_INVALID() {
        return G_MARKUP_COLLECT_INVALID;
    }
    private static final int G_MARKUP_COLLECT_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_COLLECT_STRING = 1
     * }
     */
    public static int G_MARKUP_COLLECT_STRING() {
        return G_MARKUP_COLLECT_STRING;
    }
    private static final int G_MARKUP_COLLECT_STRDUP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_COLLECT_STRDUP = 2
     * }
     */
    public static int G_MARKUP_COLLECT_STRDUP() {
        return G_MARKUP_COLLECT_STRDUP;
    }
    private static final int G_MARKUP_COLLECT_BOOLEAN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_COLLECT_BOOLEAN = 3
     * }
     */
    public static int G_MARKUP_COLLECT_BOOLEAN() {
        return G_MARKUP_COLLECT_BOOLEAN;
    }
    private static final int G_MARKUP_COLLECT_TRISTATE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_COLLECT_TRISTATE = 4
     * }
     */
    public static int G_MARKUP_COLLECT_TRISTATE() {
        return G_MARKUP_COLLECT_TRISTATE;
    }
    private static final int G_MARKUP_COLLECT_OPTIONAL = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_MARKUP_COLLECT_OPTIONAL = 65536
     * }
     */
    public static int G_MARKUP_COLLECT_OPTIONAL() {
        return G_MARKUP_COLLECT_OPTIONAL;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gboolean g_markup_collect_attributes(const gchar *element_name, const gchar **attribute_names, const gchar **attribute_values, GError **error, GMarkupCollectType first_type, const gchar *first_attr, ...)
     * }
     */
    public static class g_markup_collect_attributes {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_markup_collect_attributes");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_markup_collect_attributes(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gboolean g_markup_collect_attributes(const gchar *element_name, const gchar **attribute_names, const gchar **attribute_values, GError **error, GMarkupCollectType first_type, const gchar *first_attr, ...)
         * }
         */
        public static g_markup_collect_attributes makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_markup_collect_attributes(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment element_name, MemorySegment attribute_names, MemorySegment attribute_values, MemorySegment error, int first_type, MemorySegment first_attr, Object... x6) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_markup_collect_attributes", element_name, attribute_names, attribute_values, error, first_type, first_attr, x6);
                }
                return (int) spreader.invokeExact(element_name, attribute_names, attribute_values, error, first_type, first_attr, x6);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_variant_type_string_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_string_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_string_is_valid(const gchar *type_string)
     * }
     */
    public static FunctionDescriptor g_variant_type_string_is_valid$descriptor() {
        return g_variant_type_string_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_string_is_valid(const gchar *type_string)
     * }
     */
    public static MethodHandle g_variant_type_string_is_valid$handle() {
        return g_variant_type_string_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_string_is_valid(const gchar *type_string)
     * }
     */
    public static MemorySegment g_variant_type_string_is_valid$address() {
        return g_variant_type_string_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_string_is_valid(const gchar *type_string)
     * }
     */
    public static int g_variant_type_string_is_valid(MemorySegment type_string) {
        var mh$ = g_variant_type_string_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_string_is_valid", type_string);
            }
            return (int)mh$.invokeExact(type_string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_string_scan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_string_scan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_string_scan(const gchar *string, const gchar *limit, const gchar **endptr)
     * }
     */
    public static FunctionDescriptor g_variant_type_string_scan$descriptor() {
        return g_variant_type_string_scan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_string_scan(const gchar *string, const gchar *limit, const gchar **endptr)
     * }
     */
    public static MethodHandle g_variant_type_string_scan$handle() {
        return g_variant_type_string_scan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_string_scan(const gchar *string, const gchar *limit, const gchar **endptr)
     * }
     */
    public static MemorySegment g_variant_type_string_scan$address() {
        return g_variant_type_string_scan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_string_scan(const gchar *string, const gchar *limit, const gchar **endptr)
     * }
     */
    public static int g_variant_type_string_scan(MemorySegment string, MemorySegment limit, MemorySegment endptr) {
        var mh$ = g_variant_type_string_scan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_string_scan", string, limit, endptr);
            }
            return (int)mh$.invokeExact(string, limit, endptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_type_free(GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_free$descriptor() {
        return g_variant_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_type_free(GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_free$handle() {
        return g_variant_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_type_free(GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_free$address() {
        return g_variant_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_type_free(GVariantType *type)
     * }
     */
    public static void g_variant_type_free(MemorySegment type) {
        var mh$ = g_variant_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_free", type);
            }
            mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_copy(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_copy$descriptor() {
        return g_variant_type_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_copy(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_copy$handle() {
        return g_variant_type_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_copy(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_copy$address() {
        return g_variant_type_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_copy(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_copy(MemorySegment type) {
        var mh$ = g_variant_type_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_copy", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new(const gchar *type_string)
     * }
     */
    public static FunctionDescriptor g_variant_type_new$descriptor() {
        return g_variant_type_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new(const gchar *type_string)
     * }
     */
    public static MethodHandle g_variant_type_new$handle() {
        return g_variant_type_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new(const gchar *type_string)
     * }
     */
    public static MemorySegment g_variant_type_new$address() {
        return g_variant_type_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new(const gchar *type_string)
     * }
     */
    public static MemorySegment g_variant_type_new(MemorySegment type_string) {
        var mh$ = g_variant_type_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_new", type_string);
            }
            return (MemorySegment)mh$.invokeExact(type_string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_get_string_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_get_string_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_get_string_length(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_get_string_length$descriptor() {
        return g_variant_type_get_string_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_get_string_length(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_get_string_length$handle() {
        return g_variant_type_get_string_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_get_string_length(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_get_string_length$address() {
        return g_variant_type_get_string_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_variant_type_get_string_length(const GVariantType *type)
     * }
     */
    public static long g_variant_type_get_string_length(MemorySegment type) {
        var mh$ = g_variant_type_get_string_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_get_string_length", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_peek_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_peek_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_type_peek_string(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_peek_string$descriptor() {
        return g_variant_type_peek_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_type_peek_string(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_peek_string$handle() {
        return g_variant_type_peek_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_type_peek_string(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_peek_string$address() {
        return g_variant_type_peek_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_variant_type_peek_string(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_peek_string(MemorySegment type) {
        var mh$ = g_variant_type_peek_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_peek_string", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_dup_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_dup_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_variant_type_dup_string(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_dup_string$descriptor() {
        return g_variant_type_dup_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_variant_type_dup_string(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_dup_string$handle() {
        return g_variant_type_dup_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_variant_type_dup_string(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_dup_string$address() {
        return g_variant_type_dup_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_variant_type_dup_string(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_dup_string(MemorySegment type) {
        var mh$ = g_variant_type_dup_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_dup_string", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_definite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_definite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_definite(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_definite$descriptor() {
        return g_variant_type_is_definite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_definite(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_is_definite$handle() {
        return g_variant_type_is_definite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_definite(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_is_definite$address() {
        return g_variant_type_is_definite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_definite(const GVariantType *type)
     * }
     */
    public static int g_variant_type_is_definite(MemorySegment type) {
        var mh$ = g_variant_type_is_definite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_definite", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_container {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_container");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_container(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_container$descriptor() {
        return g_variant_type_is_container.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_container(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_is_container$handle() {
        return g_variant_type_is_container.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_container(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_is_container$address() {
        return g_variant_type_is_container.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_container(const GVariantType *type)
     * }
     */
    public static int g_variant_type_is_container(MemorySegment type) {
        var mh$ = g_variant_type_is_container.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_container", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_basic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_basic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_basic(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_basic$descriptor() {
        return g_variant_type_is_basic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_basic(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_is_basic$handle() {
        return g_variant_type_is_basic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_basic(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_is_basic$address() {
        return g_variant_type_is_basic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_basic(const GVariantType *type)
     * }
     */
    public static int g_variant_type_is_basic(MemorySegment type) {
        var mh$ = g_variant_type_is_basic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_basic", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_maybe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_maybe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_maybe(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_maybe$descriptor() {
        return g_variant_type_is_maybe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_maybe(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_is_maybe$handle() {
        return g_variant_type_is_maybe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_maybe(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_is_maybe$address() {
        return g_variant_type_is_maybe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_maybe(const GVariantType *type)
     * }
     */
    public static int g_variant_type_is_maybe(MemorySegment type) {
        var mh$ = g_variant_type_is_maybe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_maybe", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_array(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_array$descriptor() {
        return g_variant_type_is_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_array(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_is_array$handle() {
        return g_variant_type_is_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_array(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_is_array$address() {
        return g_variant_type_is_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_array(const GVariantType *type)
     * }
     */
    public static int g_variant_type_is_array(MemorySegment type) {
        var mh$ = g_variant_type_is_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_array", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_tuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_tuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_tuple(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_tuple$descriptor() {
        return g_variant_type_is_tuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_tuple(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_is_tuple$handle() {
        return g_variant_type_is_tuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_tuple(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_is_tuple$address() {
        return g_variant_type_is_tuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_tuple(const GVariantType *type)
     * }
     */
    public static int g_variant_type_is_tuple(MemorySegment type) {
        var mh$ = g_variant_type_is_tuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_tuple", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_dict_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_dict_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_dict_entry(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_dict_entry$descriptor() {
        return g_variant_type_is_dict_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_dict_entry(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_is_dict_entry$handle() {
        return g_variant_type_is_dict_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_dict_entry(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_is_dict_entry$address() {
        return g_variant_type_is_dict_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_dict_entry(const GVariantType *type)
     * }
     */
    public static int g_variant_type_is_dict_entry(MemorySegment type) {
        var mh$ = g_variant_type_is_dict_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_dict_entry", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_variant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_variant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_variant(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_variant$descriptor() {
        return g_variant_type_is_variant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_variant(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_is_variant$handle() {
        return g_variant_type_is_variant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_variant(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_is_variant$address() {
        return g_variant_type_is_variant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_variant(const GVariantType *type)
     * }
     */
    public static int g_variant_type_is_variant(MemorySegment type) {
        var mh$ = g_variant_type_is_variant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_variant", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_variant_type_hash(gconstpointer type)
     * }
     */
    public static FunctionDescriptor g_variant_type_hash$descriptor() {
        return g_variant_type_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_variant_type_hash(gconstpointer type)
     * }
     */
    public static MethodHandle g_variant_type_hash$handle() {
        return g_variant_type_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_variant_type_hash(gconstpointer type)
     * }
     */
    public static MemorySegment g_variant_type_hash$address() {
        return g_variant_type_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_variant_type_hash(gconstpointer type)
     * }
     */
    public static int g_variant_type_hash(MemorySegment type) {
        var mh$ = g_variant_type_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_hash", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_equal(gconstpointer type1, gconstpointer type2)
     * }
     */
    public static FunctionDescriptor g_variant_type_equal$descriptor() {
        return g_variant_type_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_equal(gconstpointer type1, gconstpointer type2)
     * }
     */
    public static MethodHandle g_variant_type_equal$handle() {
        return g_variant_type_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_equal(gconstpointer type1, gconstpointer type2)
     * }
     */
    public static MemorySegment g_variant_type_equal$address() {
        return g_variant_type_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_equal(gconstpointer type1, gconstpointer type2)
     * }
     */
    public static int g_variant_type_equal(MemorySegment type1, MemorySegment type2) {
        var mh$ = g_variant_type_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_equal", type1, type2);
            }
            return (int)mh$.invokeExact(type1, type2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_is_subtype_of {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_is_subtype_of");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_subtype_of(const GVariantType *type, const GVariantType *supertype)
     * }
     */
    public static FunctionDescriptor g_variant_type_is_subtype_of$descriptor() {
        return g_variant_type_is_subtype_of.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_subtype_of(const GVariantType *type, const GVariantType *supertype)
     * }
     */
    public static MethodHandle g_variant_type_is_subtype_of$handle() {
        return g_variant_type_is_subtype_of.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_subtype_of(const GVariantType *type, const GVariantType *supertype)
     * }
     */
    public static MemorySegment g_variant_type_is_subtype_of$address() {
        return g_variant_type_is_subtype_of.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_type_is_subtype_of(const GVariantType *type, const GVariantType *supertype)
     * }
     */
    public static int g_variant_type_is_subtype_of(MemorySegment type, MemorySegment supertype) {
        var mh$ = g_variant_type_is_subtype_of.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_is_subtype_of", type, supertype);
            }
            return (int)mh$.invokeExact(type, supertype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_element {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_element");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_element(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_element$descriptor() {
        return g_variant_type_element.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_element(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_element$handle() {
        return g_variant_type_element.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_element(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_element$address() {
        return g_variant_type_element.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_element(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_element(MemorySegment type) {
        var mh$ = g_variant_type_element.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_element", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_first {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_first");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_first(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_first$descriptor() {
        return g_variant_type_first.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_first(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_first$handle() {
        return g_variant_type_first.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_first(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_first$address() {
        return g_variant_type_first.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_first(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_first(MemorySegment type) {
        var mh$ = g_variant_type_first.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_first", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_next(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_next$descriptor() {
        return g_variant_type_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_next(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_next$handle() {
        return g_variant_type_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_next(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_next$address() {
        return g_variant_type_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_next(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_next(MemorySegment type) {
        var mh$ = g_variant_type_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_next", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_n_items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_n_items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_n_items(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_n_items$descriptor() {
        return g_variant_type_n_items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_n_items(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_n_items$handle() {
        return g_variant_type_n_items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_n_items(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_n_items$address() {
        return g_variant_type_n_items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_variant_type_n_items(const GVariantType *type)
     * }
     */
    public static long g_variant_type_n_items(MemorySegment type) {
        var mh$ = g_variant_type_n_items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_n_items", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_key(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_key$descriptor() {
        return g_variant_type_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_key(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_key$handle() {
        return g_variant_type_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_key(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_key$address() {
        return g_variant_type_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_key(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_key(MemorySegment type) {
        var mh$ = g_variant_type_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_key", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_value(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_type_value$descriptor() {
        return g_variant_type_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_value(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_type_value$handle() {
        return g_variant_type_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_value(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_value$address() {
        return g_variant_type_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_value(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_type_value(MemorySegment type) {
        var mh$ = g_variant_type_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_value", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_new_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_new_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_array(const GVariantType *element)
     * }
     */
    public static FunctionDescriptor g_variant_type_new_array$descriptor() {
        return g_variant_type_new_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_array(const GVariantType *element)
     * }
     */
    public static MethodHandle g_variant_type_new_array$handle() {
        return g_variant_type_new_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_array(const GVariantType *element)
     * }
     */
    public static MemorySegment g_variant_type_new_array$address() {
        return g_variant_type_new_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_array(const GVariantType *element)
     * }
     */
    public static MemorySegment g_variant_type_new_array(MemorySegment element) {
        var mh$ = g_variant_type_new_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_new_array", element);
            }
            return (MemorySegment)mh$.invokeExact(element);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_new_maybe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_new_maybe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_maybe(const GVariantType *element)
     * }
     */
    public static FunctionDescriptor g_variant_type_new_maybe$descriptor() {
        return g_variant_type_new_maybe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_maybe(const GVariantType *element)
     * }
     */
    public static MethodHandle g_variant_type_new_maybe$handle() {
        return g_variant_type_new_maybe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_maybe(const GVariantType *element)
     * }
     */
    public static MemorySegment g_variant_type_new_maybe$address() {
        return g_variant_type_new_maybe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_maybe(const GVariantType *element)
     * }
     */
    public static MemorySegment g_variant_type_new_maybe(MemorySegment element) {
        var mh$ = g_variant_type_new_maybe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_new_maybe", element);
            }
            return (MemorySegment)mh$.invokeExact(element);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_new_tuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_new_tuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_tuple(const GVariantType *const *items, gint length)
     * }
     */
    public static FunctionDescriptor g_variant_type_new_tuple$descriptor() {
        return g_variant_type_new_tuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_tuple(const GVariantType *const *items, gint length)
     * }
     */
    public static MethodHandle g_variant_type_new_tuple$handle() {
        return g_variant_type_new_tuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_tuple(const GVariantType *const *items, gint length)
     * }
     */
    public static MemorySegment g_variant_type_new_tuple$address() {
        return g_variant_type_new_tuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_tuple(const GVariantType *const *items, gint length)
     * }
     */
    public static MemorySegment g_variant_type_new_tuple(MemorySegment items, int length) {
        var mh$ = g_variant_type_new_tuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_new_tuple", items, length);
            }
            return (MemorySegment)mh$.invokeExact(items, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_new_dict_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_new_dict_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_dict_entry(const GVariantType *key, const GVariantType *value)
     * }
     */
    public static FunctionDescriptor g_variant_type_new_dict_entry$descriptor() {
        return g_variant_type_new_dict_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_dict_entry(const GVariantType *key, const GVariantType *value)
     * }
     */
    public static MethodHandle g_variant_type_new_dict_entry$handle() {
        return g_variant_type_new_dict_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_dict_entry(const GVariantType *key, const GVariantType *value)
     * }
     */
    public static MemorySegment g_variant_type_new_dict_entry$address() {
        return g_variant_type_new_dict_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantType *g_variant_type_new_dict_entry(const GVariantType *key, const GVariantType *value)
     * }
     */
    public static MemorySegment g_variant_type_new_dict_entry(MemorySegment key, MemorySegment value) {
        var mh$ = g_variant_type_new_dict_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_new_dict_entry", key, value);
            }
            return (MemorySegment)mh$.invokeExact(key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_checked_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_checked_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_checked_(const gchar *type_string)
     * }
     */
    public static FunctionDescriptor g_variant_type_checked_$descriptor() {
        return g_variant_type_checked_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_checked_(const gchar *type_string)
     * }
     */
    public static MethodHandle g_variant_type_checked_$handle() {
        return g_variant_type_checked_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_checked_(const gchar *type_string)
     * }
     */
    public static MemorySegment g_variant_type_checked_$address() {
        return g_variant_type_checked_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_type_checked_(const gchar *type_string)
     * }
     */
    public static MemorySegment g_variant_type_checked_(MemorySegment type_string) {
        var mh$ = g_variant_type_checked_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_checked_", type_string);
            }
            return (MemorySegment)mh$.invokeExact(type_string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_type_string_get_depth_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_type_string_get_depth_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_string_get_depth_(const gchar *type_string)
     * }
     */
    public static FunctionDescriptor g_variant_type_string_get_depth_$descriptor() {
        return g_variant_type_string_get_depth_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_string_get_depth_(const gchar *type_string)
     * }
     */
    public static MethodHandle g_variant_type_string_get_depth_$handle() {
        return g_variant_type_string_get_depth_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_variant_type_string_get_depth_(const gchar *type_string)
     * }
     */
    public static MemorySegment g_variant_type_string_get_depth_$address() {
        return g_variant_type_string_get_depth_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_variant_type_string_get_depth_(const gchar *type_string)
     * }
     */
    public static long g_variant_type_string_get_depth_(MemorySegment type_string) {
        var mh$ = g_variant_type_string_get_depth_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_type_string_get_depth_", type_string);
            }
            return (long)mh$.invokeExact(type_string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_VARIANT_CLASS_BOOLEAN = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_BOOLEAN = 98
     * }
     */
    public static int G_VARIANT_CLASS_BOOLEAN() {
        return G_VARIANT_CLASS_BOOLEAN;
    }
    private static final int G_VARIANT_CLASS_BYTE = (int)121L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_BYTE = 121
     * }
     */
    public static int G_VARIANT_CLASS_BYTE() {
        return G_VARIANT_CLASS_BYTE;
    }
    private static final int G_VARIANT_CLASS_INT16 = (int)110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_INT16 = 110
     * }
     */
    public static int G_VARIANT_CLASS_INT16() {
        return G_VARIANT_CLASS_INT16;
    }
    private static final int G_VARIANT_CLASS_UINT16 = (int)113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_UINT16 = 113
     * }
     */
    public static int G_VARIANT_CLASS_UINT16() {
        return G_VARIANT_CLASS_UINT16;
    }
    private static final int G_VARIANT_CLASS_INT32 = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_INT32 = 105
     * }
     */
    public static int G_VARIANT_CLASS_INT32() {
        return G_VARIANT_CLASS_INT32;
    }
    private static final int G_VARIANT_CLASS_UINT32 = (int)117L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_UINT32 = 117
     * }
     */
    public static int G_VARIANT_CLASS_UINT32() {
        return G_VARIANT_CLASS_UINT32;
    }
    private static final int G_VARIANT_CLASS_INT64 = (int)120L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_INT64 = 120
     * }
     */
    public static int G_VARIANT_CLASS_INT64() {
        return G_VARIANT_CLASS_INT64;
    }
    private static final int G_VARIANT_CLASS_UINT64 = (int)116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_UINT64 = 116
     * }
     */
    public static int G_VARIANT_CLASS_UINT64() {
        return G_VARIANT_CLASS_UINT64;
    }
    private static final int G_VARIANT_CLASS_HANDLE = (int)104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_HANDLE = 104
     * }
     */
    public static int G_VARIANT_CLASS_HANDLE() {
        return G_VARIANT_CLASS_HANDLE;
    }
    private static final int G_VARIANT_CLASS_DOUBLE = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_DOUBLE = 100
     * }
     */
    public static int G_VARIANT_CLASS_DOUBLE() {
        return G_VARIANT_CLASS_DOUBLE;
    }
    private static final int G_VARIANT_CLASS_STRING = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_STRING = 115
     * }
     */
    public static int G_VARIANT_CLASS_STRING() {
        return G_VARIANT_CLASS_STRING;
    }
    private static final int G_VARIANT_CLASS_OBJECT_PATH = (int)111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_OBJECT_PATH = 111
     * }
     */
    public static int G_VARIANT_CLASS_OBJECT_PATH() {
        return G_VARIANT_CLASS_OBJECT_PATH;
    }
    private static final int G_VARIANT_CLASS_SIGNATURE = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_SIGNATURE = 103
     * }
     */
    public static int G_VARIANT_CLASS_SIGNATURE() {
        return G_VARIANT_CLASS_SIGNATURE;
    }
    private static final int G_VARIANT_CLASS_VARIANT = (int)118L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_VARIANT = 118
     * }
     */
    public static int G_VARIANT_CLASS_VARIANT() {
        return G_VARIANT_CLASS_VARIANT;
    }
    private static final int G_VARIANT_CLASS_MAYBE = (int)109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_MAYBE = 109
     * }
     */
    public static int G_VARIANT_CLASS_MAYBE() {
        return G_VARIANT_CLASS_MAYBE;
    }
    private static final int G_VARIANT_CLASS_ARRAY = (int)97L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_ARRAY = 97
     * }
     */
    public static int G_VARIANT_CLASS_ARRAY() {
        return G_VARIANT_CLASS_ARRAY;
    }
    private static final int G_VARIANT_CLASS_TUPLE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_TUPLE = 40
     * }
     */
    public static int G_VARIANT_CLASS_TUPLE() {
        return G_VARIANT_CLASS_TUPLE;
    }
    private static final int G_VARIANT_CLASS_DICT_ENTRY = (int)123L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_CLASS_DICT_ENTRY = 123
     * }
     */
    public static int G_VARIANT_CLASS_DICT_ENTRY() {
        return G_VARIANT_CLASS_DICT_ENTRY;
    }

    private static class g_variant_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_unref(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_unref$descriptor() {
        return g_variant_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_unref(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_unref$handle() {
        return g_variant_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_unref(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_unref$address() {
        return g_variant_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_unref(GVariant *value)
     * }
     */
    public static void g_variant_unref(MemorySegment value) {
        var mh$ = g_variant_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_unref", value);
            }
            mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_ref(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_ref$descriptor() {
        return g_variant_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_ref(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_ref$handle() {
        return g_variant_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_ref(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_ref$address() {
        return g_variant_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_ref(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_ref(MemorySegment value) {
        var mh$ = g_variant_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_ref", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_ref_sink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_ref_sink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_ref_sink(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_ref_sink$descriptor() {
        return g_variant_ref_sink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_ref_sink(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_ref_sink$handle() {
        return g_variant_ref_sink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_ref_sink(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_ref_sink$address() {
        return g_variant_ref_sink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_ref_sink(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_ref_sink(MemorySegment value) {
        var mh$ = g_variant_ref_sink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_ref_sink", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_is_floating {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_is_floating");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_floating(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_is_floating$descriptor() {
        return g_variant_is_floating.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_floating(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_is_floating$handle() {
        return g_variant_is_floating.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_floating(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_is_floating$address() {
        return g_variant_is_floating.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_is_floating(GVariant *value)
     * }
     */
    public static int g_variant_is_floating(MemorySegment value) {
        var mh$ = g_variant_is_floating.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_is_floating", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_take_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_take_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_take_ref(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_take_ref$descriptor() {
        return g_variant_take_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_take_ref(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_take_ref$handle() {
        return g_variant_take_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_take_ref(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_take_ref$address() {
        return g_variant_take_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_take_ref(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_take_ref(MemorySegment value) {
        var mh$ = g_variant_take_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_take_ref", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_get_type(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_type$descriptor() {
        return g_variant_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_get_type(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_type$handle() {
        return g_variant_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_get_type(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_type$address() {
        return g_variant_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GVariantType *g_variant_get_type(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_type(MemorySegment value) {
        var mh$ = g_variant_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_type", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_type_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_type_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_type_string(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_type_string$descriptor() {
        return g_variant_get_type_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_type_string(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_type_string$handle() {
        return g_variant_get_type_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_type_string(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_type_string$address() {
        return g_variant_get_type_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_type_string(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_type_string(MemorySegment value) {
        var mh$ = g_variant_get_type_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_type_string", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_is_of_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_is_of_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_of_type(GVariant *value, const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_is_of_type$descriptor() {
        return g_variant_is_of_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_of_type(GVariant *value, const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_is_of_type$handle() {
        return g_variant_is_of_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_of_type(GVariant *value, const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_is_of_type$address() {
        return g_variant_is_of_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_is_of_type(GVariant *value, const GVariantType *type)
     * }
     */
    public static int g_variant_is_of_type(MemorySegment value, MemorySegment type) {
        var mh$ = g_variant_is_of_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_is_of_type", value, type);
            }
            return (int)mh$.invokeExact(value, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_is_container {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_is_container");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_container(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_is_container$descriptor() {
        return g_variant_is_container.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_container(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_is_container$handle() {
        return g_variant_is_container.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_container(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_is_container$address() {
        return g_variant_is_container.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_is_container(GVariant *value)
     * }
     */
    public static int g_variant_is_container(MemorySegment value) {
        var mh$ = g_variant_is_container.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_is_container", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_classify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_classify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantClass g_variant_classify(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_classify$descriptor() {
        return g_variant_classify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantClass g_variant_classify(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_classify$handle() {
        return g_variant_classify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantClass g_variant_classify(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_classify$address() {
        return g_variant_classify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantClass g_variant_classify(GVariant *value)
     * }
     */
    public static int g_variant_classify(MemorySegment value) {
        var mh$ = g_variant_classify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_classify", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_boolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_boolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_boolean(gboolean value)
     * }
     */
    public static FunctionDescriptor g_variant_new_boolean$descriptor() {
        return g_variant_new_boolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_boolean(gboolean value)
     * }
     */
    public static MethodHandle g_variant_new_boolean$handle() {
        return g_variant_new_boolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_boolean(gboolean value)
     * }
     */
    public static MemorySegment g_variant_new_boolean$address() {
        return g_variant_new_boolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_boolean(gboolean value)
     * }
     */
    public static MemorySegment g_variant_new_boolean(int value) {
        var mh$ = g_variant_new_boolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_boolean", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_byte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_byte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_byte(guint8 value)
     * }
     */
    public static FunctionDescriptor g_variant_new_byte$descriptor() {
        return g_variant_new_byte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_byte(guint8 value)
     * }
     */
    public static MethodHandle g_variant_new_byte$handle() {
        return g_variant_new_byte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_byte(guint8 value)
     * }
     */
    public static MemorySegment g_variant_new_byte$address() {
        return g_variant_new_byte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_byte(guint8 value)
     * }
     */
    public static MemorySegment g_variant_new_byte(byte value) {
        var mh$ = g_variant_new_byte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_byte", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_int16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_int16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int16(gint16 value)
     * }
     */
    public static FunctionDescriptor g_variant_new_int16$descriptor() {
        return g_variant_new_int16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int16(gint16 value)
     * }
     */
    public static MethodHandle g_variant_new_int16$handle() {
        return g_variant_new_int16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int16(gint16 value)
     * }
     */
    public static MemorySegment g_variant_new_int16$address() {
        return g_variant_new_int16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int16(gint16 value)
     * }
     */
    public static MemorySegment g_variant_new_int16(short value) {
        var mh$ = g_variant_new_int16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_int16", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_uint16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_uint16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint16(guint16 value)
     * }
     */
    public static FunctionDescriptor g_variant_new_uint16$descriptor() {
        return g_variant_new_uint16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint16(guint16 value)
     * }
     */
    public static MethodHandle g_variant_new_uint16$handle() {
        return g_variant_new_uint16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint16(guint16 value)
     * }
     */
    public static MemorySegment g_variant_new_uint16$address() {
        return g_variant_new_uint16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint16(guint16 value)
     * }
     */
    public static MemorySegment g_variant_new_uint16(short value) {
        var mh$ = g_variant_new_uint16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_uint16", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_int32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_int32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int32(gint32 value)
     * }
     */
    public static FunctionDescriptor g_variant_new_int32$descriptor() {
        return g_variant_new_int32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int32(gint32 value)
     * }
     */
    public static MethodHandle g_variant_new_int32$handle() {
        return g_variant_new_int32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int32(gint32 value)
     * }
     */
    public static MemorySegment g_variant_new_int32$address() {
        return g_variant_new_int32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int32(gint32 value)
     * }
     */
    public static MemorySegment g_variant_new_int32(int value) {
        var mh$ = g_variant_new_int32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_int32", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_uint32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_uint32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint32(guint32 value)
     * }
     */
    public static FunctionDescriptor g_variant_new_uint32$descriptor() {
        return g_variant_new_uint32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint32(guint32 value)
     * }
     */
    public static MethodHandle g_variant_new_uint32$handle() {
        return g_variant_new_uint32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint32(guint32 value)
     * }
     */
    public static MemorySegment g_variant_new_uint32$address() {
        return g_variant_new_uint32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint32(guint32 value)
     * }
     */
    public static MemorySegment g_variant_new_uint32(int value) {
        var mh$ = g_variant_new_uint32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_uint32", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int64(gint64 value)
     * }
     */
    public static FunctionDescriptor g_variant_new_int64$descriptor() {
        return g_variant_new_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int64(gint64 value)
     * }
     */
    public static MethodHandle g_variant_new_int64$handle() {
        return g_variant_new_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int64(gint64 value)
     * }
     */
    public static MemorySegment g_variant_new_int64$address() {
        return g_variant_new_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_int64(gint64 value)
     * }
     */
    public static MemorySegment g_variant_new_int64(long value) {
        var mh$ = g_variant_new_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_int64", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint64(guint64 value)
     * }
     */
    public static FunctionDescriptor g_variant_new_uint64$descriptor() {
        return g_variant_new_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint64(guint64 value)
     * }
     */
    public static MethodHandle g_variant_new_uint64$handle() {
        return g_variant_new_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint64(guint64 value)
     * }
     */
    public static MemorySegment g_variant_new_uint64$address() {
        return g_variant_new_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_uint64(guint64 value)
     * }
     */
    public static MemorySegment g_variant_new_uint64(long value) {
        var mh$ = g_variant_new_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_uint64", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_handle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_handle(gint32 value)
     * }
     */
    public static FunctionDescriptor g_variant_new_handle$descriptor() {
        return g_variant_new_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_handle(gint32 value)
     * }
     */
    public static MethodHandle g_variant_new_handle$handle() {
        return g_variant_new_handle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_handle(gint32 value)
     * }
     */
    public static MemorySegment g_variant_new_handle$address() {
        return g_variant_new_handle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_handle(gint32 value)
     * }
     */
    public static MemorySegment g_variant_new_handle(int value) {
        var mh$ = g_variant_new_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_handle", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_double(gdouble value)
     * }
     */
    public static FunctionDescriptor g_variant_new_double$descriptor() {
        return g_variant_new_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_double(gdouble value)
     * }
     */
    public static MethodHandle g_variant_new_double$handle() {
        return g_variant_new_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_double(gdouble value)
     * }
     */
    public static MemorySegment g_variant_new_double$address() {
        return g_variant_new_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_double(gdouble value)
     * }
     */
    public static MemorySegment g_variant_new_double(double value) {
        var mh$ = g_variant_new_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_double", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_string(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_variant_new_string$descriptor() {
        return g_variant_new_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_string(const gchar *string)
     * }
     */
    public static MethodHandle g_variant_new_string$handle() {
        return g_variant_new_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_string(const gchar *string)
     * }
     */
    public static MemorySegment g_variant_new_string$address() {
        return g_variant_new_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_string(const gchar *string)
     * }
     */
    public static MemorySegment g_variant_new_string(MemorySegment string) {
        var mh$ = g_variant_new_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_string", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_take_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_take_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_take_string(gchar *string)
     * }
     */
    public static FunctionDescriptor g_variant_new_take_string$descriptor() {
        return g_variant_new_take_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_take_string(gchar *string)
     * }
     */
    public static MethodHandle g_variant_new_take_string$handle() {
        return g_variant_new_take_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_take_string(gchar *string)
     * }
     */
    public static MemorySegment g_variant_new_take_string$address() {
        return g_variant_new_take_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_take_string(gchar *string)
     * }
     */
    public static MemorySegment g_variant_new_take_string(MemorySegment string) {
        var mh$ = g_variant_new_take_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_take_string", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_printf(const gchar *format_string, ...)
     * }
     */
    public static class g_variant_new_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_new_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern GVariant *g_variant_new_printf(const gchar *format_string, ...)
         * }
         */
        public static g_variant_new_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_new_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format_string, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_new_printf", format_string, x1);
                }
                return (MemorySegment) spreader.invokeExact(format_string, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_variant_new_object_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_object_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_object_path(const gchar *object_path)
     * }
     */
    public static FunctionDescriptor g_variant_new_object_path$descriptor() {
        return g_variant_new_object_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_object_path(const gchar *object_path)
     * }
     */
    public static MethodHandle g_variant_new_object_path$handle() {
        return g_variant_new_object_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_object_path(const gchar *object_path)
     * }
     */
    public static MemorySegment g_variant_new_object_path$address() {
        return g_variant_new_object_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_object_path(const gchar *object_path)
     * }
     */
    public static MemorySegment g_variant_new_object_path(MemorySegment object_path) {
        var mh$ = g_variant_new_object_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_object_path", object_path);
            }
            return (MemorySegment)mh$.invokeExact(object_path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_is_object_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_is_object_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_object_path(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_variant_is_object_path$descriptor() {
        return g_variant_is_object_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_object_path(const gchar *string)
     * }
     */
    public static MethodHandle g_variant_is_object_path$handle() {
        return g_variant_is_object_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_object_path(const gchar *string)
     * }
     */
    public static MemorySegment g_variant_is_object_path$address() {
        return g_variant_is_object_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_is_object_path(const gchar *string)
     * }
     */
    public static int g_variant_is_object_path(MemorySegment string) {
        var mh$ = g_variant_is_object_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_is_object_path", string);
            }
            return (int)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_signature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_signature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_signature(const gchar *signature)
     * }
     */
    public static FunctionDescriptor g_variant_new_signature$descriptor() {
        return g_variant_new_signature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_signature(const gchar *signature)
     * }
     */
    public static MethodHandle g_variant_new_signature$handle() {
        return g_variant_new_signature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_signature(const gchar *signature)
     * }
     */
    public static MemorySegment g_variant_new_signature$address() {
        return g_variant_new_signature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_signature(const gchar *signature)
     * }
     */
    public static MemorySegment g_variant_new_signature(MemorySegment signature) {
        var mh$ = g_variant_new_signature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_signature", signature);
            }
            return (MemorySegment)mh$.invokeExact(signature);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_is_signature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_is_signature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_signature(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_variant_is_signature$descriptor() {
        return g_variant_is_signature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_signature(const gchar *string)
     * }
     */
    public static MethodHandle g_variant_is_signature$handle() {
        return g_variant_is_signature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_signature(const gchar *string)
     * }
     */
    public static MemorySegment g_variant_is_signature$address() {
        return g_variant_is_signature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_is_signature(const gchar *string)
     * }
     */
    public static int g_variant_is_signature(MemorySegment string) {
        var mh$ = g_variant_is_signature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_is_signature", string);
            }
            return (int)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_variant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_variant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_variant(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_new_variant$descriptor() {
        return g_variant_new_variant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_variant(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_new_variant$handle() {
        return g_variant_new_variant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_variant(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_new_variant$address() {
        return g_variant_new_variant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_variant(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_new_variant(MemorySegment value) {
        var mh$ = g_variant_new_variant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_variant", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_strv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_strv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_strv(const gchar *const *strv, gssize length)
     * }
     */
    public static FunctionDescriptor g_variant_new_strv$descriptor() {
        return g_variant_new_strv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_strv(const gchar *const *strv, gssize length)
     * }
     */
    public static MethodHandle g_variant_new_strv$handle() {
        return g_variant_new_strv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_strv(const gchar *const *strv, gssize length)
     * }
     */
    public static MemorySegment g_variant_new_strv$address() {
        return g_variant_new_strv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_strv(const gchar *const *strv, gssize length)
     * }
     */
    public static MemorySegment g_variant_new_strv(MemorySegment strv, long length) {
        var mh$ = g_variant_new_strv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_strv", strv, length);
            }
            return (MemorySegment)mh$.invokeExact(strv, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_objv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_objv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_objv(const gchar *const *strv, gssize length)
     * }
     */
    public static FunctionDescriptor g_variant_new_objv$descriptor() {
        return g_variant_new_objv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_objv(const gchar *const *strv, gssize length)
     * }
     */
    public static MethodHandle g_variant_new_objv$handle() {
        return g_variant_new_objv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_objv(const gchar *const *strv, gssize length)
     * }
     */
    public static MemorySegment g_variant_new_objv$address() {
        return g_variant_new_objv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_objv(const gchar *const *strv, gssize length)
     * }
     */
    public static MemorySegment g_variant_new_objv(MemorySegment strv, long length) {
        var mh$ = g_variant_new_objv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_objv", strv, length);
            }
            return (MemorySegment)mh$.invokeExact(strv, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_bytestring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_bytestring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_bytestring(const gchar *string)
     * }
     */
    public static FunctionDescriptor g_variant_new_bytestring$descriptor() {
        return g_variant_new_bytestring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_bytestring(const gchar *string)
     * }
     */
    public static MethodHandle g_variant_new_bytestring$handle() {
        return g_variant_new_bytestring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_bytestring(const gchar *string)
     * }
     */
    public static MemorySegment g_variant_new_bytestring$address() {
        return g_variant_new_bytestring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_bytestring(const gchar *string)
     * }
     */
    public static MemorySegment g_variant_new_bytestring(MemorySegment string) {
        var mh$ = g_variant_new_bytestring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_bytestring", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_bytestring_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_bytestring_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_bytestring_array(const gchar *const *strv, gssize length)
     * }
     */
    public static FunctionDescriptor g_variant_new_bytestring_array$descriptor() {
        return g_variant_new_bytestring_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_bytestring_array(const gchar *const *strv, gssize length)
     * }
     */
    public static MethodHandle g_variant_new_bytestring_array$handle() {
        return g_variant_new_bytestring_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_bytestring_array(const gchar *const *strv, gssize length)
     * }
     */
    public static MemorySegment g_variant_new_bytestring_array$address() {
        return g_variant_new_bytestring_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_bytestring_array(const gchar *const *strv, gssize length)
     * }
     */
    public static MemorySegment g_variant_new_bytestring_array(MemorySegment strv, long length) {
        var mh$ = g_variant_new_bytestring_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_bytestring_array", strv, length);
            }
            return (MemorySegment)mh$.invokeExact(strv, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_fixed_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_fixed_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_fixed_array(const GVariantType *element_type, gconstpointer elements, gsize n_elements, gsize element_size)
     * }
     */
    public static FunctionDescriptor g_variant_new_fixed_array$descriptor() {
        return g_variant_new_fixed_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_fixed_array(const GVariantType *element_type, gconstpointer elements, gsize n_elements, gsize element_size)
     * }
     */
    public static MethodHandle g_variant_new_fixed_array$handle() {
        return g_variant_new_fixed_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_fixed_array(const GVariantType *element_type, gconstpointer elements, gsize n_elements, gsize element_size)
     * }
     */
    public static MemorySegment g_variant_new_fixed_array$address() {
        return g_variant_new_fixed_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_fixed_array(const GVariantType *element_type, gconstpointer elements, gsize n_elements, gsize element_size)
     * }
     */
    public static MemorySegment g_variant_new_fixed_array(MemorySegment element_type, MemorySegment elements, long n_elements, long element_size) {
        var mh$ = g_variant_new_fixed_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_fixed_array", element_type, elements, n_elements, element_size);
            }
            return (MemorySegment)mh$.invokeExact(element_type, elements, n_elements, element_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_boolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_boolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_get_boolean(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_boolean$descriptor() {
        return g_variant_get_boolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_get_boolean(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_boolean$handle() {
        return g_variant_get_boolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_get_boolean(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_boolean$address() {
        return g_variant_get_boolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_get_boolean(GVariant *value)
     * }
     */
    public static int g_variant_get_boolean(MemorySegment value) {
        var mh$ = g_variant_get_boolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_boolean", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_byte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_CHAR,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_byte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint8 g_variant_get_byte(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_byte$descriptor() {
        return g_variant_get_byte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint8 g_variant_get_byte(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_byte$handle() {
        return g_variant_get_byte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint8 g_variant_get_byte(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_byte$address() {
        return g_variant_get_byte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint8 g_variant_get_byte(GVariant *value)
     * }
     */
    public static byte g_variant_get_byte(MemorySegment value) {
        var mh$ = g_variant_get_byte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_byte", value);
            }
            return (byte)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_int16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_SHORT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_int16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint16 g_variant_get_int16(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_int16$descriptor() {
        return g_variant_get_int16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint16 g_variant_get_int16(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_int16$handle() {
        return g_variant_get_int16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint16 g_variant_get_int16(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_int16$address() {
        return g_variant_get_int16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint16 g_variant_get_int16(GVariant *value)
     * }
     */
    public static short g_variant_get_int16(MemorySegment value) {
        var mh$ = g_variant_get_int16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_int16", value);
            }
            return (short)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_uint16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_SHORT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_uint16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint16 g_variant_get_uint16(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_uint16$descriptor() {
        return g_variant_get_uint16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint16 g_variant_get_uint16(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_uint16$handle() {
        return g_variant_get_uint16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint16 g_variant_get_uint16(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_uint16$address() {
        return g_variant_get_uint16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint16 g_variant_get_uint16(GVariant *value)
     * }
     */
    public static short g_variant_get_uint16(MemorySegment value) {
        var mh$ = g_variant_get_uint16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_uint16", value);
            }
            return (short)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_int32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_int32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint32 g_variant_get_int32(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_int32$descriptor() {
        return g_variant_get_int32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint32 g_variant_get_int32(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_int32$handle() {
        return g_variant_get_int32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint32 g_variant_get_int32(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_int32$address() {
        return g_variant_get_int32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint32 g_variant_get_int32(GVariant *value)
     * }
     */
    public static int g_variant_get_int32(MemorySegment value) {
        var mh$ = g_variant_get_int32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_int32", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_uint32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_uint32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint32 g_variant_get_uint32(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_uint32$descriptor() {
        return g_variant_get_uint32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint32 g_variant_get_uint32(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_uint32$handle() {
        return g_variant_get_uint32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint32 g_variant_get_uint32(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_uint32$address() {
        return g_variant_get_uint32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint32 g_variant_get_uint32(GVariant *value)
     * }
     */
    public static int g_variant_get_uint32(MemorySegment value) {
        var mh$ = g_variant_get_uint32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_uint32", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_variant_get_int64(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_int64$descriptor() {
        return g_variant_get_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_variant_get_int64(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_int64$handle() {
        return g_variant_get_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_variant_get_int64(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_int64$address() {
        return g_variant_get_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_variant_get_int64(GVariant *value)
     * }
     */
    public static long g_variant_get_int64(MemorySegment value) {
        var mh$ = g_variant_get_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_int64", value);
            }
            return (long)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint64 g_variant_get_uint64(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_uint64$descriptor() {
        return g_variant_get_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint64 g_variant_get_uint64(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_uint64$handle() {
        return g_variant_get_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint64 g_variant_get_uint64(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_uint64$address() {
        return g_variant_get_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint64 g_variant_get_uint64(GVariant *value)
     * }
     */
    public static long g_variant_get_uint64(MemorySegment value) {
        var mh$ = g_variant_get_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_uint64", value);
            }
            return (long)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_handle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint32 g_variant_get_handle(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_handle$descriptor() {
        return g_variant_get_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint32 g_variant_get_handle(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_handle$handle() {
        return g_variant_get_handle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint32 g_variant_get_handle(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_handle$address() {
        return g_variant_get_handle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint32 g_variant_get_handle(GVariant *value)
     * }
     */
    public static int g_variant_get_handle(MemorySegment value) {
        var mh$ = g_variant_get_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_handle", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_variant_get_double(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_double$descriptor() {
        return g_variant_get_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_variant_get_double(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_double$handle() {
        return g_variant_get_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_variant_get_double(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_double$address() {
        return g_variant_get_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_variant_get_double(GVariant *value)
     * }
     */
    public static double g_variant_get_double(MemorySegment value) {
        var mh$ = g_variant_get_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_double", value);
            }
            return (double)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_variant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_variant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_variant(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_variant$descriptor() {
        return g_variant_get_variant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_variant(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_variant$handle() {
        return g_variant_get_variant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_variant(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_variant$address() {
        return g_variant_get_variant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_variant(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_variant(MemorySegment value) {
        var mh$ = g_variant_get_variant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_variant", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_string(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_get_string$descriptor() {
        return g_variant_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_string(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_get_string$handle() {
        return g_variant_get_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_string(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_get_string$address() {
        return g_variant_get_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_string(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_get_string(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_string", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dup_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dup_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_variant_dup_string(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_dup_string$descriptor() {
        return g_variant_dup_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_variant_dup_string(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_dup_string$handle() {
        return g_variant_dup_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_variant_dup_string(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_string$address() {
        return g_variant_dup_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_variant_dup_string(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_string(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_dup_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dup_string", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_strv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_strv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_strv(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_get_strv$descriptor() {
        return g_variant_get_strv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_strv(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_get_strv$handle() {
        return g_variant_get_strv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_strv(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_get_strv$address() {
        return g_variant_get_strv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_strv(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_get_strv(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_get_strv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_strv", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dup_strv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dup_strv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_strv(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_dup_strv$descriptor() {
        return g_variant_dup_strv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_strv(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_dup_strv$handle() {
        return g_variant_dup_strv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_strv(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_strv$address() {
        return g_variant_dup_strv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_strv(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_strv(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_dup_strv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dup_strv", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_objv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_objv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_objv(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_get_objv$descriptor() {
        return g_variant_get_objv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_objv(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_get_objv$handle() {
        return g_variant_get_objv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_objv(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_get_objv$address() {
        return g_variant_get_objv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_objv(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_get_objv(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_get_objv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_objv", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dup_objv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dup_objv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_objv(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_dup_objv$descriptor() {
        return g_variant_dup_objv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_objv(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_dup_objv$handle() {
        return g_variant_dup_objv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_objv(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_objv$address() {
        return g_variant_dup_objv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_objv(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_objv(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_dup_objv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dup_objv", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_bytestring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_bytestring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_bytestring(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_bytestring$descriptor() {
        return g_variant_get_bytestring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_bytestring(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_bytestring$handle() {
        return g_variant_get_bytestring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_bytestring(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_bytestring$address() {
        return g_variant_get_bytestring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_variant_get_bytestring(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_bytestring(MemorySegment value) {
        var mh$ = g_variant_get_bytestring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_bytestring", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dup_bytestring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dup_bytestring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_variant_dup_bytestring(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_dup_bytestring$descriptor() {
        return g_variant_dup_bytestring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_variant_dup_bytestring(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_dup_bytestring$handle() {
        return g_variant_dup_bytestring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_variant_dup_bytestring(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_bytestring$address() {
        return g_variant_dup_bytestring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_variant_dup_bytestring(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_bytestring(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_dup_bytestring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dup_bytestring", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_bytestring_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_bytestring_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_bytestring_array(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_get_bytestring_array$descriptor() {
        return g_variant_get_bytestring_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_bytestring_array(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_get_bytestring_array$handle() {
        return g_variant_get_bytestring_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_bytestring_array(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_get_bytestring_array$address() {
        return g_variant_get_bytestring_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar **g_variant_get_bytestring_array(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_get_bytestring_array(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_get_bytestring_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_bytestring_array", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dup_bytestring_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dup_bytestring_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_bytestring_array(GVariant *value, gsize *length)
     * }
     */
    public static FunctionDescriptor g_variant_dup_bytestring_array$descriptor() {
        return g_variant_dup_bytestring_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_bytestring_array(GVariant *value, gsize *length)
     * }
     */
    public static MethodHandle g_variant_dup_bytestring_array$handle() {
        return g_variant_dup_bytestring_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_bytestring_array(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_bytestring_array$address() {
        return g_variant_dup_bytestring_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_variant_dup_bytestring_array(GVariant *value, gsize *length)
     * }
     */
    public static MemorySegment g_variant_dup_bytestring_array(MemorySegment value, MemorySegment length) {
        var mh$ = g_variant_dup_bytestring_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dup_bytestring_array", value, length);
            }
            return (MemorySegment)mh$.invokeExact(value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_maybe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_maybe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_maybe(const GVariantType *child_type, GVariant *child)
     * }
     */
    public static FunctionDescriptor g_variant_new_maybe$descriptor() {
        return g_variant_new_maybe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_maybe(const GVariantType *child_type, GVariant *child)
     * }
     */
    public static MethodHandle g_variant_new_maybe$handle() {
        return g_variant_new_maybe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_maybe(const GVariantType *child_type, GVariant *child)
     * }
     */
    public static MemorySegment g_variant_new_maybe$address() {
        return g_variant_new_maybe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_maybe(const GVariantType *child_type, GVariant *child)
     * }
     */
    public static MemorySegment g_variant_new_maybe(MemorySegment child_type, MemorySegment child) {
        var mh$ = g_variant_new_maybe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_maybe", child_type, child);
            }
            return (MemorySegment)mh$.invokeExact(child_type, child);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_array(const GVariantType *child_type, GVariant *const *children, gsize n_children)
     * }
     */
    public static FunctionDescriptor g_variant_new_array$descriptor() {
        return g_variant_new_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_array(const GVariantType *child_type, GVariant *const *children, gsize n_children)
     * }
     */
    public static MethodHandle g_variant_new_array$handle() {
        return g_variant_new_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_array(const GVariantType *child_type, GVariant *const *children, gsize n_children)
     * }
     */
    public static MemorySegment g_variant_new_array$address() {
        return g_variant_new_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_array(const GVariantType *child_type, GVariant *const *children, gsize n_children)
     * }
     */
    public static MemorySegment g_variant_new_array(MemorySegment child_type, MemorySegment children, long n_children) {
        var mh$ = g_variant_new_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_array", child_type, children, n_children);
            }
            return (MemorySegment)mh$.invokeExact(child_type, children, n_children);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_tuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_tuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_tuple(GVariant *const *children, gsize n_children)
     * }
     */
    public static FunctionDescriptor g_variant_new_tuple$descriptor() {
        return g_variant_new_tuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_tuple(GVariant *const *children, gsize n_children)
     * }
     */
    public static MethodHandle g_variant_new_tuple$handle() {
        return g_variant_new_tuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_tuple(GVariant *const *children, gsize n_children)
     * }
     */
    public static MemorySegment g_variant_new_tuple$address() {
        return g_variant_new_tuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_tuple(GVariant *const *children, gsize n_children)
     * }
     */
    public static MemorySegment g_variant_new_tuple(MemorySegment children, long n_children) {
        var mh$ = g_variant_new_tuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_tuple", children, n_children);
            }
            return (MemorySegment)mh$.invokeExact(children, n_children);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_dict_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_dict_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_dict_entry(GVariant *key, GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_new_dict_entry$descriptor() {
        return g_variant_new_dict_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_dict_entry(GVariant *key, GVariant *value)
     * }
     */
    public static MethodHandle g_variant_new_dict_entry$handle() {
        return g_variant_new_dict_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_dict_entry(GVariant *key, GVariant *value)
     * }
     */
    public static MemorySegment g_variant_new_dict_entry$address() {
        return g_variant_new_dict_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_dict_entry(GVariant *key, GVariant *value)
     * }
     */
    public static MemorySegment g_variant_new_dict_entry(MemorySegment key, MemorySegment value) {
        var mh$ = g_variant_new_dict_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_dict_entry", key, value);
            }
            return (MemorySegment)mh$.invokeExact(key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_maybe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_maybe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_maybe(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_maybe$descriptor() {
        return g_variant_get_maybe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_maybe(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_maybe$handle() {
        return g_variant_get_maybe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_maybe(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_maybe$address() {
        return g_variant_get_maybe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_maybe(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_maybe(MemorySegment value) {
        var mh$ = g_variant_get_maybe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_maybe", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_n_children {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_n_children");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_variant_n_children(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_n_children$descriptor() {
        return g_variant_n_children.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_variant_n_children(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_n_children$handle() {
        return g_variant_n_children.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_variant_n_children(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_n_children$address() {
        return g_variant_n_children.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_variant_n_children(GVariant *value)
     * }
     */
    public static long g_variant_n_children(MemorySegment value) {
        var mh$ = g_variant_n_children.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_n_children", value);
            }
            return (long)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_variant_get_child(GVariant *value, gsize index_, const gchar *format_string, ...)
     * }
     */
    public static class g_variant_get_child {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_LONG_LONG,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_child");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_get_child(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_variant_get_child(GVariant *value, gsize index_, const gchar *format_string, ...)
         * }
         */
        public static g_variant_get_child makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_get_child(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment value, long index_, MemorySegment format_string, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_get_child", value, index_, format_string, x3);
                }
                 spreader.invokeExact(value, index_, format_string, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_variant_get_child_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_child_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_child_value(GVariant *value, gsize index_)
     * }
     */
    public static FunctionDescriptor g_variant_get_child_value$descriptor() {
        return g_variant_get_child_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_child_value(GVariant *value, gsize index_)
     * }
     */
    public static MethodHandle g_variant_get_child_value$handle() {
        return g_variant_get_child_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_child_value(GVariant *value, gsize index_)
     * }
     */
    public static MemorySegment g_variant_get_child_value$address() {
        return g_variant_get_child_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_child_value(GVariant *value, gsize index_)
     * }
     */
    public static MemorySegment g_variant_get_child_value(MemorySegment value, long index_) {
        var mh$ = g_variant_get_child_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_child_value", value, index_);
            }
            return (MemorySegment)mh$.invokeExact(value, index_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gboolean g_variant_lookup(GVariant *dictionary, const gchar *key, const gchar *format_string, ...)
     * }
     */
    public static class g_variant_lookup {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_lookup");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_lookup(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gboolean g_variant_lookup(GVariant *dictionary, const gchar *key, const gchar *format_string, ...)
         * }
         */
        public static g_variant_lookup makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_lookup(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment dictionary, MemorySegment key, MemorySegment format_string, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_lookup", dictionary, key, format_string, x3);
                }
                return (int) spreader.invokeExact(dictionary, key, format_string, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_variant_lookup_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_lookup_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_lookup_value(GVariant *dictionary, const gchar *key, const GVariantType *expected_type)
     * }
     */
    public static FunctionDescriptor g_variant_lookup_value$descriptor() {
        return g_variant_lookup_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_lookup_value(GVariant *dictionary, const gchar *key, const GVariantType *expected_type)
     * }
     */
    public static MethodHandle g_variant_lookup_value$handle() {
        return g_variant_lookup_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_lookup_value(GVariant *dictionary, const gchar *key, const GVariantType *expected_type)
     * }
     */
    public static MemorySegment g_variant_lookup_value$address() {
        return g_variant_lookup_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_lookup_value(GVariant *dictionary, const gchar *key, const GVariantType *expected_type)
     * }
     */
    public static MemorySegment g_variant_lookup_value(MemorySegment dictionary, MemorySegment key, MemorySegment expected_type) {
        var mh$ = g_variant_lookup_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_lookup_value", dictionary, key, expected_type);
            }
            return (MemorySegment)mh$.invokeExact(dictionary, key, expected_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_fixed_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_fixed_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gconstpointer g_variant_get_fixed_array(GVariant *value, gsize *n_elements, gsize element_size)
     * }
     */
    public static FunctionDescriptor g_variant_get_fixed_array$descriptor() {
        return g_variant_get_fixed_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gconstpointer g_variant_get_fixed_array(GVariant *value, gsize *n_elements, gsize element_size)
     * }
     */
    public static MethodHandle g_variant_get_fixed_array$handle() {
        return g_variant_get_fixed_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gconstpointer g_variant_get_fixed_array(GVariant *value, gsize *n_elements, gsize element_size)
     * }
     */
    public static MemorySegment g_variant_get_fixed_array$address() {
        return g_variant_get_fixed_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gconstpointer g_variant_get_fixed_array(GVariant *value, gsize *n_elements, gsize element_size)
     * }
     */
    public static MemorySegment g_variant_get_fixed_array(MemorySegment value, MemorySegment n_elements, long element_size) {
        var mh$ = g_variant_get_fixed_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_fixed_array", value, n_elements, element_size);
            }
            return (MemorySegment)mh$.invokeExact(value, n_elements, element_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_variant_get_size(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_size$descriptor() {
        return g_variant_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_variant_get_size(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_size$handle() {
        return g_variant_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_variant_get_size(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_size$address() {
        return g_variant_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_variant_get_size(GVariant *value)
     * }
     */
    public static long g_variant_get_size(MemorySegment value) {
        var mh$ = g_variant_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_size", value);
            }
            return (long)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gconstpointer g_variant_get_data(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_data$descriptor() {
        return g_variant_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gconstpointer g_variant_get_data(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_data$handle() {
        return g_variant_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gconstpointer g_variant_get_data(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_data$address() {
        return g_variant_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gconstpointer g_variant_get_data(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_data(MemorySegment value) {
        var mh$ = g_variant_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_data", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_data_as_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_data_as_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GBytes *g_variant_get_data_as_bytes(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_data_as_bytes$descriptor() {
        return g_variant_get_data_as_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GBytes *g_variant_get_data_as_bytes(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_data_as_bytes$handle() {
        return g_variant_get_data_as_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GBytes *g_variant_get_data_as_bytes(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_data_as_bytes$address() {
        return g_variant_get_data_as_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GBytes *g_variant_get_data_as_bytes(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_data_as_bytes(MemorySegment value) {
        var mh$ = g_variant_get_data_as_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_data_as_bytes", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_store {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_store");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_store(GVariant *value, gpointer data)
     * }
     */
    public static FunctionDescriptor g_variant_store$descriptor() {
        return g_variant_store.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_store(GVariant *value, gpointer data)
     * }
     */
    public static MethodHandle g_variant_store$handle() {
        return g_variant_store.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_store(GVariant *value, gpointer data)
     * }
     */
    public static MemorySegment g_variant_store$address() {
        return g_variant_store.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_store(GVariant *value, gpointer data)
     * }
     */
    public static void g_variant_store(MemorySegment value, MemorySegment data) {
        var mh$ = g_variant_store.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_store", value, data);
            }
            mh$.invokeExact(value, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_variant_print(GVariant *value, gboolean type_annotate)
     * }
     */
    public static FunctionDescriptor g_variant_print$descriptor() {
        return g_variant_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_variant_print(GVariant *value, gboolean type_annotate)
     * }
     */
    public static MethodHandle g_variant_print$handle() {
        return g_variant_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_variant_print(GVariant *value, gboolean type_annotate)
     * }
     */
    public static MemorySegment g_variant_print$address() {
        return g_variant_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_variant_print(GVariant *value, gboolean type_annotate)
     * }
     */
    public static MemorySegment g_variant_print(MemorySegment value, int type_annotate) {
        var mh$ = g_variant_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_print", value, type_annotate);
            }
            return (MemorySegment)mh$.invokeExact(value, type_annotate);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_print_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_print_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GString *g_variant_print_string(GVariant *value, GString *string, gboolean type_annotate)
     * }
     */
    public static FunctionDescriptor g_variant_print_string$descriptor() {
        return g_variant_print_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GString *g_variant_print_string(GVariant *value, GString *string, gboolean type_annotate)
     * }
     */
    public static MethodHandle g_variant_print_string$handle() {
        return g_variant_print_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GString *g_variant_print_string(GVariant *value, GString *string, gboolean type_annotate)
     * }
     */
    public static MemorySegment g_variant_print_string$address() {
        return g_variant_print_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GString *g_variant_print_string(GVariant *value, GString *string, gboolean type_annotate)
     * }
     */
    public static MemorySegment g_variant_print_string(MemorySegment value, MemorySegment string, int type_annotate) {
        var mh$ = g_variant_print_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_print_string", value, string, type_annotate);
            }
            return (MemorySegment)mh$.invokeExact(value, string, type_annotate);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_variant_hash(gconstpointer value)
     * }
     */
    public static FunctionDescriptor g_variant_hash$descriptor() {
        return g_variant_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_variant_hash(gconstpointer value)
     * }
     */
    public static MethodHandle g_variant_hash$handle() {
        return g_variant_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_variant_hash(gconstpointer value)
     * }
     */
    public static MemorySegment g_variant_hash$address() {
        return g_variant_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_variant_hash(gconstpointer value)
     * }
     */
    public static int g_variant_hash(MemorySegment value) {
        var mh$ = g_variant_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_hash", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_equal(gconstpointer one, gconstpointer two)
     * }
     */
    public static FunctionDescriptor g_variant_equal$descriptor() {
        return g_variant_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_equal(gconstpointer one, gconstpointer two)
     * }
     */
    public static MethodHandle g_variant_equal$handle() {
        return g_variant_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_equal(gconstpointer one, gconstpointer two)
     * }
     */
    public static MemorySegment g_variant_equal$address() {
        return g_variant_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_equal(gconstpointer one, gconstpointer two)
     * }
     */
    public static int g_variant_equal(MemorySegment one, MemorySegment two) {
        var mh$ = g_variant_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_equal", one, two);
            }
            return (int)mh$.invokeExact(one, two);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_normal_form {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_normal_form");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_normal_form(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_get_normal_form$descriptor() {
        return g_variant_get_normal_form.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_normal_form(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_get_normal_form$handle() {
        return g_variant_get_normal_form.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_normal_form(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_normal_form$address() {
        return g_variant_get_normal_form.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_get_normal_form(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_get_normal_form(MemorySegment value) {
        var mh$ = g_variant_get_normal_form.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_normal_form", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_is_normal_form {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_is_normal_form");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_normal_form(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_is_normal_form$descriptor() {
        return g_variant_is_normal_form.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_normal_form(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_is_normal_form$handle() {
        return g_variant_is_normal_form.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_is_normal_form(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_is_normal_form$address() {
        return g_variant_is_normal_form.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_is_normal_form(GVariant *value)
     * }
     */
    public static int g_variant_is_normal_form(MemorySegment value) {
        var mh$ = g_variant_is_normal_form.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_is_normal_form", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_byteswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_byteswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_byteswap(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_byteswap$descriptor() {
        return g_variant_byteswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_byteswap(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_byteswap$handle() {
        return g_variant_byteswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_byteswap(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_byteswap$address() {
        return g_variant_byteswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_byteswap(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_byteswap(MemorySegment value) {
        var mh$ = g_variant_byteswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_byteswap", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_from_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_from_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_from_bytes(const GVariantType *type, GBytes *bytes, gboolean trusted)
     * }
     */
    public static FunctionDescriptor g_variant_new_from_bytes$descriptor() {
        return g_variant_new_from_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_from_bytes(const GVariantType *type, GBytes *bytes, gboolean trusted)
     * }
     */
    public static MethodHandle g_variant_new_from_bytes$handle() {
        return g_variant_new_from_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_from_bytes(const GVariantType *type, GBytes *bytes, gboolean trusted)
     * }
     */
    public static MemorySegment g_variant_new_from_bytes$address() {
        return g_variant_new_from_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_from_bytes(const GVariantType *type, GBytes *bytes, gboolean trusted)
     * }
     */
    public static MemorySegment g_variant_new_from_bytes(MemorySegment type, MemorySegment bytes, int trusted) {
        var mh$ = g_variant_new_from_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_from_bytes", type, bytes, trusted);
            }
            return (MemorySegment)mh$.invokeExact(type, bytes, trusted);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_new_from_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_from_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_from_data(const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_variant_new_from_data$descriptor() {
        return g_variant_new_from_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_from_data(const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data)
     * }
     */
    public static MethodHandle g_variant_new_from_data$handle() {
        return g_variant_new_from_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_from_data(const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data)
     * }
     */
    public static MemorySegment g_variant_new_from_data$address() {
        return g_variant_new_from_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_from_data(const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data)
     * }
     */
    public static MemorySegment g_variant_new_from_data(MemorySegment type, MemorySegment data, long size, int trusted, MemorySegment notify, MemorySegment user_data) {
        var mh$ = g_variant_new_from_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_from_data", type, data, size, trusted, notify, user_data);
            }
            return (MemorySegment)mh$.invokeExact(type, data, size, trusted, notify, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_iter_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_iter_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantIter *g_variant_iter_new(GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_iter_new$descriptor() {
        return g_variant_iter_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantIter *g_variant_iter_new(GVariant *value)
     * }
     */
    public static MethodHandle g_variant_iter_new$handle() {
        return g_variant_iter_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantIter *g_variant_iter_new(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_iter_new$address() {
        return g_variant_iter_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantIter *g_variant_iter_new(GVariant *value)
     * }
     */
    public static MemorySegment g_variant_iter_new(MemorySegment value) {
        var mh$ = g_variant_iter_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_iter_new", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_iter_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_iter_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_variant_iter_init(GVariantIter *iter, GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_iter_init$descriptor() {
        return g_variant_iter_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_variant_iter_init(GVariantIter *iter, GVariant *value)
     * }
     */
    public static MethodHandle g_variant_iter_init$handle() {
        return g_variant_iter_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_variant_iter_init(GVariantIter *iter, GVariant *value)
     * }
     */
    public static MemorySegment g_variant_iter_init$address() {
        return g_variant_iter_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_variant_iter_init(GVariantIter *iter, GVariant *value)
     * }
     */
    public static long g_variant_iter_init(MemorySegment iter, MemorySegment value) {
        var mh$ = g_variant_iter_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_iter_init", iter, value);
            }
            return (long)mh$.invokeExact(iter, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_iter_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_iter_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantIter *g_variant_iter_copy(GVariantIter *iter)
     * }
     */
    public static FunctionDescriptor g_variant_iter_copy$descriptor() {
        return g_variant_iter_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantIter *g_variant_iter_copy(GVariantIter *iter)
     * }
     */
    public static MethodHandle g_variant_iter_copy$handle() {
        return g_variant_iter_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantIter *g_variant_iter_copy(GVariantIter *iter)
     * }
     */
    public static MemorySegment g_variant_iter_copy$address() {
        return g_variant_iter_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantIter *g_variant_iter_copy(GVariantIter *iter)
     * }
     */
    public static MemorySegment g_variant_iter_copy(MemorySegment iter) {
        var mh$ = g_variant_iter_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_iter_copy", iter);
            }
            return (MemorySegment)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_iter_n_children {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_iter_n_children");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_variant_iter_n_children(GVariantIter *iter)
     * }
     */
    public static FunctionDescriptor g_variant_iter_n_children$descriptor() {
        return g_variant_iter_n_children.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_variant_iter_n_children(GVariantIter *iter)
     * }
     */
    public static MethodHandle g_variant_iter_n_children$handle() {
        return g_variant_iter_n_children.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_variant_iter_n_children(GVariantIter *iter)
     * }
     */
    public static MemorySegment g_variant_iter_n_children$address() {
        return g_variant_iter_n_children.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_variant_iter_n_children(GVariantIter *iter)
     * }
     */
    public static long g_variant_iter_n_children(MemorySegment iter) {
        var mh$ = g_variant_iter_n_children.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_iter_n_children", iter);
            }
            return (long)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_iter_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_iter_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_iter_free(GVariantIter *iter)
     * }
     */
    public static FunctionDescriptor g_variant_iter_free$descriptor() {
        return g_variant_iter_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_iter_free(GVariantIter *iter)
     * }
     */
    public static MethodHandle g_variant_iter_free$handle() {
        return g_variant_iter_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_iter_free(GVariantIter *iter)
     * }
     */
    public static MemorySegment g_variant_iter_free$address() {
        return g_variant_iter_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_iter_free(GVariantIter *iter)
     * }
     */
    public static void g_variant_iter_free(MemorySegment iter) {
        var mh$ = g_variant_iter_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_iter_free", iter);
            }
            mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_iter_next_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_iter_next_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_iter_next_value(GVariantIter *iter)
     * }
     */
    public static FunctionDescriptor g_variant_iter_next_value$descriptor() {
        return g_variant_iter_next_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_iter_next_value(GVariantIter *iter)
     * }
     */
    public static MethodHandle g_variant_iter_next_value$handle() {
        return g_variant_iter_next_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_iter_next_value(GVariantIter *iter)
     * }
     */
    public static MemorySegment g_variant_iter_next_value$address() {
        return g_variant_iter_next_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_iter_next_value(GVariantIter *iter)
     * }
     */
    public static MemorySegment g_variant_iter_next_value(MemorySegment iter) {
        var mh$ = g_variant_iter_next_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_iter_next_value", iter);
            }
            return (MemorySegment)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gboolean g_variant_iter_next(GVariantIter *iter, const gchar *format_string, ...)
     * }
     */
    public static class g_variant_iter_next {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_iter_next");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_iter_next(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gboolean g_variant_iter_next(GVariantIter *iter, const gchar *format_string, ...)
         * }
         */
        public static g_variant_iter_next makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_iter_next(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment iter, MemorySegment format_string, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_iter_next", iter, format_string, x2);
                }
                return (int) spreader.invokeExact(iter, format_string, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gboolean g_variant_iter_loop(GVariantIter *iter, const gchar *format_string, ...)
     * }
     */
    public static class g_variant_iter_loop {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_iter_loop");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_iter_loop(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gboolean g_variant_iter_loop(GVariantIter *iter, const gchar *format_string, ...)
         * }
         */
        public static g_variant_iter_loop makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_iter_loop(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment iter, MemorySegment format_string, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_iter_loop", iter, format_string, x2);
                }
                return (int) spreader.invokeExact(iter, format_string, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    private static final int G_VARIANT_PARSE_ERROR_FAILED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_FAILED = 0
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_FAILED() {
        return G_VARIANT_PARSE_ERROR_FAILED;
    }
    private static final int G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED() {
        return G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED;
    }
    private static final int G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE() {
        return G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE;
    }
    private static final int G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED() {
        return G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED;
    }
    private static final int G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END() {
        return G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END;
    }
    private static final int G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_INVALID_CHARACTER() {
        return G_VARIANT_PARSE_ERROR_INVALID_CHARACTER;
    }
    private static final int G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING() {
        return G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING;
    }
    private static final int G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH() {
        return G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH;
    }
    private static final int G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE() {
        return G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE;
    }
    private static final int G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING() {
        return G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING;
    }
    private static final int G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE() {
        return G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE;
    }
    private static final int G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE() {
        return G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE;
    }
    private static final int G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG() {
        return G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG;
    }
    private static final int G_VARIANT_PARSE_ERROR_TYPE_ERROR = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_TYPE_ERROR() {
        return G_VARIANT_PARSE_ERROR_TYPE_ERROR;
    }
    private static final int G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN() {
        return G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN;
    }
    private static final int G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD() {
        return G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD;
    }
    private static final int G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT() {
        return G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT;
    }
    private static final int G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_VALUE_EXPECTED() {
        return G_VARIANT_PARSE_ERROR_VALUE_EXPECTED;
    }
    private static final int G_VARIANT_PARSE_ERROR_RECURSION = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_VARIANT_PARSE_ERROR_RECURSION = 18
     * }
     */
    public static int G_VARIANT_PARSE_ERROR_RECURSION() {
        return G_VARIANT_PARSE_ERROR_RECURSION;
    }

    private static class g_variant_parser_get_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_parser_get_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_variant_parser_get_error_quark()
     * }
     */
    public static FunctionDescriptor g_variant_parser_get_error_quark$descriptor() {
        return g_variant_parser_get_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_variant_parser_get_error_quark()
     * }
     */
    public static MethodHandle g_variant_parser_get_error_quark$handle() {
        return g_variant_parser_get_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_variant_parser_get_error_quark()
     * }
     */
    public static MemorySegment g_variant_parser_get_error_quark$address() {
        return g_variant_parser_get_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_variant_parser_get_error_quark()
     * }
     */
    public static int g_variant_parser_get_error_quark() {
        var mh$ = g_variant_parser_get_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_parser_get_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_parse_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_parse_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_variant_parse_error_quark()
     * }
     */
    public static FunctionDescriptor g_variant_parse_error_quark$descriptor() {
        return g_variant_parse_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_variant_parse_error_quark()
     * }
     */
    public static MethodHandle g_variant_parse_error_quark$handle() {
        return g_variant_parse_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_variant_parse_error_quark()
     * }
     */
    public static MemorySegment g_variant_parse_error_quark$address() {
        return g_variant_parse_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_variant_parse_error_quark()
     * }
     */
    public static int g_variant_parse_error_quark() {
        var mh$ = g_variant_parse_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_parse_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantBuilder *g_variant_builder_new(const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_builder_new$descriptor() {
        return g_variant_builder_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantBuilder *g_variant_builder_new(const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_builder_new$handle() {
        return g_variant_builder_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantBuilder *g_variant_builder_new(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_builder_new$address() {
        return g_variant_builder_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantBuilder *g_variant_builder_new(const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_builder_new(MemorySegment type) {
        var mh$ = g_variant_builder_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_new", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_builder_unref(GVariantBuilder *builder)
     * }
     */
    public static FunctionDescriptor g_variant_builder_unref$descriptor() {
        return g_variant_builder_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_builder_unref(GVariantBuilder *builder)
     * }
     */
    public static MethodHandle g_variant_builder_unref$handle() {
        return g_variant_builder_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_builder_unref(GVariantBuilder *builder)
     * }
     */
    public static MemorySegment g_variant_builder_unref$address() {
        return g_variant_builder_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_builder_unref(GVariantBuilder *builder)
     * }
     */
    public static void g_variant_builder_unref(MemorySegment builder) {
        var mh$ = g_variant_builder_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_unref", builder);
            }
            mh$.invokeExact(builder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder)
     * }
     */
    public static FunctionDescriptor g_variant_builder_ref$descriptor() {
        return g_variant_builder_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder)
     * }
     */
    public static MethodHandle g_variant_builder_ref$handle() {
        return g_variant_builder_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder)
     * }
     */
    public static MemorySegment g_variant_builder_ref$address() {
        return g_variant_builder_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder)
     * }
     */
    public static MemorySegment g_variant_builder_ref(MemorySegment builder) {
        var mh$ = g_variant_builder_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_ref", builder);
            }
            return (MemorySegment)mh$.invokeExact(builder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_builder_init(GVariantBuilder *builder, const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_builder_init$descriptor() {
        return g_variant_builder_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_builder_init(GVariantBuilder *builder, const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_builder_init$handle() {
        return g_variant_builder_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_builder_init(GVariantBuilder *builder, const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_builder_init$address() {
        return g_variant_builder_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_builder_init(GVariantBuilder *builder, const GVariantType *type)
     * }
     */
    public static void g_variant_builder_init(MemorySegment builder, MemorySegment type) {
        var mh$ = g_variant_builder_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_init", builder, type);
            }
            mh$.invokeExact(builder, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_builder_end(GVariantBuilder *builder)
     * }
     */
    public static FunctionDescriptor g_variant_builder_end$descriptor() {
        return g_variant_builder_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_builder_end(GVariantBuilder *builder)
     * }
     */
    public static MethodHandle g_variant_builder_end$handle() {
        return g_variant_builder_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_builder_end(GVariantBuilder *builder)
     * }
     */
    public static MemorySegment g_variant_builder_end$address() {
        return g_variant_builder_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_builder_end(GVariantBuilder *builder)
     * }
     */
    public static MemorySegment g_variant_builder_end(MemorySegment builder) {
        var mh$ = g_variant_builder_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_end", builder);
            }
            return (MemorySegment)mh$.invokeExact(builder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_builder_clear(GVariantBuilder *builder)
     * }
     */
    public static FunctionDescriptor g_variant_builder_clear$descriptor() {
        return g_variant_builder_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_builder_clear(GVariantBuilder *builder)
     * }
     */
    public static MethodHandle g_variant_builder_clear$handle() {
        return g_variant_builder_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_builder_clear(GVariantBuilder *builder)
     * }
     */
    public static MemorySegment g_variant_builder_clear$address() {
        return g_variant_builder_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_builder_clear(GVariantBuilder *builder)
     * }
     */
    public static void g_variant_builder_clear(MemorySegment builder) {
        var mh$ = g_variant_builder_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_clear", builder);
            }
            mh$.invokeExact(builder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_builder_open(GVariantBuilder *builder, const GVariantType *type)
     * }
     */
    public static FunctionDescriptor g_variant_builder_open$descriptor() {
        return g_variant_builder_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_builder_open(GVariantBuilder *builder, const GVariantType *type)
     * }
     */
    public static MethodHandle g_variant_builder_open$handle() {
        return g_variant_builder_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_builder_open(GVariantBuilder *builder, const GVariantType *type)
     * }
     */
    public static MemorySegment g_variant_builder_open$address() {
        return g_variant_builder_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_builder_open(GVariantBuilder *builder, const GVariantType *type)
     * }
     */
    public static void g_variant_builder_open(MemorySegment builder, MemorySegment type) {
        var mh$ = g_variant_builder_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_open", builder, type);
            }
            mh$.invokeExact(builder, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_builder_close(GVariantBuilder *builder)
     * }
     */
    public static FunctionDescriptor g_variant_builder_close$descriptor() {
        return g_variant_builder_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_builder_close(GVariantBuilder *builder)
     * }
     */
    public static MethodHandle g_variant_builder_close$handle() {
        return g_variant_builder_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_builder_close(GVariantBuilder *builder)
     * }
     */
    public static MemorySegment g_variant_builder_close$address() {
        return g_variant_builder_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_builder_close(GVariantBuilder *builder)
     * }
     */
    public static void g_variant_builder_close(MemorySegment builder) {
        var mh$ = g_variant_builder_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_close", builder);
            }
            mh$.invokeExact(builder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_builder_add_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_add_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_builder_add_value(GVariantBuilder *builder, GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_builder_add_value$descriptor() {
        return g_variant_builder_add_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_builder_add_value(GVariantBuilder *builder, GVariant *value)
     * }
     */
    public static MethodHandle g_variant_builder_add_value$handle() {
        return g_variant_builder_add_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_builder_add_value(GVariantBuilder *builder, GVariant *value)
     * }
     */
    public static MemorySegment g_variant_builder_add_value$address() {
        return g_variant_builder_add_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_builder_add_value(GVariantBuilder *builder, GVariant *value)
     * }
     */
    public static void g_variant_builder_add_value(MemorySegment builder, MemorySegment value) {
        var mh$ = g_variant_builder_add_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_builder_add_value", builder, value);
            }
            mh$.invokeExact(builder, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_variant_builder_add(GVariantBuilder *builder, const gchar *format_string, ...)
     * }
     */
    public static class g_variant_builder_add {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_add");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_builder_add(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_variant_builder_add(GVariantBuilder *builder, const gchar *format_string, ...)
         * }
         */
        public static g_variant_builder_add makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_builder_add(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment builder, MemorySegment format_string, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_builder_add", builder, format_string, x2);
                }
                 spreader.invokeExact(builder, format_string, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_variant_builder_add_parsed(GVariantBuilder *builder, const gchar *format, ...)
     * }
     */
    public static class g_variant_builder_add_parsed {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_builder_add_parsed");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_builder_add_parsed(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_variant_builder_add_parsed(GVariantBuilder *builder, const gchar *format, ...)
         * }
         */
        public static g_variant_builder_add_parsed makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_builder_add_parsed(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment builder, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_builder_add_parsed", builder, format, x2);
                }
                 spreader.invokeExact(builder, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new(const gchar *format_string, ...)
     * }
     */
    public static class g_variant_new {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_new(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern GVariant *g_variant_new(const gchar *format_string, ...)
         * }
         */
        public static g_variant_new makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_new(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format_string, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_new", format_string, x1);
                }
                return (MemorySegment) spreader.invokeExact(format_string, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_variant_get(GVariant *value, const gchar *format_string, ...)
     * }
     */
    public static class g_variant_get {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_get(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_variant_get(GVariant *value, const gchar *format_string, ...)
         * }
         */
        public static g_variant_get makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_get(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment value, MemorySegment format_string, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_get", value, format_string, x2);
                }
                 spreader.invokeExact(value, format_string, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_variant_new_va {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_va");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_va(const gchar *format_string, const gchar **endptr, va_list *app)
     * }
     */
    public static FunctionDescriptor g_variant_new_va$descriptor() {
        return g_variant_new_va.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_va(const gchar *format_string, const gchar **endptr, va_list *app)
     * }
     */
    public static MethodHandle g_variant_new_va$handle() {
        return g_variant_new_va.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_va(const gchar *format_string, const gchar **endptr, va_list *app)
     * }
     */
    public static MemorySegment g_variant_new_va$address() {
        return g_variant_new_va.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_va(const gchar *format_string, const gchar **endptr, va_list *app)
     * }
     */
    public static MemorySegment g_variant_new_va(MemorySegment format_string, MemorySegment endptr, MemorySegment app) {
        var mh$ = g_variant_new_va.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_va", format_string, endptr, app);
            }
            return (MemorySegment)mh$.invokeExact(format_string, endptr, app);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_get_va {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_get_va");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_get_va(GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app)
     * }
     */
    public static FunctionDescriptor g_variant_get_va$descriptor() {
        return g_variant_get_va.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_get_va(GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app)
     * }
     */
    public static MethodHandle g_variant_get_va$handle() {
        return g_variant_get_va.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_get_va(GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app)
     * }
     */
    public static MemorySegment g_variant_get_va$address() {
        return g_variant_get_va.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_get_va(GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app)
     * }
     */
    public static void g_variant_get_va(MemorySegment value, MemorySegment format_string, MemorySegment endptr, MemorySegment app) {
        var mh$ = g_variant_get_va.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_get_va", value, format_string, endptr, app);
            }
            mh$.invokeExact(value, format_string, endptr, app);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_check_format_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_check_format_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_check_format_string(GVariant *value, const gchar *format_string, gboolean copy_only)
     * }
     */
    public static FunctionDescriptor g_variant_check_format_string$descriptor() {
        return g_variant_check_format_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_check_format_string(GVariant *value, const gchar *format_string, gboolean copy_only)
     * }
     */
    public static MethodHandle g_variant_check_format_string$handle() {
        return g_variant_check_format_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_check_format_string(GVariant *value, const gchar *format_string, gboolean copy_only)
     * }
     */
    public static MemorySegment g_variant_check_format_string$address() {
        return g_variant_check_format_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_check_format_string(GVariant *value, const gchar *format_string, gboolean copy_only)
     * }
     */
    public static int g_variant_check_format_string(MemorySegment value, MemorySegment format_string, int copy_only) {
        var mh$ = g_variant_check_format_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_check_format_string", value, format_string, copy_only);
            }
            return (int)mh$.invokeExact(value, format_string, copy_only);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_parse(const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error)
     * }
     */
    public static FunctionDescriptor g_variant_parse$descriptor() {
        return g_variant_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_parse(const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error)
     * }
     */
    public static MethodHandle g_variant_parse$handle() {
        return g_variant_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_parse(const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error)
     * }
     */
    public static MemorySegment g_variant_parse$address() {
        return g_variant_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_parse(const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error)
     * }
     */
    public static MemorySegment g_variant_parse(MemorySegment type, MemorySegment text, MemorySegment limit, MemorySegment endptr, MemorySegment error) {
        var mh$ = g_variant_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_parse", type, text, limit, endptr, error);
            }
            return (MemorySegment)mh$.invokeExact(type, text, limit, endptr, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_parsed(const gchar *format, ...)
     * }
     */
    public static class g_variant_new_parsed {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_parsed");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_new_parsed(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern GVariant *g_variant_new_parsed(const gchar *format, ...)
         * }
         */
        public static g_variant_new_parsed makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_new_parsed(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_new_parsed", format, x1);
                }
                return (MemorySegment) spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_variant_new_parsed_va {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_new_parsed_va");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_parsed_va(const gchar *format, va_list *app)
     * }
     */
    public static FunctionDescriptor g_variant_new_parsed_va$descriptor() {
        return g_variant_new_parsed_va.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_parsed_va(const gchar *format, va_list *app)
     * }
     */
    public static MethodHandle g_variant_new_parsed_va$handle() {
        return g_variant_new_parsed_va.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_parsed_va(const gchar *format, va_list *app)
     * }
     */
    public static MemorySegment g_variant_new_parsed_va$address() {
        return g_variant_new_parsed_va.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_new_parsed_va(const gchar *format, va_list *app)
     * }
     */
    public static MemorySegment g_variant_new_parsed_va(MemorySegment format, MemorySegment app) {
        var mh$ = g_variant_new_parsed_va.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_new_parsed_va", format, app);
            }
            return (MemorySegment)mh$.invokeExact(format, app);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_parse_error_print_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_parse_error_print_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_variant_parse_error_print_context(GError *error, const gchar *source_str)
     * }
     */
    public static FunctionDescriptor g_variant_parse_error_print_context$descriptor() {
        return g_variant_parse_error_print_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_variant_parse_error_print_context(GError *error, const gchar *source_str)
     * }
     */
    public static MethodHandle g_variant_parse_error_print_context$handle() {
        return g_variant_parse_error_print_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_variant_parse_error_print_context(GError *error, const gchar *source_str)
     * }
     */
    public static MemorySegment g_variant_parse_error_print_context$address() {
        return g_variant_parse_error_print_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_variant_parse_error_print_context(GError *error, const gchar *source_str)
     * }
     */
    public static MemorySegment g_variant_parse_error_print_context(MemorySegment error, MemorySegment source_str) {
        var mh$ = g_variant_parse_error_print_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_parse_error_print_context", error, source_str);
            }
            return (MemorySegment)mh$.invokeExact(error, source_str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_variant_compare(gconstpointer one, gconstpointer two)
     * }
     */
    public static FunctionDescriptor g_variant_compare$descriptor() {
        return g_variant_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_variant_compare(gconstpointer one, gconstpointer two)
     * }
     */
    public static MethodHandle g_variant_compare$handle() {
        return g_variant_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_variant_compare(gconstpointer one, gconstpointer two)
     * }
     */
    public static MemorySegment g_variant_compare$address() {
        return g_variant_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_variant_compare(gconstpointer one, gconstpointer two)
     * }
     */
    public static int g_variant_compare(MemorySegment one, MemorySegment two) {
        var mh$ = g_variant_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_compare", one, two);
            }
            return (int)mh$.invokeExact(one, two);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantDict *g_variant_dict_new(GVariant *from_asv)
     * }
     */
    public static FunctionDescriptor g_variant_dict_new$descriptor() {
        return g_variant_dict_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantDict *g_variant_dict_new(GVariant *from_asv)
     * }
     */
    public static MethodHandle g_variant_dict_new$handle() {
        return g_variant_dict_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantDict *g_variant_dict_new(GVariant *from_asv)
     * }
     */
    public static MemorySegment g_variant_dict_new$address() {
        return g_variant_dict_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantDict *g_variant_dict_new(GVariant *from_asv)
     * }
     */
    public static MemorySegment g_variant_dict_new(MemorySegment from_asv) {
        var mh$ = g_variant_dict_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_new", from_asv);
            }
            return (MemorySegment)mh$.invokeExact(from_asv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_dict_init(GVariantDict *dict, GVariant *from_asv)
     * }
     */
    public static FunctionDescriptor g_variant_dict_init$descriptor() {
        return g_variant_dict_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_dict_init(GVariantDict *dict, GVariant *from_asv)
     * }
     */
    public static MethodHandle g_variant_dict_init$handle() {
        return g_variant_dict_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_dict_init(GVariantDict *dict, GVariant *from_asv)
     * }
     */
    public static MemorySegment g_variant_dict_init$address() {
        return g_variant_dict_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_dict_init(GVariantDict *dict, GVariant *from_asv)
     * }
     */
    public static void g_variant_dict_init(MemorySegment dict, MemorySegment from_asv) {
        var mh$ = g_variant_dict_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_init", dict, from_asv);
            }
            mh$.invokeExact(dict, from_asv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_lookup(GVariantDict *dict, const gchar *key, const gchar *format_string, ...)
     * }
     */
    public static class g_variant_dict_lookup {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_lookup");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_dict_lookup(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern gboolean g_variant_dict_lookup(GVariantDict *dict, const gchar *key, const gchar *format_string, ...)
         * }
         */
        public static g_variant_dict_lookup makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_dict_lookup(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment dict, MemorySegment key, MemorySegment format_string, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_dict_lookup", dict, key, format_string, x3);
                }
                return (int) spreader.invokeExact(dict, key, format_string, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_variant_dict_lookup_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_lookup_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict, const gchar *key, const GVariantType *expected_type)
     * }
     */
    public static FunctionDescriptor g_variant_dict_lookup_value$descriptor() {
        return g_variant_dict_lookup_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict, const gchar *key, const GVariantType *expected_type)
     * }
     */
    public static MethodHandle g_variant_dict_lookup_value$handle() {
        return g_variant_dict_lookup_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict, const gchar *key, const GVariantType *expected_type)
     * }
     */
    public static MemorySegment g_variant_dict_lookup_value$address() {
        return g_variant_dict_lookup_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict, const gchar *key, const GVariantType *expected_type)
     * }
     */
    public static MemorySegment g_variant_dict_lookup_value(MemorySegment dict, MemorySegment key, MemorySegment expected_type) {
        var mh$ = g_variant_dict_lookup_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_lookup_value", dict, key, expected_type);
            }
            return (MemorySegment)mh$.invokeExact(dict, key, expected_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_contains(GVariantDict *dict, const gchar *key)
     * }
     */
    public static FunctionDescriptor g_variant_dict_contains$descriptor() {
        return g_variant_dict_contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_contains(GVariantDict *dict, const gchar *key)
     * }
     */
    public static MethodHandle g_variant_dict_contains$handle() {
        return g_variant_dict_contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_contains(GVariantDict *dict, const gchar *key)
     * }
     */
    public static MemorySegment g_variant_dict_contains$address() {
        return g_variant_dict_contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_contains(GVariantDict *dict, const gchar *key)
     * }
     */
    public static int g_variant_dict_contains(MemorySegment dict, MemorySegment key) {
        var mh$ = g_variant_dict_contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_contains", dict, key);
            }
            return (int)mh$.invokeExact(dict, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_variant_dict_insert(GVariantDict *dict, const gchar *key, const gchar *format_string, ...)
     * }
     */
    public static class g_variant_dict_insert {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_insert");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_variant_dict_insert(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_variant_dict_insert(GVariantDict *dict, const gchar *key, const gchar *format_string, ...)
         * }
         */
        public static g_variant_dict_insert makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_variant_dict_insert(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment dict, MemorySegment key, MemorySegment format_string, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_variant_dict_insert", dict, key, format_string, x3);
                }
                 spreader.invokeExact(dict, key, format_string, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_variant_dict_insert_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_insert_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_dict_insert_value(GVariantDict *dict, const gchar *key, GVariant *value)
     * }
     */
    public static FunctionDescriptor g_variant_dict_insert_value$descriptor() {
        return g_variant_dict_insert_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_dict_insert_value(GVariantDict *dict, const gchar *key, GVariant *value)
     * }
     */
    public static MethodHandle g_variant_dict_insert_value$handle() {
        return g_variant_dict_insert_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_dict_insert_value(GVariantDict *dict, const gchar *key, GVariant *value)
     * }
     */
    public static MemorySegment g_variant_dict_insert_value$address() {
        return g_variant_dict_insert_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_dict_insert_value(GVariantDict *dict, const gchar *key, GVariant *value)
     * }
     */
    public static void g_variant_dict_insert_value(MemorySegment dict, MemorySegment key, MemorySegment value) {
        var mh$ = g_variant_dict_insert_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_insert_value", dict, key, value);
            }
            mh$.invokeExact(dict, key, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_remove(GVariantDict *dict, const gchar *key)
     * }
     */
    public static FunctionDescriptor g_variant_dict_remove$descriptor() {
        return g_variant_dict_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_remove(GVariantDict *dict, const gchar *key)
     * }
     */
    public static MethodHandle g_variant_dict_remove$handle() {
        return g_variant_dict_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_remove(GVariantDict *dict, const gchar *key)
     * }
     */
    public static MemorySegment g_variant_dict_remove$address() {
        return g_variant_dict_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_variant_dict_remove(GVariantDict *dict, const gchar *key)
     * }
     */
    public static int g_variant_dict_remove(MemorySegment dict, MemorySegment key) {
        var mh$ = g_variant_dict_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_remove", dict, key);
            }
            return (int)mh$.invokeExact(dict, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_dict_clear(GVariantDict *dict)
     * }
     */
    public static FunctionDescriptor g_variant_dict_clear$descriptor() {
        return g_variant_dict_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_dict_clear(GVariantDict *dict)
     * }
     */
    public static MethodHandle g_variant_dict_clear$handle() {
        return g_variant_dict_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_dict_clear(GVariantDict *dict)
     * }
     */
    public static MemorySegment g_variant_dict_clear$address() {
        return g_variant_dict_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_dict_clear(GVariantDict *dict)
     * }
     */
    public static void g_variant_dict_clear(MemorySegment dict) {
        var mh$ = g_variant_dict_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_clear", dict);
            }
            mh$.invokeExact(dict);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_dict_end(GVariantDict *dict)
     * }
     */
    public static FunctionDescriptor g_variant_dict_end$descriptor() {
        return g_variant_dict_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_dict_end(GVariantDict *dict)
     * }
     */
    public static MethodHandle g_variant_dict_end$handle() {
        return g_variant_dict_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariant *g_variant_dict_end(GVariantDict *dict)
     * }
     */
    public static MemorySegment g_variant_dict_end$address() {
        return g_variant_dict_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariant *g_variant_dict_end(GVariantDict *dict)
     * }
     */
    public static MemorySegment g_variant_dict_end(MemorySegment dict) {
        var mh$ = g_variant_dict_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_end", dict);
            }
            return (MemorySegment)mh$.invokeExact(dict);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GVariantDict *g_variant_dict_ref(GVariantDict *dict)
     * }
     */
    public static FunctionDescriptor g_variant_dict_ref$descriptor() {
        return g_variant_dict_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GVariantDict *g_variant_dict_ref(GVariantDict *dict)
     * }
     */
    public static MethodHandle g_variant_dict_ref$handle() {
        return g_variant_dict_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GVariantDict *g_variant_dict_ref(GVariantDict *dict)
     * }
     */
    public static MemorySegment g_variant_dict_ref$address() {
        return g_variant_dict_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GVariantDict *g_variant_dict_ref(GVariantDict *dict)
     * }
     */
    public static MemorySegment g_variant_dict_ref(MemorySegment dict) {
        var mh$ = g_variant_dict_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_ref", dict);
            }
            return (MemorySegment)mh$.invokeExact(dict);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_variant_dict_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_variant_dict_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_variant_dict_unref(GVariantDict *dict)
     * }
     */
    public static FunctionDescriptor g_variant_dict_unref$descriptor() {
        return g_variant_dict_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_variant_dict_unref(GVariantDict *dict)
     * }
     */
    public static MethodHandle g_variant_dict_unref$handle() {
        return g_variant_dict_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_variant_dict_unref(GVariantDict *dict)
     * }
     */
    public static MemorySegment g_variant_dict_unref$address() {
        return g_variant_dict_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_variant_dict_unref(GVariantDict *dict)
     * }
     */
    public static void g_variant_dict_unref(MemorySegment dict) {
        var mh$ = g_variant_dict_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_variant_dict_unref", dict);
            }
            mh$.invokeExact(dict);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_printf_string_upper_bound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_printf_string_upper_bound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_printf_string_upper_bound(const gchar *format, va_list args)
     * }
     */
    public static FunctionDescriptor g_printf_string_upper_bound$descriptor() {
        return g_printf_string_upper_bound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_printf_string_upper_bound(const gchar *format, va_list args)
     * }
     */
    public static MethodHandle g_printf_string_upper_bound$handle() {
        return g_printf_string_upper_bound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_printf_string_upper_bound(const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_printf_string_upper_bound$address() {
        return g_printf_string_upper_bound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_printf_string_upper_bound(const gchar *format, va_list args)
     * }
     */
    public static long g_printf_string_upper_bound(MemorySegment format, MemorySegment args) {
        var mh$ = g_printf_string_upper_bound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_printf_string_upper_bound", format, args);
            }
            return (long)mh$.invokeExact(format, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_LOG_FLAG_RECURSION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_FLAG_RECURSION = 1
     * }
     */
    public static int G_LOG_FLAG_RECURSION() {
        return G_LOG_FLAG_RECURSION;
    }
    private static final int G_LOG_FLAG_FATAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_FLAG_FATAL = 2
     * }
     */
    public static int G_LOG_FLAG_FATAL() {
        return G_LOG_FLAG_FATAL;
    }
    private static final int G_LOG_LEVEL_ERROR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_LEVEL_ERROR = 4
     * }
     */
    public static int G_LOG_LEVEL_ERROR() {
        return G_LOG_LEVEL_ERROR;
    }
    private static final int G_LOG_LEVEL_CRITICAL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_LEVEL_CRITICAL = 8
     * }
     */
    public static int G_LOG_LEVEL_CRITICAL() {
        return G_LOG_LEVEL_CRITICAL;
    }
    private static final int G_LOG_LEVEL_WARNING = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_LEVEL_WARNING = 16
     * }
     */
    public static int G_LOG_LEVEL_WARNING() {
        return G_LOG_LEVEL_WARNING;
    }
    private static final int G_LOG_LEVEL_MESSAGE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_LEVEL_MESSAGE = 32
     * }
     */
    public static int G_LOG_LEVEL_MESSAGE() {
        return G_LOG_LEVEL_MESSAGE;
    }
    private static final int G_LOG_LEVEL_INFO = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_LEVEL_INFO = 64
     * }
     */
    public static int G_LOG_LEVEL_INFO() {
        return G_LOG_LEVEL_INFO;
    }
    private static final int G_LOG_LEVEL_DEBUG = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_LEVEL_DEBUG = 128
     * }
     */
    public static int G_LOG_LEVEL_DEBUG() {
        return G_LOG_LEVEL_DEBUG;
    }
    private static final int G_LOG_LEVEL_MASK = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_LEVEL_MASK = -4
     * }
     */
    public static int G_LOG_LEVEL_MASK() {
        return G_LOG_LEVEL_MASK;
    }

    private static class g_log_set_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_set_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_log_set_handler(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_log_set_handler$descriptor() {
        return g_log_set_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_log_set_handler(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_log_set_handler$handle() {
        return g_log_set_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_log_set_handler(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_log_set_handler$address() {
        return g_log_set_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_log_set_handler(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data)
     * }
     */
    public static int g_log_set_handler(MemorySegment log_domain, int log_levels, MemorySegment log_func, MemorySegment user_data) {
        var mh$ = g_log_set_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_set_handler", log_domain, log_levels, log_func, user_data);
            }
            return (int)mh$.invokeExact(log_domain, log_levels, log_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_set_handler_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_set_handler_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_log_set_handler_full(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy)
     * }
     */
    public static FunctionDescriptor g_log_set_handler_full$descriptor() {
        return g_log_set_handler_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_log_set_handler_full(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy)
     * }
     */
    public static MethodHandle g_log_set_handler_full$handle() {
        return g_log_set_handler_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_log_set_handler_full(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_log_set_handler_full$address() {
        return g_log_set_handler_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_log_set_handler_full(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy)
     * }
     */
    public static int g_log_set_handler_full(MemorySegment log_domain, int log_levels, MemorySegment log_func, MemorySegment user_data, MemorySegment destroy) {
        var mh$ = g_log_set_handler_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_set_handler_full", log_domain, log_levels, log_func, user_data, destroy);
            }
            return (int)mh$.invokeExact(log_domain, log_levels, log_func, user_data, destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_remove_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_remove_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_log_remove_handler(const gchar *log_domain, guint handler_id)
     * }
     */
    public static FunctionDescriptor g_log_remove_handler$descriptor() {
        return g_log_remove_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_log_remove_handler(const gchar *log_domain, guint handler_id)
     * }
     */
    public static MethodHandle g_log_remove_handler$handle() {
        return g_log_remove_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_log_remove_handler(const gchar *log_domain, guint handler_id)
     * }
     */
    public static MemorySegment g_log_remove_handler$address() {
        return g_log_remove_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_log_remove_handler(const gchar *log_domain, guint handler_id)
     * }
     */
    public static void g_log_remove_handler(MemorySegment log_domain, int handler_id) {
        var mh$ = g_log_remove_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_remove_handler", log_domain, handler_id);
            }
            mh$.invokeExact(log_domain, handler_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_default_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_default_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_log_default_handler(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data)
     * }
     */
    public static FunctionDescriptor g_log_default_handler$descriptor() {
        return g_log_default_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_log_default_handler(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data)
     * }
     */
    public static MethodHandle g_log_default_handler$handle() {
        return g_log_default_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_log_default_handler(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data)
     * }
     */
    public static MemorySegment g_log_default_handler$address() {
        return g_log_default_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_log_default_handler(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data)
     * }
     */
    public static void g_log_default_handler(MemorySegment log_domain, int log_level, MemorySegment message, MemorySegment unused_data) {
        var mh$ = g_log_default_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_default_handler", log_domain, log_level, message, unused_data);
            }
            mh$.invokeExact(log_domain, log_level, message, unused_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_set_default_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_set_default_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLogFunc g_log_set_default_handler(GLogFunc log_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_log_set_default_handler$descriptor() {
        return g_log_set_default_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLogFunc g_log_set_default_handler(GLogFunc log_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_log_set_default_handler$handle() {
        return g_log_set_default_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLogFunc g_log_set_default_handler(GLogFunc log_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_log_set_default_handler$address() {
        return g_log_set_default_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLogFunc g_log_set_default_handler(GLogFunc log_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_log_set_default_handler(MemorySegment log_func, MemorySegment user_data) {
        var mh$ = g_log_set_default_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_set_default_handler", log_func, user_data);
            }
            return (MemorySegment)mh$.invokeExact(log_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_log(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, ...)
     * }
     */
    public static class g_log {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_log(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_log(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, ...)
         * }
         */
        public static g_log makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_log(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment log_domain, int log_level, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_log", log_domain, log_level, format, x3);
                }
                 spreader.invokeExact(log_domain, log_level, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_logv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_logv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_logv(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args)
     * }
     */
    public static FunctionDescriptor g_logv$descriptor() {
        return g_logv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_logv(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args)
     * }
     */
    public static MethodHandle g_logv$handle() {
        return g_logv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_logv(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args)
     * }
     */
    public static MemorySegment g_logv$address() {
        return g_logv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_logv(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args)
     * }
     */
    public static void g_logv(MemorySegment log_domain, int log_level, MemorySegment format, MemorySegment args) {
        var mh$ = g_logv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_logv", log_domain, log_level, format, args);
            }
            mh$.invokeExact(log_domain, log_level, format, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_set_fatal_mask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_set_fatal_mask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLogLevelFlags g_log_set_fatal_mask(const gchar *log_domain, GLogLevelFlags fatal_mask)
     * }
     */
    public static FunctionDescriptor g_log_set_fatal_mask$descriptor() {
        return g_log_set_fatal_mask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLogLevelFlags g_log_set_fatal_mask(const gchar *log_domain, GLogLevelFlags fatal_mask)
     * }
     */
    public static MethodHandle g_log_set_fatal_mask$handle() {
        return g_log_set_fatal_mask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLogLevelFlags g_log_set_fatal_mask(const gchar *log_domain, GLogLevelFlags fatal_mask)
     * }
     */
    public static MemorySegment g_log_set_fatal_mask$address() {
        return g_log_set_fatal_mask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLogLevelFlags g_log_set_fatal_mask(const gchar *log_domain, GLogLevelFlags fatal_mask)
     * }
     */
    public static int g_log_set_fatal_mask(MemorySegment log_domain, int fatal_mask) {
        var mh$ = g_log_set_fatal_mask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_set_fatal_mask", log_domain, fatal_mask);
            }
            return (int)mh$.invokeExact(log_domain, fatal_mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_set_always_fatal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_set_always_fatal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask)
     * }
     */
    public static FunctionDescriptor g_log_set_always_fatal$descriptor() {
        return g_log_set_always_fatal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask)
     * }
     */
    public static MethodHandle g_log_set_always_fatal$handle() {
        return g_log_set_always_fatal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask)
     * }
     */
    public static MemorySegment g_log_set_always_fatal$address() {
        return g_log_set_always_fatal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask)
     * }
     */
    public static int g_log_set_always_fatal(int fatal_mask) {
        var mh$ = g_log_set_always_fatal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_set_always_fatal", fatal_mask);
            }
            return (int)mh$.invokeExact(fatal_mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_LOG_WRITER_HANDLED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_WRITER_HANDLED = 1
     * }
     */
    public static int G_LOG_WRITER_HANDLED() {
        return G_LOG_WRITER_HANDLED;
    }
    private static final int G_LOG_WRITER_UNHANDLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_LOG_WRITER_UNHANDLED = 0
     * }
     */
    public static int G_LOG_WRITER_UNHANDLED() {
        return G_LOG_WRITER_UNHANDLED;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_log_structured(const gchar *log_domain, GLogLevelFlags log_level, ...)
     * }
     */
    public static class g_log_structured {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_INT
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_structured");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_log_structured(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_log_structured(const gchar *log_domain, GLogLevelFlags log_level, ...)
         * }
         */
        public static g_log_structured makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_log_structured(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment log_domain, int log_level, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_log_structured", log_domain, log_level, x2);
                }
                 spreader.invokeExact(log_domain, log_level, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_log_structured_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_structured_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_log_structured_array(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields)
     * }
     */
    public static FunctionDescriptor g_log_structured_array$descriptor() {
        return g_log_structured_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_log_structured_array(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields)
     * }
     */
    public static MethodHandle g_log_structured_array$handle() {
        return g_log_structured_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_log_structured_array(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields)
     * }
     */
    public static MemorySegment g_log_structured_array$address() {
        return g_log_structured_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_log_structured_array(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields)
     * }
     */
    public static void g_log_structured_array(int log_level, MemorySegment fields, long n_fields) {
        var mh$ = g_log_structured_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_structured_array", log_level, fields, n_fields);
            }
            mh$.invokeExact(log_level, fields, n_fields);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_variant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_variant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_log_variant(const gchar *log_domain, GLogLevelFlags log_level, GVariant *fields)
     * }
     */
    public static FunctionDescriptor g_log_variant$descriptor() {
        return g_log_variant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_log_variant(const gchar *log_domain, GLogLevelFlags log_level, GVariant *fields)
     * }
     */
    public static MethodHandle g_log_variant$handle() {
        return g_log_variant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_log_variant(const gchar *log_domain, GLogLevelFlags log_level, GVariant *fields)
     * }
     */
    public static MemorySegment g_log_variant$address() {
        return g_log_variant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_log_variant(const gchar *log_domain, GLogLevelFlags log_level, GVariant *fields)
     * }
     */
    public static void g_log_variant(MemorySegment log_domain, int log_level, MemorySegment fields) {
        var mh$ = g_log_variant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_variant", log_domain, log_level, fields);
            }
            mh$.invokeExact(log_domain, log_level, fields);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_set_writer_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_set_writer_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_log_set_writer_func(GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free)
     * }
     */
    public static FunctionDescriptor g_log_set_writer_func$descriptor() {
        return g_log_set_writer_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_log_set_writer_func(GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free)
     * }
     */
    public static MethodHandle g_log_set_writer_func$handle() {
        return g_log_set_writer_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_log_set_writer_func(GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free)
     * }
     */
    public static MemorySegment g_log_set_writer_func$address() {
        return g_log_set_writer_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_log_set_writer_func(GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free)
     * }
     */
    public static void g_log_set_writer_func(MemorySegment func, MemorySegment user_data, MemorySegment user_data_free) {
        var mh$ = g_log_set_writer_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_set_writer_func", func, user_data, user_data_free);
            }
            mh$.invokeExact(func, user_data, user_data_free);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_supports_color {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_supports_color");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_supports_color(gint output_fd)
     * }
     */
    public static FunctionDescriptor g_log_writer_supports_color$descriptor() {
        return g_log_writer_supports_color.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_supports_color(gint output_fd)
     * }
     */
    public static MethodHandle g_log_writer_supports_color$handle() {
        return g_log_writer_supports_color.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_supports_color(gint output_fd)
     * }
     */
    public static MemorySegment g_log_writer_supports_color$address() {
        return g_log_writer_supports_color.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_log_writer_supports_color(gint output_fd)
     * }
     */
    public static int g_log_writer_supports_color(int output_fd) {
        var mh$ = g_log_writer_supports_color.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_supports_color", output_fd);
            }
            return (int)mh$.invokeExact(output_fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_is_journald {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_is_journald");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_is_journald(gint output_fd)
     * }
     */
    public static FunctionDescriptor g_log_writer_is_journald$descriptor() {
        return g_log_writer_is_journald.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_is_journald(gint output_fd)
     * }
     */
    public static MethodHandle g_log_writer_is_journald$handle() {
        return g_log_writer_is_journald.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_is_journald(gint output_fd)
     * }
     */
    public static MemorySegment g_log_writer_is_journald$address() {
        return g_log_writer_is_journald.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_log_writer_is_journald(gint output_fd)
     * }
     */
    public static int g_log_writer_is_journald(int output_fd) {
        var mh$ = g_log_writer_is_journald.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_is_journald", output_fd);
            }
            return (int)mh$.invokeExact(output_fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_format_fields {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_format_fields");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gboolean use_color)
     * }
     */
    public static FunctionDescriptor g_log_writer_format_fields$descriptor() {
        return g_log_writer_format_fields.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gboolean use_color)
     * }
     */
    public static MethodHandle g_log_writer_format_fields$handle() {
        return g_log_writer_format_fields.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gboolean use_color)
     * }
     */
    public static MemorySegment g_log_writer_format_fields$address() {
        return g_log_writer_format_fields.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gboolean use_color)
     * }
     */
    public static MemorySegment g_log_writer_format_fields(int log_level, MemorySegment fields, long n_fields, int use_color) {
        var mh$ = g_log_writer_format_fields.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_format_fields", log_level, fields, n_fields, use_color);
            }
            return (MemorySegment)mh$.invokeExact(log_level, fields, n_fields, use_color);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_syslog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_syslog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_syslog(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_log_writer_syslog$descriptor() {
        return g_log_writer_syslog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_syslog(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static MethodHandle g_log_writer_syslog$handle() {
        return g_log_writer_syslog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_syslog(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static MemorySegment g_log_writer_syslog$address() {
        return g_log_writer_syslog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_syslog(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static int g_log_writer_syslog(int log_level, MemorySegment fields, long n_fields, MemorySegment user_data) {
        var mh$ = g_log_writer_syslog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_syslog", log_level, fields, n_fields, user_data);
            }
            return (int)mh$.invokeExact(log_level, fields, n_fields, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_journald {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_journald");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_log_writer_journald$descriptor() {
        return g_log_writer_journald.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static MethodHandle g_log_writer_journald$handle() {
        return g_log_writer_journald.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static MemorySegment g_log_writer_journald$address() {
        return g_log_writer_journald.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static int g_log_writer_journald(int log_level, MemorySegment fields, long n_fields, MemorySegment user_data) {
        var mh$ = g_log_writer_journald.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_journald", log_level, fields, n_fields, user_data);
            }
            return (int)mh$.invokeExact(log_level, fields, n_fields, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_standard_streams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_standard_streams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_log_writer_standard_streams$descriptor() {
        return g_log_writer_standard_streams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static MethodHandle g_log_writer_standard_streams$handle() {
        return g_log_writer_standard_streams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static MemorySegment g_log_writer_standard_streams$address() {
        return g_log_writer_standard_streams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static int g_log_writer_standard_streams(int log_level, MemorySegment fields, long n_fields, MemorySegment user_data) {
        var mh$ = g_log_writer_standard_streams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_standard_streams", log_level, fields, n_fields, user_data);
            }
            return (int)mh$.invokeExact(log_level, fields, n_fields, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_log_writer_default$descriptor() {
        return g_log_writer_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static MethodHandle g_log_writer_default$handle() {
        return g_log_writer_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static MemorySegment g_log_writer_default$address() {
        return g_log_writer_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
     * }
     */
    public static int g_log_writer_default(int log_level, MemorySegment fields, long n_fields, MemorySegment user_data) {
        var mh$ = g_log_writer_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_default", log_level, fields, n_fields, user_data);
            }
            return (int)mh$.invokeExact(log_level, fields, n_fields, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_default_set_use_stderr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_default_set_use_stderr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_log_writer_default_set_use_stderr(gboolean use_stderr)
     * }
     */
    public static FunctionDescriptor g_log_writer_default_set_use_stderr$descriptor() {
        return g_log_writer_default_set_use_stderr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_log_writer_default_set_use_stderr(gboolean use_stderr)
     * }
     */
    public static MethodHandle g_log_writer_default_set_use_stderr$handle() {
        return g_log_writer_default_set_use_stderr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_log_writer_default_set_use_stderr(gboolean use_stderr)
     * }
     */
    public static MemorySegment g_log_writer_default_set_use_stderr$address() {
        return g_log_writer_default_set_use_stderr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_log_writer_default_set_use_stderr(gboolean use_stderr)
     * }
     */
    public static void g_log_writer_default_set_use_stderr(int use_stderr) {
        var mh$ = g_log_writer_default_set_use_stderr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_default_set_use_stderr", use_stderr);
            }
            mh$.invokeExact(use_stderr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_default_would_drop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_default_would_drop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_default_would_drop(GLogLevelFlags log_level, const char *log_domain)
     * }
     */
    public static FunctionDescriptor g_log_writer_default_would_drop$descriptor() {
        return g_log_writer_default_would_drop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_default_would_drop(GLogLevelFlags log_level, const char *log_domain)
     * }
     */
    public static MethodHandle g_log_writer_default_would_drop$handle() {
        return g_log_writer_default_would_drop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_log_writer_default_would_drop(GLogLevelFlags log_level, const char *log_domain)
     * }
     */
    public static MemorySegment g_log_writer_default_would_drop$address() {
        return g_log_writer_default_would_drop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_log_writer_default_would_drop(GLogLevelFlags log_level, const char *log_domain)
     * }
     */
    public static int g_log_writer_default_would_drop(int log_level, MemorySegment log_domain) {
        var mh$ = g_log_writer_default_would_drop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_default_would_drop", log_level, log_domain);
            }
            return (int)mh$.invokeExact(log_level, log_domain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_writer_default_set_debug_domains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_writer_default_set_debug_domains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_log_writer_default_set_debug_domains(const gchar *const *domains)
     * }
     */
    public static FunctionDescriptor g_log_writer_default_set_debug_domains$descriptor() {
        return g_log_writer_default_set_debug_domains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_log_writer_default_set_debug_domains(const gchar *const *domains)
     * }
     */
    public static MethodHandle g_log_writer_default_set_debug_domains$handle() {
        return g_log_writer_default_set_debug_domains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_log_writer_default_set_debug_domains(const gchar *const *domains)
     * }
     */
    public static MemorySegment g_log_writer_default_set_debug_domains$address() {
        return g_log_writer_default_set_debug_domains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_log_writer_default_set_debug_domains(const gchar *const *domains)
     * }
     */
    public static void g_log_writer_default_set_debug_domains(MemorySegment domains) {
        var mh$ = g_log_writer_default_set_debug_domains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_writer_default_set_debug_domains", domains);
            }
            mh$.invokeExact(domains);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_get_debug_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_get_debug_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_log_get_debug_enabled()
     * }
     */
    public static FunctionDescriptor g_log_get_debug_enabled$descriptor() {
        return g_log_get_debug_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_log_get_debug_enabled()
     * }
     */
    public static MethodHandle g_log_get_debug_enabled$handle() {
        return g_log_get_debug_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_log_get_debug_enabled()
     * }
     */
    public static MemorySegment g_log_get_debug_enabled$address() {
        return g_log_get_debug_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_log_get_debug_enabled()
     * }
     */
    public static int g_log_get_debug_enabled() {
        var mh$ = g_log_get_debug_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_get_debug_enabled");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_log_set_debug_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_set_debug_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_log_set_debug_enabled(gboolean enabled)
     * }
     */
    public static FunctionDescriptor g_log_set_debug_enabled$descriptor() {
        return g_log_set_debug_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_log_set_debug_enabled(gboolean enabled)
     * }
     */
    public static MethodHandle g_log_set_debug_enabled$handle() {
        return g_log_set_debug_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_log_set_debug_enabled(gboolean enabled)
     * }
     */
    public static MemorySegment g_log_set_debug_enabled$address() {
        return g_log_set_debug_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_log_set_debug_enabled(gboolean enabled)
     * }
     */
    public static void g_log_set_debug_enabled(int enabled) {
        var mh$ = g_log_set_debug_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_log_set_debug_enabled", enabled);
            }
            mh$.invokeExact(enabled);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _g_log_fallback_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_g_log_fallback_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _g_log_fallback_handler(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data)
     * }
     */
    public static FunctionDescriptor _g_log_fallback_handler$descriptor() {
        return _g_log_fallback_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _g_log_fallback_handler(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data)
     * }
     */
    public static MethodHandle _g_log_fallback_handler$handle() {
        return _g_log_fallback_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _g_log_fallback_handler(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data)
     * }
     */
    public static MemorySegment _g_log_fallback_handler$address() {
        return _g_log_fallback_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _g_log_fallback_handler(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data)
     * }
     */
    public static void _g_log_fallback_handler(MemorySegment log_domain, int log_level, MemorySegment message, MemorySegment unused_data) {
        var mh$ = _g_log_fallback_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_g_log_fallback_handler", log_domain, log_level, message, unused_data);
            }
            mh$.invokeExact(log_domain, log_level, message, unused_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_return_if_fail_warning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_return_if_fail_warning");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_return_if_fail_warning(const char *log_domain, const char *pretty_function, const char *expression)
     * }
     */
    public static FunctionDescriptor g_return_if_fail_warning$descriptor() {
        return g_return_if_fail_warning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_return_if_fail_warning(const char *log_domain, const char *pretty_function, const char *expression)
     * }
     */
    public static MethodHandle g_return_if_fail_warning$handle() {
        return g_return_if_fail_warning.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_return_if_fail_warning(const char *log_domain, const char *pretty_function, const char *expression)
     * }
     */
    public static MemorySegment g_return_if_fail_warning$address() {
        return g_return_if_fail_warning.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_return_if_fail_warning(const char *log_domain, const char *pretty_function, const char *expression)
     * }
     */
    public static void g_return_if_fail_warning(MemorySegment log_domain, MemorySegment pretty_function, MemorySegment expression) {
        var mh$ = g_return_if_fail_warning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_return_if_fail_warning", log_domain, pretty_function, expression);
            }
            mh$.invokeExact(log_domain, pretty_function, expression);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_warn_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_warn_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_warn_message(const char *domain, const char *file, int line, const char *func, const char *warnexpr)
     * }
     */
    public static FunctionDescriptor g_warn_message$descriptor() {
        return g_warn_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_warn_message(const char *domain, const char *file, int line, const char *func, const char *warnexpr)
     * }
     */
    public static MethodHandle g_warn_message$handle() {
        return g_warn_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_warn_message(const char *domain, const char *file, int line, const char *func, const char *warnexpr)
     * }
     */
    public static MemorySegment g_warn_message$address() {
        return g_warn_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_warn_message(const char *domain, const char *file, int line, const char *func, const char *warnexpr)
     * }
     */
    public static void g_warn_message(MemorySegment domain, MemorySegment file, int line, MemorySegment func, MemorySegment warnexpr) {
        var mh$ = g_warn_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_warn_message", domain, file, line, func, warnexpr);
            }
            mh$.invokeExact(domain, file, line, func, warnexpr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_assert_warning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_assert_warning");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_assert_warning(const char *log_domain, const char *file, const int line, const char *pretty_function, const char *expression)
     * }
     */
    public static FunctionDescriptor g_assert_warning$descriptor() {
        return g_assert_warning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_assert_warning(const char *log_domain, const char *file, const int line, const char *pretty_function, const char *expression)
     * }
     */
    public static MethodHandle g_assert_warning$handle() {
        return g_assert_warning.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_assert_warning(const char *log_domain, const char *file, const int line, const char *pretty_function, const char *expression)
     * }
     */
    public static MemorySegment g_assert_warning$address() {
        return g_assert_warning.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_assert_warning(const char *log_domain, const char *file, const int line, const char *pretty_function, const char *expression)
     * }
     */
    public static void g_assert_warning(MemorySegment log_domain, MemorySegment file, int line, MemorySegment pretty_function, MemorySegment expression) {
        var mh$ = g_assert_warning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_assert_warning", log_domain, file, line, pretty_function, expression);
            }
            mh$.invokeExact(log_domain, file, line, pretty_function, expression);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_log_structured_standard(const gchar *log_domain, GLogLevelFlags log_level, const gchar *file, const gchar *line, const gchar *func, const gchar *message_format, ...)
     * }
     */
    public static class g_log_structured_standard {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_INT,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_log_structured_standard");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_log_structured_standard(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_log_structured_standard(const gchar *log_domain, GLogLevelFlags log_level, const gchar *file, const gchar *line, const gchar *func, const gchar *message_format, ...)
         * }
         */
        public static g_log_structured_standard makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_log_structured_standard(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment log_domain, int log_level, MemorySegment file, MemorySegment line, MemorySegment func, MemorySegment message_format, Object... x6) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_log_structured_standard", log_domain, log_level, file, line, func, message_format, x6);
                }
                 spreader.invokeExact(log_domain, log_level, file, line, func, message_format, x6);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_print(const gchar *format, ...)
     * }
     */
    public static class g_print {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_print");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_print(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_print(const gchar *format, ...)
         * }
         */
        public static g_print makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_print(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_print", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_set_print_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_set_print_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPrintFunc g_set_print_handler(GPrintFunc func)
     * }
     */
    public static FunctionDescriptor g_set_print_handler$descriptor() {
        return g_set_print_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPrintFunc g_set_print_handler(GPrintFunc func)
     * }
     */
    public static MethodHandle g_set_print_handler$handle() {
        return g_set_print_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPrintFunc g_set_print_handler(GPrintFunc func)
     * }
     */
    public static MemorySegment g_set_print_handler$address() {
        return g_set_print_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPrintFunc g_set_print_handler(GPrintFunc func)
     * }
     */
    public static MemorySegment g_set_print_handler(MemorySegment func) {
        var mh$ = g_set_print_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_set_print_handler", func);
            }
            return (MemorySegment)mh$.invokeExact(func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_printerr(const gchar *format, ...)
     * }
     */
    public static class g_printerr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_printerr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_printerr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_printerr(const gchar *format, ...)
         * }
         */
        public static g_printerr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_printerr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_printerr", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_set_printerr_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_set_printerr_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPrintFunc g_set_printerr_handler(GPrintFunc func)
     * }
     */
    public static FunctionDescriptor g_set_printerr_handler$descriptor() {
        return g_set_printerr_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPrintFunc g_set_printerr_handler(GPrintFunc func)
     * }
     */
    public static MethodHandle g_set_printerr_handler$handle() {
        return g_set_printerr_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPrintFunc g_set_printerr_handler(GPrintFunc func)
     * }
     */
    public static MemorySegment g_set_printerr_handler$address() {
        return g_set_printerr_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPrintFunc g_set_printerr_handler(GPrintFunc func)
     * }
     */
    public static MemorySegment g_set_printerr_handler(MemorySegment func) {
        var mh$ = g_set_printerr_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_set_printerr_handler", func);
            }
            return (MemorySegment)mh$.invokeExact(func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_OPTION_FLAG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_FLAG_NONE = 0
     * }
     */
    public static int G_OPTION_FLAG_NONE() {
        return G_OPTION_FLAG_NONE;
    }
    private static final int G_OPTION_FLAG_HIDDEN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_FLAG_HIDDEN = 1
     * }
     */
    public static int G_OPTION_FLAG_HIDDEN() {
        return G_OPTION_FLAG_HIDDEN;
    }
    private static final int G_OPTION_FLAG_IN_MAIN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_FLAG_IN_MAIN = 2
     * }
     */
    public static int G_OPTION_FLAG_IN_MAIN() {
        return G_OPTION_FLAG_IN_MAIN;
    }
    private static final int G_OPTION_FLAG_REVERSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_FLAG_REVERSE = 4
     * }
     */
    public static int G_OPTION_FLAG_REVERSE() {
        return G_OPTION_FLAG_REVERSE;
    }
    private static final int G_OPTION_FLAG_NO_ARG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_FLAG_NO_ARG = 8
     * }
     */
    public static int G_OPTION_FLAG_NO_ARG() {
        return G_OPTION_FLAG_NO_ARG;
    }
    private static final int G_OPTION_FLAG_FILENAME = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_FLAG_FILENAME = 16
     * }
     */
    public static int G_OPTION_FLAG_FILENAME() {
        return G_OPTION_FLAG_FILENAME;
    }
    private static final int G_OPTION_FLAG_OPTIONAL_ARG = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_FLAG_OPTIONAL_ARG = 32
     * }
     */
    public static int G_OPTION_FLAG_OPTIONAL_ARG() {
        return G_OPTION_FLAG_OPTIONAL_ARG;
    }
    private static final int G_OPTION_FLAG_NOALIAS = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_FLAG_NOALIAS = 64
     * }
     */
    public static int G_OPTION_FLAG_NOALIAS() {
        return G_OPTION_FLAG_NOALIAS;
    }
    private static final int G_OPTION_ARG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_NONE = 0
     * }
     */
    public static int G_OPTION_ARG_NONE() {
        return G_OPTION_ARG_NONE;
    }
    private static final int G_OPTION_ARG_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_STRING = 1
     * }
     */
    public static int G_OPTION_ARG_STRING() {
        return G_OPTION_ARG_STRING;
    }
    private static final int G_OPTION_ARG_INT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_INT = 2
     * }
     */
    public static int G_OPTION_ARG_INT() {
        return G_OPTION_ARG_INT;
    }
    private static final int G_OPTION_ARG_CALLBACK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_CALLBACK = 3
     * }
     */
    public static int G_OPTION_ARG_CALLBACK() {
        return G_OPTION_ARG_CALLBACK;
    }
    private static final int G_OPTION_ARG_FILENAME = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_FILENAME = 4
     * }
     */
    public static int G_OPTION_ARG_FILENAME() {
        return G_OPTION_ARG_FILENAME;
    }
    private static final int G_OPTION_ARG_STRING_ARRAY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_STRING_ARRAY = 5
     * }
     */
    public static int G_OPTION_ARG_STRING_ARRAY() {
        return G_OPTION_ARG_STRING_ARRAY;
    }
    private static final int G_OPTION_ARG_FILENAME_ARRAY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_FILENAME_ARRAY = 6
     * }
     */
    public static int G_OPTION_ARG_FILENAME_ARRAY() {
        return G_OPTION_ARG_FILENAME_ARRAY;
    }
    private static final int G_OPTION_ARG_DOUBLE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_DOUBLE = 7
     * }
     */
    public static int G_OPTION_ARG_DOUBLE() {
        return G_OPTION_ARG_DOUBLE;
    }
    private static final int G_OPTION_ARG_INT64 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ARG_INT64 = 8
     * }
     */
    public static int G_OPTION_ARG_INT64() {
        return G_OPTION_ARG_INT64;
    }
    private static final int G_OPTION_ERROR_UNKNOWN_OPTION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ERROR_UNKNOWN_OPTION = 0
     * }
     */
    public static int G_OPTION_ERROR_UNKNOWN_OPTION() {
        return G_OPTION_ERROR_UNKNOWN_OPTION;
    }
    private static final int G_OPTION_ERROR_BAD_VALUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ERROR_BAD_VALUE = 1
     * }
     */
    public static int G_OPTION_ERROR_BAD_VALUE() {
        return G_OPTION_ERROR_BAD_VALUE;
    }
    private static final int G_OPTION_ERROR_FAILED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_OPTION_ERROR_FAILED = 2
     * }
     */
    public static int G_OPTION_ERROR_FAILED() {
        return G_OPTION_ERROR_FAILED;
    }

    private static class g_option_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_option_error_quark()
     * }
     */
    public static FunctionDescriptor g_option_error_quark$descriptor() {
        return g_option_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_option_error_quark()
     * }
     */
    public static MethodHandle g_option_error_quark$handle() {
        return g_option_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_option_error_quark()
     * }
     */
    public static MemorySegment g_option_error_quark$address() {
        return g_option_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_option_error_quark()
     * }
     */
    public static int g_option_error_quark() {
        var mh$ = g_option_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GOptionContext *g_option_context_new(const gchar *parameter_string)
     * }
     */
    public static FunctionDescriptor g_option_context_new$descriptor() {
        return g_option_context_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GOptionContext *g_option_context_new(const gchar *parameter_string)
     * }
     */
    public static MethodHandle g_option_context_new$handle() {
        return g_option_context_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GOptionContext *g_option_context_new(const gchar *parameter_string)
     * }
     */
    public static MemorySegment g_option_context_new$address() {
        return g_option_context_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GOptionContext *g_option_context_new(const gchar *parameter_string)
     * }
     */
    public static MemorySegment g_option_context_new(MemorySegment parameter_string) {
        var mh$ = g_option_context_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_new", parameter_string);
            }
            return (MemorySegment)mh$.invokeExact(parameter_string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_set_summary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_set_summary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_set_summary(GOptionContext *context, const gchar *summary)
     * }
     */
    public static FunctionDescriptor g_option_context_set_summary$descriptor() {
        return g_option_context_set_summary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_set_summary(GOptionContext *context, const gchar *summary)
     * }
     */
    public static MethodHandle g_option_context_set_summary$handle() {
        return g_option_context_set_summary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_set_summary(GOptionContext *context, const gchar *summary)
     * }
     */
    public static MemorySegment g_option_context_set_summary$address() {
        return g_option_context_set_summary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_set_summary(GOptionContext *context, const gchar *summary)
     * }
     */
    public static void g_option_context_set_summary(MemorySegment context, MemorySegment summary) {
        var mh$ = g_option_context_set_summary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_set_summary", context, summary);
            }
            mh$.invokeExact(context, summary);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_get_summary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_get_summary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_option_context_get_summary(GOptionContext *context)
     * }
     */
    public static FunctionDescriptor g_option_context_get_summary$descriptor() {
        return g_option_context_get_summary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_option_context_get_summary(GOptionContext *context)
     * }
     */
    public static MethodHandle g_option_context_get_summary$handle() {
        return g_option_context_get_summary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_option_context_get_summary(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_summary$address() {
        return g_option_context_get_summary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_option_context_get_summary(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_summary(MemorySegment context) {
        var mh$ = g_option_context_get_summary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_get_summary", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_set_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_set_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_set_description(GOptionContext *context, const gchar *description)
     * }
     */
    public static FunctionDescriptor g_option_context_set_description$descriptor() {
        return g_option_context_set_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_set_description(GOptionContext *context, const gchar *description)
     * }
     */
    public static MethodHandle g_option_context_set_description$handle() {
        return g_option_context_set_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_set_description(GOptionContext *context, const gchar *description)
     * }
     */
    public static MemorySegment g_option_context_set_description$address() {
        return g_option_context_set_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_set_description(GOptionContext *context, const gchar *description)
     * }
     */
    public static void g_option_context_set_description(MemorySegment context, MemorySegment description) {
        var mh$ = g_option_context_set_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_set_description", context, description);
            }
            mh$.invokeExact(context, description);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_get_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_get_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_option_context_get_description(GOptionContext *context)
     * }
     */
    public static FunctionDescriptor g_option_context_get_description$descriptor() {
        return g_option_context_get_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_option_context_get_description(GOptionContext *context)
     * }
     */
    public static MethodHandle g_option_context_get_description$handle() {
        return g_option_context_get_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_option_context_get_description(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_description$address() {
        return g_option_context_get_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_option_context_get_description(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_description(MemorySegment context) {
        var mh$ = g_option_context_get_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_get_description", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_free(GOptionContext *context)
     * }
     */
    public static FunctionDescriptor g_option_context_free$descriptor() {
        return g_option_context_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_free(GOptionContext *context)
     * }
     */
    public static MethodHandle g_option_context_free$handle() {
        return g_option_context_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_free(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_free$address() {
        return g_option_context_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_free(GOptionContext *context)
     * }
     */
    public static void g_option_context_free(MemorySegment context) {
        var mh$ = g_option_context_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_free", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_set_help_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_set_help_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_set_help_enabled(GOptionContext *context, gboolean help_enabled)
     * }
     */
    public static FunctionDescriptor g_option_context_set_help_enabled$descriptor() {
        return g_option_context_set_help_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_set_help_enabled(GOptionContext *context, gboolean help_enabled)
     * }
     */
    public static MethodHandle g_option_context_set_help_enabled$handle() {
        return g_option_context_set_help_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_set_help_enabled(GOptionContext *context, gboolean help_enabled)
     * }
     */
    public static MemorySegment g_option_context_set_help_enabled$address() {
        return g_option_context_set_help_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_set_help_enabled(GOptionContext *context, gboolean help_enabled)
     * }
     */
    public static void g_option_context_set_help_enabled(MemorySegment context, int help_enabled) {
        var mh$ = g_option_context_set_help_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_set_help_enabled", context, help_enabled);
            }
            mh$.invokeExact(context, help_enabled);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_get_help_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_get_help_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_help_enabled(GOptionContext *context)
     * }
     */
    public static FunctionDescriptor g_option_context_get_help_enabled$descriptor() {
        return g_option_context_get_help_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_help_enabled(GOptionContext *context)
     * }
     */
    public static MethodHandle g_option_context_get_help_enabled$handle() {
        return g_option_context_get_help_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_help_enabled(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_help_enabled$address() {
        return g_option_context_get_help_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_help_enabled(GOptionContext *context)
     * }
     */
    public static int g_option_context_get_help_enabled(MemorySegment context) {
        var mh$ = g_option_context_get_help_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_get_help_enabled", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_set_ignore_unknown_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_set_ignore_unknown_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_set_ignore_unknown_options(GOptionContext *context, gboolean ignore_unknown)
     * }
     */
    public static FunctionDescriptor g_option_context_set_ignore_unknown_options$descriptor() {
        return g_option_context_set_ignore_unknown_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_set_ignore_unknown_options(GOptionContext *context, gboolean ignore_unknown)
     * }
     */
    public static MethodHandle g_option_context_set_ignore_unknown_options$handle() {
        return g_option_context_set_ignore_unknown_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_set_ignore_unknown_options(GOptionContext *context, gboolean ignore_unknown)
     * }
     */
    public static MemorySegment g_option_context_set_ignore_unknown_options$address() {
        return g_option_context_set_ignore_unknown_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_set_ignore_unknown_options(GOptionContext *context, gboolean ignore_unknown)
     * }
     */
    public static void g_option_context_set_ignore_unknown_options(MemorySegment context, int ignore_unknown) {
        var mh$ = g_option_context_set_ignore_unknown_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_set_ignore_unknown_options", context, ignore_unknown);
            }
            mh$.invokeExact(context, ignore_unknown);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_get_ignore_unknown_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_get_ignore_unknown_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *context)
     * }
     */
    public static FunctionDescriptor g_option_context_get_ignore_unknown_options$descriptor() {
        return g_option_context_get_ignore_unknown_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *context)
     * }
     */
    public static MethodHandle g_option_context_get_ignore_unknown_options$handle() {
        return g_option_context_get_ignore_unknown_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_ignore_unknown_options$address() {
        return g_option_context_get_ignore_unknown_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *context)
     * }
     */
    public static int g_option_context_get_ignore_unknown_options(MemorySegment context) {
        var mh$ = g_option_context_get_ignore_unknown_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_get_ignore_unknown_options", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_set_strict_posix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_set_strict_posix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_set_strict_posix(GOptionContext *context, gboolean strict_posix)
     * }
     */
    public static FunctionDescriptor g_option_context_set_strict_posix$descriptor() {
        return g_option_context_set_strict_posix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_set_strict_posix(GOptionContext *context, gboolean strict_posix)
     * }
     */
    public static MethodHandle g_option_context_set_strict_posix$handle() {
        return g_option_context_set_strict_posix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_set_strict_posix(GOptionContext *context, gboolean strict_posix)
     * }
     */
    public static MemorySegment g_option_context_set_strict_posix$address() {
        return g_option_context_set_strict_posix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_set_strict_posix(GOptionContext *context, gboolean strict_posix)
     * }
     */
    public static void g_option_context_set_strict_posix(MemorySegment context, int strict_posix) {
        var mh$ = g_option_context_set_strict_posix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_set_strict_posix", context, strict_posix);
            }
            mh$.invokeExact(context, strict_posix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_get_strict_posix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_get_strict_posix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_strict_posix(GOptionContext *context)
     * }
     */
    public static FunctionDescriptor g_option_context_get_strict_posix$descriptor() {
        return g_option_context_get_strict_posix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_strict_posix(GOptionContext *context)
     * }
     */
    public static MethodHandle g_option_context_get_strict_posix$handle() {
        return g_option_context_get_strict_posix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_strict_posix(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_strict_posix$address() {
        return g_option_context_get_strict_posix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_option_context_get_strict_posix(GOptionContext *context)
     * }
     */
    public static int g_option_context_get_strict_posix(MemorySegment context) {
        var mh$ = g_option_context_get_strict_posix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_get_strict_posix", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_add_main_entries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_add_main_entries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_add_main_entries(GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain)
     * }
     */
    public static FunctionDescriptor g_option_context_add_main_entries$descriptor() {
        return g_option_context_add_main_entries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_add_main_entries(GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain)
     * }
     */
    public static MethodHandle g_option_context_add_main_entries$handle() {
        return g_option_context_add_main_entries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_add_main_entries(GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain)
     * }
     */
    public static MemorySegment g_option_context_add_main_entries$address() {
        return g_option_context_add_main_entries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_add_main_entries(GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain)
     * }
     */
    public static void g_option_context_add_main_entries(MemorySegment context, MemorySegment entries, MemorySegment translation_domain) {
        var mh$ = g_option_context_add_main_entries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_add_main_entries", context, entries, translation_domain);
            }
            mh$.invokeExact(context, entries, translation_domain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_parse(GOptionContext *context, gint *argc, gchar ***argv, GError **error)
     * }
     */
    public static FunctionDescriptor g_option_context_parse$descriptor() {
        return g_option_context_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_parse(GOptionContext *context, gint *argc, gchar ***argv, GError **error)
     * }
     */
    public static MethodHandle g_option_context_parse$handle() {
        return g_option_context_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_parse(GOptionContext *context, gint *argc, gchar ***argv, GError **error)
     * }
     */
    public static MemorySegment g_option_context_parse$address() {
        return g_option_context_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_option_context_parse(GOptionContext *context, gint *argc, gchar ***argv, GError **error)
     * }
     */
    public static int g_option_context_parse(MemorySegment context, MemorySegment argc, MemorySegment argv, MemorySegment error) {
        var mh$ = g_option_context_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_parse", context, argc, argv, error);
            }
            return (int)mh$.invokeExact(context, argc, argv, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_parse_strv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_parse_strv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_parse_strv(GOptionContext *context, gchar ***arguments, GError **error)
     * }
     */
    public static FunctionDescriptor g_option_context_parse_strv$descriptor() {
        return g_option_context_parse_strv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_parse_strv(GOptionContext *context, gchar ***arguments, GError **error)
     * }
     */
    public static MethodHandle g_option_context_parse_strv$handle() {
        return g_option_context_parse_strv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_option_context_parse_strv(GOptionContext *context, gchar ***arguments, GError **error)
     * }
     */
    public static MemorySegment g_option_context_parse_strv$address() {
        return g_option_context_parse_strv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_option_context_parse_strv(GOptionContext *context, gchar ***arguments, GError **error)
     * }
     */
    public static int g_option_context_parse_strv(MemorySegment context, MemorySegment arguments, MemorySegment error) {
        var mh$ = g_option_context_parse_strv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_parse_strv", context, arguments, error);
            }
            return (int)mh$.invokeExact(context, arguments, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_set_translate_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_set_translate_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_set_translate_func(GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify)
     * }
     */
    public static FunctionDescriptor g_option_context_set_translate_func$descriptor() {
        return g_option_context_set_translate_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_set_translate_func(GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify)
     * }
     */
    public static MethodHandle g_option_context_set_translate_func$handle() {
        return g_option_context_set_translate_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_set_translate_func(GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify)
     * }
     */
    public static MemorySegment g_option_context_set_translate_func$address() {
        return g_option_context_set_translate_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_set_translate_func(GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify)
     * }
     */
    public static void g_option_context_set_translate_func(MemorySegment context, MemorySegment func, MemorySegment data, MemorySegment destroy_notify) {
        var mh$ = g_option_context_set_translate_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_set_translate_func", context, func, data, destroy_notify);
            }
            mh$.invokeExact(context, func, data, destroy_notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_set_translation_domain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_set_translation_domain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_set_translation_domain(GOptionContext *context, const gchar *domain)
     * }
     */
    public static FunctionDescriptor g_option_context_set_translation_domain$descriptor() {
        return g_option_context_set_translation_domain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_set_translation_domain(GOptionContext *context, const gchar *domain)
     * }
     */
    public static MethodHandle g_option_context_set_translation_domain$handle() {
        return g_option_context_set_translation_domain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_set_translation_domain(GOptionContext *context, const gchar *domain)
     * }
     */
    public static MemorySegment g_option_context_set_translation_domain$address() {
        return g_option_context_set_translation_domain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_set_translation_domain(GOptionContext *context, const gchar *domain)
     * }
     */
    public static void g_option_context_set_translation_domain(MemorySegment context, MemorySegment domain) {
        var mh$ = g_option_context_set_translation_domain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_set_translation_domain", context, domain);
            }
            mh$.invokeExact(context, domain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_add_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_add_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_add_group(GOptionContext *context, GOptionGroup *group)
     * }
     */
    public static FunctionDescriptor g_option_context_add_group$descriptor() {
        return g_option_context_add_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_add_group(GOptionContext *context, GOptionGroup *group)
     * }
     */
    public static MethodHandle g_option_context_add_group$handle() {
        return g_option_context_add_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_add_group(GOptionContext *context, GOptionGroup *group)
     * }
     */
    public static MemorySegment g_option_context_add_group$address() {
        return g_option_context_add_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_add_group(GOptionContext *context, GOptionGroup *group)
     * }
     */
    public static void g_option_context_add_group(MemorySegment context, MemorySegment group) {
        var mh$ = g_option_context_add_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_add_group", context, group);
            }
            mh$.invokeExact(context, group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_set_main_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_set_main_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_context_set_main_group(GOptionContext *context, GOptionGroup *group)
     * }
     */
    public static FunctionDescriptor g_option_context_set_main_group$descriptor() {
        return g_option_context_set_main_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_context_set_main_group(GOptionContext *context, GOptionGroup *group)
     * }
     */
    public static MethodHandle g_option_context_set_main_group$handle() {
        return g_option_context_set_main_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_context_set_main_group(GOptionContext *context, GOptionGroup *group)
     * }
     */
    public static MemorySegment g_option_context_set_main_group$address() {
        return g_option_context_set_main_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_context_set_main_group(GOptionContext *context, GOptionGroup *group)
     * }
     */
    public static void g_option_context_set_main_group(MemorySegment context, MemorySegment group) {
        var mh$ = g_option_context_set_main_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_set_main_group", context, group);
            }
            mh$.invokeExact(context, group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_get_main_group {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_get_main_group");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context)
     * }
     */
    public static FunctionDescriptor g_option_context_get_main_group$descriptor() {
        return g_option_context_get_main_group.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context)
     * }
     */
    public static MethodHandle g_option_context_get_main_group$handle() {
        return g_option_context_get_main_group.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_main_group$address() {
        return g_option_context_get_main_group.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context)
     * }
     */
    public static MemorySegment g_option_context_get_main_group(MemorySegment context) {
        var mh$ = g_option_context_get_main_group.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_get_main_group", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_context_get_help {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_context_get_help");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_option_context_get_help(GOptionContext *context, gboolean main_help, GOptionGroup *group)
     * }
     */
    public static FunctionDescriptor g_option_context_get_help$descriptor() {
        return g_option_context_get_help.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_option_context_get_help(GOptionContext *context, gboolean main_help, GOptionGroup *group)
     * }
     */
    public static MethodHandle g_option_context_get_help$handle() {
        return g_option_context_get_help.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_option_context_get_help(GOptionContext *context, gboolean main_help, GOptionGroup *group)
     * }
     */
    public static MemorySegment g_option_context_get_help$address() {
        return g_option_context_get_help.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_option_context_get_help(GOptionContext *context, gboolean main_help, GOptionGroup *group)
     * }
     */
    public static MemorySegment g_option_context_get_help(MemorySegment context, int main_help, MemorySegment group) {
        var mh$ = g_option_context_get_help.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_context_get_help", context, main_help, group);
            }
            return (MemorySegment)mh$.invokeExact(context, main_help, group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_group_new(const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy)
     * }
     */
    public static FunctionDescriptor g_option_group_new$descriptor() {
        return g_option_group_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_group_new(const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy)
     * }
     */
    public static MethodHandle g_option_group_new$handle() {
        return g_option_group_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_group_new(const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_option_group_new$address() {
        return g_option_group_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_group_new(const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy)
     * }
     */
    public static MemorySegment g_option_group_new(MemorySegment name, MemorySegment description, MemorySegment help_description, MemorySegment user_data, MemorySegment destroy) {
        var mh$ = g_option_group_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_new", name, description, help_description, user_data, destroy);
            }
            return (MemorySegment)mh$.invokeExact(name, description, help_description, user_data, destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_set_parse_hooks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_set_parse_hooks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_group_set_parse_hooks(GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func)
     * }
     */
    public static FunctionDescriptor g_option_group_set_parse_hooks$descriptor() {
        return g_option_group_set_parse_hooks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_group_set_parse_hooks(GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func)
     * }
     */
    public static MethodHandle g_option_group_set_parse_hooks$handle() {
        return g_option_group_set_parse_hooks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_group_set_parse_hooks(GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func)
     * }
     */
    public static MemorySegment g_option_group_set_parse_hooks$address() {
        return g_option_group_set_parse_hooks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_group_set_parse_hooks(GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func)
     * }
     */
    public static void g_option_group_set_parse_hooks(MemorySegment group, MemorySegment pre_parse_func, MemorySegment post_parse_func) {
        var mh$ = g_option_group_set_parse_hooks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_set_parse_hooks", group, pre_parse_func, post_parse_func);
            }
            mh$.invokeExact(group, pre_parse_func, post_parse_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_set_error_hook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_set_error_hook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_group_set_error_hook(GOptionGroup *group, GOptionErrorFunc error_func)
     * }
     */
    public static FunctionDescriptor g_option_group_set_error_hook$descriptor() {
        return g_option_group_set_error_hook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_group_set_error_hook(GOptionGroup *group, GOptionErrorFunc error_func)
     * }
     */
    public static MethodHandle g_option_group_set_error_hook$handle() {
        return g_option_group_set_error_hook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_group_set_error_hook(GOptionGroup *group, GOptionErrorFunc error_func)
     * }
     */
    public static MemorySegment g_option_group_set_error_hook$address() {
        return g_option_group_set_error_hook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_group_set_error_hook(GOptionGroup *group, GOptionErrorFunc error_func)
     * }
     */
    public static void g_option_group_set_error_hook(MemorySegment group, MemorySegment error_func) {
        var mh$ = g_option_group_set_error_hook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_set_error_hook", group, error_func);
            }
            mh$.invokeExact(group, error_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_group_free(GOptionGroup *group)
     * }
     */
    public static FunctionDescriptor g_option_group_free$descriptor() {
        return g_option_group_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_group_free(GOptionGroup *group)
     * }
     */
    public static MethodHandle g_option_group_free$handle() {
        return g_option_group_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_group_free(GOptionGroup *group)
     * }
     */
    public static MemorySegment g_option_group_free$address() {
        return g_option_group_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_group_free(GOptionGroup *group)
     * }
     */
    public static void g_option_group_free(MemorySegment group) {
        var mh$ = g_option_group_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_free", group);
            }
            mh$.invokeExact(group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_group_ref(GOptionGroup *group)
     * }
     */
    public static FunctionDescriptor g_option_group_ref$descriptor() {
        return g_option_group_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_group_ref(GOptionGroup *group)
     * }
     */
    public static MethodHandle g_option_group_ref$handle() {
        return g_option_group_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_group_ref(GOptionGroup *group)
     * }
     */
    public static MemorySegment g_option_group_ref$address() {
        return g_option_group_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GOptionGroup *g_option_group_ref(GOptionGroup *group)
     * }
     */
    public static MemorySegment g_option_group_ref(MemorySegment group) {
        var mh$ = g_option_group_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_ref", group);
            }
            return (MemorySegment)mh$.invokeExact(group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_group_unref(GOptionGroup *group)
     * }
     */
    public static FunctionDescriptor g_option_group_unref$descriptor() {
        return g_option_group_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_group_unref(GOptionGroup *group)
     * }
     */
    public static MethodHandle g_option_group_unref$handle() {
        return g_option_group_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_group_unref(GOptionGroup *group)
     * }
     */
    public static MemorySegment g_option_group_unref$address() {
        return g_option_group_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_group_unref(GOptionGroup *group)
     * }
     */
    public static void g_option_group_unref(MemorySegment group) {
        var mh$ = g_option_group_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_unref", group);
            }
            mh$.invokeExact(group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_add_entries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_add_entries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_group_add_entries(GOptionGroup *group, const GOptionEntry *entries)
     * }
     */
    public static FunctionDescriptor g_option_group_add_entries$descriptor() {
        return g_option_group_add_entries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_group_add_entries(GOptionGroup *group, const GOptionEntry *entries)
     * }
     */
    public static MethodHandle g_option_group_add_entries$handle() {
        return g_option_group_add_entries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_group_add_entries(GOptionGroup *group, const GOptionEntry *entries)
     * }
     */
    public static MemorySegment g_option_group_add_entries$address() {
        return g_option_group_add_entries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_group_add_entries(GOptionGroup *group, const GOptionEntry *entries)
     * }
     */
    public static void g_option_group_add_entries(MemorySegment group, MemorySegment entries) {
        var mh$ = g_option_group_add_entries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_add_entries", group, entries);
            }
            mh$.invokeExact(group, entries);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_set_translate_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_set_translate_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_group_set_translate_func(GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify)
     * }
     */
    public static FunctionDescriptor g_option_group_set_translate_func$descriptor() {
        return g_option_group_set_translate_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_group_set_translate_func(GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify)
     * }
     */
    public static MethodHandle g_option_group_set_translate_func$handle() {
        return g_option_group_set_translate_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_group_set_translate_func(GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify)
     * }
     */
    public static MemorySegment g_option_group_set_translate_func$address() {
        return g_option_group_set_translate_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_group_set_translate_func(GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify)
     * }
     */
    public static void g_option_group_set_translate_func(MemorySegment group, MemorySegment func, MemorySegment data, MemorySegment destroy_notify) {
        var mh$ = g_option_group_set_translate_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_set_translate_func", group, func, data, destroy_notify);
            }
            mh$.invokeExact(group, func, data, destroy_notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_option_group_set_translation_domain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_option_group_set_translation_domain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_option_group_set_translation_domain(GOptionGroup *group, const gchar *domain)
     * }
     */
    public static FunctionDescriptor g_option_group_set_translation_domain$descriptor() {
        return g_option_group_set_translation_domain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_option_group_set_translation_domain(GOptionGroup *group, const gchar *domain)
     * }
     */
    public static MethodHandle g_option_group_set_translation_domain$handle() {
        return g_option_group_set_translation_domain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_option_group_set_translation_domain(GOptionGroup *group, const gchar *domain)
     * }
     */
    public static MemorySegment g_option_group_set_translation_domain$address() {
        return g_option_group_set_translation_domain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_option_group_set_translation_domain(GOptionGroup *group, const gchar *domain)
     * }
     */
    public static void g_option_group_set_translation_domain(MemorySegment group, MemorySegment domain) {
        var mh$ = g_option_group_set_translation_domain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_option_group_set_translation_domain", group, domain);
            }
            mh$.invokeExact(group, domain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_new()
     * }
     */
    public static FunctionDescriptor g_path_buf_new$descriptor() {
        return g_path_buf_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_new()
     * }
     */
    public static MethodHandle g_path_buf_new$handle() {
        return g_path_buf_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_new()
     * }
     */
    public static MemorySegment g_path_buf_new$address() {
        return g_path_buf_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_new()
     * }
     */
    public static MemorySegment g_path_buf_new() {
        var mh$ = g_path_buf_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_new_from_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_new_from_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_new_from_path(const char *path)
     * }
     */
    public static FunctionDescriptor g_path_buf_new_from_path$descriptor() {
        return g_path_buf_new_from_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_new_from_path(const char *path)
     * }
     */
    public static MethodHandle g_path_buf_new_from_path$handle() {
        return g_path_buf_new_from_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_new_from_path(const char *path)
     * }
     */
    public static MemorySegment g_path_buf_new_from_path$address() {
        return g_path_buf_new_from_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_new_from_path(const char *path)
     * }
     */
    public static MemorySegment g_path_buf_new_from_path(MemorySegment path) {
        var mh$ = g_path_buf_new_from_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_new_from_path", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_init(GPathBuf *buf)
     * }
     */
    public static FunctionDescriptor g_path_buf_init$descriptor() {
        return g_path_buf_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_init(GPathBuf *buf)
     * }
     */
    public static MethodHandle g_path_buf_init$handle() {
        return g_path_buf_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_init(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_init$address() {
        return g_path_buf_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_init(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_init(MemorySegment buf) {
        var mh$ = g_path_buf_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_init", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_init_from_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_init_from_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_init_from_path(GPathBuf *buf, const char *path)
     * }
     */
    public static FunctionDescriptor g_path_buf_init_from_path$descriptor() {
        return g_path_buf_init_from_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_init_from_path(GPathBuf *buf, const char *path)
     * }
     */
    public static MethodHandle g_path_buf_init_from_path$handle() {
        return g_path_buf_init_from_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_init_from_path(GPathBuf *buf, const char *path)
     * }
     */
    public static MemorySegment g_path_buf_init_from_path$address() {
        return g_path_buf_init_from_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_init_from_path(GPathBuf *buf, const char *path)
     * }
     */
    public static MemorySegment g_path_buf_init_from_path(MemorySegment buf, MemorySegment path) {
        var mh$ = g_path_buf_init_from_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_init_from_path", buf, path);
            }
            return (MemorySegment)mh$.invokeExact(buf, path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_path_buf_clear(GPathBuf *buf)
     * }
     */
    public static FunctionDescriptor g_path_buf_clear$descriptor() {
        return g_path_buf_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_path_buf_clear(GPathBuf *buf)
     * }
     */
    public static MethodHandle g_path_buf_clear$handle() {
        return g_path_buf_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_path_buf_clear(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_clear$address() {
        return g_path_buf_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_path_buf_clear(GPathBuf *buf)
     * }
     */
    public static void g_path_buf_clear(MemorySegment buf) {
        var mh$ = g_path_buf_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_clear", buf);
            }
            mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_clear_to_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_clear_to_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_path_buf_clear_to_path(GPathBuf *buf)
     * }
     */
    public static FunctionDescriptor g_path_buf_clear_to_path$descriptor() {
        return g_path_buf_clear_to_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_path_buf_clear_to_path(GPathBuf *buf)
     * }
     */
    public static MethodHandle g_path_buf_clear_to_path$handle() {
        return g_path_buf_clear_to_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_path_buf_clear_to_path(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_clear_to_path$address() {
        return g_path_buf_clear_to_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_path_buf_clear_to_path(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_clear_to_path(MemorySegment buf) {
        var mh$ = g_path_buf_clear_to_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_clear_to_path", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_path_buf_free(GPathBuf *buf)
     * }
     */
    public static FunctionDescriptor g_path_buf_free$descriptor() {
        return g_path_buf_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_path_buf_free(GPathBuf *buf)
     * }
     */
    public static MethodHandle g_path_buf_free$handle() {
        return g_path_buf_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_path_buf_free(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_free$address() {
        return g_path_buf_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_path_buf_free(GPathBuf *buf)
     * }
     */
    public static void g_path_buf_free(MemorySegment buf) {
        var mh$ = g_path_buf_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_free", buf);
            }
            mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_free_to_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_free_to_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_path_buf_free_to_path(GPathBuf *buf)
     * }
     */
    public static FunctionDescriptor g_path_buf_free_to_path$descriptor() {
        return g_path_buf_free_to_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_path_buf_free_to_path(GPathBuf *buf)
     * }
     */
    public static MethodHandle g_path_buf_free_to_path$handle() {
        return g_path_buf_free_to_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_path_buf_free_to_path(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_free_to_path$address() {
        return g_path_buf_free_to_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_path_buf_free_to_path(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_free_to_path(MemorySegment buf) {
        var mh$ = g_path_buf_free_to_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_free_to_path", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_copy(GPathBuf *buf)
     * }
     */
    public static FunctionDescriptor g_path_buf_copy$descriptor() {
        return g_path_buf_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_copy(GPathBuf *buf)
     * }
     */
    public static MethodHandle g_path_buf_copy$handle() {
        return g_path_buf_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_copy(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_copy$address() {
        return g_path_buf_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_copy(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_copy(MemorySegment buf) {
        var mh$ = g_path_buf_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_copy", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_push(GPathBuf *buf, const char *path)
     * }
     */
    public static FunctionDescriptor g_path_buf_push$descriptor() {
        return g_path_buf_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_push(GPathBuf *buf, const char *path)
     * }
     */
    public static MethodHandle g_path_buf_push$handle() {
        return g_path_buf_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_push(GPathBuf *buf, const char *path)
     * }
     */
    public static MemorySegment g_path_buf_push$address() {
        return g_path_buf_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPathBuf *g_path_buf_push(GPathBuf *buf, const char *path)
     * }
     */
    public static MemorySegment g_path_buf_push(MemorySegment buf, MemorySegment path) {
        var mh$ = g_path_buf_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_push", buf, path);
            }
            return (MemorySegment)mh$.invokeExact(buf, path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_pop(GPathBuf *buf)
     * }
     */
    public static FunctionDescriptor g_path_buf_pop$descriptor() {
        return g_path_buf_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_pop(GPathBuf *buf)
     * }
     */
    public static MethodHandle g_path_buf_pop$handle() {
        return g_path_buf_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_pop(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_pop$address() {
        return g_path_buf_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_path_buf_pop(GPathBuf *buf)
     * }
     */
    public static int g_path_buf_pop(MemorySegment buf) {
        var mh$ = g_path_buf_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_pop", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_set_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_set_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_set_filename(GPathBuf *buf, const char *file_name)
     * }
     */
    public static FunctionDescriptor g_path_buf_set_filename$descriptor() {
        return g_path_buf_set_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_set_filename(GPathBuf *buf, const char *file_name)
     * }
     */
    public static MethodHandle g_path_buf_set_filename$handle() {
        return g_path_buf_set_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_set_filename(GPathBuf *buf, const char *file_name)
     * }
     */
    public static MemorySegment g_path_buf_set_filename$address() {
        return g_path_buf_set_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_path_buf_set_filename(GPathBuf *buf, const char *file_name)
     * }
     */
    public static int g_path_buf_set_filename(MemorySegment buf, MemorySegment file_name) {
        var mh$ = g_path_buf_set_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_set_filename", buf, file_name);
            }
            return (int)mh$.invokeExact(buf, file_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_set_extension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_set_extension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_set_extension(GPathBuf *buf, const char *extension)
     * }
     */
    public static FunctionDescriptor g_path_buf_set_extension$descriptor() {
        return g_path_buf_set_extension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_set_extension(GPathBuf *buf, const char *extension)
     * }
     */
    public static MethodHandle g_path_buf_set_extension$handle() {
        return g_path_buf_set_extension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_set_extension(GPathBuf *buf, const char *extension)
     * }
     */
    public static MemorySegment g_path_buf_set_extension$address() {
        return g_path_buf_set_extension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_path_buf_set_extension(GPathBuf *buf, const char *extension)
     * }
     */
    public static int g_path_buf_set_extension(MemorySegment buf, MemorySegment extension) {
        var mh$ = g_path_buf_set_extension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_set_extension", buf, extension);
            }
            return (int)mh$.invokeExact(buf, extension);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_to_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_to_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_path_buf_to_path(GPathBuf *buf)
     * }
     */
    public static FunctionDescriptor g_path_buf_to_path$descriptor() {
        return g_path_buf_to_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_path_buf_to_path(GPathBuf *buf)
     * }
     */
    public static MethodHandle g_path_buf_to_path$handle() {
        return g_path_buf_to_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_path_buf_to_path(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_to_path$address() {
        return g_path_buf_to_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_path_buf_to_path(GPathBuf *buf)
     * }
     */
    public static MemorySegment g_path_buf_to_path(MemorySegment buf) {
        var mh$ = g_path_buf_to_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_to_path", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_path_buf_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_path_buf_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static FunctionDescriptor g_path_buf_equal$descriptor() {
        return g_path_buf_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MethodHandle g_path_buf_equal$handle() {
        return g_path_buf_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_path_buf_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static MemorySegment g_path_buf_equal$address() {
        return g_path_buf_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_path_buf_equal(gconstpointer v1, gconstpointer v2)
     * }
     */
    public static int g_path_buf_equal(MemorySegment v1, MemorySegment v2) {
        var mh$ = g_path_buf_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_path_buf_equal", v1, v2);
            }
            return (int)mh$.invokeExact(v1, v2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_spec_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_spec_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPatternSpec *g_pattern_spec_new(const gchar *pattern)
     * }
     */
    public static FunctionDescriptor g_pattern_spec_new$descriptor() {
        return g_pattern_spec_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPatternSpec *g_pattern_spec_new(const gchar *pattern)
     * }
     */
    public static MethodHandle g_pattern_spec_new$handle() {
        return g_pattern_spec_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPatternSpec *g_pattern_spec_new(const gchar *pattern)
     * }
     */
    public static MemorySegment g_pattern_spec_new$address() {
        return g_pattern_spec_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPatternSpec *g_pattern_spec_new(const gchar *pattern)
     * }
     */
    public static MemorySegment g_pattern_spec_new(MemorySegment pattern) {
        var mh$ = g_pattern_spec_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_spec_new", pattern);
            }
            return (MemorySegment)mh$.invokeExact(pattern);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_spec_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_spec_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_pattern_spec_free(GPatternSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_pattern_spec_free$descriptor() {
        return g_pattern_spec_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_pattern_spec_free(GPatternSpec *pspec)
     * }
     */
    public static MethodHandle g_pattern_spec_free$handle() {
        return g_pattern_spec_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_pattern_spec_free(GPatternSpec *pspec)
     * }
     */
    public static MemorySegment g_pattern_spec_free$address() {
        return g_pattern_spec_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_pattern_spec_free(GPatternSpec *pspec)
     * }
     */
    public static void g_pattern_spec_free(MemorySegment pspec) {
        var mh$ = g_pattern_spec_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_spec_free", pspec);
            }
            mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_spec_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_spec_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GPatternSpec *g_pattern_spec_copy(GPatternSpec *pspec)
     * }
     */
    public static FunctionDescriptor g_pattern_spec_copy$descriptor() {
        return g_pattern_spec_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GPatternSpec *g_pattern_spec_copy(GPatternSpec *pspec)
     * }
     */
    public static MethodHandle g_pattern_spec_copy$handle() {
        return g_pattern_spec_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GPatternSpec *g_pattern_spec_copy(GPatternSpec *pspec)
     * }
     */
    public static MemorySegment g_pattern_spec_copy$address() {
        return g_pattern_spec_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GPatternSpec *g_pattern_spec_copy(GPatternSpec *pspec)
     * }
     */
    public static MemorySegment g_pattern_spec_copy(MemorySegment pspec) {
        var mh$ = g_pattern_spec_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_spec_copy", pspec);
            }
            return (MemorySegment)mh$.invokeExact(pspec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_spec_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_spec_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1, GPatternSpec *pspec2)
     * }
     */
    public static FunctionDescriptor g_pattern_spec_equal$descriptor() {
        return g_pattern_spec_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1, GPatternSpec *pspec2)
     * }
     */
    public static MethodHandle g_pattern_spec_equal$handle() {
        return g_pattern_spec_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1, GPatternSpec *pspec2)
     * }
     */
    public static MemorySegment g_pattern_spec_equal$address() {
        return g_pattern_spec_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1, GPatternSpec *pspec2)
     * }
     */
    public static int g_pattern_spec_equal(MemorySegment pspec1, MemorySegment pspec2) {
        var mh$ = g_pattern_spec_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_spec_equal", pspec1, pspec2);
            }
            return (int)mh$.invokeExact(pspec1, pspec2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_spec_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_spec_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_match(GPatternSpec *pspec, gsize string_length, const gchar *string, const gchar *string_reversed)
     * }
     */
    public static FunctionDescriptor g_pattern_spec_match$descriptor() {
        return g_pattern_spec_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_match(GPatternSpec *pspec, gsize string_length, const gchar *string, const gchar *string_reversed)
     * }
     */
    public static MethodHandle g_pattern_spec_match$handle() {
        return g_pattern_spec_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_match(GPatternSpec *pspec, gsize string_length, const gchar *string, const gchar *string_reversed)
     * }
     */
    public static MemorySegment g_pattern_spec_match$address() {
        return g_pattern_spec_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_match(GPatternSpec *pspec, gsize string_length, const gchar *string, const gchar *string_reversed)
     * }
     */
    public static int g_pattern_spec_match(MemorySegment pspec, long string_length, MemorySegment string, MemorySegment string_reversed) {
        var mh$ = g_pattern_spec_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_spec_match", pspec, string_length, string, string_reversed);
            }
            return (int)mh$.invokeExact(pspec, string_length, string, string_reversed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_spec_match_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_spec_match_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_match_string(GPatternSpec *pspec, const gchar *string)
     * }
     */
    public static FunctionDescriptor g_pattern_spec_match_string$descriptor() {
        return g_pattern_spec_match_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_match_string(GPatternSpec *pspec, const gchar *string)
     * }
     */
    public static MethodHandle g_pattern_spec_match_string$handle() {
        return g_pattern_spec_match_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_match_string(GPatternSpec *pspec, const gchar *string)
     * }
     */
    public static MemorySegment g_pattern_spec_match_string$address() {
        return g_pattern_spec_match_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_pattern_spec_match_string(GPatternSpec *pspec, const gchar *string)
     * }
     */
    public static int g_pattern_spec_match_string(MemorySegment pspec, MemorySegment string) {
        var mh$ = g_pattern_spec_match_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_spec_match_string", pspec, string);
            }
            return (int)mh$.invokeExact(pspec, string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match(GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed)
     * }
     */
    public static FunctionDescriptor g_pattern_match$descriptor() {
        return g_pattern_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match(GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed)
     * }
     */
    public static MethodHandle g_pattern_match$handle() {
        return g_pattern_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match(GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed)
     * }
     */
    public static MemorySegment g_pattern_match$address() {
        return g_pattern_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_pattern_match(GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed)
     * }
     */
    public static int g_pattern_match(MemorySegment pspec, int string_length, MemorySegment string, MemorySegment string_reversed) {
        var mh$ = g_pattern_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_match", pspec, string_length, string, string_reversed);
            }
            return (int)mh$.invokeExact(pspec, string_length, string, string_reversed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_match_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_match_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match_string(GPatternSpec *pspec, const gchar *string)
     * }
     */
    public static FunctionDescriptor g_pattern_match_string$descriptor() {
        return g_pattern_match_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match_string(GPatternSpec *pspec, const gchar *string)
     * }
     */
    public static MethodHandle g_pattern_match_string$handle() {
        return g_pattern_match_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match_string(GPatternSpec *pspec, const gchar *string)
     * }
     */
    public static MemorySegment g_pattern_match_string$address() {
        return g_pattern_match_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_pattern_match_string(GPatternSpec *pspec, const gchar *string)
     * }
     */
    public static int g_pattern_match_string(MemorySegment pspec, MemorySegment string) {
        var mh$ = g_pattern_match_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_match_string", pspec, string);
            }
            return (int)mh$.invokeExact(pspec, string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_pattern_match_simple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_pattern_match_simple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match_simple(const gchar *pattern, const gchar *string)
     * }
     */
    public static FunctionDescriptor g_pattern_match_simple$descriptor() {
        return g_pattern_match_simple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match_simple(const gchar *pattern, const gchar *string)
     * }
     */
    public static MethodHandle g_pattern_match_simple$handle() {
        return g_pattern_match_simple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_pattern_match_simple(const gchar *pattern, const gchar *string)
     * }
     */
    public static MemorySegment g_pattern_match_simple$address() {
        return g_pattern_match_simple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_pattern_match_simple(const gchar *pattern, const gchar *string)
     * }
     */
    public static int g_pattern_match_simple(MemorySegment pattern, MemorySegment string) {
        var mh$ = g_pattern_match_simple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_pattern_match_simple", pattern, string);
            }
            return (int)mh$.invokeExact(pattern, string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spaced_primes_closest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spaced_primes_closest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_spaced_primes_closest(guint num)
     * }
     */
    public static FunctionDescriptor g_spaced_primes_closest$descriptor() {
        return g_spaced_primes_closest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_spaced_primes_closest(guint num)
     * }
     */
    public static MethodHandle g_spaced_primes_closest$handle() {
        return g_spaced_primes_closest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_spaced_primes_closest(guint num)
     * }
     */
    public static MemorySegment g_spaced_primes_closest$address() {
        return g_spaced_primes_closest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_spaced_primes_closest(guint num)
     * }
     */
    public static int g_spaced_primes_closest(int num) {
        var mh$ = g_spaced_primes_closest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spaced_primes_closest", num);
            }
            return (int)mh$.invokeExact(num);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_qsort_with_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_qsort_with_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_qsort_with_data(gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_qsort_with_data$descriptor() {
        return g_qsort_with_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_qsort_with_data(gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_qsort_with_data$handle() {
        return g_qsort_with_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_qsort_with_data(gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_qsort_with_data$address() {
        return g_qsort_with_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_qsort_with_data(gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static void g_qsort_with_data(MemorySegment pbase, int total_elems, long size, MemorySegment compare_func, MemorySegment user_data) {
        var mh$ = g_qsort_with_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_qsort_with_data", pbase, total_elems, size, compare_func, user_data);
            }
            mh$.invokeExact(pbase, total_elems, size, compare_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQueue *g_queue_new()
     * }
     */
    public static FunctionDescriptor g_queue_new$descriptor() {
        return g_queue_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQueue *g_queue_new()
     * }
     */
    public static MethodHandle g_queue_new$handle() {
        return g_queue_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQueue *g_queue_new()
     * }
     */
    public static MemorySegment g_queue_new$address() {
        return g_queue_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQueue *g_queue_new()
     * }
     */
    public static MemorySegment g_queue_new() {
        var mh$ = g_queue_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_free(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_free$descriptor() {
        return g_queue_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_free(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_free$handle() {
        return g_queue_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_free(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_free$address() {
        return g_queue_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_free(GQueue *queue)
     * }
     */
    public static void g_queue_free(MemorySegment queue) {
        var mh$ = g_queue_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_free", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_free_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_free_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_free_full(GQueue *queue, GDestroyNotify free_func)
     * }
     */
    public static FunctionDescriptor g_queue_free_full$descriptor() {
        return g_queue_free_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_free_full(GQueue *queue, GDestroyNotify free_func)
     * }
     */
    public static MethodHandle g_queue_free_full$handle() {
        return g_queue_free_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_free_full(GQueue *queue, GDestroyNotify free_func)
     * }
     */
    public static MemorySegment g_queue_free_full$address() {
        return g_queue_free_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_free_full(GQueue *queue, GDestroyNotify free_func)
     * }
     */
    public static void g_queue_free_full(MemorySegment queue, MemorySegment free_func) {
        var mh$ = g_queue_free_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_free_full", queue, free_func);
            }
            mh$.invokeExact(queue, free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_init(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_init$descriptor() {
        return g_queue_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_init(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_init$handle() {
        return g_queue_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_init(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_init$address() {
        return g_queue_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_init(GQueue *queue)
     * }
     */
    public static void g_queue_init(MemorySegment queue) {
        var mh$ = g_queue_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_init", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_clear(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_clear$descriptor() {
        return g_queue_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_clear(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_clear$handle() {
        return g_queue_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_clear(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_clear$address() {
        return g_queue_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_clear(GQueue *queue)
     * }
     */
    public static void g_queue_clear(MemorySegment queue) {
        var mh$ = g_queue_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_clear", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_is_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_is_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_queue_is_empty(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_is_empty$descriptor() {
        return g_queue_is_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_queue_is_empty(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_is_empty$handle() {
        return g_queue_is_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_queue_is_empty(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_is_empty$address() {
        return g_queue_is_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_queue_is_empty(GQueue *queue)
     * }
     */
    public static int g_queue_is_empty(MemorySegment queue) {
        var mh$ = g_queue_is_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_is_empty", queue);
            }
            return (int)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_clear_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_clear_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_clear_full(GQueue *queue, GDestroyNotify free_func)
     * }
     */
    public static FunctionDescriptor g_queue_clear_full$descriptor() {
        return g_queue_clear_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_clear_full(GQueue *queue, GDestroyNotify free_func)
     * }
     */
    public static MethodHandle g_queue_clear_full$handle() {
        return g_queue_clear_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_clear_full(GQueue *queue, GDestroyNotify free_func)
     * }
     */
    public static MemorySegment g_queue_clear_full$address() {
        return g_queue_clear_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_clear_full(GQueue *queue, GDestroyNotify free_func)
     * }
     */
    public static void g_queue_clear_full(MemorySegment queue, MemorySegment free_func) {
        var mh$ = g_queue_clear_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_clear_full", queue, free_func);
            }
            mh$.invokeExact(queue, free_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_get_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_get_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_queue_get_length(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_get_length$descriptor() {
        return g_queue_get_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_queue_get_length(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_get_length$handle() {
        return g_queue_get_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_queue_get_length(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_get_length$address() {
        return g_queue_get_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_queue_get_length(GQueue *queue)
     * }
     */
    public static int g_queue_get_length(MemorySegment queue) {
        var mh$ = g_queue_get_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_get_length", queue);
            }
            return (int)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_reverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_reverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_reverse(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_reverse$descriptor() {
        return g_queue_reverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_reverse(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_reverse$handle() {
        return g_queue_reverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_reverse(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_reverse$address() {
        return g_queue_reverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_reverse(GQueue *queue)
     * }
     */
    public static void g_queue_reverse(MemorySegment queue) {
        var mh$ = g_queue_reverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_reverse", queue);
            }
            mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQueue *g_queue_copy(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_copy$descriptor() {
        return g_queue_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQueue *g_queue_copy(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_copy$handle() {
        return g_queue_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQueue *g_queue_copy(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_copy$address() {
        return g_queue_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQueue *g_queue_copy(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_copy(MemorySegment queue) {
        var mh$ = g_queue_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_copy", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_foreach(GQueue *queue, GFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_queue_foreach$descriptor() {
        return g_queue_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_foreach(GQueue *queue, GFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_queue_foreach$handle() {
        return g_queue_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_foreach(GQueue *queue, GFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_queue_foreach$address() {
        return g_queue_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_foreach(GQueue *queue, GFunc func, gpointer user_data)
     * }
     */
    public static void g_queue_foreach(MemorySegment queue, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_queue_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_foreach", queue, func, user_data);
            }
            mh$.invokeExact(queue, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_queue_find(GQueue *queue, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_queue_find$descriptor() {
        return g_queue_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_queue_find(GQueue *queue, gconstpointer data)
     * }
     */
    public static MethodHandle g_queue_find$handle() {
        return g_queue_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_queue_find(GQueue *queue, gconstpointer data)
     * }
     */
    public static MemorySegment g_queue_find$address() {
        return g_queue_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_queue_find(GQueue *queue, gconstpointer data)
     * }
     */
    public static MemorySegment g_queue_find(MemorySegment queue, MemorySegment data) {
        var mh$ = g_queue_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_find", queue, data);
            }
            return (MemorySegment)mh$.invokeExact(queue, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_find_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_find_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_queue_find_custom(GQueue *queue, gconstpointer data, GCompareFunc func)
     * }
     */
    public static FunctionDescriptor g_queue_find_custom$descriptor() {
        return g_queue_find_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_queue_find_custom(GQueue *queue, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MethodHandle g_queue_find_custom$handle() {
        return g_queue_find_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_queue_find_custom(GQueue *queue, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_queue_find_custom$address() {
        return g_queue_find_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_queue_find_custom(GQueue *queue, gconstpointer data, GCompareFunc func)
     * }
     */
    public static MemorySegment g_queue_find_custom(MemorySegment queue, MemorySegment data, MemorySegment func) {
        var mh$ = g_queue_find_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_find_custom", queue, data, func);
            }
            return (MemorySegment)mh$.invokeExact(queue, data, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_sort(GQueue *queue, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_queue_sort$descriptor() {
        return g_queue_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_sort(GQueue *queue, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MethodHandle g_queue_sort$handle() {
        return g_queue_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_sort(GQueue *queue, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static MemorySegment g_queue_sort$address() {
        return g_queue_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_sort(GQueue *queue, GCompareDataFunc compare_func, gpointer user_data)
     * }
     */
    public static void g_queue_sort(MemorySegment queue, MemorySegment compare_func, MemorySegment user_data) {
        var mh$ = g_queue_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_sort", queue, compare_func, user_data);
            }
            mh$.invokeExact(queue, compare_func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_push_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_push_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_push_head(GQueue *queue, gpointer data)
     * }
     */
    public static FunctionDescriptor g_queue_push_head$descriptor() {
        return g_queue_push_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_push_head(GQueue *queue, gpointer data)
     * }
     */
    public static MethodHandle g_queue_push_head$handle() {
        return g_queue_push_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_push_head(GQueue *queue, gpointer data)
     * }
     */
    public static MemorySegment g_queue_push_head$address() {
        return g_queue_push_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_push_head(GQueue *queue, gpointer data)
     * }
     */
    public static void g_queue_push_head(MemorySegment queue, MemorySegment data) {
        var mh$ = g_queue_push_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_push_head", queue, data);
            }
            mh$.invokeExact(queue, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_push_tail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_push_tail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_push_tail(GQueue *queue, gpointer data)
     * }
     */
    public static FunctionDescriptor g_queue_push_tail$descriptor() {
        return g_queue_push_tail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_push_tail(GQueue *queue, gpointer data)
     * }
     */
    public static MethodHandle g_queue_push_tail$handle() {
        return g_queue_push_tail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_push_tail(GQueue *queue, gpointer data)
     * }
     */
    public static MemorySegment g_queue_push_tail$address() {
        return g_queue_push_tail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_push_tail(GQueue *queue, gpointer data)
     * }
     */
    public static void g_queue_push_tail(MemorySegment queue, MemorySegment data) {
        var mh$ = g_queue_push_tail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_push_tail", queue, data);
            }
            mh$.invokeExact(queue, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_push_nth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_push_nth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_push_nth(GQueue *queue, gpointer data, gint n)
     * }
     */
    public static FunctionDescriptor g_queue_push_nth$descriptor() {
        return g_queue_push_nth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_push_nth(GQueue *queue, gpointer data, gint n)
     * }
     */
    public static MethodHandle g_queue_push_nth$handle() {
        return g_queue_push_nth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_push_nth(GQueue *queue, gpointer data, gint n)
     * }
     */
    public static MemorySegment g_queue_push_nth$address() {
        return g_queue_push_nth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_push_nth(GQueue *queue, gpointer data, gint n)
     * }
     */
    public static void g_queue_push_nth(MemorySegment queue, MemorySegment data, int n) {
        var mh$ = g_queue_push_nth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_push_nth", queue, data, n);
            }
            mh$.invokeExact(queue, data, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_pop_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_pop_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_head(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_pop_head$descriptor() {
        return g_queue_pop_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_head(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_pop_head$handle() {
        return g_queue_pop_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_head(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_pop_head$address() {
        return g_queue_pop_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_head(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_pop_head(MemorySegment queue) {
        var mh$ = g_queue_pop_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_pop_head", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_pop_tail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_pop_tail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_tail(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_pop_tail$descriptor() {
        return g_queue_pop_tail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_tail(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_pop_tail$handle() {
        return g_queue_pop_tail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_tail(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_pop_tail$address() {
        return g_queue_pop_tail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_tail(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_pop_tail(MemorySegment queue) {
        var mh$ = g_queue_pop_tail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_pop_tail", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_pop_nth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_pop_nth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_nth(GQueue *queue, guint n)
     * }
     */
    public static FunctionDescriptor g_queue_pop_nth$descriptor() {
        return g_queue_pop_nth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_nth(GQueue *queue, guint n)
     * }
     */
    public static MethodHandle g_queue_pop_nth$handle() {
        return g_queue_pop_nth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_nth(GQueue *queue, guint n)
     * }
     */
    public static MemorySegment g_queue_pop_nth$address() {
        return g_queue_pop_nth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_queue_pop_nth(GQueue *queue, guint n)
     * }
     */
    public static MemorySegment g_queue_pop_nth(MemorySegment queue, int n) {
        var mh$ = g_queue_pop_nth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_pop_nth", queue, n);
            }
            return (MemorySegment)mh$.invokeExact(queue, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_peek_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_peek_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_head(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_peek_head$descriptor() {
        return g_queue_peek_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_head(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_peek_head$handle() {
        return g_queue_peek_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_head(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_peek_head$address() {
        return g_queue_peek_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_head(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_peek_head(MemorySegment queue) {
        var mh$ = g_queue_peek_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_peek_head", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_peek_tail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_peek_tail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_tail(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_peek_tail$descriptor() {
        return g_queue_peek_tail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_tail(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_peek_tail$handle() {
        return g_queue_peek_tail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_tail(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_peek_tail$address() {
        return g_queue_peek_tail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_tail(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_peek_tail(MemorySegment queue) {
        var mh$ = g_queue_peek_tail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_peek_tail", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_peek_nth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_peek_nth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_nth(GQueue *queue, guint n)
     * }
     */
    public static FunctionDescriptor g_queue_peek_nth$descriptor() {
        return g_queue_peek_nth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_nth(GQueue *queue, guint n)
     * }
     */
    public static MethodHandle g_queue_peek_nth$handle() {
        return g_queue_peek_nth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_nth(GQueue *queue, guint n)
     * }
     */
    public static MemorySegment g_queue_peek_nth$address() {
        return g_queue_peek_nth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_queue_peek_nth(GQueue *queue, guint n)
     * }
     */
    public static MemorySegment g_queue_peek_nth(MemorySegment queue, int n) {
        var mh$ = g_queue_peek_nth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_peek_nth", queue, n);
            }
            return (MemorySegment)mh$.invokeExact(queue, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_queue_index(GQueue *queue, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_queue_index$descriptor() {
        return g_queue_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_queue_index(GQueue *queue, gconstpointer data)
     * }
     */
    public static MethodHandle g_queue_index$handle() {
        return g_queue_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_queue_index(GQueue *queue, gconstpointer data)
     * }
     */
    public static MemorySegment g_queue_index$address() {
        return g_queue_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_queue_index(GQueue *queue, gconstpointer data)
     * }
     */
    public static int g_queue_index(MemorySegment queue, MemorySegment data) {
        var mh$ = g_queue_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_index", queue, data);
            }
            return (int)mh$.invokeExact(queue, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_queue_remove(GQueue *queue, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_queue_remove$descriptor() {
        return g_queue_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_queue_remove(GQueue *queue, gconstpointer data)
     * }
     */
    public static MethodHandle g_queue_remove$handle() {
        return g_queue_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_queue_remove(GQueue *queue, gconstpointer data)
     * }
     */
    public static MemorySegment g_queue_remove$address() {
        return g_queue_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_queue_remove(GQueue *queue, gconstpointer data)
     * }
     */
    public static int g_queue_remove(MemorySegment queue, MemorySegment data) {
        var mh$ = g_queue_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_remove", queue, data);
            }
            return (int)mh$.invokeExact(queue, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_remove_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_remove_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_queue_remove_all(GQueue *queue, gconstpointer data)
     * }
     */
    public static FunctionDescriptor g_queue_remove_all$descriptor() {
        return g_queue_remove_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_queue_remove_all(GQueue *queue, gconstpointer data)
     * }
     */
    public static MethodHandle g_queue_remove_all$handle() {
        return g_queue_remove_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_queue_remove_all(GQueue *queue, gconstpointer data)
     * }
     */
    public static MemorySegment g_queue_remove_all$address() {
        return g_queue_remove_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_queue_remove_all(GQueue *queue, gconstpointer data)
     * }
     */
    public static int g_queue_remove_all(MemorySegment queue, MemorySegment data) {
        var mh$ = g_queue_remove_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_remove_all", queue, data);
            }
            return (int)mh$.invokeExact(queue, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_insert_before {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_insert_before");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_insert_before(GQueue *queue, GList *sibling, gpointer data)
     * }
     */
    public static FunctionDescriptor g_queue_insert_before$descriptor() {
        return g_queue_insert_before.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_insert_before(GQueue *queue, GList *sibling, gpointer data)
     * }
     */
    public static MethodHandle g_queue_insert_before$handle() {
        return g_queue_insert_before.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_insert_before(GQueue *queue, GList *sibling, gpointer data)
     * }
     */
    public static MemorySegment g_queue_insert_before$address() {
        return g_queue_insert_before.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_insert_before(GQueue *queue, GList *sibling, gpointer data)
     * }
     */
    public static void g_queue_insert_before(MemorySegment queue, MemorySegment sibling, MemorySegment data) {
        var mh$ = g_queue_insert_before.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_insert_before", queue, sibling, data);
            }
            mh$.invokeExact(queue, sibling, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_insert_before_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_insert_before_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_insert_before_link(GQueue *queue, GList *sibling, GList *link_)
     * }
     */
    public static FunctionDescriptor g_queue_insert_before_link$descriptor() {
        return g_queue_insert_before_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_insert_before_link(GQueue *queue, GList *sibling, GList *link_)
     * }
     */
    public static MethodHandle g_queue_insert_before_link$handle() {
        return g_queue_insert_before_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_insert_before_link(GQueue *queue, GList *sibling, GList *link_)
     * }
     */
    public static MemorySegment g_queue_insert_before_link$address() {
        return g_queue_insert_before_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_insert_before_link(GQueue *queue, GList *sibling, GList *link_)
     * }
     */
    public static void g_queue_insert_before_link(MemorySegment queue, MemorySegment sibling, MemorySegment link_) {
        var mh$ = g_queue_insert_before_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_insert_before_link", queue, sibling, link_);
            }
            mh$.invokeExact(queue, sibling, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_insert_after {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_insert_after");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_insert_after(GQueue *queue, GList *sibling, gpointer data)
     * }
     */
    public static FunctionDescriptor g_queue_insert_after$descriptor() {
        return g_queue_insert_after.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_insert_after(GQueue *queue, GList *sibling, gpointer data)
     * }
     */
    public static MethodHandle g_queue_insert_after$handle() {
        return g_queue_insert_after.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_insert_after(GQueue *queue, GList *sibling, gpointer data)
     * }
     */
    public static MemorySegment g_queue_insert_after$address() {
        return g_queue_insert_after.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_insert_after(GQueue *queue, GList *sibling, gpointer data)
     * }
     */
    public static void g_queue_insert_after(MemorySegment queue, MemorySegment sibling, MemorySegment data) {
        var mh$ = g_queue_insert_after.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_insert_after", queue, sibling, data);
            }
            mh$.invokeExact(queue, sibling, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_insert_after_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_insert_after_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_insert_after_link(GQueue *queue, GList *sibling, GList *link_)
     * }
     */
    public static FunctionDescriptor g_queue_insert_after_link$descriptor() {
        return g_queue_insert_after_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_insert_after_link(GQueue *queue, GList *sibling, GList *link_)
     * }
     */
    public static MethodHandle g_queue_insert_after_link$handle() {
        return g_queue_insert_after_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_insert_after_link(GQueue *queue, GList *sibling, GList *link_)
     * }
     */
    public static MemorySegment g_queue_insert_after_link$address() {
        return g_queue_insert_after_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_insert_after_link(GQueue *queue, GList *sibling, GList *link_)
     * }
     */
    public static void g_queue_insert_after_link(MemorySegment queue, MemorySegment sibling, MemorySegment link_) {
        var mh$ = g_queue_insert_after_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_insert_after_link", queue, sibling, link_);
            }
            mh$.invokeExact(queue, sibling, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_insert_sorted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_insert_sorted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_insert_sorted(GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_queue_insert_sorted$descriptor() {
        return g_queue_insert_sorted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_insert_sorted(GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_queue_insert_sorted$handle() {
        return g_queue_insert_sorted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_insert_sorted(GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_queue_insert_sorted$address() {
        return g_queue_insert_sorted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_insert_sorted(GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data)
     * }
     */
    public static void g_queue_insert_sorted(MemorySegment queue, MemorySegment data, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_queue_insert_sorted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_insert_sorted", queue, data, func, user_data);
            }
            mh$.invokeExact(queue, data, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_push_head_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_push_head_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_push_head_link(GQueue *queue, GList *link_)
     * }
     */
    public static FunctionDescriptor g_queue_push_head_link$descriptor() {
        return g_queue_push_head_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_push_head_link(GQueue *queue, GList *link_)
     * }
     */
    public static MethodHandle g_queue_push_head_link$handle() {
        return g_queue_push_head_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_push_head_link(GQueue *queue, GList *link_)
     * }
     */
    public static MemorySegment g_queue_push_head_link$address() {
        return g_queue_push_head_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_push_head_link(GQueue *queue, GList *link_)
     * }
     */
    public static void g_queue_push_head_link(MemorySegment queue, MemorySegment link_) {
        var mh$ = g_queue_push_head_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_push_head_link", queue, link_);
            }
            mh$.invokeExact(queue, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_push_tail_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_push_tail_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_push_tail_link(GQueue *queue, GList *link_)
     * }
     */
    public static FunctionDescriptor g_queue_push_tail_link$descriptor() {
        return g_queue_push_tail_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_push_tail_link(GQueue *queue, GList *link_)
     * }
     */
    public static MethodHandle g_queue_push_tail_link$handle() {
        return g_queue_push_tail_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_push_tail_link(GQueue *queue, GList *link_)
     * }
     */
    public static MemorySegment g_queue_push_tail_link$address() {
        return g_queue_push_tail_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_push_tail_link(GQueue *queue, GList *link_)
     * }
     */
    public static void g_queue_push_tail_link(MemorySegment queue, MemorySegment link_) {
        var mh$ = g_queue_push_tail_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_push_tail_link", queue, link_);
            }
            mh$.invokeExact(queue, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_push_nth_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_push_nth_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_push_nth_link(GQueue *queue, gint n, GList *link_)
     * }
     */
    public static FunctionDescriptor g_queue_push_nth_link$descriptor() {
        return g_queue_push_nth_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_push_nth_link(GQueue *queue, gint n, GList *link_)
     * }
     */
    public static MethodHandle g_queue_push_nth_link$handle() {
        return g_queue_push_nth_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_push_nth_link(GQueue *queue, gint n, GList *link_)
     * }
     */
    public static MemorySegment g_queue_push_nth_link$address() {
        return g_queue_push_nth_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_push_nth_link(GQueue *queue, gint n, GList *link_)
     * }
     */
    public static void g_queue_push_nth_link(MemorySegment queue, int n, MemorySegment link_) {
        var mh$ = g_queue_push_nth_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_push_nth_link", queue, n, link_);
            }
            mh$.invokeExact(queue, n, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_pop_head_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_pop_head_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_head_link(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_pop_head_link$descriptor() {
        return g_queue_pop_head_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_head_link(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_pop_head_link$handle() {
        return g_queue_pop_head_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_head_link(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_pop_head_link$address() {
        return g_queue_pop_head_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_queue_pop_head_link(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_pop_head_link(MemorySegment queue) {
        var mh$ = g_queue_pop_head_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_pop_head_link", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_pop_tail_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_pop_tail_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_tail_link(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_pop_tail_link$descriptor() {
        return g_queue_pop_tail_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_tail_link(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_pop_tail_link$handle() {
        return g_queue_pop_tail_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_tail_link(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_pop_tail_link$address() {
        return g_queue_pop_tail_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_queue_pop_tail_link(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_pop_tail_link(MemorySegment queue) {
        var mh$ = g_queue_pop_tail_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_pop_tail_link", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_pop_nth_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_pop_nth_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_nth_link(GQueue *queue, guint n)
     * }
     */
    public static FunctionDescriptor g_queue_pop_nth_link$descriptor() {
        return g_queue_pop_nth_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_nth_link(GQueue *queue, guint n)
     * }
     */
    public static MethodHandle g_queue_pop_nth_link$handle() {
        return g_queue_pop_nth_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_queue_pop_nth_link(GQueue *queue, guint n)
     * }
     */
    public static MemorySegment g_queue_pop_nth_link$address() {
        return g_queue_pop_nth_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_queue_pop_nth_link(GQueue *queue, guint n)
     * }
     */
    public static MemorySegment g_queue_pop_nth_link(MemorySegment queue, int n) {
        var mh$ = g_queue_pop_nth_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_pop_nth_link", queue, n);
            }
            return (MemorySegment)mh$.invokeExact(queue, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_peek_head_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_peek_head_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_head_link(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_peek_head_link$descriptor() {
        return g_queue_peek_head_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_head_link(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_peek_head_link$handle() {
        return g_queue_peek_head_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_head_link(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_peek_head_link$address() {
        return g_queue_peek_head_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_queue_peek_head_link(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_peek_head_link(MemorySegment queue) {
        var mh$ = g_queue_peek_head_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_peek_head_link", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_peek_tail_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_peek_tail_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_tail_link(GQueue *queue)
     * }
     */
    public static FunctionDescriptor g_queue_peek_tail_link$descriptor() {
        return g_queue_peek_tail_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_tail_link(GQueue *queue)
     * }
     */
    public static MethodHandle g_queue_peek_tail_link$handle() {
        return g_queue_peek_tail_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_tail_link(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_peek_tail_link$address() {
        return g_queue_peek_tail_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_queue_peek_tail_link(GQueue *queue)
     * }
     */
    public static MemorySegment g_queue_peek_tail_link(MemorySegment queue) {
        var mh$ = g_queue_peek_tail_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_peek_tail_link", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_peek_nth_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_peek_nth_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_nth_link(GQueue *queue, guint n)
     * }
     */
    public static FunctionDescriptor g_queue_peek_nth_link$descriptor() {
        return g_queue_peek_nth_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_nth_link(GQueue *queue, guint n)
     * }
     */
    public static MethodHandle g_queue_peek_nth_link$handle() {
        return g_queue_peek_nth_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GList *g_queue_peek_nth_link(GQueue *queue, guint n)
     * }
     */
    public static MemorySegment g_queue_peek_nth_link$address() {
        return g_queue_peek_nth_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GList *g_queue_peek_nth_link(GQueue *queue, guint n)
     * }
     */
    public static MemorySegment g_queue_peek_nth_link(MemorySegment queue, int n) {
        var mh$ = g_queue_peek_nth_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_peek_nth_link", queue, n);
            }
            return (MemorySegment)mh$.invokeExact(queue, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_link_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_link_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_queue_link_index(GQueue *queue, GList *link_)
     * }
     */
    public static FunctionDescriptor g_queue_link_index$descriptor() {
        return g_queue_link_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_queue_link_index(GQueue *queue, GList *link_)
     * }
     */
    public static MethodHandle g_queue_link_index$handle() {
        return g_queue_link_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_queue_link_index(GQueue *queue, GList *link_)
     * }
     */
    public static MemorySegment g_queue_link_index$address() {
        return g_queue_link_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_queue_link_index(GQueue *queue, GList *link_)
     * }
     */
    public static int g_queue_link_index(MemorySegment queue, MemorySegment link_) {
        var mh$ = g_queue_link_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_link_index", queue, link_);
            }
            return (int)mh$.invokeExact(queue, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_unlink(GQueue *queue, GList *link_)
     * }
     */
    public static FunctionDescriptor g_queue_unlink$descriptor() {
        return g_queue_unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_unlink(GQueue *queue, GList *link_)
     * }
     */
    public static MethodHandle g_queue_unlink$handle() {
        return g_queue_unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_unlink(GQueue *queue, GList *link_)
     * }
     */
    public static MemorySegment g_queue_unlink$address() {
        return g_queue_unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_unlink(GQueue *queue, GList *link_)
     * }
     */
    public static void g_queue_unlink(MemorySegment queue, MemorySegment link_) {
        var mh$ = g_queue_unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_unlink", queue, link_);
            }
            mh$.invokeExact(queue, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_queue_delete_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_queue_delete_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_queue_delete_link(GQueue *queue, GList *link_)
     * }
     */
    public static FunctionDescriptor g_queue_delete_link$descriptor() {
        return g_queue_delete_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_queue_delete_link(GQueue *queue, GList *link_)
     * }
     */
    public static MethodHandle g_queue_delete_link$handle() {
        return g_queue_delete_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_queue_delete_link(GQueue *queue, GList *link_)
     * }
     */
    public static MemorySegment g_queue_delete_link$address() {
        return g_queue_delete_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_queue_delete_link(GQueue *queue, GList *link_)
     * }
     */
    public static void g_queue_delete_link(MemorySegment queue, MemorySegment link_) {
        var mh$ = g_queue_delete_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_queue_delete_link", queue, link_);
            }
            mh$.invokeExact(queue, link_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_new_with_seed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_new_with_seed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new_with_seed(guint32 seed)
     * }
     */
    public static FunctionDescriptor g_rand_new_with_seed$descriptor() {
        return g_rand_new_with_seed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new_with_seed(guint32 seed)
     * }
     */
    public static MethodHandle g_rand_new_with_seed$handle() {
        return g_rand_new_with_seed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new_with_seed(guint32 seed)
     * }
     */
    public static MemorySegment g_rand_new_with_seed$address() {
        return g_rand_new_with_seed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRand *g_rand_new_with_seed(guint32 seed)
     * }
     */
    public static MemorySegment g_rand_new_with_seed(int seed) {
        var mh$ = g_rand_new_with_seed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_new_with_seed", seed);
            }
            return (MemorySegment)mh$.invokeExact(seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_new_with_seed_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_new_with_seed_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new_with_seed_array(const guint32 *seed, guint seed_length)
     * }
     */
    public static FunctionDescriptor g_rand_new_with_seed_array$descriptor() {
        return g_rand_new_with_seed_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new_with_seed_array(const guint32 *seed, guint seed_length)
     * }
     */
    public static MethodHandle g_rand_new_with_seed_array$handle() {
        return g_rand_new_with_seed_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new_with_seed_array(const guint32 *seed, guint seed_length)
     * }
     */
    public static MemorySegment g_rand_new_with_seed_array$address() {
        return g_rand_new_with_seed_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRand *g_rand_new_with_seed_array(const guint32 *seed, guint seed_length)
     * }
     */
    public static MemorySegment g_rand_new_with_seed_array(MemorySegment seed, int seed_length) {
        var mh$ = g_rand_new_with_seed_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_new_with_seed_array", seed, seed_length);
            }
            return (MemorySegment)mh$.invokeExact(seed, seed_length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new()
     * }
     */
    public static FunctionDescriptor g_rand_new$descriptor() {
        return g_rand_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new()
     * }
     */
    public static MethodHandle g_rand_new$handle() {
        return g_rand_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRand *g_rand_new()
     * }
     */
    public static MemorySegment g_rand_new$address() {
        return g_rand_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRand *g_rand_new()
     * }
     */
    public static MemorySegment g_rand_new() {
        var mh$ = g_rand_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rand_free(GRand *rand_)
     * }
     */
    public static FunctionDescriptor g_rand_free$descriptor() {
        return g_rand_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rand_free(GRand *rand_)
     * }
     */
    public static MethodHandle g_rand_free$handle() {
        return g_rand_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rand_free(GRand *rand_)
     * }
     */
    public static MemorySegment g_rand_free$address() {
        return g_rand_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rand_free(GRand *rand_)
     * }
     */
    public static void g_rand_free(MemorySegment rand_) {
        var mh$ = g_rand_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_free", rand_);
            }
            mh$.invokeExact(rand_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRand *g_rand_copy(GRand *rand_)
     * }
     */
    public static FunctionDescriptor g_rand_copy$descriptor() {
        return g_rand_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRand *g_rand_copy(GRand *rand_)
     * }
     */
    public static MethodHandle g_rand_copy$handle() {
        return g_rand_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRand *g_rand_copy(GRand *rand_)
     * }
     */
    public static MemorySegment g_rand_copy$address() {
        return g_rand_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRand *g_rand_copy(GRand *rand_)
     * }
     */
    public static MemorySegment g_rand_copy(MemorySegment rand_) {
        var mh$ = g_rand_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_copy", rand_);
            }
            return (MemorySegment)mh$.invokeExact(rand_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_set_seed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_set_seed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rand_set_seed(GRand *rand_, guint32 seed)
     * }
     */
    public static FunctionDescriptor g_rand_set_seed$descriptor() {
        return g_rand_set_seed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rand_set_seed(GRand *rand_, guint32 seed)
     * }
     */
    public static MethodHandle g_rand_set_seed$handle() {
        return g_rand_set_seed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rand_set_seed(GRand *rand_, guint32 seed)
     * }
     */
    public static MemorySegment g_rand_set_seed$address() {
        return g_rand_set_seed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rand_set_seed(GRand *rand_, guint32 seed)
     * }
     */
    public static void g_rand_set_seed(MemorySegment rand_, int seed) {
        var mh$ = g_rand_set_seed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_set_seed", rand_, seed);
            }
            mh$.invokeExact(rand_, seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_set_seed_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_set_seed_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rand_set_seed_array(GRand *rand_, const guint32 *seed, guint seed_length)
     * }
     */
    public static FunctionDescriptor g_rand_set_seed_array$descriptor() {
        return g_rand_set_seed_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rand_set_seed_array(GRand *rand_, const guint32 *seed, guint seed_length)
     * }
     */
    public static MethodHandle g_rand_set_seed_array$handle() {
        return g_rand_set_seed_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rand_set_seed_array(GRand *rand_, const guint32 *seed, guint seed_length)
     * }
     */
    public static MemorySegment g_rand_set_seed_array$address() {
        return g_rand_set_seed_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rand_set_seed_array(GRand *rand_, const guint32 *seed, guint seed_length)
     * }
     */
    public static void g_rand_set_seed_array(MemorySegment rand_, MemorySegment seed, int seed_length) {
        var mh$ = g_rand_set_seed_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_set_seed_array", rand_, seed, seed_length);
            }
            mh$.invokeExact(rand_, seed, seed_length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint32 g_rand_int(GRand *rand_)
     * }
     */
    public static FunctionDescriptor g_rand_int$descriptor() {
        return g_rand_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint32 g_rand_int(GRand *rand_)
     * }
     */
    public static MethodHandle g_rand_int$handle() {
        return g_rand_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint32 g_rand_int(GRand *rand_)
     * }
     */
    public static MemorySegment g_rand_int$address() {
        return g_rand_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint32 g_rand_int(GRand *rand_)
     * }
     */
    public static int g_rand_int(MemorySegment rand_) {
        var mh$ = g_rand_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_int", rand_);
            }
            return (int)mh$.invokeExact(rand_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_int_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_int_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint32 g_rand_int_range(GRand *rand_, gint32 begin, gint32 end)
     * }
     */
    public static FunctionDescriptor g_rand_int_range$descriptor() {
        return g_rand_int_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint32 g_rand_int_range(GRand *rand_, gint32 begin, gint32 end)
     * }
     */
    public static MethodHandle g_rand_int_range$handle() {
        return g_rand_int_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint32 g_rand_int_range(GRand *rand_, gint32 begin, gint32 end)
     * }
     */
    public static MemorySegment g_rand_int_range$address() {
        return g_rand_int_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint32 g_rand_int_range(GRand *rand_, gint32 begin, gint32 end)
     * }
     */
    public static int g_rand_int_range(MemorySegment rand_, int begin, int end) {
        var mh$ = g_rand_int_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_int_range", rand_, begin, end);
            }
            return (int)mh$.invokeExact(rand_, begin, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_rand_double(GRand *rand_)
     * }
     */
    public static FunctionDescriptor g_rand_double$descriptor() {
        return g_rand_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_rand_double(GRand *rand_)
     * }
     */
    public static MethodHandle g_rand_double$handle() {
        return g_rand_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_rand_double(GRand *rand_)
     * }
     */
    public static MemorySegment g_rand_double$address() {
        return g_rand_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_rand_double(GRand *rand_)
     * }
     */
    public static double g_rand_double(MemorySegment rand_) {
        var mh$ = g_rand_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_double", rand_);
            }
            return (double)mh$.invokeExact(rand_);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rand_double_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rand_double_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_rand_double_range(GRand *rand_, gdouble begin, gdouble end)
     * }
     */
    public static FunctionDescriptor g_rand_double_range$descriptor() {
        return g_rand_double_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_rand_double_range(GRand *rand_, gdouble begin, gdouble end)
     * }
     */
    public static MethodHandle g_rand_double_range$handle() {
        return g_rand_double_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_rand_double_range(GRand *rand_, gdouble begin, gdouble end)
     * }
     */
    public static MemorySegment g_rand_double_range$address() {
        return g_rand_double_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_rand_double_range(GRand *rand_, gdouble begin, gdouble end)
     * }
     */
    public static double g_rand_double_range(MemorySegment rand_, double begin, double end) {
        var mh$ = g_rand_double_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rand_double_range", rand_, begin, end);
            }
            return (double)mh$.invokeExact(rand_, begin, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_random_set_seed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_random_set_seed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_random_set_seed(guint32 seed)
     * }
     */
    public static FunctionDescriptor g_random_set_seed$descriptor() {
        return g_random_set_seed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_random_set_seed(guint32 seed)
     * }
     */
    public static MethodHandle g_random_set_seed$handle() {
        return g_random_set_seed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_random_set_seed(guint32 seed)
     * }
     */
    public static MemorySegment g_random_set_seed$address() {
        return g_random_set_seed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_random_set_seed(guint32 seed)
     * }
     */
    public static void g_random_set_seed(int seed) {
        var mh$ = g_random_set_seed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_random_set_seed", seed);
            }
            mh$.invokeExact(seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_random_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_random_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint32 g_random_int()
     * }
     */
    public static FunctionDescriptor g_random_int$descriptor() {
        return g_random_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint32 g_random_int()
     * }
     */
    public static MethodHandle g_random_int$handle() {
        return g_random_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint32 g_random_int()
     * }
     */
    public static MemorySegment g_random_int$address() {
        return g_random_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint32 g_random_int()
     * }
     */
    public static int g_random_int() {
        var mh$ = g_random_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_random_int");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_random_int_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_random_int_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint32 g_random_int_range(gint32 begin, gint32 end)
     * }
     */
    public static FunctionDescriptor g_random_int_range$descriptor() {
        return g_random_int_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint32 g_random_int_range(gint32 begin, gint32 end)
     * }
     */
    public static MethodHandle g_random_int_range$handle() {
        return g_random_int_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint32 g_random_int_range(gint32 begin, gint32 end)
     * }
     */
    public static MemorySegment g_random_int_range$address() {
        return g_random_int_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint32 g_random_int_range(gint32 begin, gint32 end)
     * }
     */
    public static int g_random_int_range(int begin, int end) {
        var mh$ = g_random_int_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_random_int_range", begin, end);
            }
            return (int)mh$.invokeExact(begin, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_random_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_random_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_random_double()
     * }
     */
    public static FunctionDescriptor g_random_double$descriptor() {
        return g_random_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_random_double()
     * }
     */
    public static MethodHandle g_random_double$handle() {
        return g_random_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_random_double()
     * }
     */
    public static MemorySegment g_random_double$address() {
        return g_random_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_random_double()
     * }
     */
    public static double g_random_double() {
        var mh$ = g_random_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_random_double");
            }
            return (double)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_random_double_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE,
            gst_min_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_random_double_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gdouble g_random_double_range(gdouble begin, gdouble end)
     * }
     */
    public static FunctionDescriptor g_random_double_range$descriptor() {
        return g_random_double_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gdouble g_random_double_range(gdouble begin, gdouble end)
     * }
     */
    public static MethodHandle g_random_double_range$handle() {
        return g_random_double_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gdouble g_random_double_range(gdouble begin, gdouble end)
     * }
     */
    public static MemorySegment g_random_double_range$address() {
        return g_random_double_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gdouble g_random_double_range(gdouble begin, gdouble end)
     * }
     */
    public static double g_random_double_range(double begin, double end) {
        var mh$ = g_random_double_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_random_double_range", begin, end);
            }
            return (double)mh$.invokeExact(begin, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rc_box_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rc_box_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_alloc(gsize block_size)
     * }
     */
    public static FunctionDescriptor g_rc_box_alloc$descriptor() {
        return g_rc_box_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_alloc(gsize block_size)
     * }
     */
    public static MethodHandle g_rc_box_alloc$handle() {
        return g_rc_box_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_alloc(gsize block_size)
     * }
     */
    public static MemorySegment g_rc_box_alloc$address() {
        return g_rc_box_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_rc_box_alloc(gsize block_size)
     * }
     */
    public static MemorySegment g_rc_box_alloc(long block_size) {
        var mh$ = g_rc_box_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rc_box_alloc", block_size);
            }
            return (MemorySegment)mh$.invokeExact(block_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rc_box_alloc0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rc_box_alloc0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_alloc0(gsize block_size)
     * }
     */
    public static FunctionDescriptor g_rc_box_alloc0$descriptor() {
        return g_rc_box_alloc0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_alloc0(gsize block_size)
     * }
     */
    public static MethodHandle g_rc_box_alloc0$handle() {
        return g_rc_box_alloc0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_alloc0(gsize block_size)
     * }
     */
    public static MemorySegment g_rc_box_alloc0$address() {
        return g_rc_box_alloc0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_rc_box_alloc0(gsize block_size)
     * }
     */
    public static MemorySegment g_rc_box_alloc0(long block_size) {
        var mh$ = g_rc_box_alloc0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rc_box_alloc0", block_size);
            }
            return (MemorySegment)mh$.invokeExact(block_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rc_box_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rc_box_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_dup(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_rc_box_dup$descriptor() {
        return g_rc_box_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_dup(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MethodHandle g_rc_box_dup$handle() {
        return g_rc_box_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_dup(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MemorySegment g_rc_box_dup$address() {
        return g_rc_box_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_rc_box_dup(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MemorySegment g_rc_box_dup(long block_size, MemorySegment mem_block) {
        var mh$ = g_rc_box_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rc_box_dup", block_size, mem_block);
            }
            return (MemorySegment)mh$.invokeExact(block_size, mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rc_box_acquire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rc_box_acquire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_acquire(gpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_rc_box_acquire$descriptor() {
        return g_rc_box_acquire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_acquire(gpointer mem_block)
     * }
     */
    public static MethodHandle g_rc_box_acquire$handle() {
        return g_rc_box_acquire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_rc_box_acquire(gpointer mem_block)
     * }
     */
    public static MemorySegment g_rc_box_acquire$address() {
        return g_rc_box_acquire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_rc_box_acquire(gpointer mem_block)
     * }
     */
    public static MemorySegment g_rc_box_acquire(MemorySegment mem_block) {
        var mh$ = g_rc_box_acquire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rc_box_acquire", mem_block);
            }
            return (MemorySegment)mh$.invokeExact(mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rc_box_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rc_box_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rc_box_release(gpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_rc_box_release$descriptor() {
        return g_rc_box_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rc_box_release(gpointer mem_block)
     * }
     */
    public static MethodHandle g_rc_box_release$handle() {
        return g_rc_box_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rc_box_release(gpointer mem_block)
     * }
     */
    public static MemorySegment g_rc_box_release$address() {
        return g_rc_box_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rc_box_release(gpointer mem_block)
     * }
     */
    public static void g_rc_box_release(MemorySegment mem_block) {
        var mh$ = g_rc_box_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rc_box_release", mem_block);
            }
            mh$.invokeExact(mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rc_box_release_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rc_box_release_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_rc_box_release_full(gpointer mem_block, GDestroyNotify clear_func)
     * }
     */
    public static FunctionDescriptor g_rc_box_release_full$descriptor() {
        return g_rc_box_release_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_rc_box_release_full(gpointer mem_block, GDestroyNotify clear_func)
     * }
     */
    public static MethodHandle g_rc_box_release_full$handle() {
        return g_rc_box_release_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_rc_box_release_full(gpointer mem_block, GDestroyNotify clear_func)
     * }
     */
    public static MemorySegment g_rc_box_release_full$address() {
        return g_rc_box_release_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_rc_box_release_full(gpointer mem_block, GDestroyNotify clear_func)
     * }
     */
    public static void g_rc_box_release_full(MemorySegment mem_block, MemorySegment clear_func) {
        var mh$ = g_rc_box_release_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rc_box_release_full", mem_block, clear_func);
            }
            mh$.invokeExact(mem_block, clear_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_rc_box_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_rc_box_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_rc_box_get_size(gpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_rc_box_get_size$descriptor() {
        return g_rc_box_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_rc_box_get_size(gpointer mem_block)
     * }
     */
    public static MethodHandle g_rc_box_get_size$handle() {
        return g_rc_box_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_rc_box_get_size(gpointer mem_block)
     * }
     */
    public static MemorySegment g_rc_box_get_size$address() {
        return g_rc_box_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_rc_box_get_size(gpointer mem_block)
     * }
     */
    public static long g_rc_box_get_size(MemorySegment mem_block) {
        var mh$ = g_rc_box_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_rc_box_get_size", mem_block);
            }
            return (long)mh$.invokeExact(mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_rc_box_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_rc_box_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_alloc(gsize block_size)
     * }
     */
    public static FunctionDescriptor g_atomic_rc_box_alloc$descriptor() {
        return g_atomic_rc_box_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_alloc(gsize block_size)
     * }
     */
    public static MethodHandle g_atomic_rc_box_alloc$handle() {
        return g_atomic_rc_box_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_alloc(gsize block_size)
     * }
     */
    public static MemorySegment g_atomic_rc_box_alloc$address() {
        return g_atomic_rc_box_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_alloc(gsize block_size)
     * }
     */
    public static MemorySegment g_atomic_rc_box_alloc(long block_size) {
        var mh$ = g_atomic_rc_box_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_rc_box_alloc", block_size);
            }
            return (MemorySegment)mh$.invokeExact(block_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_rc_box_alloc0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_rc_box_alloc0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_alloc0(gsize block_size)
     * }
     */
    public static FunctionDescriptor g_atomic_rc_box_alloc0$descriptor() {
        return g_atomic_rc_box_alloc0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_alloc0(gsize block_size)
     * }
     */
    public static MethodHandle g_atomic_rc_box_alloc0$handle() {
        return g_atomic_rc_box_alloc0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_alloc0(gsize block_size)
     * }
     */
    public static MemorySegment g_atomic_rc_box_alloc0$address() {
        return g_atomic_rc_box_alloc0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_alloc0(gsize block_size)
     * }
     */
    public static MemorySegment g_atomic_rc_box_alloc0(long block_size) {
        var mh$ = g_atomic_rc_box_alloc0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_rc_box_alloc0", block_size);
            }
            return (MemorySegment)mh$.invokeExact(block_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_rc_box_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_rc_box_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_dup(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_atomic_rc_box_dup$descriptor() {
        return g_atomic_rc_box_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_dup(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MethodHandle g_atomic_rc_box_dup$handle() {
        return g_atomic_rc_box_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_dup(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MemorySegment g_atomic_rc_box_dup$address() {
        return g_atomic_rc_box_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_dup(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MemorySegment g_atomic_rc_box_dup(long block_size, MemorySegment mem_block) {
        var mh$ = g_atomic_rc_box_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_rc_box_dup", block_size, mem_block);
            }
            return (MemorySegment)mh$.invokeExact(block_size, mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_rc_box_acquire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_rc_box_acquire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_acquire(gpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_atomic_rc_box_acquire$descriptor() {
        return g_atomic_rc_box_acquire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_acquire(gpointer mem_block)
     * }
     */
    public static MethodHandle g_atomic_rc_box_acquire$handle() {
        return g_atomic_rc_box_acquire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_acquire(gpointer mem_block)
     * }
     */
    public static MemorySegment g_atomic_rc_box_acquire$address() {
        return g_atomic_rc_box_acquire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_atomic_rc_box_acquire(gpointer mem_block)
     * }
     */
    public static MemorySegment g_atomic_rc_box_acquire(MemorySegment mem_block) {
        var mh$ = g_atomic_rc_box_acquire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_rc_box_acquire", mem_block);
            }
            return (MemorySegment)mh$.invokeExact(mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_rc_box_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_rc_box_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_atomic_rc_box_release(gpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_atomic_rc_box_release$descriptor() {
        return g_atomic_rc_box_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_atomic_rc_box_release(gpointer mem_block)
     * }
     */
    public static MethodHandle g_atomic_rc_box_release$handle() {
        return g_atomic_rc_box_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_atomic_rc_box_release(gpointer mem_block)
     * }
     */
    public static MemorySegment g_atomic_rc_box_release$address() {
        return g_atomic_rc_box_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_atomic_rc_box_release(gpointer mem_block)
     * }
     */
    public static void g_atomic_rc_box_release(MemorySegment mem_block) {
        var mh$ = g_atomic_rc_box_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_rc_box_release", mem_block);
            }
            mh$.invokeExact(mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_rc_box_release_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_rc_box_release_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_atomic_rc_box_release_full(gpointer mem_block, GDestroyNotify clear_func)
     * }
     */
    public static FunctionDescriptor g_atomic_rc_box_release_full$descriptor() {
        return g_atomic_rc_box_release_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_atomic_rc_box_release_full(gpointer mem_block, GDestroyNotify clear_func)
     * }
     */
    public static MethodHandle g_atomic_rc_box_release_full$handle() {
        return g_atomic_rc_box_release_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_atomic_rc_box_release_full(gpointer mem_block, GDestroyNotify clear_func)
     * }
     */
    public static MemorySegment g_atomic_rc_box_release_full$address() {
        return g_atomic_rc_box_release_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_atomic_rc_box_release_full(gpointer mem_block, GDestroyNotify clear_func)
     * }
     */
    public static void g_atomic_rc_box_release_full(MemorySegment mem_block, MemorySegment clear_func) {
        var mh$ = g_atomic_rc_box_release_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_rc_box_release_full", mem_block, clear_func);
            }
            mh$.invokeExact(mem_block, clear_func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_rc_box_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_rc_box_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_atomic_rc_box_get_size(gpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_atomic_rc_box_get_size$descriptor() {
        return g_atomic_rc_box_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_atomic_rc_box_get_size(gpointer mem_block)
     * }
     */
    public static MethodHandle g_atomic_rc_box_get_size$handle() {
        return g_atomic_rc_box_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_atomic_rc_box_get_size(gpointer mem_block)
     * }
     */
    public static MemorySegment g_atomic_rc_box_get_size$address() {
        return g_atomic_rc_box_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_atomic_rc_box_get_size(gpointer mem_block)
     * }
     */
    public static long g_atomic_rc_box_get_size(MemorySegment mem_block) {
        var mh$ = g_atomic_rc_box_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_rc_box_get_size", mem_block);
            }
            return (long)mh$.invokeExact(mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_count_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_count_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ref_count_init(grefcount *rc)
     * }
     */
    public static FunctionDescriptor g_ref_count_init$descriptor() {
        return g_ref_count_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ref_count_init(grefcount *rc)
     * }
     */
    public static MethodHandle g_ref_count_init$handle() {
        return g_ref_count_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ref_count_init(grefcount *rc)
     * }
     */
    public static MemorySegment g_ref_count_init$address() {
        return g_ref_count_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ref_count_init(grefcount *rc)
     * }
     */
    public static void g_ref_count_init(MemorySegment rc) {
        var mh$ = g_ref_count_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_count_init", rc);
            }
            mh$.invokeExact(rc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_count_inc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_count_inc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ref_count_inc(grefcount *rc)
     * }
     */
    public static FunctionDescriptor g_ref_count_inc$descriptor() {
        return g_ref_count_inc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ref_count_inc(grefcount *rc)
     * }
     */
    public static MethodHandle g_ref_count_inc$handle() {
        return g_ref_count_inc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ref_count_inc(grefcount *rc)
     * }
     */
    public static MemorySegment g_ref_count_inc$address() {
        return g_ref_count_inc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ref_count_inc(grefcount *rc)
     * }
     */
    public static void g_ref_count_inc(MemorySegment rc) {
        var mh$ = g_ref_count_inc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_count_inc", rc);
            }
            mh$.invokeExact(rc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_count_dec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_count_dec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ref_count_dec(grefcount *rc)
     * }
     */
    public static FunctionDescriptor g_ref_count_dec$descriptor() {
        return g_ref_count_dec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ref_count_dec(grefcount *rc)
     * }
     */
    public static MethodHandle g_ref_count_dec$handle() {
        return g_ref_count_dec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ref_count_dec(grefcount *rc)
     * }
     */
    public static MemorySegment g_ref_count_dec$address() {
        return g_ref_count_dec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ref_count_dec(grefcount *rc)
     * }
     */
    public static int g_ref_count_dec(MemorySegment rc) {
        var mh$ = g_ref_count_dec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_count_dec", rc);
            }
            return (int)mh$.invokeExact(rc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_count_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_count_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_ref_count_compare(grefcount *rc, gint val)
     * }
     */
    public static FunctionDescriptor g_ref_count_compare$descriptor() {
        return g_ref_count_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_ref_count_compare(grefcount *rc, gint val)
     * }
     */
    public static MethodHandle g_ref_count_compare$handle() {
        return g_ref_count_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_ref_count_compare(grefcount *rc, gint val)
     * }
     */
    public static MemorySegment g_ref_count_compare$address() {
        return g_ref_count_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_ref_count_compare(grefcount *rc, gint val)
     * }
     */
    public static int g_ref_count_compare(MemorySegment rc, int val) {
        var mh$ = g_ref_count_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_count_compare", rc, val);
            }
            return (int)mh$.invokeExact(rc, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_ref_count_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_ref_count_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_atomic_ref_count_init(gatomicrefcount *arc)
     * }
     */
    public static FunctionDescriptor g_atomic_ref_count_init$descriptor() {
        return g_atomic_ref_count_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_atomic_ref_count_init(gatomicrefcount *arc)
     * }
     */
    public static MethodHandle g_atomic_ref_count_init$handle() {
        return g_atomic_ref_count_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_atomic_ref_count_init(gatomicrefcount *arc)
     * }
     */
    public static MemorySegment g_atomic_ref_count_init$address() {
        return g_atomic_ref_count_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_atomic_ref_count_init(gatomicrefcount *arc)
     * }
     */
    public static void g_atomic_ref_count_init(MemorySegment arc) {
        var mh$ = g_atomic_ref_count_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_ref_count_init", arc);
            }
            mh$.invokeExact(arc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_ref_count_inc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_ref_count_inc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_atomic_ref_count_inc(gatomicrefcount *arc)
     * }
     */
    public static FunctionDescriptor g_atomic_ref_count_inc$descriptor() {
        return g_atomic_ref_count_inc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_atomic_ref_count_inc(gatomicrefcount *arc)
     * }
     */
    public static MethodHandle g_atomic_ref_count_inc$handle() {
        return g_atomic_ref_count_inc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_atomic_ref_count_inc(gatomicrefcount *arc)
     * }
     */
    public static MemorySegment g_atomic_ref_count_inc$address() {
        return g_atomic_ref_count_inc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_atomic_ref_count_inc(gatomicrefcount *arc)
     * }
     */
    public static void g_atomic_ref_count_inc(MemorySegment arc) {
        var mh$ = g_atomic_ref_count_inc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_ref_count_inc", arc);
            }
            mh$.invokeExact(arc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_ref_count_dec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_ref_count_dec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_ref_count_dec(gatomicrefcount *arc)
     * }
     */
    public static FunctionDescriptor g_atomic_ref_count_dec$descriptor() {
        return g_atomic_ref_count_dec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_ref_count_dec(gatomicrefcount *arc)
     * }
     */
    public static MethodHandle g_atomic_ref_count_dec$handle() {
        return g_atomic_ref_count_dec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_ref_count_dec(gatomicrefcount *arc)
     * }
     */
    public static MemorySegment g_atomic_ref_count_dec$address() {
        return g_atomic_ref_count_dec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_atomic_ref_count_dec(gatomicrefcount *arc)
     * }
     */
    public static int g_atomic_ref_count_dec(MemorySegment arc) {
        var mh$ = g_atomic_ref_count_dec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_ref_count_dec", arc);
            }
            return (int)mh$.invokeExact(arc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_atomic_ref_count_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_atomic_ref_count_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_ref_count_compare(gatomicrefcount *arc, gint val)
     * }
     */
    public static FunctionDescriptor g_atomic_ref_count_compare$descriptor() {
        return g_atomic_ref_count_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_ref_count_compare(gatomicrefcount *arc, gint val)
     * }
     */
    public static MethodHandle g_atomic_ref_count_compare$handle() {
        return g_atomic_ref_count_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_atomic_ref_count_compare(gatomicrefcount *arc, gint val)
     * }
     */
    public static MemorySegment g_atomic_ref_count_compare$address() {
        return g_atomic_ref_count_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_atomic_ref_count_compare(gatomicrefcount *arc, gint val)
     * }
     */
    public static int g_atomic_ref_count_compare(MemorySegment arc, int val) {
        var mh$ = g_atomic_ref_count_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_atomic_ref_count_compare", arc, val);
            }
            return (int)mh$.invokeExact(arc, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_string_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_string_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new(const char *str)
     * }
     */
    public static FunctionDescriptor g_ref_string_new$descriptor() {
        return g_ref_string_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new(const char *str)
     * }
     */
    public static MethodHandle g_ref_string_new$handle() {
        return g_ref_string_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new(const char *str)
     * }
     */
    public static MemorySegment g_ref_string_new$address() {
        return g_ref_string_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_ref_string_new(const char *str)
     * }
     */
    public static MemorySegment g_ref_string_new(MemorySegment str) {
        var mh$ = g_ref_string_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_string_new", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_string_new_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_string_new_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new_len(const char *str, gssize len)
     * }
     */
    public static FunctionDescriptor g_ref_string_new_len$descriptor() {
        return g_ref_string_new_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new_len(const char *str, gssize len)
     * }
     */
    public static MethodHandle g_ref_string_new_len$handle() {
        return g_ref_string_new_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new_len(const char *str, gssize len)
     * }
     */
    public static MemorySegment g_ref_string_new_len$address() {
        return g_ref_string_new_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_ref_string_new_len(const char *str, gssize len)
     * }
     */
    public static MemorySegment g_ref_string_new_len(MemorySegment str, long len) {
        var mh$ = g_ref_string_new_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_string_new_len", str, len);
            }
            return (MemorySegment)mh$.invokeExact(str, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_string_new_intern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_string_new_intern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new_intern(const char *str)
     * }
     */
    public static FunctionDescriptor g_ref_string_new_intern$descriptor() {
        return g_ref_string_new_intern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new_intern(const char *str)
     * }
     */
    public static MethodHandle g_ref_string_new_intern$handle() {
        return g_ref_string_new_intern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_ref_string_new_intern(const char *str)
     * }
     */
    public static MemorySegment g_ref_string_new_intern$address() {
        return g_ref_string_new_intern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_ref_string_new_intern(const char *str)
     * }
     */
    public static MemorySegment g_ref_string_new_intern(MemorySegment str) {
        var mh$ = g_ref_string_new_intern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_string_new_intern", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_string_acquire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_string_acquire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *g_ref_string_acquire(char *str)
     * }
     */
    public static FunctionDescriptor g_ref_string_acquire$descriptor() {
        return g_ref_string_acquire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *g_ref_string_acquire(char *str)
     * }
     */
    public static MethodHandle g_ref_string_acquire$handle() {
        return g_ref_string_acquire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *g_ref_string_acquire(char *str)
     * }
     */
    public static MemorySegment g_ref_string_acquire$address() {
        return g_ref_string_acquire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *g_ref_string_acquire(char *str)
     * }
     */
    public static MemorySegment g_ref_string_acquire(MemorySegment str) {
        var mh$ = g_ref_string_acquire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_string_acquire", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_string_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_string_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_ref_string_release(char *str)
     * }
     */
    public static FunctionDescriptor g_ref_string_release$descriptor() {
        return g_ref_string_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_ref_string_release(char *str)
     * }
     */
    public static MethodHandle g_ref_string_release$handle() {
        return g_ref_string_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_ref_string_release(char *str)
     * }
     */
    public static MemorySegment g_ref_string_release$address() {
        return g_ref_string_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_ref_string_release(char *str)
     * }
     */
    public static void g_ref_string_release(MemorySegment str) {
        var mh$ = g_ref_string_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_string_release", str);
            }
            mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_ref_string_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_ref_string_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gsize g_ref_string_length(char *str)
     * }
     */
    public static FunctionDescriptor g_ref_string_length$descriptor() {
        return g_ref_string_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gsize g_ref_string_length(char *str)
     * }
     */
    public static MethodHandle g_ref_string_length$handle() {
        return g_ref_string_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gsize g_ref_string_length(char *str)
     * }
     */
    public static MemorySegment g_ref_string_length$address() {
        return g_ref_string_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gsize g_ref_string_length(char *str)
     * }
     */
    public static long g_ref_string_length(MemorySegment str) {
        var mh$ = g_ref_string_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_ref_string_length", str);
            }
            return (long)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef char GRefString
     * }
     */
    public static final OfByte GRefString = gst_min_h.C_CHAR;
    private static final int G_REGEX_ERROR_COMPILE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_COMPILE = 0
     * }
     */
    public static int G_REGEX_ERROR_COMPILE() {
        return G_REGEX_ERROR_COMPILE;
    }
    private static final int G_REGEX_ERROR_OPTIMIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_OPTIMIZE = 1
     * }
     */
    public static int G_REGEX_ERROR_OPTIMIZE() {
        return G_REGEX_ERROR_OPTIMIZE;
    }
    private static final int G_REGEX_ERROR_REPLACE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_REPLACE = 2
     * }
     */
    public static int G_REGEX_ERROR_REPLACE() {
        return G_REGEX_ERROR_REPLACE;
    }
    private static final int G_REGEX_ERROR_MATCH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MATCH = 3
     * }
     */
    public static int G_REGEX_ERROR_MATCH() {
        return G_REGEX_ERROR_MATCH;
    }
    private static final int G_REGEX_ERROR_INTERNAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INTERNAL = 4
     * }
     */
    public static int G_REGEX_ERROR_INTERNAL() {
        return G_REGEX_ERROR_INTERNAL;
    }
    private static final int G_REGEX_ERROR_STRAY_BACKSLASH = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_STRAY_BACKSLASH = 101
     * }
     */
    public static int G_REGEX_ERROR_STRAY_BACKSLASH() {
        return G_REGEX_ERROR_STRAY_BACKSLASH;
    }
    private static final int G_REGEX_ERROR_MISSING_CONTROL_CHAR = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102
     * }
     */
    public static int G_REGEX_ERROR_MISSING_CONTROL_CHAR() {
        return G_REGEX_ERROR_MISSING_CONTROL_CHAR;
    }
    private static final int G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103
     * }
     */
    public static int G_REGEX_ERROR_UNRECOGNIZED_ESCAPE() {
        return G_REGEX_ERROR_UNRECOGNIZED_ESCAPE;
    }
    private static final int G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = (int)104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104
     * }
     */
    public static int G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER() {
        return G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER;
    }
    private static final int G_REGEX_ERROR_QUANTIFIER_TOO_BIG = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105
     * }
     */
    public static int G_REGEX_ERROR_QUANTIFIER_TOO_BIG() {
        return G_REGEX_ERROR_QUANTIFIER_TOO_BIG;
    }
    private static final int G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = (int)106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106
     * }
     */
    public static int G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS() {
        return G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS;
    }
    private static final int G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = (int)107L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107
     * }
     */
    public static int G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS() {
        return G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS;
    }
    private static final int G_REGEX_ERROR_RANGE_OUT_OF_ORDER = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108
     * }
     */
    public static int G_REGEX_ERROR_RANGE_OUT_OF_ORDER() {
        return G_REGEX_ERROR_RANGE_OUT_OF_ORDER;
    }
    private static final int G_REGEX_ERROR_NOTHING_TO_REPEAT = (int)109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_NOTHING_TO_REPEAT = 109
     * }
     */
    public static int G_REGEX_ERROR_NOTHING_TO_REPEAT() {
        return G_REGEX_ERROR_NOTHING_TO_REPEAT;
    }
    private static final int G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = (int)112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112
     * }
     */
    public static int G_REGEX_ERROR_UNRECOGNIZED_CHARACTER() {
        return G_REGEX_ERROR_UNRECOGNIZED_CHARACTER;
    }
    private static final int G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = (int)113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113
     * }
     */
    public static int G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS() {
        return G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS;
    }
    private static final int G_REGEX_ERROR_UNMATCHED_PARENTHESIS = (int)114L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114
     * }
     */
    public static int G_REGEX_ERROR_UNMATCHED_PARENTHESIS() {
        return G_REGEX_ERROR_UNMATCHED_PARENTHESIS;
    }
    private static final int G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115
     * }
     */
    public static int G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE() {
        return G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE;
    }
    private static final int G_REGEX_ERROR_UNTERMINATED_COMMENT = (int)118L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_UNTERMINATED_COMMENT = 118
     * }
     */
    public static int G_REGEX_ERROR_UNTERMINATED_COMMENT() {
        return G_REGEX_ERROR_UNTERMINATED_COMMENT;
    }
    private static final int G_REGEX_ERROR_EXPRESSION_TOO_LARGE = (int)120L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120
     * }
     */
    public static int G_REGEX_ERROR_EXPRESSION_TOO_LARGE() {
        return G_REGEX_ERROR_EXPRESSION_TOO_LARGE;
    }
    private static final int G_REGEX_ERROR_MEMORY_ERROR = (int)121L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MEMORY_ERROR = 121
     * }
     */
    public static int G_REGEX_ERROR_MEMORY_ERROR() {
        return G_REGEX_ERROR_MEMORY_ERROR;
    }
    private static final int G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = (int)125L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125
     * }
     */
    public static int G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND() {
        return G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND;
    }
    private static final int G_REGEX_ERROR_MALFORMED_CONDITION = (int)126L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MALFORMED_CONDITION = 126
     * }
     */
    public static int G_REGEX_ERROR_MALFORMED_CONDITION() {
        return G_REGEX_ERROR_MALFORMED_CONDITION;
    }
    private static final int G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = (int)127L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127
     * }
     */
    public static int G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES() {
        return G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES;
    }
    private static final int G_REGEX_ERROR_ASSERTION_EXPECTED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_ASSERTION_EXPECTED = 128
     * }
     */
    public static int G_REGEX_ERROR_ASSERTION_EXPECTED() {
        return G_REGEX_ERROR_ASSERTION_EXPECTED;
    }
    private static final int G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = (int)130L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130
     * }
     */
    public static int G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME() {
        return G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME;
    }
    private static final int G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = (int)131L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131
     * }
     */
    public static int G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED() {
        return G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED;
    }
    private static final int G_REGEX_ERROR_HEX_CODE_TOO_LARGE = (int)134L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134
     * }
     */
    public static int G_REGEX_ERROR_HEX_CODE_TOO_LARGE() {
        return G_REGEX_ERROR_HEX_CODE_TOO_LARGE;
    }
    private static final int G_REGEX_ERROR_INVALID_CONDITION = (int)135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INVALID_CONDITION = 135
     * }
     */
    public static int G_REGEX_ERROR_INVALID_CONDITION() {
        return G_REGEX_ERROR_INVALID_CONDITION;
    }
    private static final int G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = (int)136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136
     * }
     */
    public static int G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND() {
        return G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND;
    }
    private static final int G_REGEX_ERROR_INFINITE_LOOP = (int)140L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INFINITE_LOOP = 140
     * }
     */
    public static int G_REGEX_ERROR_INFINITE_LOOP() {
        return G_REGEX_ERROR_INFINITE_LOOP;
    }
    private static final int G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = (int)142L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142
     * }
     */
    public static int G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR() {
        return G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR;
    }
    private static final int G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = (int)143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143
     * }
     */
    public static int G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME() {
        return G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME;
    }
    private static final int G_REGEX_ERROR_MALFORMED_PROPERTY = (int)146L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MALFORMED_PROPERTY = 146
     * }
     */
    public static int G_REGEX_ERROR_MALFORMED_PROPERTY() {
        return G_REGEX_ERROR_MALFORMED_PROPERTY;
    }
    private static final int G_REGEX_ERROR_UNKNOWN_PROPERTY = (int)147L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_UNKNOWN_PROPERTY = 147
     * }
     */
    public static int G_REGEX_ERROR_UNKNOWN_PROPERTY() {
        return G_REGEX_ERROR_UNKNOWN_PROPERTY;
    }
    private static final int G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = (int)148L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148
     * }
     */
    public static int G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG() {
        return G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG;
    }
    private static final int G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = (int)149L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149
     * }
     */
    public static int G_REGEX_ERROR_TOO_MANY_SUBPATTERNS() {
        return G_REGEX_ERROR_TOO_MANY_SUBPATTERNS;
    }
    private static final int G_REGEX_ERROR_INVALID_OCTAL_VALUE = (int)151L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151
     * }
     */
    public static int G_REGEX_ERROR_INVALID_OCTAL_VALUE() {
        return G_REGEX_ERROR_INVALID_OCTAL_VALUE;
    }
    private static final int G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = (int)154L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154
     * }
     */
    public static int G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE() {
        return G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE;
    }
    private static final int G_REGEX_ERROR_DEFINE_REPETION = (int)155L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_DEFINE_REPETION = 155
     * }
     */
    public static int G_REGEX_ERROR_DEFINE_REPETION() {
        return G_REGEX_ERROR_DEFINE_REPETION;
    }
    private static final int G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = (int)156L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156
     * }
     */
    public static int G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS() {
        return G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS;
    }
    private static final int G_REGEX_ERROR_MISSING_BACK_REFERENCE = (int)157L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157
     * }
     */
    public static int G_REGEX_ERROR_MISSING_BACK_REFERENCE() {
        return G_REGEX_ERROR_MISSING_BACK_REFERENCE;
    }
    private static final int G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = (int)158L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158
     * }
     */
    public static int G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE() {
        return G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE;
    }
    private static final int G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = (int)159L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159
     * }
     */
    public static int G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN() {
        return G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN;
    }
    private static final int G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = (int)160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160
     * }
     */
    public static int G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB() {
        return G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB;
    }
    private static final int G_REGEX_ERROR_NUMBER_TOO_BIG = (int)161L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_NUMBER_TOO_BIG = 161
     * }
     */
    public static int G_REGEX_ERROR_NUMBER_TOO_BIG() {
        return G_REGEX_ERROR_NUMBER_TOO_BIG;
    }
    private static final int G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = (int)162L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162
     * }
     */
    public static int G_REGEX_ERROR_MISSING_SUBPATTERN_NAME() {
        return G_REGEX_ERROR_MISSING_SUBPATTERN_NAME;
    }
    private static final int G_REGEX_ERROR_MISSING_DIGIT = (int)163L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MISSING_DIGIT = 163
     * }
     */
    public static int G_REGEX_ERROR_MISSING_DIGIT() {
        return G_REGEX_ERROR_MISSING_DIGIT;
    }
    private static final int G_REGEX_ERROR_INVALID_DATA_CHARACTER = (int)164L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164
     * }
     */
    public static int G_REGEX_ERROR_INVALID_DATA_CHARACTER() {
        return G_REGEX_ERROR_INVALID_DATA_CHARACTER;
    }
    private static final int G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = (int)165L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165
     * }
     */
    public static int G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME() {
        return G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME;
    }
    private static final int G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = (int)166L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166
     * }
     */
    public static int G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED() {
        return G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED;
    }
    private static final int G_REGEX_ERROR_INVALID_CONTROL_CHAR = (int)168L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168
     * }
     */
    public static int G_REGEX_ERROR_INVALID_CONTROL_CHAR() {
        return G_REGEX_ERROR_INVALID_CONTROL_CHAR;
    }
    private static final int G_REGEX_ERROR_MISSING_NAME = (int)169L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_MISSING_NAME = 169
     * }
     */
    public static int G_REGEX_ERROR_MISSING_NAME() {
        return G_REGEX_ERROR_MISSING_NAME;
    }
    private static final int G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = (int)171L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171
     * }
     */
    public static int G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS() {
        return G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS;
    }
    private static final int G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = (int)172L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172
     * }
     */
    public static int G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES() {
        return G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES;
    }
    private static final int G_REGEX_ERROR_NAME_TOO_LONG = (int)175L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_NAME_TOO_LONG = 175
     * }
     */
    public static int G_REGEX_ERROR_NAME_TOO_LONG() {
        return G_REGEX_ERROR_NAME_TOO_LONG;
    }
    private static final int G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = (int)176L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176
     * }
     */
    public static int G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE() {
        return G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE;
    }

    private static class g_regex_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_regex_error_quark()
     * }
     */
    public static FunctionDescriptor g_regex_error_quark$descriptor() {
        return g_regex_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_regex_error_quark()
     * }
     */
    public static MethodHandle g_regex_error_quark$handle() {
        return g_regex_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_regex_error_quark()
     * }
     */
    public static MemorySegment g_regex_error_quark$address() {
        return g_regex_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_regex_error_quark()
     * }
     */
    public static int g_regex_error_quark() {
        var mh$ = g_regex_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_REGEX_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_DEFAULT = 0
     * }
     */
    public static int G_REGEX_DEFAULT() {
        return G_REGEX_DEFAULT;
    }
    private static final int G_REGEX_CASELESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_CASELESS = 1
     * }
     */
    public static int G_REGEX_CASELESS() {
        return G_REGEX_CASELESS;
    }
    private static final int G_REGEX_MULTILINE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MULTILINE = 2
     * }
     */
    public static int G_REGEX_MULTILINE() {
        return G_REGEX_MULTILINE;
    }
    private static final int G_REGEX_DOTALL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_DOTALL = 4
     * }
     */
    public static int G_REGEX_DOTALL() {
        return G_REGEX_DOTALL;
    }
    private static final int G_REGEX_EXTENDED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_EXTENDED = 8
     * }
     */
    public static int G_REGEX_EXTENDED() {
        return G_REGEX_EXTENDED;
    }
    private static final int G_REGEX_ANCHORED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_ANCHORED = 16
     * }
     */
    public static int G_REGEX_ANCHORED() {
        return G_REGEX_ANCHORED;
    }
    private static final int G_REGEX_DOLLAR_ENDONLY = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_DOLLAR_ENDONLY = 32
     * }
     */
    public static int G_REGEX_DOLLAR_ENDONLY() {
        return G_REGEX_DOLLAR_ENDONLY;
    }
    private static final int G_REGEX_UNGREEDY = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_UNGREEDY = 512
     * }
     */
    public static int G_REGEX_UNGREEDY() {
        return G_REGEX_UNGREEDY;
    }
    private static final int G_REGEX_RAW = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_RAW = 2048
     * }
     */
    public static int G_REGEX_RAW() {
        return G_REGEX_RAW;
    }
    private static final int G_REGEX_NO_AUTO_CAPTURE = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_NO_AUTO_CAPTURE = 4096
     * }
     */
    public static int G_REGEX_NO_AUTO_CAPTURE() {
        return G_REGEX_NO_AUTO_CAPTURE;
    }
    private static final int G_REGEX_OPTIMIZE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_OPTIMIZE = 8192
     * }
     */
    public static int G_REGEX_OPTIMIZE() {
        return G_REGEX_OPTIMIZE;
    }
    private static final int G_REGEX_FIRSTLINE = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_FIRSTLINE = 262144
     * }
     */
    public static int G_REGEX_FIRSTLINE() {
        return G_REGEX_FIRSTLINE;
    }
    private static final int G_REGEX_DUPNAMES = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_DUPNAMES = 524288
     * }
     */
    public static int G_REGEX_DUPNAMES() {
        return G_REGEX_DUPNAMES;
    }
    private static final int G_REGEX_NEWLINE_CR = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_NEWLINE_CR = 1048576
     * }
     */
    public static int G_REGEX_NEWLINE_CR() {
        return G_REGEX_NEWLINE_CR;
    }
    private static final int G_REGEX_NEWLINE_LF = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_NEWLINE_LF = 2097152
     * }
     */
    public static int G_REGEX_NEWLINE_LF() {
        return G_REGEX_NEWLINE_LF;
    }
    private static final int G_REGEX_NEWLINE_CRLF = (int)3145728L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_NEWLINE_CRLF = 3145728
     * }
     */
    public static int G_REGEX_NEWLINE_CRLF() {
        return G_REGEX_NEWLINE_CRLF;
    }
    private static final int G_REGEX_NEWLINE_ANYCRLF = (int)5242880L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_NEWLINE_ANYCRLF = 5242880
     * }
     */
    public static int G_REGEX_NEWLINE_ANYCRLF() {
        return G_REGEX_NEWLINE_ANYCRLF;
    }
    private static final int G_REGEX_BSR_ANYCRLF = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_BSR_ANYCRLF = 8388608
     * }
     */
    public static int G_REGEX_BSR_ANYCRLF() {
        return G_REGEX_BSR_ANYCRLF;
    }
    private static final int G_REGEX_JAVASCRIPT_COMPAT = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_JAVASCRIPT_COMPAT = 33554432
     * }
     */
    public static int G_REGEX_JAVASCRIPT_COMPAT() {
        return G_REGEX_JAVASCRIPT_COMPAT;
    }
    private static final int G_REGEX_MATCH_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_DEFAULT = 0
     * }
     */
    public static int G_REGEX_MATCH_DEFAULT() {
        return G_REGEX_MATCH_DEFAULT;
    }
    private static final int G_REGEX_MATCH_ANCHORED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_ANCHORED = 16
     * }
     */
    public static int G_REGEX_MATCH_ANCHORED() {
        return G_REGEX_MATCH_ANCHORED;
    }
    private static final int G_REGEX_MATCH_NOTBOL = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NOTBOL = 128
     * }
     */
    public static int G_REGEX_MATCH_NOTBOL() {
        return G_REGEX_MATCH_NOTBOL;
    }
    private static final int G_REGEX_MATCH_NOTEOL = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NOTEOL = 256
     * }
     */
    public static int G_REGEX_MATCH_NOTEOL() {
        return G_REGEX_MATCH_NOTEOL;
    }
    private static final int G_REGEX_MATCH_NOTEMPTY = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NOTEMPTY = 1024
     * }
     */
    public static int G_REGEX_MATCH_NOTEMPTY() {
        return G_REGEX_MATCH_NOTEMPTY;
    }
    private static final int G_REGEX_MATCH_PARTIAL = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_PARTIAL = 32768
     * }
     */
    public static int G_REGEX_MATCH_PARTIAL() {
        return G_REGEX_MATCH_PARTIAL;
    }
    private static final int G_REGEX_MATCH_NEWLINE_CR = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NEWLINE_CR = 1048576
     * }
     */
    public static int G_REGEX_MATCH_NEWLINE_CR() {
        return G_REGEX_MATCH_NEWLINE_CR;
    }
    private static final int G_REGEX_MATCH_NEWLINE_LF = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NEWLINE_LF = 2097152
     * }
     */
    public static int G_REGEX_MATCH_NEWLINE_LF() {
        return G_REGEX_MATCH_NEWLINE_LF;
    }
    private static final int G_REGEX_MATCH_NEWLINE_CRLF = (int)3145728L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NEWLINE_CRLF = 3145728
     * }
     */
    public static int G_REGEX_MATCH_NEWLINE_CRLF() {
        return G_REGEX_MATCH_NEWLINE_CRLF;
    }
    private static final int G_REGEX_MATCH_NEWLINE_ANY = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NEWLINE_ANY = 4194304
     * }
     */
    public static int G_REGEX_MATCH_NEWLINE_ANY() {
        return G_REGEX_MATCH_NEWLINE_ANY;
    }
    private static final int G_REGEX_MATCH_NEWLINE_ANYCRLF = (int)5242880L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880
     * }
     */
    public static int G_REGEX_MATCH_NEWLINE_ANYCRLF() {
        return G_REGEX_MATCH_NEWLINE_ANYCRLF;
    }
    private static final int G_REGEX_MATCH_BSR_ANYCRLF = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_BSR_ANYCRLF = 8388608
     * }
     */
    public static int G_REGEX_MATCH_BSR_ANYCRLF() {
        return G_REGEX_MATCH_BSR_ANYCRLF;
    }
    private static final int G_REGEX_MATCH_BSR_ANY = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_BSR_ANY = 16777216
     * }
     */
    public static int G_REGEX_MATCH_BSR_ANY() {
        return G_REGEX_MATCH_BSR_ANY;
    }
    private static final int G_REGEX_MATCH_PARTIAL_SOFT = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_PARTIAL_SOFT = 32768
     * }
     */
    public static int G_REGEX_MATCH_PARTIAL_SOFT() {
        return G_REGEX_MATCH_PARTIAL_SOFT;
    }
    private static final int G_REGEX_MATCH_PARTIAL_HARD = (int)134217728L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_PARTIAL_HARD = 134217728
     * }
     */
    public static int G_REGEX_MATCH_PARTIAL_HARD() {
        return G_REGEX_MATCH_PARTIAL_HARD;
    }
    private static final int G_REGEX_MATCH_NOTEMPTY_ATSTART = (int)268435456L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456
     * }
     */
    public static int G_REGEX_MATCH_NOTEMPTY_ATSTART() {
        return G_REGEX_MATCH_NOTEMPTY_ATSTART;
    }

    private static class g_regex_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRegex *g_regex_new(const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static FunctionDescriptor g_regex_new$descriptor() {
        return g_regex_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRegex *g_regex_new(const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MethodHandle g_regex_new$handle() {
        return g_regex_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRegex *g_regex_new(const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MemorySegment g_regex_new$address() {
        return g_regex_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRegex *g_regex_new(const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MemorySegment g_regex_new(MemorySegment pattern, int compile_options, int match_options, MemorySegment error) {
        var mh$ = g_regex_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_new", pattern, compile_options, match_options, error);
            }
            return (MemorySegment)mh$.invokeExact(pattern, compile_options, match_options, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRegex *g_regex_ref(GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_ref$descriptor() {
        return g_regex_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRegex *g_regex_ref(GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_ref$handle() {
        return g_regex_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRegex *g_regex_ref(GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_ref$address() {
        return g_regex_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRegex *g_regex_ref(GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_ref(MemorySegment regex) {
        var mh$ = g_regex_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_ref", regex);
            }
            return (MemorySegment)mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_regex_unref(GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_unref$descriptor() {
        return g_regex_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_regex_unref(GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_unref$handle() {
        return g_regex_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_regex_unref(GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_unref$address() {
        return g_regex_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_regex_unref(GRegex *regex)
     * }
     */
    public static void g_regex_unref(MemorySegment regex) {
        var mh$ = g_regex_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_unref", regex);
            }
            mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_pattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_pattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_regex_get_pattern(const GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_get_pattern$descriptor() {
        return g_regex_get_pattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_regex_get_pattern(const GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_get_pattern$handle() {
        return g_regex_get_pattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_regex_get_pattern(const GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_get_pattern$address() {
        return g_regex_get_pattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_regex_get_pattern(const GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_get_pattern(MemorySegment regex) {
        var mh$ = g_regex_get_pattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_pattern", regex);
            }
            return (MemorySegment)mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_max_backref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_max_backref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_regex_get_max_backref(const GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_get_max_backref$descriptor() {
        return g_regex_get_max_backref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_regex_get_max_backref(const GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_get_max_backref$handle() {
        return g_regex_get_max_backref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_regex_get_max_backref(const GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_get_max_backref$address() {
        return g_regex_get_max_backref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_regex_get_max_backref(const GRegex *regex)
     * }
     */
    public static int g_regex_get_max_backref(MemorySegment regex) {
        var mh$ = g_regex_get_max_backref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_max_backref", regex);
            }
            return (int)mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_capture_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_capture_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_regex_get_capture_count(const GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_get_capture_count$descriptor() {
        return g_regex_get_capture_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_regex_get_capture_count(const GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_get_capture_count$handle() {
        return g_regex_get_capture_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_regex_get_capture_count(const GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_get_capture_count$address() {
        return g_regex_get_capture_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_regex_get_capture_count(const GRegex *regex)
     * }
     */
    public static int g_regex_get_capture_count(MemorySegment regex) {
        var mh$ = g_regex_get_capture_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_capture_count", regex);
            }
            return (int)mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_has_cr_or_lf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_has_cr_or_lf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_regex_get_has_cr_or_lf(const GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_get_has_cr_or_lf$descriptor() {
        return g_regex_get_has_cr_or_lf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_regex_get_has_cr_or_lf(const GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_get_has_cr_or_lf$handle() {
        return g_regex_get_has_cr_or_lf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_regex_get_has_cr_or_lf(const GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_get_has_cr_or_lf$address() {
        return g_regex_get_has_cr_or_lf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_regex_get_has_cr_or_lf(const GRegex *regex)
     * }
     */
    public static int g_regex_get_has_cr_or_lf(MemorySegment regex) {
        var mh$ = g_regex_get_has_cr_or_lf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_has_cr_or_lf", regex);
            }
            return (int)mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_max_lookbehind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_max_lookbehind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_regex_get_max_lookbehind(const GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_get_max_lookbehind$descriptor() {
        return g_regex_get_max_lookbehind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_regex_get_max_lookbehind(const GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_get_max_lookbehind$handle() {
        return g_regex_get_max_lookbehind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_regex_get_max_lookbehind(const GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_get_max_lookbehind$address() {
        return g_regex_get_max_lookbehind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_regex_get_max_lookbehind(const GRegex *regex)
     * }
     */
    public static int g_regex_get_max_lookbehind(MemorySegment regex) {
        var mh$ = g_regex_get_max_lookbehind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_max_lookbehind", regex);
            }
            return (int)mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_string_number {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_string_number");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_regex_get_string_number(const GRegex *regex, const gchar *name)
     * }
     */
    public static FunctionDescriptor g_regex_get_string_number$descriptor() {
        return g_regex_get_string_number.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_regex_get_string_number(const GRegex *regex, const gchar *name)
     * }
     */
    public static MethodHandle g_regex_get_string_number$handle() {
        return g_regex_get_string_number.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_regex_get_string_number(const GRegex *regex, const gchar *name)
     * }
     */
    public static MemorySegment g_regex_get_string_number$address() {
        return g_regex_get_string_number.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_regex_get_string_number(const GRegex *regex, const gchar *name)
     * }
     */
    public static int g_regex_get_string_number(MemorySegment regex, MemorySegment name) {
        var mh$ = g_regex_get_string_number.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_string_number", regex, name);
            }
            return (int)mh$.invokeExact(regex, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_escape_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_escape_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_regex_escape_string(const gchar *string, gint length)
     * }
     */
    public static FunctionDescriptor g_regex_escape_string$descriptor() {
        return g_regex_escape_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_regex_escape_string(const gchar *string, gint length)
     * }
     */
    public static MethodHandle g_regex_escape_string$handle() {
        return g_regex_escape_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_regex_escape_string(const gchar *string, gint length)
     * }
     */
    public static MemorySegment g_regex_escape_string$address() {
        return g_regex_escape_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_regex_escape_string(const gchar *string, gint length)
     * }
     */
    public static MemorySegment g_regex_escape_string(MemorySegment string, int length) {
        var mh$ = g_regex_escape_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_escape_string", string, length);
            }
            return (MemorySegment)mh$.invokeExact(string, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_escape_nul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_escape_nul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_regex_escape_nul(const gchar *string, gint length)
     * }
     */
    public static FunctionDescriptor g_regex_escape_nul$descriptor() {
        return g_regex_escape_nul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_regex_escape_nul(const gchar *string, gint length)
     * }
     */
    public static MethodHandle g_regex_escape_nul$handle() {
        return g_regex_escape_nul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_regex_escape_nul(const gchar *string, gint length)
     * }
     */
    public static MemorySegment g_regex_escape_nul$address() {
        return g_regex_escape_nul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_regex_escape_nul(const gchar *string, gint length)
     * }
     */
    public static MemorySegment g_regex_escape_nul(MemorySegment string, int length) {
        var mh$ = g_regex_escape_nul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_escape_nul", string, length);
            }
            return (MemorySegment)mh$.invokeExact(string, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_compile_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_compile_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRegexCompileFlags g_regex_get_compile_flags(const GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_get_compile_flags$descriptor() {
        return g_regex_get_compile_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRegexCompileFlags g_regex_get_compile_flags(const GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_get_compile_flags$handle() {
        return g_regex_get_compile_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRegexCompileFlags g_regex_get_compile_flags(const GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_get_compile_flags$address() {
        return g_regex_get_compile_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRegexCompileFlags g_regex_get_compile_flags(const GRegex *regex)
     * }
     */
    public static int g_regex_get_compile_flags(MemorySegment regex) {
        var mh$ = g_regex_get_compile_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_compile_flags", regex);
            }
            return (int)mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_get_match_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_get_match_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRegexMatchFlags g_regex_get_match_flags(const GRegex *regex)
     * }
     */
    public static FunctionDescriptor g_regex_get_match_flags$descriptor() {
        return g_regex_get_match_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRegexMatchFlags g_regex_get_match_flags(const GRegex *regex)
     * }
     */
    public static MethodHandle g_regex_get_match_flags$handle() {
        return g_regex_get_match_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRegexMatchFlags g_regex_get_match_flags(const GRegex *regex)
     * }
     */
    public static MemorySegment g_regex_get_match_flags$address() {
        return g_regex_get_match_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRegexMatchFlags g_regex_get_match_flags(const GRegex *regex)
     * }
     */
    public static int g_regex_get_match_flags(MemorySegment regex) {
        var mh$ = g_regex_get_match_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_get_match_flags", regex);
            }
            return (int)mh$.invokeExact(regex);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_match_simple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_match_simple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_simple(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options)
     * }
     */
    public static FunctionDescriptor g_regex_match_simple$descriptor() {
        return g_regex_match_simple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_simple(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options)
     * }
     */
    public static MethodHandle g_regex_match_simple$handle() {
        return g_regex_match_simple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_simple(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options)
     * }
     */
    public static MemorySegment g_regex_match_simple$address() {
        return g_regex_match_simple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_regex_match_simple(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options)
     * }
     */
    public static int g_regex_match_simple(MemorySegment pattern, MemorySegment string, int compile_options, int match_options) {
        var mh$ = g_regex_match_simple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_match_simple", pattern, string, compile_options, match_options);
            }
            return (int)mh$.invokeExact(pattern, string, compile_options, match_options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info)
     * }
     */
    public static FunctionDescriptor g_regex_match$descriptor() {
        return g_regex_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info)
     * }
     */
    public static MethodHandle g_regex_match$handle() {
        return g_regex_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info)
     * }
     */
    public static MemorySegment g_regex_match$address() {
        return g_regex_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_regex_match(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info)
     * }
     */
    public static int g_regex_match(MemorySegment regex, MemorySegment string, int match_options, MemorySegment match_info) {
        var mh$ = g_regex_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_match", regex, string, match_options, match_info);
            }
            return (int)mh$.invokeExact(regex, string, match_options, match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_match_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_match_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error)
     * }
     */
    public static FunctionDescriptor g_regex_match_full$descriptor() {
        return g_regex_match_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error)
     * }
     */
    public static MethodHandle g_regex_match_full$handle() {
        return g_regex_match_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error)
     * }
     */
    public static MemorySegment g_regex_match_full$address() {
        return g_regex_match_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_regex_match_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error)
     * }
     */
    public static int g_regex_match_full(MemorySegment regex, MemorySegment string, long string_len, int start_position, int match_options, MemorySegment match_info, MemorySegment error) {
        var mh$ = g_regex_match_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_match_full", regex, string, string_len, start_position, match_options, match_info, error);
            }
            return (int)mh$.invokeExact(regex, string, string_len, start_position, match_options, match_info, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_match_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_match_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_all(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info)
     * }
     */
    public static FunctionDescriptor g_regex_match_all$descriptor() {
        return g_regex_match_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_all(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info)
     * }
     */
    public static MethodHandle g_regex_match_all$handle() {
        return g_regex_match_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_all(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info)
     * }
     */
    public static MemorySegment g_regex_match_all$address() {
        return g_regex_match_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_regex_match_all(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info)
     * }
     */
    public static int g_regex_match_all(MemorySegment regex, MemorySegment string, int match_options, MemorySegment match_info) {
        var mh$ = g_regex_match_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_match_all", regex, string, match_options, match_info);
            }
            return (int)mh$.invokeExact(regex, string, match_options, match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_match_all_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_match_all_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_all_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error)
     * }
     */
    public static FunctionDescriptor g_regex_match_all_full$descriptor() {
        return g_regex_match_all_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_all_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error)
     * }
     */
    public static MethodHandle g_regex_match_all_full$handle() {
        return g_regex_match_all_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_regex_match_all_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error)
     * }
     */
    public static MemorySegment g_regex_match_all_full$address() {
        return g_regex_match_all_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_regex_match_all_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error)
     * }
     */
    public static int g_regex_match_all_full(MemorySegment regex, MemorySegment string, long string_len, int start_position, int match_options, MemorySegment match_info, MemorySegment error) {
        var mh$ = g_regex_match_all_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_match_all_full", regex, string, string_len, start_position, match_options, match_info, error);
            }
            return (int)mh$.invokeExact(regex, string, string_len, start_position, match_options, match_info, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_split_simple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_split_simple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split_simple(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options)
     * }
     */
    public static FunctionDescriptor g_regex_split_simple$descriptor() {
        return g_regex_split_simple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split_simple(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options)
     * }
     */
    public static MethodHandle g_regex_split_simple$handle() {
        return g_regex_split_simple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split_simple(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options)
     * }
     */
    public static MemorySegment g_regex_split_simple$address() {
        return g_regex_split_simple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_regex_split_simple(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options)
     * }
     */
    public static MemorySegment g_regex_split_simple(MemorySegment pattern, MemorySegment string, int compile_options, int match_options) {
        var mh$ = g_regex_split_simple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_split_simple", pattern, string, compile_options, match_options);
            }
            return (MemorySegment)mh$.invokeExact(pattern, string, compile_options, match_options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options)
     * }
     */
    public static FunctionDescriptor g_regex_split$descriptor() {
        return g_regex_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options)
     * }
     */
    public static MethodHandle g_regex_split$handle() {
        return g_regex_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options)
     * }
     */
    public static MemorySegment g_regex_split$address() {
        return g_regex_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_regex_split(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options)
     * }
     */
    public static MemorySegment g_regex_split(MemorySegment regex, MemorySegment string, int match_options) {
        var mh$ = g_regex_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_split", regex, string, match_options);
            }
            return (MemorySegment)mh$.invokeExact(regex, string, match_options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_split_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_split_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error)
     * }
     */
    public static FunctionDescriptor g_regex_split_full$descriptor() {
        return g_regex_split_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error)
     * }
     */
    public static MethodHandle g_regex_split_full$handle() {
        return g_regex_split_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_regex_split_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error)
     * }
     */
    public static MemorySegment g_regex_split_full$address() {
        return g_regex_split_full.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_regex_split_full(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error)
     * }
     */
    public static MemorySegment g_regex_split_full(MemorySegment regex, MemorySegment string, long string_len, int start_position, int match_options, int max_tokens, MemorySegment error) {
        var mh$ = g_regex_split_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_split_full", regex, string, string_len, start_position, match_options, max_tokens, error);
            }
            return (MemorySegment)mh$.invokeExact(regex, string, string_len, start_position, match_options, max_tokens, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static FunctionDescriptor g_regex_replace$descriptor() {
        return g_regex_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MethodHandle g_regex_replace$handle() {
        return g_regex_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MemorySegment g_regex_replace$address() {
        return g_regex_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_regex_replace(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MemorySegment g_regex_replace(MemorySegment regex, MemorySegment string, long string_len, int start_position, MemorySegment replacement, int match_options, MemorySegment error) {
        var mh$ = g_regex_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_replace", regex, string, string_len, start_position, replacement, match_options, error);
            }
            return (MemorySegment)mh$.invokeExact(regex, string, string_len, start_position, replacement, match_options, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_replace_literal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_replace_literal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace_literal(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static FunctionDescriptor g_regex_replace_literal$descriptor() {
        return g_regex_replace_literal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace_literal(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MethodHandle g_regex_replace_literal$handle() {
        return g_regex_replace_literal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace_literal(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MemorySegment g_regex_replace_literal$address() {
        return g_regex_replace_literal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_regex_replace_literal(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error)
     * }
     */
    public static MemorySegment g_regex_replace_literal(MemorySegment regex, MemorySegment string, long string_len, int start_position, MemorySegment replacement, int match_options, MemorySegment error) {
        var mh$ = g_regex_replace_literal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_replace_literal", regex, string, string_len, start_position, replacement, match_options, error);
            }
            return (MemorySegment)mh$.invokeExact(regex, string, string_len, start_position, replacement, match_options, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_replace_eval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_replace_eval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace_eval(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error)
     * }
     */
    public static FunctionDescriptor g_regex_replace_eval$descriptor() {
        return g_regex_replace_eval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace_eval(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error)
     * }
     */
    public static MethodHandle g_regex_replace_eval$handle() {
        return g_regex_replace_eval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_regex_replace_eval(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error)
     * }
     */
    public static MemorySegment g_regex_replace_eval$address() {
        return g_regex_replace_eval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_regex_replace_eval(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error)
     * }
     */
    public static MemorySegment g_regex_replace_eval(MemorySegment regex, MemorySegment string, long string_len, int start_position, int match_options, MemorySegment eval, MemorySegment user_data, MemorySegment error) {
        var mh$ = g_regex_replace_eval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_replace_eval", regex, string, string_len, start_position, match_options, eval, user_data, error);
            }
            return (MemorySegment)mh$.invokeExact(regex, string, string_len, start_position, match_options, eval, user_data, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_regex_check_replacement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_regex_check_replacement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_regex_check_replacement(const gchar *replacement, gboolean *has_references, GError **error)
     * }
     */
    public static FunctionDescriptor g_regex_check_replacement$descriptor() {
        return g_regex_check_replacement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_regex_check_replacement(const gchar *replacement, gboolean *has_references, GError **error)
     * }
     */
    public static MethodHandle g_regex_check_replacement$handle() {
        return g_regex_check_replacement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_regex_check_replacement(const gchar *replacement, gboolean *has_references, GError **error)
     * }
     */
    public static MemorySegment g_regex_check_replacement$address() {
        return g_regex_check_replacement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_regex_check_replacement(const gchar *replacement, gboolean *has_references, GError **error)
     * }
     */
    public static int g_regex_check_replacement(MemorySegment replacement, MemorySegment has_references, MemorySegment error) {
        var mh$ = g_regex_check_replacement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_regex_check_replacement", replacement, has_references, error);
            }
            return (int)mh$.invokeExact(replacement, has_references, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_get_regex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_get_regex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GRegex *g_match_info_get_regex(const GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_get_regex$descriptor() {
        return g_match_info_get_regex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GRegex *g_match_info_get_regex(const GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_get_regex$handle() {
        return g_match_info_get_regex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GRegex *g_match_info_get_regex(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_get_regex$address() {
        return g_match_info_get_regex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GRegex *g_match_info_get_regex(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_get_regex(MemorySegment match_info) {
        var mh$ = g_match_info_get_regex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_get_regex", match_info);
            }
            return (MemorySegment)mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_get_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const gchar *g_match_info_get_string(const GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_get_string$descriptor() {
        return g_match_info_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const gchar *g_match_info_get_string(const GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_get_string$handle() {
        return g_match_info_get_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const gchar *g_match_info_get_string(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_get_string$address() {
        return g_match_info_get_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const gchar *g_match_info_get_string(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_get_string(MemorySegment match_info) {
        var mh$ = g_match_info_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_get_string", match_info);
            }
            return (MemorySegment)mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_ref$descriptor() {
        return g_match_info_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_ref$handle() {
        return g_match_info_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_ref$address() {
        return g_match_info_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_ref(MemorySegment match_info) {
        var mh$ = g_match_info_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_ref", match_info);
            }
            return (MemorySegment)mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_match_info_unref(GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_unref$descriptor() {
        return g_match_info_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_match_info_unref(GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_unref$handle() {
        return g_match_info_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_match_info_unref(GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_unref$address() {
        return g_match_info_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_match_info_unref(GMatchInfo *match_info)
     * }
     */
    public static void g_match_info_unref(MemorySegment match_info) {
        var mh$ = g_match_info_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_unref", match_info);
            }
            mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_match_info_free(GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_free$descriptor() {
        return g_match_info_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_match_info_free(GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_free$handle() {
        return g_match_info_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_match_info_free(GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_free$address() {
        return g_match_info_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_match_info_free(GMatchInfo *match_info)
     * }
     */
    public static void g_match_info_free(MemorySegment match_info) {
        var mh$ = g_match_info_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_free", match_info);
            }
            mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_next(GMatchInfo *match_info, GError **error)
     * }
     */
    public static FunctionDescriptor g_match_info_next$descriptor() {
        return g_match_info_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_next(GMatchInfo *match_info, GError **error)
     * }
     */
    public static MethodHandle g_match_info_next$handle() {
        return g_match_info_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_next(GMatchInfo *match_info, GError **error)
     * }
     */
    public static MemorySegment g_match_info_next$address() {
        return g_match_info_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_match_info_next(GMatchInfo *match_info, GError **error)
     * }
     */
    public static int g_match_info_next(MemorySegment match_info, MemorySegment error) {
        var mh$ = g_match_info_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_next", match_info, error);
            }
            return (int)mh$.invokeExact(match_info, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_matches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_matches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_matches(const GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_matches$descriptor() {
        return g_match_info_matches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_matches(const GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_matches$handle() {
        return g_match_info_matches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_matches(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_matches$address() {
        return g_match_info_matches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_match_info_matches(const GMatchInfo *match_info)
     * }
     */
    public static int g_match_info_matches(MemorySegment match_info) {
        var mh$ = g_match_info_matches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_matches", match_info);
            }
            return (int)mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_get_match_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_get_match_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_match_info_get_match_count(const GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_get_match_count$descriptor() {
        return g_match_info_get_match_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_match_info_get_match_count(const GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_get_match_count$handle() {
        return g_match_info_get_match_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_match_info_get_match_count(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_get_match_count$address() {
        return g_match_info_get_match_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_match_info_get_match_count(const GMatchInfo *match_info)
     * }
     */
    public static int g_match_info_get_match_count(MemorySegment match_info) {
        var mh$ = g_match_info_get_match_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_get_match_count", match_info);
            }
            return (int)mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_is_partial_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_is_partial_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_is_partial_match(const GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_is_partial_match$descriptor() {
        return g_match_info_is_partial_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_is_partial_match(const GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_is_partial_match$handle() {
        return g_match_info_is_partial_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_is_partial_match(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_is_partial_match$address() {
        return g_match_info_is_partial_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_match_info_is_partial_match(const GMatchInfo *match_info)
     * }
     */
    public static int g_match_info_is_partial_match(MemorySegment match_info) {
        var mh$ = g_match_info_is_partial_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_is_partial_match", match_info);
            }
            return (int)mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_expand_references {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_expand_references");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_expand_references(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error)
     * }
     */
    public static FunctionDescriptor g_match_info_expand_references$descriptor() {
        return g_match_info_expand_references.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_expand_references(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error)
     * }
     */
    public static MethodHandle g_match_info_expand_references$handle() {
        return g_match_info_expand_references.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_expand_references(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error)
     * }
     */
    public static MemorySegment g_match_info_expand_references$address() {
        return g_match_info_expand_references.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_match_info_expand_references(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error)
     * }
     */
    public static MemorySegment g_match_info_expand_references(MemorySegment match_info, MemorySegment string_to_expand, MemorySegment error) {
        var mh$ = g_match_info_expand_references.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_expand_references", match_info, string_to_expand, error);
            }
            return (MemorySegment)mh$.invokeExact(match_info, string_to_expand, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_fetch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_fetch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_fetch(const GMatchInfo *match_info, gint match_num)
     * }
     */
    public static FunctionDescriptor g_match_info_fetch$descriptor() {
        return g_match_info_fetch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_fetch(const GMatchInfo *match_info, gint match_num)
     * }
     */
    public static MethodHandle g_match_info_fetch$handle() {
        return g_match_info_fetch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_fetch(const GMatchInfo *match_info, gint match_num)
     * }
     */
    public static MemorySegment g_match_info_fetch$address() {
        return g_match_info_fetch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_match_info_fetch(const GMatchInfo *match_info, gint match_num)
     * }
     */
    public static MemorySegment g_match_info_fetch(MemorySegment match_info, int match_num) {
        var mh$ = g_match_info_fetch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_fetch", match_info, match_num);
            }
            return (MemorySegment)mh$.invokeExact(match_info, match_num);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_fetch_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_fetch_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_fetch_pos(const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos)
     * }
     */
    public static FunctionDescriptor g_match_info_fetch_pos$descriptor() {
        return g_match_info_fetch_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_fetch_pos(const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos)
     * }
     */
    public static MethodHandle g_match_info_fetch_pos$handle() {
        return g_match_info_fetch_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_fetch_pos(const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos)
     * }
     */
    public static MemorySegment g_match_info_fetch_pos$address() {
        return g_match_info_fetch_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_match_info_fetch_pos(const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos)
     * }
     */
    public static int g_match_info_fetch_pos(MemorySegment match_info, int match_num, MemorySegment start_pos, MemorySegment end_pos) {
        var mh$ = g_match_info_fetch_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_fetch_pos", match_info, match_num, start_pos, end_pos);
            }
            return (int)mh$.invokeExact(match_info, match_num, start_pos, end_pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_fetch_named {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_fetch_named");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_fetch_named(const GMatchInfo *match_info, const gchar *name)
     * }
     */
    public static FunctionDescriptor g_match_info_fetch_named$descriptor() {
        return g_match_info_fetch_named.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_fetch_named(const GMatchInfo *match_info, const gchar *name)
     * }
     */
    public static MethodHandle g_match_info_fetch_named$handle() {
        return g_match_info_fetch_named.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_match_info_fetch_named(const GMatchInfo *match_info, const gchar *name)
     * }
     */
    public static MemorySegment g_match_info_fetch_named$address() {
        return g_match_info_fetch_named.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_match_info_fetch_named(const GMatchInfo *match_info, const gchar *name)
     * }
     */
    public static MemorySegment g_match_info_fetch_named(MemorySegment match_info, MemorySegment name) {
        var mh$ = g_match_info_fetch_named.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_fetch_named", match_info, name);
            }
            return (MemorySegment)mh$.invokeExact(match_info, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_fetch_named_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_fetch_named_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_fetch_named_pos(const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos)
     * }
     */
    public static FunctionDescriptor g_match_info_fetch_named_pos$descriptor() {
        return g_match_info_fetch_named_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_fetch_named_pos(const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos)
     * }
     */
    public static MethodHandle g_match_info_fetch_named_pos$handle() {
        return g_match_info_fetch_named_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_match_info_fetch_named_pos(const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos)
     * }
     */
    public static MemorySegment g_match_info_fetch_named_pos$address() {
        return g_match_info_fetch_named_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_match_info_fetch_named_pos(const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos)
     * }
     */
    public static int g_match_info_fetch_named_pos(MemorySegment match_info, MemorySegment name, MemorySegment start_pos, MemorySegment end_pos) {
        var mh$ = g_match_info_fetch_named_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_fetch_named_pos", match_info, name, start_pos, end_pos);
            }
            return (int)mh$.invokeExact(match_info, name, start_pos, end_pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_match_info_fetch_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_match_info_fetch_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar **g_match_info_fetch_all(const GMatchInfo *match_info)
     * }
     */
    public static FunctionDescriptor g_match_info_fetch_all$descriptor() {
        return g_match_info_fetch_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar **g_match_info_fetch_all(const GMatchInfo *match_info)
     * }
     */
    public static MethodHandle g_match_info_fetch_all$handle() {
        return g_match_info_fetch_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar **g_match_info_fetch_all(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_fetch_all$address() {
        return g_match_info_fetch_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar **g_match_info_fetch_all(const GMatchInfo *match_info)
     * }
     */
    public static MemorySegment g_match_info_fetch_all(MemorySegment match_info) {
        var mh$ = g_match_info_fetch_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_match_info_fetch_all", match_info);
            }
            return (MemorySegment)mh$.invokeExact(match_info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_ERR_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ERR_UNKNOWN = 0
     * }
     */
    public static int G_ERR_UNKNOWN() {
        return G_ERR_UNKNOWN;
    }
    private static final int G_ERR_UNEXP_EOF = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ERR_UNEXP_EOF = 1
     * }
     */
    public static int G_ERR_UNEXP_EOF() {
        return G_ERR_UNEXP_EOF;
    }
    private static final int G_ERR_UNEXP_EOF_IN_STRING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ERR_UNEXP_EOF_IN_STRING = 2
     * }
     */
    public static int G_ERR_UNEXP_EOF_IN_STRING() {
        return G_ERR_UNEXP_EOF_IN_STRING;
    }
    private static final int G_ERR_UNEXP_EOF_IN_COMMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ERR_UNEXP_EOF_IN_COMMENT = 3
     * }
     */
    public static int G_ERR_UNEXP_EOF_IN_COMMENT() {
        return G_ERR_UNEXP_EOF_IN_COMMENT;
    }
    private static final int G_ERR_NON_DIGIT_IN_CONST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ERR_NON_DIGIT_IN_CONST = 4
     * }
     */
    public static int G_ERR_NON_DIGIT_IN_CONST() {
        return G_ERR_NON_DIGIT_IN_CONST;
    }
    private static final int G_ERR_DIGIT_RADIX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ERR_DIGIT_RADIX = 5
     * }
     */
    public static int G_ERR_DIGIT_RADIX() {
        return G_ERR_DIGIT_RADIX;
    }
    private static final int G_ERR_FLOAT_RADIX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ERR_FLOAT_RADIX = 6
     * }
     */
    public static int G_ERR_FLOAT_RADIX() {
        return G_ERR_FLOAT_RADIX;
    }
    private static final int G_ERR_FLOAT_MALFORMED = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_ERR_FLOAT_MALFORMED = 7
     * }
     */
    public static int G_ERR_FLOAT_MALFORMED() {
        return G_ERR_FLOAT_MALFORMED;
    }
    private static final int G_TOKEN_EOF = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_EOF = 0
     * }
     */
    public static int G_TOKEN_EOF() {
        return G_TOKEN_EOF;
    }
    private static final int G_TOKEN_LEFT_PAREN = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_LEFT_PAREN = 40
     * }
     */
    public static int G_TOKEN_LEFT_PAREN() {
        return G_TOKEN_LEFT_PAREN;
    }
    private static final int G_TOKEN_RIGHT_PAREN = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_RIGHT_PAREN = 41
     * }
     */
    public static int G_TOKEN_RIGHT_PAREN() {
        return G_TOKEN_RIGHT_PAREN;
    }
    private static final int G_TOKEN_LEFT_CURLY = (int)123L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_LEFT_CURLY = 123
     * }
     */
    public static int G_TOKEN_LEFT_CURLY() {
        return G_TOKEN_LEFT_CURLY;
    }
    private static final int G_TOKEN_RIGHT_CURLY = (int)125L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_RIGHT_CURLY = 125
     * }
     */
    public static int G_TOKEN_RIGHT_CURLY() {
        return G_TOKEN_RIGHT_CURLY;
    }
    private static final int G_TOKEN_LEFT_BRACE = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_LEFT_BRACE = 91
     * }
     */
    public static int G_TOKEN_LEFT_BRACE() {
        return G_TOKEN_LEFT_BRACE;
    }
    private static final int G_TOKEN_RIGHT_BRACE = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_RIGHT_BRACE = 93
     * }
     */
    public static int G_TOKEN_RIGHT_BRACE() {
        return G_TOKEN_RIGHT_BRACE;
    }
    private static final int G_TOKEN_EQUAL_SIGN = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_EQUAL_SIGN = 61
     * }
     */
    public static int G_TOKEN_EQUAL_SIGN() {
        return G_TOKEN_EQUAL_SIGN;
    }
    private static final int G_TOKEN_COMMA = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_COMMA = 44
     * }
     */
    public static int G_TOKEN_COMMA() {
        return G_TOKEN_COMMA;
    }
    private static final int G_TOKEN_NONE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_NONE = 256
     * }
     */
    public static int G_TOKEN_NONE() {
        return G_TOKEN_NONE;
    }
    private static final int G_TOKEN_ERROR = (int)257L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_ERROR = 257
     * }
     */
    public static int G_TOKEN_ERROR() {
        return G_TOKEN_ERROR;
    }
    private static final int G_TOKEN_CHAR = (int)258L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_CHAR = 258
     * }
     */
    public static int G_TOKEN_CHAR() {
        return G_TOKEN_CHAR;
    }
    private static final int G_TOKEN_BINARY = (int)259L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_BINARY = 259
     * }
     */
    public static int G_TOKEN_BINARY() {
        return G_TOKEN_BINARY;
    }
    private static final int G_TOKEN_OCTAL = (int)260L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_OCTAL = 260
     * }
     */
    public static int G_TOKEN_OCTAL() {
        return G_TOKEN_OCTAL;
    }
    private static final int G_TOKEN_INT = (int)261L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_INT = 261
     * }
     */
    public static int G_TOKEN_INT() {
        return G_TOKEN_INT;
    }
    private static final int G_TOKEN_HEX = (int)262L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_HEX = 262
     * }
     */
    public static int G_TOKEN_HEX() {
        return G_TOKEN_HEX;
    }
    private static final int G_TOKEN_FLOAT = (int)263L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_FLOAT = 263
     * }
     */
    public static int G_TOKEN_FLOAT() {
        return G_TOKEN_FLOAT;
    }
    private static final int G_TOKEN_STRING = (int)264L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_STRING = 264
     * }
     */
    public static int G_TOKEN_STRING() {
        return G_TOKEN_STRING;
    }
    private static final int G_TOKEN_SYMBOL = (int)265L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_SYMBOL = 265
     * }
     */
    public static int G_TOKEN_SYMBOL() {
        return G_TOKEN_SYMBOL;
    }
    private static final int G_TOKEN_IDENTIFIER = (int)266L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_IDENTIFIER = 266
     * }
     */
    public static int G_TOKEN_IDENTIFIER() {
        return G_TOKEN_IDENTIFIER;
    }
    private static final int G_TOKEN_IDENTIFIER_NULL = (int)267L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_IDENTIFIER_NULL = 267
     * }
     */
    public static int G_TOKEN_IDENTIFIER_NULL() {
        return G_TOKEN_IDENTIFIER_NULL;
    }
    private static final int G_TOKEN_COMMENT_SINGLE = (int)268L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_COMMENT_SINGLE = 268
     * }
     */
    public static int G_TOKEN_COMMENT_SINGLE() {
        return G_TOKEN_COMMENT_SINGLE;
    }
    private static final int G_TOKEN_COMMENT_MULTI = (int)269L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_COMMENT_MULTI = 269
     * }
     */
    public static int G_TOKEN_COMMENT_MULTI() {
        return G_TOKEN_COMMENT_MULTI;
    }
    private static final int G_TOKEN_LAST = (int)270L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_TOKEN_LAST = 270
     * }
     */
    public static int G_TOKEN_LAST() {
        return G_TOKEN_LAST;
    }

    private static class g_scanner_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GScanner *g_scanner_new(const GScannerConfig *config_templ)
     * }
     */
    public static FunctionDescriptor g_scanner_new$descriptor() {
        return g_scanner_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GScanner *g_scanner_new(const GScannerConfig *config_templ)
     * }
     */
    public static MethodHandle g_scanner_new$handle() {
        return g_scanner_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GScanner *g_scanner_new(const GScannerConfig *config_templ)
     * }
     */
    public static MemorySegment g_scanner_new$address() {
        return g_scanner_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GScanner *g_scanner_new(const GScannerConfig *config_templ)
     * }
     */
    public static MemorySegment g_scanner_new(MemorySegment config_templ) {
        var mh$ = g_scanner_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_new", config_templ);
            }
            return (MemorySegment)mh$.invokeExact(config_templ);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_scanner_destroy(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_destroy$descriptor() {
        return g_scanner_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_scanner_destroy(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_destroy$handle() {
        return g_scanner_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_scanner_destroy(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_destroy$address() {
        return g_scanner_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_scanner_destroy(GScanner *scanner)
     * }
     */
    public static void g_scanner_destroy(MemorySegment scanner) {
        var mh$ = g_scanner_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_destroy", scanner);
            }
            mh$.invokeExact(scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_input_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_input_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_scanner_input_file(GScanner *scanner, gint input_fd)
     * }
     */
    public static FunctionDescriptor g_scanner_input_file$descriptor() {
        return g_scanner_input_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_scanner_input_file(GScanner *scanner, gint input_fd)
     * }
     */
    public static MethodHandle g_scanner_input_file$handle() {
        return g_scanner_input_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_scanner_input_file(GScanner *scanner, gint input_fd)
     * }
     */
    public static MemorySegment g_scanner_input_file$address() {
        return g_scanner_input_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_scanner_input_file(GScanner *scanner, gint input_fd)
     * }
     */
    public static void g_scanner_input_file(MemorySegment scanner, int input_fd) {
        var mh$ = g_scanner_input_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_input_file", scanner, input_fd);
            }
            mh$.invokeExact(scanner, input_fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_sync_file_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_sync_file_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_scanner_sync_file_offset(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_sync_file_offset$descriptor() {
        return g_scanner_sync_file_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_scanner_sync_file_offset(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_sync_file_offset$handle() {
        return g_scanner_sync_file_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_scanner_sync_file_offset(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_sync_file_offset$address() {
        return g_scanner_sync_file_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_scanner_sync_file_offset(GScanner *scanner)
     * }
     */
    public static void g_scanner_sync_file_offset(MemorySegment scanner) {
        var mh$ = g_scanner_sync_file_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_sync_file_offset", scanner);
            }
            mh$.invokeExact(scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_input_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_input_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_scanner_input_text(GScanner *scanner, const gchar *text, guint text_len)
     * }
     */
    public static FunctionDescriptor g_scanner_input_text$descriptor() {
        return g_scanner_input_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_scanner_input_text(GScanner *scanner, const gchar *text, guint text_len)
     * }
     */
    public static MethodHandle g_scanner_input_text$handle() {
        return g_scanner_input_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_scanner_input_text(GScanner *scanner, const gchar *text, guint text_len)
     * }
     */
    public static MemorySegment g_scanner_input_text$address() {
        return g_scanner_input_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_scanner_input_text(GScanner *scanner, const gchar *text, guint text_len)
     * }
     */
    public static void g_scanner_input_text(MemorySegment scanner, MemorySegment text, int text_len) {
        var mh$ = g_scanner_input_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_input_text", scanner, text, text_len);
            }
            mh$.invokeExact(scanner, text, text_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_get_next_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_get_next_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_get_next_token(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_get_next_token$descriptor() {
        return g_scanner_get_next_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_get_next_token(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_get_next_token$handle() {
        return g_scanner_get_next_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_get_next_token(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_get_next_token$address() {
        return g_scanner_get_next_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTokenType g_scanner_get_next_token(GScanner *scanner)
     * }
     */
    public static int g_scanner_get_next_token(MemorySegment scanner) {
        var mh$ = g_scanner_get_next_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_get_next_token", scanner);
            }
            return (int)mh$.invokeExact(scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_peek_next_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_peek_next_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_peek_next_token(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_peek_next_token$descriptor() {
        return g_scanner_peek_next_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_peek_next_token(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_peek_next_token$handle() {
        return g_scanner_peek_next_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_peek_next_token(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_peek_next_token$address() {
        return g_scanner_peek_next_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTokenType g_scanner_peek_next_token(GScanner *scanner)
     * }
     */
    public static int g_scanner_peek_next_token(MemorySegment scanner) {
        var mh$ = g_scanner_peek_next_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_peek_next_token", scanner);
            }
            return (int)mh$.invokeExact(scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_cur_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_cur_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_cur_token(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_cur_token$descriptor() {
        return g_scanner_cur_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_cur_token(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_cur_token$handle() {
        return g_scanner_cur_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTokenType g_scanner_cur_token(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_cur_token$address() {
        return g_scanner_cur_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTokenType g_scanner_cur_token(GScanner *scanner)
     * }
     */
    public static int g_scanner_cur_token(MemorySegment scanner) {
        var mh$ = g_scanner_cur_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_cur_token", scanner);
            }
            return (int)mh$.invokeExact(scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_cur_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _GTokenValue.layout(),
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_cur_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GTokenValue g_scanner_cur_value(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_cur_value$descriptor() {
        return g_scanner_cur_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GTokenValue g_scanner_cur_value(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_cur_value$handle() {
        return g_scanner_cur_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GTokenValue g_scanner_cur_value(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_cur_value$address() {
        return g_scanner_cur_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GTokenValue g_scanner_cur_value(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_cur_value(SegmentAllocator allocator, MemorySegment scanner) {
        var mh$ = g_scanner_cur_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_cur_value", allocator, scanner);
            }
            return (MemorySegment)mh$.invokeExact(allocator, scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_cur_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_cur_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_scanner_cur_line(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_cur_line$descriptor() {
        return g_scanner_cur_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_scanner_cur_line(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_cur_line$handle() {
        return g_scanner_cur_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_scanner_cur_line(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_cur_line$address() {
        return g_scanner_cur_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_scanner_cur_line(GScanner *scanner)
     * }
     */
    public static int g_scanner_cur_line(MemorySegment scanner) {
        var mh$ = g_scanner_cur_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_cur_line", scanner);
            }
            return (int)mh$.invokeExact(scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_cur_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_cur_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_scanner_cur_position(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_cur_position$descriptor() {
        return g_scanner_cur_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_scanner_cur_position(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_cur_position$handle() {
        return g_scanner_cur_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_scanner_cur_position(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_cur_position$address() {
        return g_scanner_cur_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_scanner_cur_position(GScanner *scanner)
     * }
     */
    public static int g_scanner_cur_position(MemorySegment scanner) {
        var mh$ = g_scanner_cur_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_cur_position", scanner);
            }
            return (int)mh$.invokeExact(scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_eof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_eof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_scanner_eof(GScanner *scanner)
     * }
     */
    public static FunctionDescriptor g_scanner_eof$descriptor() {
        return g_scanner_eof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_scanner_eof(GScanner *scanner)
     * }
     */
    public static MethodHandle g_scanner_eof$handle() {
        return g_scanner_eof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_scanner_eof(GScanner *scanner)
     * }
     */
    public static MemorySegment g_scanner_eof$address() {
        return g_scanner_eof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_scanner_eof(GScanner *scanner)
     * }
     */
    public static int g_scanner_eof(MemorySegment scanner) {
        var mh$ = g_scanner_eof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_eof", scanner);
            }
            return (int)mh$.invokeExact(scanner);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_set_scope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_set_scope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern guint g_scanner_set_scope(GScanner *scanner, guint scope_id)
     * }
     */
    public static FunctionDescriptor g_scanner_set_scope$descriptor() {
        return g_scanner_set_scope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern guint g_scanner_set_scope(GScanner *scanner, guint scope_id)
     * }
     */
    public static MethodHandle g_scanner_set_scope$handle() {
        return g_scanner_set_scope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern guint g_scanner_set_scope(GScanner *scanner, guint scope_id)
     * }
     */
    public static MemorySegment g_scanner_set_scope$address() {
        return g_scanner_set_scope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern guint g_scanner_set_scope(GScanner *scanner, guint scope_id)
     * }
     */
    public static int g_scanner_set_scope(MemorySegment scanner, int scope_id) {
        var mh$ = g_scanner_set_scope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_set_scope", scanner, scope_id);
            }
            return (int)mh$.invokeExact(scanner, scope_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_scope_add_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_scope_add_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_add_symbol(GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value)
     * }
     */
    public static FunctionDescriptor g_scanner_scope_add_symbol$descriptor() {
        return g_scanner_scope_add_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_add_symbol(GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value)
     * }
     */
    public static MethodHandle g_scanner_scope_add_symbol$handle() {
        return g_scanner_scope_add_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_add_symbol(GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value)
     * }
     */
    public static MemorySegment g_scanner_scope_add_symbol$address() {
        return g_scanner_scope_add_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_scanner_scope_add_symbol(GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value)
     * }
     */
    public static void g_scanner_scope_add_symbol(MemorySegment scanner, int scope_id, MemorySegment symbol, MemorySegment value) {
        var mh$ = g_scanner_scope_add_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_scope_add_symbol", scanner, scope_id, symbol, value);
            }
            mh$.invokeExact(scanner, scope_id, symbol, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_scope_remove_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_scope_remove_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_remove_symbol(GScanner *scanner, guint scope_id, const gchar *symbol)
     * }
     */
    public static FunctionDescriptor g_scanner_scope_remove_symbol$descriptor() {
        return g_scanner_scope_remove_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_remove_symbol(GScanner *scanner, guint scope_id, const gchar *symbol)
     * }
     */
    public static MethodHandle g_scanner_scope_remove_symbol$handle() {
        return g_scanner_scope_remove_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_remove_symbol(GScanner *scanner, guint scope_id, const gchar *symbol)
     * }
     */
    public static MemorySegment g_scanner_scope_remove_symbol$address() {
        return g_scanner_scope_remove_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_scanner_scope_remove_symbol(GScanner *scanner, guint scope_id, const gchar *symbol)
     * }
     */
    public static void g_scanner_scope_remove_symbol(MemorySegment scanner, int scope_id, MemorySegment symbol) {
        var mh$ = g_scanner_scope_remove_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_scope_remove_symbol", scanner, scope_id, symbol);
            }
            mh$.invokeExact(scanner, scope_id, symbol);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_scope_lookup_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_scope_lookup_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner, guint scope_id, const gchar *symbol)
     * }
     */
    public static FunctionDescriptor g_scanner_scope_lookup_symbol$descriptor() {
        return g_scanner_scope_lookup_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner, guint scope_id, const gchar *symbol)
     * }
     */
    public static MethodHandle g_scanner_scope_lookup_symbol$handle() {
        return g_scanner_scope_lookup_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner, guint scope_id, const gchar *symbol)
     * }
     */
    public static MemorySegment g_scanner_scope_lookup_symbol$address() {
        return g_scanner_scope_lookup_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner, guint scope_id, const gchar *symbol)
     * }
     */
    public static MemorySegment g_scanner_scope_lookup_symbol(MemorySegment scanner, int scope_id, MemorySegment symbol) {
        var mh$ = g_scanner_scope_lookup_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_scope_lookup_symbol", scanner, scope_id, symbol);
            }
            return (MemorySegment)mh$.invokeExact(scanner, scope_id, symbol);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_scope_foreach_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_scope_foreach_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_foreach_symbol(GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_scanner_scope_foreach_symbol$descriptor() {
        return g_scanner_scope_foreach_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_foreach_symbol(GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_scanner_scope_foreach_symbol$handle() {
        return g_scanner_scope_foreach_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_scanner_scope_foreach_symbol(GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_scanner_scope_foreach_symbol$address() {
        return g_scanner_scope_foreach_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_scanner_scope_foreach_symbol(GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data)
     * }
     */
    public static void g_scanner_scope_foreach_symbol(MemorySegment scanner, int scope_id, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_scanner_scope_foreach_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_scope_foreach_symbol", scanner, scope_id, func, user_data);
            }
            mh$.invokeExact(scanner, scope_id, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_lookup_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_lookup_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_scanner_lookup_symbol(GScanner *scanner, const gchar *symbol)
     * }
     */
    public static FunctionDescriptor g_scanner_lookup_symbol$descriptor() {
        return g_scanner_lookup_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_scanner_lookup_symbol(GScanner *scanner, const gchar *symbol)
     * }
     */
    public static MethodHandle g_scanner_lookup_symbol$handle() {
        return g_scanner_lookup_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_scanner_lookup_symbol(GScanner *scanner, const gchar *symbol)
     * }
     */
    public static MemorySegment g_scanner_lookup_symbol$address() {
        return g_scanner_lookup_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_scanner_lookup_symbol(GScanner *scanner, const gchar *symbol)
     * }
     */
    public static MemorySegment g_scanner_lookup_symbol(MemorySegment scanner, MemorySegment symbol) {
        var mh$ = g_scanner_lookup_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_lookup_symbol", scanner, symbol);
            }
            return (MemorySegment)mh$.invokeExact(scanner, symbol);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_scanner_unexp_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_unexp_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_scanner_unexp_token(GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error)
     * }
     */
    public static FunctionDescriptor g_scanner_unexp_token$descriptor() {
        return g_scanner_unexp_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_scanner_unexp_token(GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error)
     * }
     */
    public static MethodHandle g_scanner_unexp_token$handle() {
        return g_scanner_unexp_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_scanner_unexp_token(GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error)
     * }
     */
    public static MemorySegment g_scanner_unexp_token$address() {
        return g_scanner_unexp_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_scanner_unexp_token(GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error)
     * }
     */
    public static void g_scanner_unexp_token(MemorySegment scanner, int expected_token, MemorySegment identifier_spec, MemorySegment symbol_spec, MemorySegment symbol_name, MemorySegment message, int is_error) {
        var mh$ = g_scanner_unexp_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_scanner_unexp_token", scanner, expected_token, identifier_spec, symbol_spec, symbol_name, message, is_error);
            }
            mh$.invokeExact(scanner, expected_token, identifier_spec, symbol_spec, symbol_name, message, is_error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_scanner_error(GScanner *scanner, const gchar *format, ...)
     * }
     */
    public static class g_scanner_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_scanner_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_scanner_error(GScanner *scanner, const gchar *format, ...)
         * }
         */
        public static g_scanner_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_scanner_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment scanner, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_scanner_error", scanner, format, x2);
                }
                 spreader.invokeExact(scanner, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_scanner_warn(GScanner *scanner, const gchar *format, ...)
     * }
     */
    public static class g_scanner_warn {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER,
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_scanner_warn");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_scanner_warn(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_scanner_warn(GScanner *scanner, const gchar *format, ...)
         * }
         */
        public static g_scanner_warn makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_scanner_warn(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment scanner, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_scanner_warn", scanner, format, x2);
                }
                 spreader.invokeExact(scanner, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_sequence_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequence *g_sequence_new(GDestroyNotify data_destroy)
     * }
     */
    public static FunctionDescriptor g_sequence_new$descriptor() {
        return g_sequence_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequence *g_sequence_new(GDestroyNotify data_destroy)
     * }
     */
    public static MethodHandle g_sequence_new$handle() {
        return g_sequence_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequence *g_sequence_new(GDestroyNotify data_destroy)
     * }
     */
    public static MemorySegment g_sequence_new$address() {
        return g_sequence_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequence *g_sequence_new(GDestroyNotify data_destroy)
     * }
     */
    public static MemorySegment g_sequence_new(MemorySegment data_destroy) {
        var mh$ = g_sequence_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_new", data_destroy);
            }
            return (MemorySegment)mh$.invokeExact(data_destroy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_free(GSequence *seq)
     * }
     */
    public static FunctionDescriptor g_sequence_free$descriptor() {
        return g_sequence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_free(GSequence *seq)
     * }
     */
    public static MethodHandle g_sequence_free$handle() {
        return g_sequence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_free(GSequence *seq)
     * }
     */
    public static MemorySegment g_sequence_free$address() {
        return g_sequence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_free(GSequence *seq)
     * }
     */
    public static void g_sequence_free(MemorySegment seq) {
        var mh$ = g_sequence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_free", seq);
            }
            mh$.invokeExact(seq);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_get_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_get_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_sequence_get_length(GSequence *seq)
     * }
     */
    public static FunctionDescriptor g_sequence_get_length$descriptor() {
        return g_sequence_get_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_sequence_get_length(GSequence *seq)
     * }
     */
    public static MethodHandle g_sequence_get_length$handle() {
        return g_sequence_get_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_sequence_get_length(GSequence *seq)
     * }
     */
    public static MemorySegment g_sequence_get_length$address() {
        return g_sequence_get_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_sequence_get_length(GSequence *seq)
     * }
     */
    public static int g_sequence_get_length(MemorySegment seq) {
        var mh$ = g_sequence_get_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_get_length", seq);
            }
            return (int)mh$.invokeExact(seq);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_foreach(GSequence *seq, GFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_sequence_foreach$descriptor() {
        return g_sequence_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_foreach(GSequence *seq, GFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_sequence_foreach$handle() {
        return g_sequence_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_foreach(GSequence *seq, GFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_sequence_foreach$address() {
        return g_sequence_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_foreach(GSequence *seq, GFunc func, gpointer user_data)
     * }
     */
    public static void g_sequence_foreach(MemorySegment seq, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_sequence_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_foreach", seq, func, user_data);
            }
            mh$.invokeExact(seq, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_foreach_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_foreach_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_foreach_range(GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data)
     * }
     */
    public static FunctionDescriptor g_sequence_foreach_range$descriptor() {
        return g_sequence_foreach_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_foreach_range(GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data)
     * }
     */
    public static MethodHandle g_sequence_foreach_range$handle() {
        return g_sequence_foreach_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_foreach_range(GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data)
     * }
     */
    public static MemorySegment g_sequence_foreach_range$address() {
        return g_sequence_foreach_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_foreach_range(GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data)
     * }
     */
    public static void g_sequence_foreach_range(MemorySegment begin, MemorySegment end, MemorySegment func, MemorySegment user_data) {
        var mh$ = g_sequence_foreach_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_foreach_range", begin, end, func, user_data);
            }
            mh$.invokeExact(begin, end, func, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_sort(GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_sort$descriptor() {
        return g_sequence_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_sort(GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_sort$handle() {
        return g_sequence_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_sort(GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_sort$address() {
        return g_sequence_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_sort(GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static void g_sequence_sort(MemorySegment seq, MemorySegment cmp_func, MemorySegment cmp_data) {
        var mh$ = g_sequence_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_sort", seq, cmp_func, cmp_data);
            }
            mh$.invokeExact(seq, cmp_func, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_sort_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_sort_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_iter(GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_sort_iter$descriptor() {
        return g_sequence_sort_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_iter(GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_sort_iter$handle() {
        return g_sequence_sort_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_iter(GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_sort_iter$address() {
        return g_sequence_sort_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_sort_iter(GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static void g_sequence_sort_iter(MemorySegment seq, MemorySegment cmp_func, MemorySegment cmp_data) {
        var mh$ = g_sequence_sort_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_sort_iter", seq, cmp_func, cmp_data);
            }
            mh$.invokeExact(seq, cmp_func, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_is_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_is_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_is_empty(GSequence *seq)
     * }
     */
    public static FunctionDescriptor g_sequence_is_empty$descriptor() {
        return g_sequence_is_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_is_empty(GSequence *seq)
     * }
     */
    public static MethodHandle g_sequence_is_empty$handle() {
        return g_sequence_is_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_is_empty(GSequence *seq)
     * }
     */
    public static MemorySegment g_sequence_is_empty$address() {
        return g_sequence_is_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_sequence_is_empty(GSequence *seq)
     * }
     */
    public static int g_sequence_is_empty(MemorySegment seq) {
        var mh$ = g_sequence_is_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_is_empty", seq);
            }
            return (int)mh$.invokeExact(seq);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_get_begin_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_get_begin_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq)
     * }
     */
    public static FunctionDescriptor g_sequence_get_begin_iter$descriptor() {
        return g_sequence_get_begin_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq)
     * }
     */
    public static MethodHandle g_sequence_get_begin_iter$handle() {
        return g_sequence_get_begin_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq)
     * }
     */
    public static MemorySegment g_sequence_get_begin_iter$address() {
        return g_sequence_get_begin_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq)
     * }
     */
    public static MemorySegment g_sequence_get_begin_iter(MemorySegment seq) {
        var mh$ = g_sequence_get_begin_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_get_begin_iter", seq);
            }
            return (MemorySegment)mh$.invokeExact(seq);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_get_end_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_get_end_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq)
     * }
     */
    public static FunctionDescriptor g_sequence_get_end_iter$descriptor() {
        return g_sequence_get_end_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq)
     * }
     */
    public static MethodHandle g_sequence_get_end_iter$handle() {
        return g_sequence_get_end_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq)
     * }
     */
    public static MemorySegment g_sequence_get_end_iter$address() {
        return g_sequence_get_end_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq)
     * }
     */
    public static MemorySegment g_sequence_get_end_iter(MemorySegment seq) {
        var mh$ = g_sequence_get_end_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_get_end_iter", seq);
            }
            return (MemorySegment)mh$.invokeExact(seq);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_get_iter_at_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_get_iter_at_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq, gint pos)
     * }
     */
    public static FunctionDescriptor g_sequence_get_iter_at_pos$descriptor() {
        return g_sequence_get_iter_at_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq, gint pos)
     * }
     */
    public static MethodHandle g_sequence_get_iter_at_pos$handle() {
        return g_sequence_get_iter_at_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq, gint pos)
     * }
     */
    public static MemorySegment g_sequence_get_iter_at_pos$address() {
        return g_sequence_get_iter_at_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq, gint pos)
     * }
     */
    public static MemorySegment g_sequence_get_iter_at_pos(MemorySegment seq, int pos) {
        var mh$ = g_sequence_get_iter_at_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_get_iter_at_pos", seq, pos);
            }
            return (MemorySegment)mh$.invokeExact(seq, pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_append(GSequence *seq, gpointer data)
     * }
     */
    public static FunctionDescriptor g_sequence_append$descriptor() {
        return g_sequence_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_append(GSequence *seq, gpointer data)
     * }
     */
    public static MethodHandle g_sequence_append$handle() {
        return g_sequence_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_append(GSequence *seq, gpointer data)
     * }
     */
    public static MemorySegment g_sequence_append$address() {
        return g_sequence_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_append(GSequence *seq, gpointer data)
     * }
     */
    public static MemorySegment g_sequence_append(MemorySegment seq, MemorySegment data) {
        var mh$ = g_sequence_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_append", seq, data);
            }
            return (MemorySegment)mh$.invokeExact(seq, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_prepend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_prepend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_prepend(GSequence *seq, gpointer data)
     * }
     */
    public static FunctionDescriptor g_sequence_prepend$descriptor() {
        return g_sequence_prepend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_prepend(GSequence *seq, gpointer data)
     * }
     */
    public static MethodHandle g_sequence_prepend$handle() {
        return g_sequence_prepend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_prepend(GSequence *seq, gpointer data)
     * }
     */
    public static MemorySegment g_sequence_prepend$address() {
        return g_sequence_prepend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_prepend(GSequence *seq, gpointer data)
     * }
     */
    public static MemorySegment g_sequence_prepend(MemorySegment seq, MemorySegment data) {
        var mh$ = g_sequence_prepend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_prepend", seq, data);
            }
            return (MemorySegment)mh$.invokeExact(seq, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_insert_before {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_insert_before");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter, gpointer data)
     * }
     */
    public static FunctionDescriptor g_sequence_insert_before$descriptor() {
        return g_sequence_insert_before.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter, gpointer data)
     * }
     */
    public static MethodHandle g_sequence_insert_before$handle() {
        return g_sequence_insert_before.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter, gpointer data)
     * }
     */
    public static MemorySegment g_sequence_insert_before$address() {
        return g_sequence_insert_before.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter, gpointer data)
     * }
     */
    public static MemorySegment g_sequence_insert_before(MemorySegment iter, MemorySegment data) {
        var mh$ = g_sequence_insert_before.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_insert_before", iter, data);
            }
            return (MemorySegment)mh$.invokeExact(iter, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_move {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_move");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_move(GSequenceIter *src, GSequenceIter *dest)
     * }
     */
    public static FunctionDescriptor g_sequence_move$descriptor() {
        return g_sequence_move.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_move(GSequenceIter *src, GSequenceIter *dest)
     * }
     */
    public static MethodHandle g_sequence_move$handle() {
        return g_sequence_move.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_move(GSequenceIter *src, GSequenceIter *dest)
     * }
     */
    public static MemorySegment g_sequence_move$address() {
        return g_sequence_move.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_move(GSequenceIter *src, GSequenceIter *dest)
     * }
     */
    public static void g_sequence_move(MemorySegment src, MemorySegment dest) {
        var mh$ = g_sequence_move.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_move", src, dest);
            }
            mh$.invokeExact(src, dest);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_swap(GSequenceIter *a, GSequenceIter *b)
     * }
     */
    public static FunctionDescriptor g_sequence_swap$descriptor() {
        return g_sequence_swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_swap(GSequenceIter *a, GSequenceIter *b)
     * }
     */
    public static MethodHandle g_sequence_swap$handle() {
        return g_sequence_swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_swap(GSequenceIter *a, GSequenceIter *b)
     * }
     */
    public static MemorySegment g_sequence_swap$address() {
        return g_sequence_swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_swap(GSequenceIter *a, GSequenceIter *b)
     * }
     */
    public static void g_sequence_swap(MemorySegment a, MemorySegment b) {
        var mh$ = g_sequence_swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_swap", a, b);
            }
            mh$.invokeExact(a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_insert_sorted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_insert_sorted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_insert_sorted$descriptor() {
        return g_sequence_insert_sorted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_insert_sorted$handle() {
        return g_sequence_insert_sorted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_insert_sorted$address() {
        return g_sequence_insert_sorted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_insert_sorted(MemorySegment seq, MemorySegment data, MemorySegment cmp_func, MemorySegment cmp_data) {
        var mh$ = g_sequence_insert_sorted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_insert_sorted", seq, data, cmp_func, cmp_data);
            }
            return (MemorySegment)mh$.invokeExact(seq, data, cmp_func, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_insert_sorted_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_insert_sorted_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_insert_sorted_iter$descriptor() {
        return g_sequence_insert_sorted_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_insert_sorted_iter$handle() {
        return g_sequence_insert_sorted_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_insert_sorted_iter$address() {
        return g_sequence_insert_sorted_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_insert_sorted_iter(MemorySegment seq, MemorySegment data, MemorySegment iter_cmp, MemorySegment cmp_data) {
        var mh$ = g_sequence_insert_sorted_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_insert_sorted_iter", seq, data, iter_cmp, cmp_data);
            }
            return (MemorySegment)mh$.invokeExact(seq, data, iter_cmp, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_sort_changed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_sort_changed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_changed(GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_sort_changed$descriptor() {
        return g_sequence_sort_changed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_changed(GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_sort_changed$handle() {
        return g_sequence_sort_changed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_changed(GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_sort_changed$address() {
        return g_sequence_sort_changed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_sort_changed(GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static void g_sequence_sort_changed(MemorySegment iter, MemorySegment cmp_func, MemorySegment cmp_data) {
        var mh$ = g_sequence_sort_changed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_sort_changed", iter, cmp_func, cmp_data);
            }
            mh$.invokeExact(iter, cmp_func, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_sort_changed_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_sort_changed_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_changed_iter(GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_sort_changed_iter$descriptor() {
        return g_sequence_sort_changed_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_changed_iter(GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_sort_changed_iter$handle() {
        return g_sequence_sort_changed_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_sort_changed_iter(GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_sort_changed_iter$address() {
        return g_sequence_sort_changed_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_sort_changed_iter(GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static void g_sequence_sort_changed_iter(MemorySegment iter, MemorySegment iter_cmp, MemorySegment cmp_data) {
        var mh$ = g_sequence_sort_changed_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_sort_changed_iter", iter, iter_cmp, cmp_data);
            }
            mh$.invokeExact(iter, iter_cmp, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_remove(GSequenceIter *iter)
     * }
     */
    public static FunctionDescriptor g_sequence_remove$descriptor() {
        return g_sequence_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_remove(GSequenceIter *iter)
     * }
     */
    public static MethodHandle g_sequence_remove$handle() {
        return g_sequence_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_remove(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_remove$address() {
        return g_sequence_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_remove(GSequenceIter *iter)
     * }
     */
    public static void g_sequence_remove(MemorySegment iter) {
        var mh$ = g_sequence_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_remove", iter);
            }
            mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_remove_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_remove_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_remove_range(GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static FunctionDescriptor g_sequence_remove_range$descriptor() {
        return g_sequence_remove_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_remove_range(GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static MethodHandle g_sequence_remove_range$handle() {
        return g_sequence_remove_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_remove_range(GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static MemorySegment g_sequence_remove_range$address() {
        return g_sequence_remove_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_remove_range(GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static void g_sequence_remove_range(MemorySegment begin, MemorySegment end) {
        var mh$ = g_sequence_remove_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_remove_range", begin, end);
            }
            mh$.invokeExact(begin, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_move_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_move_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_move_range(GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static FunctionDescriptor g_sequence_move_range$descriptor() {
        return g_sequence_move_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_move_range(GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static MethodHandle g_sequence_move_range$handle() {
        return g_sequence_move_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_move_range(GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static MemorySegment g_sequence_move_range$address() {
        return g_sequence_move_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_move_range(GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static void g_sequence_move_range(MemorySegment dest, MemorySegment begin, MemorySegment end) {
        var mh$ = g_sequence_move_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_move_range", dest, begin, end);
            }
            mh$.invokeExact(dest, begin, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_search {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_search");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_search(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_search$descriptor() {
        return g_sequence_search.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_search(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_search$handle() {
        return g_sequence_search.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_search(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_search$address() {
        return g_sequence_search.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_search(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_search(MemorySegment seq, MemorySegment data, MemorySegment cmp_func, MemorySegment cmp_data) {
        var mh$ = g_sequence_search.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_search", seq, data, cmp_func, cmp_data);
            }
            return (MemorySegment)mh$.invokeExact(seq, data, cmp_func, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_search_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_search_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_search_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_search_iter$descriptor() {
        return g_sequence_search_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_search_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_search_iter$handle() {
        return g_sequence_search_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_search_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_search_iter$address() {
        return g_sequence_search_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_search_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_search_iter(MemorySegment seq, MemorySegment data, MemorySegment iter_cmp, MemorySegment cmp_data) {
        var mh$ = g_sequence_search_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_search_iter", seq, data, iter_cmp, cmp_data);
            }
            return (MemorySegment)mh$.invokeExact(seq, data, iter_cmp, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_lookup(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_lookup$descriptor() {
        return g_sequence_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_lookup(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_lookup$handle() {
        return g_sequence_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_lookup(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_lookup$address() {
        return g_sequence_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_lookup(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_lookup(MemorySegment seq, MemorySegment data, MemorySegment cmp_func, MemorySegment cmp_data) {
        var mh$ = g_sequence_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_lookup", seq, data, cmp_func, cmp_data);
            }
            return (MemorySegment)mh$.invokeExact(seq, data, cmp_func, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_lookup_iter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_lookup_iter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static FunctionDescriptor g_sequence_lookup_iter$descriptor() {
        return g_sequence_lookup_iter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MethodHandle g_sequence_lookup_iter$handle() {
        return g_sequence_lookup_iter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_lookup_iter$address() {
        return g_sequence_lookup_iter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data)
     * }
     */
    public static MemorySegment g_sequence_lookup_iter(MemorySegment seq, MemorySegment data, MemorySegment iter_cmp, MemorySegment cmp_data) {
        var mh$ = g_sequence_lookup_iter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_lookup_iter", seq, data, iter_cmp, cmp_data);
            }
            return (MemorySegment)mh$.invokeExact(seq, data, iter_cmp, cmp_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_sequence_get(GSequenceIter *iter)
     * }
     */
    public static FunctionDescriptor g_sequence_get$descriptor() {
        return g_sequence_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_sequence_get(GSequenceIter *iter)
     * }
     */
    public static MethodHandle g_sequence_get$handle() {
        return g_sequence_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_sequence_get(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_get$address() {
        return g_sequence_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_sequence_get(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_get(MemorySegment iter) {
        var mh$ = g_sequence_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_get", iter);
            }
            return (MemorySegment)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_sequence_set(GSequenceIter *iter, gpointer data)
     * }
     */
    public static FunctionDescriptor g_sequence_set$descriptor() {
        return g_sequence_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_sequence_set(GSequenceIter *iter, gpointer data)
     * }
     */
    public static MethodHandle g_sequence_set$handle() {
        return g_sequence_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_sequence_set(GSequenceIter *iter, gpointer data)
     * }
     */
    public static MemorySegment g_sequence_set$address() {
        return g_sequence_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_sequence_set(GSequenceIter *iter, gpointer data)
     * }
     */
    public static void g_sequence_set(MemorySegment iter, MemorySegment data) {
        var mh$ = g_sequence_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_set", iter, data);
            }
            mh$.invokeExact(iter, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_iter_is_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_iter_is_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter)
     * }
     */
    public static FunctionDescriptor g_sequence_iter_is_begin$descriptor() {
        return g_sequence_iter_is_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter)
     * }
     */
    public static MethodHandle g_sequence_iter_is_begin$handle() {
        return g_sequence_iter_is_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_is_begin$address() {
        return g_sequence_iter_is_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter)
     * }
     */
    public static int g_sequence_iter_is_begin(MemorySegment iter) {
        var mh$ = g_sequence_iter_is_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_iter_is_begin", iter);
            }
            return (int)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_iter_is_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_iter_is_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_iter_is_end(GSequenceIter *iter)
     * }
     */
    public static FunctionDescriptor g_sequence_iter_is_end$descriptor() {
        return g_sequence_iter_is_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_iter_is_end(GSequenceIter *iter)
     * }
     */
    public static MethodHandle g_sequence_iter_is_end$handle() {
        return g_sequence_iter_is_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_sequence_iter_is_end(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_is_end$address() {
        return g_sequence_iter_is_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_sequence_iter_is_end(GSequenceIter *iter)
     * }
     */
    public static int g_sequence_iter_is_end(MemorySegment iter) {
        var mh$ = g_sequence_iter_is_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_iter_is_end", iter);
            }
            return (int)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_iter_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_iter_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter)
     * }
     */
    public static FunctionDescriptor g_sequence_iter_next$descriptor() {
        return g_sequence_iter_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter)
     * }
     */
    public static MethodHandle g_sequence_iter_next$handle() {
        return g_sequence_iter_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_next$address() {
        return g_sequence_iter_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_next(MemorySegment iter) {
        var mh$ = g_sequence_iter_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_iter_next", iter);
            }
            return (MemorySegment)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_iter_prev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_iter_prev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter)
     * }
     */
    public static FunctionDescriptor g_sequence_iter_prev$descriptor() {
        return g_sequence_iter_prev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter)
     * }
     */
    public static MethodHandle g_sequence_iter_prev$handle() {
        return g_sequence_iter_prev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_prev$address() {
        return g_sequence_iter_prev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_prev(MemorySegment iter) {
        var mh$ = g_sequence_iter_prev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_iter_prev", iter);
            }
            return (MemorySegment)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_iter_get_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_iter_get_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_sequence_iter_get_position(GSequenceIter *iter)
     * }
     */
    public static FunctionDescriptor g_sequence_iter_get_position$descriptor() {
        return g_sequence_iter_get_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_sequence_iter_get_position(GSequenceIter *iter)
     * }
     */
    public static MethodHandle g_sequence_iter_get_position$handle() {
        return g_sequence_iter_get_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_sequence_iter_get_position(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_get_position$address() {
        return g_sequence_iter_get_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_sequence_iter_get_position(GSequenceIter *iter)
     * }
     */
    public static int g_sequence_iter_get_position(MemorySegment iter) {
        var mh$ = g_sequence_iter_get_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_iter_get_position", iter);
            }
            return (int)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_iter_move {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_iter_move");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter, gint delta)
     * }
     */
    public static FunctionDescriptor g_sequence_iter_move$descriptor() {
        return g_sequence_iter_move.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter, gint delta)
     * }
     */
    public static MethodHandle g_sequence_iter_move$handle() {
        return g_sequence_iter_move.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter, gint delta)
     * }
     */
    public static MemorySegment g_sequence_iter_move$address() {
        return g_sequence_iter_move.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter, gint delta)
     * }
     */
    public static MemorySegment g_sequence_iter_move(MemorySegment iter, int delta) {
        var mh$ = g_sequence_iter_move.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_iter_move", iter, delta);
            }
            return (MemorySegment)mh$.invokeExact(iter, delta);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_iter_get_sequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_iter_get_sequence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter)
     * }
     */
    public static FunctionDescriptor g_sequence_iter_get_sequence$descriptor() {
        return g_sequence_iter_get_sequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter)
     * }
     */
    public static MethodHandle g_sequence_iter_get_sequence$handle() {
        return g_sequence_iter_get_sequence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_get_sequence$address() {
        return g_sequence_iter_get_sequence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter)
     * }
     */
    public static MemorySegment g_sequence_iter_get_sequence(MemorySegment iter) {
        var mh$ = g_sequence_iter_get_sequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_iter_get_sequence", iter);
            }
            return (MemorySegment)mh$.invokeExact(iter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_iter_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_iter_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint g_sequence_iter_compare(GSequenceIter *a, GSequenceIter *b)
     * }
     */
    public static FunctionDescriptor g_sequence_iter_compare$descriptor() {
        return g_sequence_iter_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint g_sequence_iter_compare(GSequenceIter *a, GSequenceIter *b)
     * }
     */
    public static MethodHandle g_sequence_iter_compare$handle() {
        return g_sequence_iter_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint g_sequence_iter_compare(GSequenceIter *a, GSequenceIter *b)
     * }
     */
    public static MemorySegment g_sequence_iter_compare$address() {
        return g_sequence_iter_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint g_sequence_iter_compare(GSequenceIter *a, GSequenceIter *b)
     * }
     */
    public static int g_sequence_iter_compare(MemorySegment a, MemorySegment b) {
        var mh$ = g_sequence_iter_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_iter_compare", a, b);
            }
            return (int)mh$.invokeExact(a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_sequence_range_get_midpoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_sequence_range_get_midpoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static FunctionDescriptor g_sequence_range_get_midpoint$descriptor() {
        return g_sequence_range_get_midpoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static MethodHandle g_sequence_range_get_midpoint$handle() {
        return g_sequence_range_get_midpoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static MemorySegment g_sequence_range_get_midpoint$address() {
        return g_sequence_range_get_midpoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin, GSequenceIter *end)
     * }
     */
    public static MemorySegment g_sequence_range_get_midpoint(MemorySegment begin, MemorySegment end) {
        var mh$ = g_sequence_range_get_midpoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_sequence_range_get_midpoint", begin, end);
            }
            return (MemorySegment)mh$.invokeExact(begin, end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_SHELL_ERROR_BAD_QUOTING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SHELL_ERROR_BAD_QUOTING = 0
     * }
     */
    public static int G_SHELL_ERROR_BAD_QUOTING() {
        return G_SHELL_ERROR_BAD_QUOTING;
    }
    private static final int G_SHELL_ERROR_EMPTY_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SHELL_ERROR_EMPTY_STRING = 1
     * }
     */
    public static int G_SHELL_ERROR_EMPTY_STRING() {
        return G_SHELL_ERROR_EMPTY_STRING;
    }
    private static final int G_SHELL_ERROR_FAILED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SHELL_ERROR_FAILED = 2
     * }
     */
    public static int G_SHELL_ERROR_FAILED() {
        return G_SHELL_ERROR_FAILED;
    }

    private static class g_shell_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_shell_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_shell_error_quark()
     * }
     */
    public static FunctionDescriptor g_shell_error_quark$descriptor() {
        return g_shell_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_shell_error_quark()
     * }
     */
    public static MethodHandle g_shell_error_quark$handle() {
        return g_shell_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_shell_error_quark()
     * }
     */
    public static MemorySegment g_shell_error_quark$address() {
        return g_shell_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_shell_error_quark()
     * }
     */
    public static int g_shell_error_quark() {
        var mh$ = g_shell_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_shell_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_shell_quote {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_shell_quote");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_shell_quote(const gchar *unquoted_string)
     * }
     */
    public static FunctionDescriptor g_shell_quote$descriptor() {
        return g_shell_quote.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_shell_quote(const gchar *unquoted_string)
     * }
     */
    public static MethodHandle g_shell_quote$handle() {
        return g_shell_quote.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_shell_quote(const gchar *unquoted_string)
     * }
     */
    public static MemorySegment g_shell_quote$address() {
        return g_shell_quote.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_shell_quote(const gchar *unquoted_string)
     * }
     */
    public static MemorySegment g_shell_quote(MemorySegment unquoted_string) {
        var mh$ = g_shell_quote.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_shell_quote", unquoted_string);
            }
            return (MemorySegment)mh$.invokeExact(unquoted_string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_shell_unquote {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_shell_unquote");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_shell_unquote(const gchar *quoted_string, GError **error)
     * }
     */
    public static FunctionDescriptor g_shell_unquote$descriptor() {
        return g_shell_unquote.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_shell_unquote(const gchar *quoted_string, GError **error)
     * }
     */
    public static MethodHandle g_shell_unquote$handle() {
        return g_shell_unquote.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_shell_unquote(const gchar *quoted_string, GError **error)
     * }
     */
    public static MemorySegment g_shell_unquote$address() {
        return g_shell_unquote.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_shell_unquote(const gchar *quoted_string, GError **error)
     * }
     */
    public static MemorySegment g_shell_unquote(MemorySegment quoted_string, MemorySegment error) {
        var mh$ = g_shell_unquote.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_shell_unquote", quoted_string, error);
            }
            return (MemorySegment)mh$.invokeExact(quoted_string, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_shell_parse_argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_shell_parse_argv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_shell_parse_argv(const gchar *command_line, gint *argcp, gchar ***argvp, GError **error)
     * }
     */
    public static FunctionDescriptor g_shell_parse_argv$descriptor() {
        return g_shell_parse_argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_shell_parse_argv(const gchar *command_line, gint *argcp, gchar ***argvp, GError **error)
     * }
     */
    public static MethodHandle g_shell_parse_argv$handle() {
        return g_shell_parse_argv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_shell_parse_argv(const gchar *command_line, gint *argcp, gchar ***argvp, GError **error)
     * }
     */
    public static MemorySegment g_shell_parse_argv$address() {
        return g_shell_parse_argv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_shell_parse_argv(const gchar *command_line, gint *argcp, gchar ***argvp, GError **error)
     * }
     */
    public static int g_shell_parse_argv(MemorySegment command_line, MemorySegment argcp, MemorySegment argvp, MemorySegment error) {
        var mh$ = g_shell_parse_argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_shell_parse_argv", command_line, argcp, argvp, error);
            }
            return (int)mh$.invokeExact(command_line, argcp, argvp, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slice_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slice_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_slice_alloc(gsize block_size)
     * }
     */
    public static FunctionDescriptor g_slice_alloc$descriptor() {
        return g_slice_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_slice_alloc(gsize block_size)
     * }
     */
    public static MethodHandle g_slice_alloc$handle() {
        return g_slice_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_slice_alloc(gsize block_size)
     * }
     */
    public static MemorySegment g_slice_alloc$address() {
        return g_slice_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_slice_alloc(gsize block_size)
     * }
     */
    public static MemorySegment g_slice_alloc(long block_size) {
        var mh$ = g_slice_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slice_alloc", block_size);
            }
            return (MemorySegment)mh$.invokeExact(block_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slice_alloc0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slice_alloc0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_slice_alloc0(gsize block_size)
     * }
     */
    public static FunctionDescriptor g_slice_alloc0$descriptor() {
        return g_slice_alloc0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_slice_alloc0(gsize block_size)
     * }
     */
    public static MethodHandle g_slice_alloc0$handle() {
        return g_slice_alloc0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_slice_alloc0(gsize block_size)
     * }
     */
    public static MemorySegment g_slice_alloc0$address() {
        return g_slice_alloc0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_slice_alloc0(gsize block_size)
     * }
     */
    public static MemorySegment g_slice_alloc0(long block_size) {
        var mh$ = g_slice_alloc0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slice_alloc0", block_size);
            }
            return (MemorySegment)mh$.invokeExact(block_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slice_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slice_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gpointer g_slice_copy(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_slice_copy$descriptor() {
        return g_slice_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gpointer g_slice_copy(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MethodHandle g_slice_copy$handle() {
        return g_slice_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gpointer g_slice_copy(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MemorySegment g_slice_copy$address() {
        return g_slice_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gpointer g_slice_copy(gsize block_size, gconstpointer mem_block)
     * }
     */
    public static MemorySegment g_slice_copy(long block_size, MemorySegment mem_block) {
        var mh$ = g_slice_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slice_copy", block_size, mem_block);
            }
            return (MemorySegment)mh$.invokeExact(block_size, mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slice_free1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slice_free1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slice_free1(gsize block_size, gpointer mem_block)
     * }
     */
    public static FunctionDescriptor g_slice_free1$descriptor() {
        return g_slice_free1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slice_free1(gsize block_size, gpointer mem_block)
     * }
     */
    public static MethodHandle g_slice_free1$handle() {
        return g_slice_free1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slice_free1(gsize block_size, gpointer mem_block)
     * }
     */
    public static MemorySegment g_slice_free1$address() {
        return g_slice_free1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slice_free1(gsize block_size, gpointer mem_block)
     * }
     */
    public static void g_slice_free1(long block_size, MemorySegment mem_block) {
        var mh$ = g_slice_free1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slice_free1", block_size, mem_block);
            }
            mh$.invokeExact(block_size, mem_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slice_free_chain_with_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slice_free_chain_with_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slice_free_chain_with_offset(gsize block_size, gpointer mem_chain, gsize next_offset)
     * }
     */
    public static FunctionDescriptor g_slice_free_chain_with_offset$descriptor() {
        return g_slice_free_chain_with_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slice_free_chain_with_offset(gsize block_size, gpointer mem_chain, gsize next_offset)
     * }
     */
    public static MethodHandle g_slice_free_chain_with_offset$handle() {
        return g_slice_free_chain_with_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slice_free_chain_with_offset(gsize block_size, gpointer mem_chain, gsize next_offset)
     * }
     */
    public static MemorySegment g_slice_free_chain_with_offset$address() {
        return g_slice_free_chain_with_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slice_free_chain_with_offset(gsize block_size, gpointer mem_chain, gsize next_offset)
     * }
     */
    public static void g_slice_free_chain_with_offset(long block_size, MemorySegment mem_chain, long next_offset) {
        var mh$ = g_slice_free_chain_with_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slice_free_chain_with_offset", block_size, mem_chain, next_offset);
            }
            mh$.invokeExact(block_size, mem_chain, next_offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_SLICE_CONFIG_ALWAYS_MALLOC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SLICE_CONFIG_ALWAYS_MALLOC = 1
     * }
     */
    public static int G_SLICE_CONFIG_ALWAYS_MALLOC() {
        return G_SLICE_CONFIG_ALWAYS_MALLOC;
    }
    private static final int G_SLICE_CONFIG_BYPASS_MAGAZINES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SLICE_CONFIG_BYPASS_MAGAZINES = 2
     * }
     */
    public static int G_SLICE_CONFIG_BYPASS_MAGAZINES() {
        return G_SLICE_CONFIG_BYPASS_MAGAZINES;
    }
    private static final int G_SLICE_CONFIG_WORKING_SET_MSECS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SLICE_CONFIG_WORKING_SET_MSECS = 3
     * }
     */
    public static int G_SLICE_CONFIG_WORKING_SET_MSECS() {
        return G_SLICE_CONFIG_WORKING_SET_MSECS;
    }
    private static final int G_SLICE_CONFIG_COLOR_INCREMENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SLICE_CONFIG_COLOR_INCREMENT = 4
     * }
     */
    public static int G_SLICE_CONFIG_COLOR_INCREMENT() {
        return G_SLICE_CONFIG_COLOR_INCREMENT;
    }
    private static final int G_SLICE_CONFIG_CHUNK_SIZES = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SLICE_CONFIG_CHUNK_SIZES = 5
     * }
     */
    public static int G_SLICE_CONFIG_CHUNK_SIZES() {
        return G_SLICE_CONFIG_CHUNK_SIZES;
    }
    private static final int G_SLICE_CONFIG_CONTENTION_COUNTER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SLICE_CONFIG_CONTENTION_COUNTER = 6
     * }
     */
    public static int G_SLICE_CONFIG_CONTENTION_COUNTER() {
        return G_SLICE_CONFIG_CONTENTION_COUNTER;
    }

    private static class g_slice_set_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slice_set_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_slice_set_config(GSliceConfig ckey, gint64 value)
     * }
     */
    public static FunctionDescriptor g_slice_set_config$descriptor() {
        return g_slice_set_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_slice_set_config(GSliceConfig ckey, gint64 value)
     * }
     */
    public static MethodHandle g_slice_set_config$handle() {
        return g_slice_set_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_slice_set_config(GSliceConfig ckey, gint64 value)
     * }
     */
    public static MemorySegment g_slice_set_config$address() {
        return g_slice_set_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_slice_set_config(GSliceConfig ckey, gint64 value)
     * }
     */
    public static void g_slice_set_config(int ckey, long value) {
        var mh$ = g_slice_set_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slice_set_config", ckey, value);
            }
            mh$.invokeExact(ckey, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slice_get_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slice_get_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 g_slice_get_config(GSliceConfig ckey)
     * }
     */
    public static FunctionDescriptor g_slice_get_config$descriptor() {
        return g_slice_get_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 g_slice_get_config(GSliceConfig ckey)
     * }
     */
    public static MethodHandle g_slice_get_config$handle() {
        return g_slice_get_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 g_slice_get_config(GSliceConfig ckey)
     * }
     */
    public static MemorySegment g_slice_get_config$address() {
        return g_slice_get_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 g_slice_get_config(GSliceConfig ckey)
     * }
     */
    public static long g_slice_get_config(int ckey) {
        var mh$ = g_slice_get_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slice_get_config", ckey);
            }
            return (long)mh$.invokeExact(ckey);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_slice_get_config_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_slice_get_config_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gint64 *g_slice_get_config_state(GSliceConfig ckey, gint64 address, guint *n_values)
     * }
     */
    public static FunctionDescriptor g_slice_get_config_state$descriptor() {
        return g_slice_get_config_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gint64 *g_slice_get_config_state(GSliceConfig ckey, gint64 address, guint *n_values)
     * }
     */
    public static MethodHandle g_slice_get_config_state$handle() {
        return g_slice_get_config_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gint64 *g_slice_get_config_state(GSliceConfig ckey, gint64 address, guint *n_values)
     * }
     */
    public static MemorySegment g_slice_get_config_state$address() {
        return g_slice_get_config_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gint64 *g_slice_get_config_state(GSliceConfig ckey, gint64 address, guint *n_values)
     * }
     */
    public static MemorySegment g_slice_get_config_state(int ckey, long address, MemorySegment n_values) {
        var mh$ = g_slice_get_config_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_slice_get_config_state", ckey, address, n_values);
            }
            return (MemorySegment)mh$.invokeExact(ckey, address, n_values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int G_SPAWN_ERROR_FORK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_FORK = 0
     * }
     */
    public static int G_SPAWN_ERROR_FORK() {
        return G_SPAWN_ERROR_FORK;
    }
    private static final int G_SPAWN_ERROR_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_READ = 1
     * }
     */
    public static int G_SPAWN_ERROR_READ() {
        return G_SPAWN_ERROR_READ;
    }
    private static final int G_SPAWN_ERROR_CHDIR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_CHDIR = 2
     * }
     */
    public static int G_SPAWN_ERROR_CHDIR() {
        return G_SPAWN_ERROR_CHDIR;
    }
    private static final int G_SPAWN_ERROR_ACCES = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_ACCES = 3
     * }
     */
    public static int G_SPAWN_ERROR_ACCES() {
        return G_SPAWN_ERROR_ACCES;
    }
    private static final int G_SPAWN_ERROR_PERM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_PERM = 4
     * }
     */
    public static int G_SPAWN_ERROR_PERM() {
        return G_SPAWN_ERROR_PERM;
    }
    private static final int G_SPAWN_ERROR_TOO_BIG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_TOO_BIG = 5
     * }
     */
    public static int G_SPAWN_ERROR_TOO_BIG() {
        return G_SPAWN_ERROR_TOO_BIG;
    }
    private static final int G_SPAWN_ERROR_2BIG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_2BIG = 5
     * }
     */
    public static int G_SPAWN_ERROR_2BIG() {
        return G_SPAWN_ERROR_2BIG;
    }
    private static final int G_SPAWN_ERROR_NOEXEC = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_NOEXEC = 6
     * }
     */
    public static int G_SPAWN_ERROR_NOEXEC() {
        return G_SPAWN_ERROR_NOEXEC;
    }
    private static final int G_SPAWN_ERROR_NAMETOOLONG = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_NAMETOOLONG = 7
     * }
     */
    public static int G_SPAWN_ERROR_NAMETOOLONG() {
        return G_SPAWN_ERROR_NAMETOOLONG;
    }
    private static final int G_SPAWN_ERROR_NOENT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_NOENT = 8
     * }
     */
    public static int G_SPAWN_ERROR_NOENT() {
        return G_SPAWN_ERROR_NOENT;
    }
    private static final int G_SPAWN_ERROR_NOMEM = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_NOMEM = 9
     * }
     */
    public static int G_SPAWN_ERROR_NOMEM() {
        return G_SPAWN_ERROR_NOMEM;
    }
    private static final int G_SPAWN_ERROR_NOTDIR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_NOTDIR = 10
     * }
     */
    public static int G_SPAWN_ERROR_NOTDIR() {
        return G_SPAWN_ERROR_NOTDIR;
    }
    private static final int G_SPAWN_ERROR_LOOP = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_LOOP = 11
     * }
     */
    public static int G_SPAWN_ERROR_LOOP() {
        return G_SPAWN_ERROR_LOOP;
    }
    private static final int G_SPAWN_ERROR_TXTBUSY = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_TXTBUSY = 12
     * }
     */
    public static int G_SPAWN_ERROR_TXTBUSY() {
        return G_SPAWN_ERROR_TXTBUSY;
    }
    private static final int G_SPAWN_ERROR_IO = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_IO = 13
     * }
     */
    public static int G_SPAWN_ERROR_IO() {
        return G_SPAWN_ERROR_IO;
    }
    private static final int G_SPAWN_ERROR_NFILE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_NFILE = 14
     * }
     */
    public static int G_SPAWN_ERROR_NFILE() {
        return G_SPAWN_ERROR_NFILE;
    }
    private static final int G_SPAWN_ERROR_MFILE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_MFILE = 15
     * }
     */
    public static int G_SPAWN_ERROR_MFILE() {
        return G_SPAWN_ERROR_MFILE;
    }
    private static final int G_SPAWN_ERROR_INVAL = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_INVAL = 16
     * }
     */
    public static int G_SPAWN_ERROR_INVAL() {
        return G_SPAWN_ERROR_INVAL;
    }
    private static final int G_SPAWN_ERROR_ISDIR = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_ISDIR = 17
     * }
     */
    public static int G_SPAWN_ERROR_ISDIR() {
        return G_SPAWN_ERROR_ISDIR;
    }
    private static final int G_SPAWN_ERROR_LIBBAD = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_LIBBAD = 18
     * }
     */
    public static int G_SPAWN_ERROR_LIBBAD() {
        return G_SPAWN_ERROR_LIBBAD;
    }
    private static final int G_SPAWN_ERROR_FAILED = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_ERROR_FAILED = 19
     * }
     */
    public static int G_SPAWN_ERROR_FAILED() {
        return G_SPAWN_ERROR_FAILED;
    }
    private static final int G_SPAWN_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_DEFAULT = 0
     * }
     */
    public static int G_SPAWN_DEFAULT() {
        return G_SPAWN_DEFAULT;
    }
    private static final int G_SPAWN_LEAVE_DESCRIPTORS_OPEN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1
     * }
     */
    public static int G_SPAWN_LEAVE_DESCRIPTORS_OPEN() {
        return G_SPAWN_LEAVE_DESCRIPTORS_OPEN;
    }
    private static final int G_SPAWN_DO_NOT_REAP_CHILD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_DO_NOT_REAP_CHILD = 2
     * }
     */
    public static int G_SPAWN_DO_NOT_REAP_CHILD() {
        return G_SPAWN_DO_NOT_REAP_CHILD;
    }
    private static final int G_SPAWN_SEARCH_PATH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_SEARCH_PATH = 4
     * }
     */
    public static int G_SPAWN_SEARCH_PATH() {
        return G_SPAWN_SEARCH_PATH;
    }
    private static final int G_SPAWN_STDOUT_TO_DEV_NULL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_STDOUT_TO_DEV_NULL = 8
     * }
     */
    public static int G_SPAWN_STDOUT_TO_DEV_NULL() {
        return G_SPAWN_STDOUT_TO_DEV_NULL;
    }
    private static final int G_SPAWN_STDERR_TO_DEV_NULL = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_STDERR_TO_DEV_NULL = 16
     * }
     */
    public static int G_SPAWN_STDERR_TO_DEV_NULL() {
        return G_SPAWN_STDERR_TO_DEV_NULL;
    }
    private static final int G_SPAWN_CHILD_INHERITS_STDIN = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_CHILD_INHERITS_STDIN = 32
     * }
     */
    public static int G_SPAWN_CHILD_INHERITS_STDIN() {
        return G_SPAWN_CHILD_INHERITS_STDIN;
    }
    private static final int G_SPAWN_FILE_AND_ARGV_ZERO = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_FILE_AND_ARGV_ZERO = 64
     * }
     */
    public static int G_SPAWN_FILE_AND_ARGV_ZERO() {
        return G_SPAWN_FILE_AND_ARGV_ZERO;
    }
    private static final int G_SPAWN_SEARCH_PATH_FROM_ENVP = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_SEARCH_PATH_FROM_ENVP = 128
     * }
     */
    public static int G_SPAWN_SEARCH_PATH_FROM_ENVP() {
        return G_SPAWN_SEARCH_PATH_FROM_ENVP;
    }
    private static final int G_SPAWN_CLOEXEC_PIPES = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_CLOEXEC_PIPES = 256
     * }
     */
    public static int G_SPAWN_CLOEXEC_PIPES() {
        return G_SPAWN_CLOEXEC_PIPES;
    }
    private static final int G_SPAWN_CHILD_INHERITS_STDOUT = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_CHILD_INHERITS_STDOUT = 512
     * }
     */
    public static int G_SPAWN_CHILD_INHERITS_STDOUT() {
        return G_SPAWN_CHILD_INHERITS_STDOUT;
    }
    private static final int G_SPAWN_CHILD_INHERITS_STDERR = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_CHILD_INHERITS_STDERR = 1024
     * }
     */
    public static int G_SPAWN_CHILD_INHERITS_STDERR() {
        return G_SPAWN_CHILD_INHERITS_STDERR;
    }
    private static final int G_SPAWN_STDIN_FROM_DEV_NULL = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.G_SPAWN_STDIN_FROM_DEV_NULL = 2048
     * }
     */
    public static int G_SPAWN_STDIN_FROM_DEV_NULL() {
        return G_SPAWN_STDIN_FROM_DEV_NULL;
    }

    private static class g_spawn_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_spawn_error_quark()
     * }
     */
    public static FunctionDescriptor g_spawn_error_quark$descriptor() {
        return g_spawn_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_spawn_error_quark()
     * }
     */
    public static MethodHandle g_spawn_error_quark$handle() {
        return g_spawn_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_spawn_error_quark()
     * }
     */
    public static MemorySegment g_spawn_error_quark$address() {
        return g_spawn_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_spawn_error_quark()
     * }
     */
    public static int g_spawn_error_quark() {
        var mh$ = g_spawn_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_exit_error_quark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_exit_error_quark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GQuark g_spawn_exit_error_quark()
     * }
     */
    public static FunctionDescriptor g_spawn_exit_error_quark$descriptor() {
        return g_spawn_exit_error_quark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GQuark g_spawn_exit_error_quark()
     * }
     */
    public static MethodHandle g_spawn_exit_error_quark$handle() {
        return g_spawn_exit_error_quark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GQuark g_spawn_exit_error_quark()
     * }
     */
    public static MemorySegment g_spawn_exit_error_quark$address() {
        return g_spawn_exit_error_quark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GQuark g_spawn_exit_error_quark()
     * }
     */
    public static int g_spawn_exit_error_quark() {
        var mh$ = g_spawn_exit_error_quark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_exit_error_quark");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_async$descriptor() {
        return g_spawn_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error)
     * }
     */
    public static MethodHandle g_spawn_async$handle() {
        return g_spawn_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error)
     * }
     */
    public static MemorySegment g_spawn_async$address() {
        return g_spawn_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_async(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error)
     * }
     */
    public static int g_spawn_async(MemorySegment working_directory, MemorySegment argv, MemorySegment envp, int flags, MemorySegment child_setup, MemorySegment user_data, MemorySegment child_pid, MemorySegment error) {
        var mh$ = g_spawn_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_async", working_directory, argv, envp, flags, child_setup, user_data, child_pid, error);
            }
            return (int)mh$.invokeExact(working_directory, argv, envp, flags, child_setup, user_data, child_pid, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_async_with_pipes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_async_with_pipes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_pipes(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_async_with_pipes$descriptor() {
        return g_spawn_async_with_pipes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_pipes(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error)
     * }
     */
    public static MethodHandle g_spawn_async_with_pipes$handle() {
        return g_spawn_async_with_pipes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_pipes(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error)
     * }
     */
    public static MemorySegment g_spawn_async_with_pipes$address() {
        return g_spawn_async_with_pipes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_pipes(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error)
     * }
     */
    public static int g_spawn_async_with_pipes(MemorySegment working_directory, MemorySegment argv, MemorySegment envp, int flags, MemorySegment child_setup, MemorySegment user_data, MemorySegment child_pid, MemorySegment standard_input, MemorySegment standard_output, MemorySegment standard_error, MemorySegment error) {
        var mh$ = g_spawn_async_with_pipes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_async_with_pipes", working_directory, argv, envp, flags, child_setup, user_data, child_pid, standard_input, standard_output, standard_error, error);
            }
            return (int)mh$.invokeExact(working_directory, argv, envp, flags, child_setup, user_data, child_pid, standard_input, standard_output, standard_error, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_async_with_pipes_and_fds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_async_with_pipes_and_fds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_pipes_and_fds(const gchar *working_directory, const gchar *const *argv, const gchar *const *envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, const gint *source_fds, const gint *target_fds, gsize n_fds, GPid *child_pid_out, gint *stdin_pipe_out, gint *stdout_pipe_out, gint *stderr_pipe_out, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_async_with_pipes_and_fds$descriptor() {
        return g_spawn_async_with_pipes_and_fds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_pipes_and_fds(const gchar *working_directory, const gchar *const *argv, const gchar *const *envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, const gint *source_fds, const gint *target_fds, gsize n_fds, GPid *child_pid_out, gint *stdin_pipe_out, gint *stdout_pipe_out, gint *stderr_pipe_out, GError **error)
     * }
     */
    public static MethodHandle g_spawn_async_with_pipes_and_fds$handle() {
        return g_spawn_async_with_pipes_and_fds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_pipes_and_fds(const gchar *working_directory, const gchar *const *argv, const gchar *const *envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, const gint *source_fds, const gint *target_fds, gsize n_fds, GPid *child_pid_out, gint *stdin_pipe_out, gint *stdout_pipe_out, gint *stderr_pipe_out, GError **error)
     * }
     */
    public static MemorySegment g_spawn_async_with_pipes_and_fds$address() {
        return g_spawn_async_with_pipes_and_fds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_pipes_and_fds(const gchar *working_directory, const gchar *const *argv, const gchar *const *envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, const gint *source_fds, const gint *target_fds, gsize n_fds, GPid *child_pid_out, gint *stdin_pipe_out, gint *stdout_pipe_out, gint *stderr_pipe_out, GError **error)
     * }
     */
    public static int g_spawn_async_with_pipes_and_fds(MemorySegment working_directory, MemorySegment argv, MemorySegment envp, int flags, MemorySegment child_setup, MemorySegment user_data, int stdin_fd, int stdout_fd, int stderr_fd, MemorySegment source_fds, MemorySegment target_fds, long n_fds, MemorySegment child_pid_out, MemorySegment stdin_pipe_out, MemorySegment stdout_pipe_out, MemorySegment stderr_pipe_out, MemorySegment error) {
        var mh$ = g_spawn_async_with_pipes_and_fds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_async_with_pipes_and_fds", working_directory, argv, envp, flags, child_setup, user_data, stdin_fd, stdout_fd, stderr_fd, source_fds, target_fds, n_fds, child_pid_out, stdin_pipe_out, stdout_pipe_out, stderr_pipe_out, error);
            }
            return (int)mh$.invokeExact(working_directory, argv, envp, flags, child_setup, user_data, stdin_fd, stdout_fd, stderr_fd, source_fds, target_fds, n_fds, child_pid_out, stdin_pipe_out, stdout_pipe_out, stderr_pipe_out, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_async_with_fds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_async_with_fds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_fds(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_async_with_fds$descriptor() {
        return g_spawn_async_with_fds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_fds(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError **error)
     * }
     */
    public static MethodHandle g_spawn_async_with_fds$handle() {
        return g_spawn_async_with_fds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_fds(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError **error)
     * }
     */
    public static MemorySegment g_spawn_async_with_fds$address() {
        return g_spawn_async_with_fds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_async_with_fds(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError **error)
     * }
     */
    public static int g_spawn_async_with_fds(MemorySegment working_directory, MemorySegment argv, MemorySegment envp, int flags, MemorySegment child_setup, MemorySegment user_data, MemorySegment child_pid, int stdin_fd, int stdout_fd, int stderr_fd, MemorySegment error) {
        var mh$ = g_spawn_async_with_fds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_async_with_fds", working_directory, argv, envp, flags, child_setup, user_data, child_pid, stdin_fd, stdout_fd, stderr_fd, error);
            }
            return (int)mh$.invokeExact(working_directory, argv, envp, flags, child_setup, user_data, child_pid, stdin_fd, stdout_fd, stderr_fd, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_sync(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_sync$descriptor() {
        return g_spawn_sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_sync(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error)
     * }
     */
    public static MethodHandle g_spawn_sync$handle() {
        return g_spawn_sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_sync(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error)
     * }
     */
    public static MemorySegment g_spawn_sync$address() {
        return g_spawn_sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_sync(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error)
     * }
     */
    public static int g_spawn_sync(MemorySegment working_directory, MemorySegment argv, MemorySegment envp, int flags, MemorySegment child_setup, MemorySegment user_data, MemorySegment standard_output, MemorySegment standard_error, MemorySegment wait_status, MemorySegment error) {
        var mh$ = g_spawn_sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_sync", working_directory, argv, envp, flags, child_setup, user_data, standard_output, standard_error, wait_status, error);
            }
            return (int)mh$.invokeExact(working_directory, argv, envp, flags, child_setup, user_data, standard_output, standard_error, wait_status, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_command_line_sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_command_line_sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_command_line_sync(const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_command_line_sync$descriptor() {
        return g_spawn_command_line_sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_command_line_sync(const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error)
     * }
     */
    public static MethodHandle g_spawn_command_line_sync$handle() {
        return g_spawn_command_line_sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_command_line_sync(const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error)
     * }
     */
    public static MemorySegment g_spawn_command_line_sync$address() {
        return g_spawn_command_line_sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_command_line_sync(const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error)
     * }
     */
    public static int g_spawn_command_line_sync(MemorySegment command_line, MemorySegment standard_output, MemorySegment standard_error, MemorySegment wait_status, MemorySegment error) {
        var mh$ = g_spawn_command_line_sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_command_line_sync", command_line, standard_output, standard_error, wait_status, error);
            }
            return (int)mh$.invokeExact(command_line, standard_output, standard_error, wait_status, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_command_line_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_command_line_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_command_line_async(const gchar *command_line, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_command_line_async$descriptor() {
        return g_spawn_command_line_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_command_line_async(const gchar *command_line, GError **error)
     * }
     */
    public static MethodHandle g_spawn_command_line_async$handle() {
        return g_spawn_command_line_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_command_line_async(const gchar *command_line, GError **error)
     * }
     */
    public static MemorySegment g_spawn_command_line_async$address() {
        return g_spawn_command_line_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_command_line_async(const gchar *command_line, GError **error)
     * }
     */
    public static int g_spawn_command_line_async(MemorySegment command_line, MemorySegment error) {
        var mh$ = g_spawn_command_line_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_command_line_async", command_line, error);
            }
            return (int)mh$.invokeExact(command_line, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_check_wait_status {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_check_wait_status");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_check_wait_status(gint wait_status, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_check_wait_status$descriptor() {
        return g_spawn_check_wait_status.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_check_wait_status(gint wait_status, GError **error)
     * }
     */
    public static MethodHandle g_spawn_check_wait_status$handle() {
        return g_spawn_check_wait_status.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_check_wait_status(gint wait_status, GError **error)
     * }
     */
    public static MemorySegment g_spawn_check_wait_status$address() {
        return g_spawn_check_wait_status.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_check_wait_status(gint wait_status, GError **error)
     * }
     */
    public static int g_spawn_check_wait_status(int wait_status, MemorySegment error) {
        var mh$ = g_spawn_check_wait_status.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_check_wait_status", wait_status, error);
            }
            return (int)mh$.invokeExact(wait_status, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_check_exit_status {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_check_exit_status");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_check_exit_status(gint wait_status, GError **error)
     * }
     */
    public static FunctionDescriptor g_spawn_check_exit_status$descriptor() {
        return g_spawn_check_exit_status.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_check_exit_status(gint wait_status, GError **error)
     * }
     */
    public static MethodHandle g_spawn_check_exit_status$handle() {
        return g_spawn_check_exit_status.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gboolean g_spawn_check_exit_status(gint wait_status, GError **error)
     * }
     */
    public static MemorySegment g_spawn_check_exit_status$address() {
        return g_spawn_check_exit_status.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gboolean g_spawn_check_exit_status(gint wait_status, GError **error)
     * }
     */
    public static int g_spawn_check_exit_status(int wait_status, MemorySegment error) {
        var mh$ = g_spawn_check_exit_status.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_check_exit_status", wait_status, error);
            }
            return (int)mh$.invokeExact(wait_status, error);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_spawn_close_pid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_spawn_close_pid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_spawn_close_pid(GPid pid)
     * }
     */
    public static FunctionDescriptor g_spawn_close_pid$descriptor() {
        return g_spawn_close_pid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_spawn_close_pid(GPid pid)
     * }
     */
    public static MethodHandle g_spawn_close_pid$handle() {
        return g_spawn_close_pid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_spawn_close_pid(GPid pid)
     * }
     */
    public static MemorySegment g_spawn_close_pid$address() {
        return g_spawn_close_pid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_spawn_close_pid(GPid pid)
     * }
     */
    public static void g_spawn_close_pid(MemorySegment pid) {
        var mh$ = g_spawn_close_pid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_spawn_close_pid", pid);
            }
            mh$.invokeExact(pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_chunk_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_chunk_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GStringChunk *g_string_chunk_new(gsize size)
     * }
     */
    public static FunctionDescriptor g_string_chunk_new$descriptor() {
        return g_string_chunk_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GStringChunk *g_string_chunk_new(gsize size)
     * }
     */
    public static MethodHandle g_string_chunk_new$handle() {
        return g_string_chunk_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GStringChunk *g_string_chunk_new(gsize size)
     * }
     */
    public static MemorySegment g_string_chunk_new$address() {
        return g_string_chunk_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GStringChunk *g_string_chunk_new(gsize size)
     * }
     */
    public static MemorySegment g_string_chunk_new(long size) {
        var mh$ = g_string_chunk_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_chunk_new", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_chunk_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_chunk_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_string_chunk_free(GStringChunk *chunk)
     * }
     */
    public static FunctionDescriptor g_string_chunk_free$descriptor() {
        return g_string_chunk_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_string_chunk_free(GStringChunk *chunk)
     * }
     */
    public static MethodHandle g_string_chunk_free$handle() {
        return g_string_chunk_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_string_chunk_free(GStringChunk *chunk)
     * }
     */
    public static MemorySegment g_string_chunk_free$address() {
        return g_string_chunk_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_string_chunk_free(GStringChunk *chunk)
     * }
     */
    public static void g_string_chunk_free(MemorySegment chunk) {
        var mh$ = g_string_chunk_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_chunk_free", chunk);
            }
            mh$.invokeExact(chunk);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_chunk_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_chunk_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_string_chunk_clear(GStringChunk *chunk)
     * }
     */
    public static FunctionDescriptor g_string_chunk_clear$descriptor() {
        return g_string_chunk_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_string_chunk_clear(GStringChunk *chunk)
     * }
     */
    public static MethodHandle g_string_chunk_clear$handle() {
        return g_string_chunk_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_string_chunk_clear(GStringChunk *chunk)
     * }
     */
    public static MemorySegment g_string_chunk_clear$address() {
        return g_string_chunk_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_string_chunk_clear(GStringChunk *chunk)
     * }
     */
    public static void g_string_chunk_clear(MemorySegment chunk) {
        var mh$ = g_string_chunk_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_chunk_clear", chunk);
            }
            mh$.invokeExact(chunk);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_chunk_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_chunk_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert(GStringChunk *chunk, const gchar *string)
     * }
     */
    public static FunctionDescriptor g_string_chunk_insert$descriptor() {
        return g_string_chunk_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert(GStringChunk *chunk, const gchar *string)
     * }
     */
    public static MethodHandle g_string_chunk_insert$handle() {
        return g_string_chunk_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert(GStringChunk *chunk, const gchar *string)
     * }
     */
    public static MemorySegment g_string_chunk_insert$address() {
        return g_string_chunk_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert(GStringChunk *chunk, const gchar *string)
     * }
     */
    public static MemorySegment g_string_chunk_insert(MemorySegment chunk, MemorySegment string) {
        var mh$ = g_string_chunk_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_chunk_insert", chunk, string);
            }
            return (MemorySegment)mh$.invokeExact(chunk, string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_chunk_insert_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_chunk_insert_len");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert_len(GStringChunk *chunk, const gchar *string, gssize len)
     * }
     */
    public static FunctionDescriptor g_string_chunk_insert_len$descriptor() {
        return g_string_chunk_insert_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert_len(GStringChunk *chunk, const gchar *string, gssize len)
     * }
     */
    public static MethodHandle g_string_chunk_insert_len$handle() {
        return g_string_chunk_insert_len.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert_len(GStringChunk *chunk, const gchar *string, gssize len)
     * }
     */
    public static MemorySegment g_string_chunk_insert_len$address() {
        return g_string_chunk_insert_len.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert_len(GStringChunk *chunk, const gchar *string, gssize len)
     * }
     */
    public static MemorySegment g_string_chunk_insert_len(MemorySegment chunk, MemorySegment string, long len) {
        var mh$ = g_string_chunk_insert_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_chunk_insert_len", chunk, string, len);
            }
            return (MemorySegment)mh$.invokeExact(chunk, string, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_string_chunk_insert_const {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_string_chunk_insert_const");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert_const(GStringChunk *chunk, const gchar *string)
     * }
     */
    public static FunctionDescriptor g_string_chunk_insert_const$descriptor() {
        return g_string_chunk_insert_const.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert_const(GStringChunk *chunk, const gchar *string)
     * }
     */
    public static MethodHandle g_string_chunk_insert_const$handle() {
        return g_string_chunk_insert_const.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert_const(GStringChunk *chunk, const gchar *string)
     * }
     */
    public static MemorySegment g_string_chunk_insert_const$address() {
        return g_string_chunk_insert_const.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern gchar *g_string_chunk_insert_const(GStringChunk *chunk, const gchar *string)
     * }
     */
    public static MemorySegment g_string_chunk_insert_const(MemorySegment chunk, MemorySegment string) {
        var mh$ = g_string_chunk_insert_const.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_string_chunk_insert_const", chunk, string);
            }
            return (MemorySegment)mh$.invokeExact(chunk, string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_builder_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GStrvBuilder *g_strv_builder_new()
     * }
     */
    public static FunctionDescriptor g_strv_builder_new$descriptor() {
        return g_strv_builder_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GStrvBuilder *g_strv_builder_new()
     * }
     */
    public static MethodHandle g_strv_builder_new$handle() {
        return g_strv_builder_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GStrvBuilder *g_strv_builder_new()
     * }
     */
    public static MemorySegment g_strv_builder_new$address() {
        return g_strv_builder_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GStrvBuilder *g_strv_builder_new()
     * }
     */
    public static MemorySegment g_strv_builder_new() {
        var mh$ = g_strv_builder_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_builder_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_builder_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_strv_builder_unref(GStrvBuilder *builder)
     * }
     */
    public static FunctionDescriptor g_strv_builder_unref$descriptor() {
        return g_strv_builder_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_strv_builder_unref(GStrvBuilder *builder)
     * }
     */
    public static MethodHandle g_strv_builder_unref$handle() {
        return g_strv_builder_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_strv_builder_unref(GStrvBuilder *builder)
     * }
     */
    public static MemorySegment g_strv_builder_unref$address() {
        return g_strv_builder_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_strv_builder_unref(GStrvBuilder *builder)
     * }
     */
    public static void g_strv_builder_unref(MemorySegment builder) {
        var mh$ = g_strv_builder_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_builder_unref", builder);
            }
            mh$.invokeExact(builder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_builder_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GStrvBuilder *g_strv_builder_ref(GStrvBuilder *builder)
     * }
     */
    public static FunctionDescriptor g_strv_builder_ref$descriptor() {
        return g_strv_builder_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GStrvBuilder *g_strv_builder_ref(GStrvBuilder *builder)
     * }
     */
    public static MethodHandle g_strv_builder_ref$handle() {
        return g_strv_builder_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GStrvBuilder *g_strv_builder_ref(GStrvBuilder *builder)
     * }
     */
    public static MemorySegment g_strv_builder_ref$address() {
        return g_strv_builder_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GStrvBuilder *g_strv_builder_ref(GStrvBuilder *builder)
     * }
     */
    public static MemorySegment g_strv_builder_ref(MemorySegment builder) {
        var mh$ = g_strv_builder_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_builder_ref", builder);
            }
            return (MemorySegment)mh$.invokeExact(builder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_builder_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_strv_builder_add(GStrvBuilder *builder, const char *value)
     * }
     */
    public static FunctionDescriptor g_strv_builder_add$descriptor() {
        return g_strv_builder_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_strv_builder_add(GStrvBuilder *builder, const char *value)
     * }
     */
    public static MethodHandle g_strv_builder_add$handle() {
        return g_strv_builder_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_strv_builder_add(GStrvBuilder *builder, const char *value)
     * }
     */
    public static MemorySegment g_strv_builder_add$address() {
        return g_strv_builder_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_strv_builder_add(GStrvBuilder *builder, const char *value)
     * }
     */
    public static void g_strv_builder_add(MemorySegment builder, MemorySegment value) {
        var mh$ = g_strv_builder_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_builder_add", builder, value);
            }
            mh$.invokeExact(builder, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_builder_addv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_addv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_strv_builder_addv(GStrvBuilder *builder, const char **value)
     * }
     */
    public static FunctionDescriptor g_strv_builder_addv$descriptor() {
        return g_strv_builder_addv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_strv_builder_addv(GStrvBuilder *builder, const char **value)
     * }
     */
    public static MethodHandle g_strv_builder_addv$handle() {
        return g_strv_builder_addv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_strv_builder_addv(GStrvBuilder *builder, const char **value)
     * }
     */
    public static MemorySegment g_strv_builder_addv$address() {
        return g_strv_builder_addv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_strv_builder_addv(GStrvBuilder *builder, const char **value)
     * }
     */
    public static void g_strv_builder_addv(MemorySegment builder, MemorySegment value) {
        var mh$ = g_strv_builder_addv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_builder_addv", builder, value);
            }
            mh$.invokeExact(builder, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void g_strv_builder_add_many(GStrvBuilder *builder, ...)
     * }
     */
    public static class g_strv_builder_add_many {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gst_min_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_add_many");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private g_strv_builder_add_many(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void g_strv_builder_add_many(GStrvBuilder *builder, ...)
         * }
         */
        public static g_strv_builder_add_many makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new g_strv_builder_add_many(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment builder, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("g_strv_builder_add_many", builder, x1);
                }
                 spreader.invokeExact(builder, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class g_strv_builder_take {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_take");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void g_strv_builder_take(GStrvBuilder *builder, char *value)
     * }
     */
    public static FunctionDescriptor g_strv_builder_take$descriptor() {
        return g_strv_builder_take.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void g_strv_builder_take(GStrvBuilder *builder, char *value)
     * }
     */
    public static MethodHandle g_strv_builder_take$handle() {
        return g_strv_builder_take.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void g_strv_builder_take(GStrvBuilder *builder, char *value)
     * }
     */
    public static MemorySegment g_strv_builder_take$address() {
        return g_strv_builder_take.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void g_strv_builder_take(GStrvBuilder *builder, char *value)
     * }
     */
    public static void g_strv_builder_take(MemorySegment builder, MemorySegment value) {
        var mh$ = g_strv_builder_take.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_builder_take", builder, value);
            }
            mh$.invokeExact(builder, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class g_strv_builder_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("g_strv_builder_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GStrv g_strv_builder_end(GStrvBuilder *builder)
     * }
     */
    public static FunctionDescriptor g_strv_builder_end$descriptor() {
        return g_strv_builder_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GStrv g_strv_builder_end(GStrvBuilder *builder)
     * }
     */
    public static MethodHandle g_strv_builder_end$handle() {
        return g_strv_builder_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GStrv g_strv_builder_end(GStrvBuilder *builder)
     * }
     */
    public static MemorySegment g_strv_builder_end$address() {
        return g_strv_builder_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GStrv g_strv_builder_end(GStrvBuilder *builder)
     * }
     */
    public static MemorySegment g_strv_builder_end(MemorySegment builder) {
        var mh$ = g_strv_builder_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("g_strv_builder_end", builder);
            }
            return (MemorySegment)mh$.invokeExact(builder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor bsearch_s$descriptor() {
        return bsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle bsearch_s$handle() {
        return bsearch_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s$address() {
        return bsearch_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = bsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor qsort_s$descriptor() {
        return qsort_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle qsort_s$handle() {
        return qsort_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment qsort_s$address() {
        return qsort_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static void qsort_s(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = qsort_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_s", _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static void qsort(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lfind_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lfind_s$descriptor() {
        return _lfind_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lfind_s$handle() {
        return _lfind_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s$address() {
        return _lfind_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lfind_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lfind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lfind$descriptor() {
        return _lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lfind$handle() {
        return _lfind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind$address() {
        return _lfind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lsearch_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lsearch_s$descriptor() {
        return _lsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lsearch_s$handle() {
        return _lsearch_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s$address() {
        return _lsearch_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lsearch$descriptor() {
        return _lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lsearch$handle() {
        return _lsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch$address() {
        return _lsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lfind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lfind$descriptor() {
        return lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lfind$handle() {
        return lfind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind$address() {
        return lfind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lsearch$descriptor() {
        return lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lsearch$handle() {
        return lsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch$address() {
        return lsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_itow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow_s$descriptor() {
        return _itow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itow_s$handle() {
        return _itow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itow_s$address() {
        return _itow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_itow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow$descriptor() {
        return _itow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itow$handle() {
        return _itow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow$address() {
        return _itow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ltow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow_s$descriptor() {
        return _ltow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltow_s$handle() {
        return _ltow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltow_s$address() {
        return _ltow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ltow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow$descriptor() {
        return _ltow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltow$handle() {
        return _ltow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow$address() {
        return _ltow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ultow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow_s$descriptor() {
        return _ultow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultow_s$handle() {
        return _ultow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultow_s$address() {
        return _ultow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ultow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow$descriptor() {
        return _ultow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultow$handle() {
        return _ultow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow$address() {
        return _ultow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstod$descriptor() {
        return wcstod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstod$handle() {
        return wcstod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstod$address() {
        return wcstod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstod_l$descriptor() {
        return _wcstod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstod_l$handle() {
        return _wcstod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstod_l$address() {
        return _wcstod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstol$descriptor() {
        return wcstol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstol$handle() {
        return wcstol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstol$address() {
        return wcstol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstol_l$descriptor() {
        return _wcstol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstol_l$handle() {
        return _wcstol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstol_l$address() {
        return _wcstol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoll$descriptor() {
        return wcstoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoll$handle() {
        return wcstoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoll$address() {
        return wcstoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoll_l$descriptor() {
        return _wcstoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoll_l$handle() {
        return _wcstoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoll_l$address() {
        return _wcstoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoul$descriptor() {
        return wcstoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoul$handle() {
        return wcstoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoul$address() {
        return wcstoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoul_l$descriptor() {
        return _wcstoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoul_l$handle() {
        return _wcstoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoul_l$address() {
        return _wcstoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoull$descriptor() {
        return wcstoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoull$handle() {
        return wcstoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoull$address() {
        return wcstoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoull_l$descriptor() {
        return _wcstoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoull_l$handle() {
        return _wcstoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoull_l$address() {
        return _wcstoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstold$descriptor() {
        return wcstold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstold$handle() {
        return wcstold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstold$address() {
        return wcstold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstold_l$descriptor() {
        return _wcstold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstold_l$handle() {
        return _wcstold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstold_l$address() {
        return _wcstold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_FLOAT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstof$descriptor() {
        return wcstof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstof$handle() {
        return wcstof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstof$address() {
        return wcstof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static float wcstof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_FLOAT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstof_l$descriptor() {
        return _wcstof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstof_l$handle() {
        return _wcstof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstof_l$address() {
        return _wcstof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _wcstof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtof$descriptor() {
        return _wtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtof$handle() {
        return _wtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtof$address() {
        return _wtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static double _wtof(MemorySegment _String) {
        var mh$ = _wtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtof_l$descriptor() {
        return _wtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtof_l$handle() {
        return _wtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtof_l$address() {
        return _wtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static double _wtof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi$descriptor() {
        return _wtoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi$handle() {
        return _wtoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi$address() {
        return _wtoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static int _wtoi(MemorySegment _String) {
        var mh$ = _wtoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi_l$descriptor() {
        return _wtoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi_l$handle() {
        return _wtoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi_l$address() {
        return _wtoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtol$descriptor() {
        return _wtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtol$handle() {
        return _wtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtol$address() {
        return _wtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static int _wtol(MemorySegment _String) {
        var mh$ = _wtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtol_l$descriptor() {
        return _wtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtol_l$handle() {
        return _wtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtol_l$address() {
        return _wtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoll$descriptor() {
        return _wtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoll$handle() {
        return _wtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoll$address() {
        return _wtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static long _wtoll(MemorySegment _String) {
        var mh$ = _wtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoll_l$descriptor() {
        return _wtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoll_l$handle() {
        return _wtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoll_l$address() {
        return _wtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_i64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow_s$descriptor() {
        return _i64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64tow_s$handle() {
        return _i64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64tow_s$address() {
        return _i64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_i64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow$descriptor() {
        return _i64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64tow$handle() {
        return _i64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow$address() {
        return _i64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ui64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow_s$descriptor() {
        return _ui64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow_s$handle() {
        return _ui64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow_s$address() {
        return _ui64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ui64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow$descriptor() {
        return _ui64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow$handle() {
        return _ui64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow$address() {
        return _ui64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi64$descriptor() {
        return _wtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi64$handle() {
        return _wtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi64$address() {
        return _wtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static long _wtoi64(MemorySegment _String) {
        var mh$ = _wtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi64_l$descriptor() {
        return _wtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi64_l$handle() {
        return _wtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi64_l$address() {
        return _wtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoi64$descriptor() {
        return _wcstoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoi64$handle() {
        return _wcstoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoi64$address() {
        return _wcstoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoi64_l$descriptor() {
        return _wcstoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoi64_l$handle() {
        return _wcstoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoi64_l$address() {
        return _wcstoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoui64$descriptor() {
        return _wcstoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoui64$handle() {
        return _wcstoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoui64$address() {
        return _wcstoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoui64_l$descriptor() {
        return _wcstoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoui64_l$handle() {
        return _wcstoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoui64_l$address() {
        return _wcstoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wfullpath$descriptor() {
        return _wfullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wfullpath$handle() {
        return _wfullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath$address() {
        return _wfullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _wfullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wmakepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath_s$descriptor() {
        return _wmakepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath_s$handle() {
        return _wmakepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath_s$address() {
        return _wmakepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static int _wmakepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wmakepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath$descriptor() {
        return _wmakepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath$handle() {
        return _wmakepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath$address() {
        return _wmakepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static void _wmakepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wperror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment _wperror$address() {
        return _wperror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsplitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wsplitpath$descriptor() {
        return _wsplitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wsplitpath$handle() {
        return _wsplitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wsplitpath$address() {
        return _wsplitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static void _wsplitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wsplitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsplitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _wsplitpath_s$descriptor() {
        return _wsplitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _wsplitpath_s$handle() {
        return _wsplitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _wsplitpath_s$address() {
        return _wsplitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static int _wsplitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _wsplitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wdupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wdupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wdupenv_s$descriptor() {
        return _wdupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wdupenv_s$handle() {
        return _wdupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wdupenv_s$address() {
        return _wdupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wdupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _wdupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wdupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wgetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv$descriptor() {
        return _wgetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv$handle() {
        return _wgetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv$address() {
        return _wgetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv(MemorySegment _VarName) {
        var mh$ = _wgetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wgetenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv_s$descriptor() {
        return _wgetenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv_s$handle() {
        return _wgetenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv_s$address() {
        return _wgetenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wgetenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = _wgetenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wputenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static FunctionDescriptor _wputenv$descriptor() {
        return _wputenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MethodHandle _wputenv$handle() {
        return _wputenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MemorySegment _wputenv$address() {
        return _wputenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static int _wputenv(MemorySegment _EnvString) {
        var mh$ = _wputenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wputenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static FunctionDescriptor _wputenv_s$descriptor() {
        return _wputenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MethodHandle _wputenv_s$handle() {
        return _wputenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MemorySegment _wputenv_s$address() {
        return _wputenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static int _wputenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _wputenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsearchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wsearchenv_s$descriptor() {
        return _wsearchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wsearchenv_s$handle() {
        return _wsearchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wsearchenv_s$address() {
        return _wsearchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wsearchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wsearchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsearchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static FunctionDescriptor _wsearchenv$descriptor() {
        return _wsearchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MethodHandle _wsearchenv$handle() {
        return _wsearchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MemorySegment _wsearchenv$address() {
        return _wsearchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static void _wsearchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _ResultPath) {
        var mh$ = _wsearchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv", _Filename, _VarName, _ResultPath);
            }
            mh$.invokeExact(_Filename, _VarName, _ResultPath);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsystem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static FunctionDescriptor _wsystem$descriptor() {
        return _wsystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MethodHandle _wsystem$handle() {
        return _wsystem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MemorySegment _wsystem$address() {
        return _wsystem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static int _wsystem(MemorySegment _Command) {
        var mh$ = _wsystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsystem", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _swab$descriptor() {
        return _swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle _swab$handle() {
        return _swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment _swab$address() {
        return _swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void _swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = _swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static void exit(int _Code) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static void _exit(int _Code) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static void _Exit(int _Code) {
        var mh$ = _Exit$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static void quick_exit(int _Code) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_abort_behavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_abort_behavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _set_abort_behavior$descriptor() {
        return _set_abort_behavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MethodHandle _set_abort_behavior$handle() {
        return _set_abort_behavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MemorySegment _set_abort_behavior$address() {
        return _set_abort_behavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static int _set_abort_behavior(int _Flags, int _Mask) {
        var mh$ = _set_abort_behavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_abort_behavior", _Flags, _Mask);
            }
            return (int)mh$.invokeExact(_Flags, _Mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor _onexit$descriptor() {
        return _onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle _onexit$handle() {
        return _onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit$address() {
        return _onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit(MemorySegment _Func) {
        var mh$ = _onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_purecall_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_purecall_handler$descriptor() {
        return _set_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MethodHandle _set_purecall_handler$handle() {
        return _set_purecall_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler$address() {
        return _set_purecall_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler(MemorySegment _Handler) {
        var mh$ = _set_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_purecall_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_purecall_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static FunctionDescriptor _get_purecall_handler$descriptor() {
        return _get_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MethodHandle _get_purecall_handler$handle() {
        return _get_purecall_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler$address() {
        return _get_purecall_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler() {
        var mh$ = _get_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_purecall_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_invalid_parameter_handler$descriptor() {
        return _set_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_invalid_parameter_handler$handle() {
        return _set_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler$address() {
        return _set_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_invalid_parameter_handler$descriptor() {
        return _get_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_invalid_parameter_handler$handle() {
        return _get_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler$address() {
        return _get_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler() {
        var mh$ = _get_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_thread_local_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_thread_local_invalid_parameter_handler$descriptor() {
        return _set_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_thread_local_invalid_parameter_handler$handle() {
        return _set_thread_local_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler$address() {
        return _set_thread_local_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_thread_local_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_thread_local_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_thread_local_invalid_parameter_handler$descriptor() {
        return _get_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_thread_local_invalid_parameter_handler$handle() {
        return _get_thread_local_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler$address() {
        return _get_thread_local_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler() {
        var mh$ = _get_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_thread_local_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_error_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_error_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_error_mode$descriptor() {
        return _set_error_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MethodHandle _set_error_mode$handle() {
        return _set_error_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MemorySegment _set_error_mode$address() {
        return _set_error_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static int _set_error_mode(int _Mode) {
        var mh$ = _set_error_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_error_mode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_errlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sys_errlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static FunctionDescriptor __sys_errlist$descriptor() {
        return __sys_errlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MethodHandle __sys_errlist$handle() {
        return __sys_errlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist$address() {
        return __sys_errlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist() {
        var mh$ = __sys_errlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_errlist");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_nerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sys_nerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static FunctionDescriptor __sys_nerr$descriptor() {
        return __sys_nerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MethodHandle __sys_nerr$handle() {
        return __sys_nerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr$address() {
        return __sys_nerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr() {
        var mh$ = __sys_nerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_nerr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static void perror(MemorySegment _ErrMsg) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrMsg);
            }
            mh$.invokeExact(_ErrMsg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__pgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static FunctionDescriptor __p__pgmptr$descriptor() {
        return __p__pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MethodHandle __p__pgmptr$handle() {
        return __p__pgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr$address() {
        return __p__pgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr() {
        var mh$ = __p__pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__pgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__wpgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static FunctionDescriptor __p__wpgmptr$descriptor() {
        return __p__wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MethodHandle __p__wpgmptr$handle() {
        return __p__wpgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr$address() {
        return __p__wpgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr() {
        var mh$ = __p__wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wpgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static FunctionDescriptor __p__fmode$descriptor() {
        return __p__fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MethodHandle __p__fmode$handle() {
        return __p__fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode$address() {
        return __p__fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode() {
        var mh$ = __p__fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__fmode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_pgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static FunctionDescriptor _get_pgmptr$descriptor() {
        return _get_pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MethodHandle _get_pgmptr$handle() {
        return _get_pgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MemorySegment _get_pgmptr$address() {
        return _get_pgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static int _get_pgmptr(MemorySegment _Value) {
        var mh$ = _get_pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_pgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_wpgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static FunctionDescriptor _get_wpgmptr$descriptor() {
        return _get_wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MethodHandle _get_wpgmptr$handle() {
        return _get_wpgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MemorySegment _get_wpgmptr$address() {
        return _get_wpgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static int _get_wpgmptr(MemorySegment _Value) {
        var mh$ = _get_wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_wpgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_fmode$descriptor() {
        return _set_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MethodHandle _set_fmode$handle() {
        return _set_fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MemorySegment _set_fmode$address() {
        return _set_fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static int _set_fmode(int _Mode) {
        var mh$ = _set_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_fmode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static FunctionDescriptor _get_fmode$descriptor() {
        return _get_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MethodHandle _get_fmode$handle() {
        return _get_fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MemorySegment _get_fmode$address() {
        return _get_fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static int _get_fmode(MemorySegment _PMode) {
        var mh$ = _get_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_fmode", _PMode);
            }
            return (int)mh$.invokeExact(_PMode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static int abs(int _Number) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static int labs(int _Number) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static long llabs(long _Number) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _abs64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_abs64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static FunctionDescriptor _abs64$descriptor() {
        return _abs64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MethodHandle _abs64$handle() {
        return _abs64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MemorySegment _abs64$address() {
        return _abs64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static long _abs64(long _Number) {
        var mh$ = _abs64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_abs64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ushort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_SHORT,
            gst_min_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_byteswap_ushort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ushort$descriptor() {
        return _byteswap_ushort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MethodHandle _byteswap_ushort$handle() {
        return _byteswap_ushort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MemorySegment _byteswap_ushort$address() {
        return _byteswap_ushort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static short _byteswap_ushort(short _Number) {
        var mh$ = _byteswap_ushort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ushort", _Number);
            }
            return (short)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ulong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_byteswap_ulong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ulong$descriptor() {
        return _byteswap_ulong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MethodHandle _byteswap_ulong$handle() {
        return _byteswap_ulong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MemorySegment _byteswap_ulong$address() {
        return _byteswap_ulong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static int _byteswap_ulong(int _Number) {
        var mh$ = _byteswap_ulong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ulong", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_byteswap_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_uint64$descriptor() {
        return _byteswap_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MethodHandle _byteswap_uint64$handle() {
        return _byteswap_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MemorySegment _byteswap_uint64$address() {
        return _byteswap_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static long _byteswap_uint64(long _Number) {
        var mh$ = _byteswap_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_uint64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _div_t.layout(),
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _ldiv_t.layout(),
            gst_min_h.C_LONG,
            gst_min_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _lldiv_t.layout(),
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rotl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotl$descriptor() {
        return _rotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotl$handle() {
        return _rotl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotl$address() {
        return _rotl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static int _rotl(int _Value, int _Shift) {
        var mh$ = _rotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lrotl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotl$descriptor() {
        return _lrotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotl$handle() {
        return _lrotl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MemorySegment _lrotl$address() {
        return _lrotl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotl(int _Value, int _Shift) {
        var mh$ = _lrotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rotl64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotl64$descriptor() {
        return _rotl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotl64$handle() {
        return _rotl64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotl64$address() {
        return _rotl64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static long _rotl64(long _Value, int _Shift) {
        var mh$ = _rotl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl64", _Value, _Shift);
            }
            return (long)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rotr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotr$descriptor() {
        return _rotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotr$handle() {
        return _rotr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotr$address() {
        return _rotr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static int _rotr(int _Value, int _Shift) {
        var mh$ = _rotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lrotr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotr$descriptor() {
        return _lrotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotr$handle() {
        return _lrotr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MemorySegment _lrotr$address() {
        return _lrotr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotr(int _Value, int _Shift) {
        var mh$ = _lrotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rotr64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotr64$descriptor() {
        return _rotr64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotr64$handle() {
        return _rotr64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotr64$address() {
        return _rotr64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static long _rotr64(long _Value, int _Shift) {
        var mh$ = _rotr64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr64", _Value, _Shift);
            }
            return (long)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static void srand(int _Seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", _Seed);
            }
            mh$.invokeExact(_Seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static double atof(MemorySegment _String) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static int atoi(MemorySegment _String) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static int atol(MemorySegment _String) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static long atoll(MemorySegment _String) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static FunctionDescriptor _atoi64$descriptor() {
        return _atoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MethodHandle _atoi64$handle() {
        return _atoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MemorySegment _atoi64$address() {
        return _atoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static long _atoi64(MemorySegment _String) {
        var mh$ = _atoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atof_l$descriptor() {
        return _atof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atof_l$handle() {
        return _atof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atof_l$address() {
        return _atof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static double _atof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi_l$descriptor() {
        return _atoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi_l$handle() {
        return _atoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoi_l$address() {
        return _atoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atol_l$descriptor() {
        return _atol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atol_l$handle() {
        return _atol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atol_l$address() {
        return _atol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoll_l$descriptor() {
        return _atoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoll_l$handle() {
        return _atoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoll_l$address() {
        return _atoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi64_l$descriptor() {
        return _atoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi64_l$handle() {
        return _atoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoi64_l$address() {
        return _atoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoflt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static FunctionDescriptor _atoflt$descriptor() {
        return _atoflt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MethodHandle _atoflt$handle() {
        return _atoflt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MemorySegment _atoflt$address() {
        return _atoflt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static int _atoflt(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoflt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atodbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atodbl$descriptor() {
        return _atodbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atodbl$handle() {
        return _atodbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MemorySegment _atodbl$address() {
        return _atodbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static int _atodbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atodbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoldbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atoldbl$descriptor() {
        return _atoldbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atoldbl$handle() {
        return _atoldbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MemorySegment _atoldbl$address() {
        return _atoldbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static int _atoldbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoldbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoflt_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoflt_l$descriptor() {
        return _atoflt_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoflt_l$handle() {
        return _atoflt_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoflt_l$address() {
        return _atoflt_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoflt_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoflt_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atodbl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atodbl_l$descriptor() {
        return _atodbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atodbl_l$handle() {
        return _atodbl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atodbl_l$address() {
        return _atodbl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atodbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atodbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoldbl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoldbl_l$descriptor() {
        return _atoldbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoldbl_l$handle() {
        return _atoldbl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoldbl_l$address() {
        return _atoldbl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoldbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoldbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_FLOAT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static float strtof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_FLOAT,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtof_l$descriptor() {
        return _strtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtof_l$handle() {
        return _strtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtof_l$address() {
        return _strtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _strtof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtod_l$descriptor() {
        return _strtod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtod_l$handle() {
        return _strtod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtod_l$address() {
        return _strtod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtold$descriptor() {
        return strtold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtold$handle() {
        return strtold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtold$address() {
        return strtold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_DOUBLE,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtold_l$descriptor() {
        return _strtold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtold_l$handle() {
        return _strtold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtold_l$address() {
        return _strtold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtol_l$descriptor() {
        return _strtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtol_l$handle() {
        return _strtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtol_l$address() {
        return _strtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoll_l$descriptor() {
        return _strtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoll_l$handle() {
        return _strtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoll_l$address() {
        return _strtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoul_l$descriptor() {
        return _strtoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoul_l$handle() {
        return _strtoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoul_l$address() {
        return _strtoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoull_l$descriptor() {
        return _strtoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoull_l$handle() {
        return _strtoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoull_l$address() {
        return _strtoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoi64$descriptor() {
        return _strtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoi64$handle() {
        return _strtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _strtoi64$address() {
        return _strtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoi64_l$descriptor() {
        return _strtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoi64_l$handle() {
        return _strtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoi64_l$address() {
        return _strtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoui64$descriptor() {
        return _strtoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoui64$handle() {
        return _strtoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _strtoui64$address() {
        return _strtoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_POINTER,
            gst_min_h.C_POINTER,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoui64_l$descriptor() {
        return _strtoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoui64_l$handle() {
        return _strtoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoui64_l$address() {
        return _strtoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gst_min_h.C_INT,
            gst_min_h.C_INT,
            gst_min_h.C_POINTER,
            gst_min_h.C_LONG_LONG,
            gst_min_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_itoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa_s$descriptor() {
        return _itoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itoa_s$handle() {
        return _itoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itoa_s$address() {
        return _itoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

